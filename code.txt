--file ClientManager.cs
﻿using CSEmu.Network.Services;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using WebZen.Util;

namespace CSEmu
{
    public class ClientManager
    {
        private Dictionary<int, List<SCAdd>> _serverClientList = new Dictionary<int, List<SCAdd>>();

        public void AddServer(int ServerCode)
        {
            _serverClientList.Add(ServerCode, new List<SCAdd>());
        }
        public void AddClient(SCAdd client)
        {
            if (!_serverClientList.ContainsKey(client.Server))
                throw new Exception("Invalid Server Code " + client.Server);

            ServerManager.Instance.BroadCast(client);
            _serverClientList[client.Server].Add(client);
        }
        public void RemClient(SCRem message)
        { 
            if (!_serverClientList.ContainsKey(message.Server))
                return;

            var name = message.List.First().btName.MakeString();

            var client = _serverClientList[message.Server].First(x => x.btName.MakeString() == name);

            ServerManager.Instance.BroadCast(message);
            _serverClientList[message.Server].Remove(client);
        }
        public void RemServer(byte ServerCode)
        {
            if (!_serverClientList.ContainsKey(ServerCode))
                return;

            ServerManager.Instance.BroadCast(new SCRem
            {
                Server = ServerCode,
                List = _serverClientList[ServerCode]
                    .Select(x => new CliRemDto { btName = x.btName })
                    .ToArray()
            });

            _serverClientList[ServerCode].Clear();
            _serverClientList.Remove(ServerCode);
        }
    }
}


--file ChatManager.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace CSEmu.Network
{
    internal class RoomMember
    {

    }
    internal class Room
    {
        private Dictionary<CSSession, RoomMember> _room = new Dictionary<CSSession, RoomMember>();
        public int Index { get; private set; }
        public Room(int id)
        {
            Index = id;
        }

        public void Join(CSSession session, string member)
        {
            _room.Add(session, new RoomMember() { });
        }
    }

    internal class ChatManager
    {
        private Dictionary<string, Room> _rooms;
        private static ChatManager _instance;

        public static void Initialize()
        {
            if (_instance != null)
                throw new InvalidOperationException();

            _instance = new ChatManager();
        }

        public static Room CreateRoom()
        {
            var id = (_instance._rooms.Count() + (int)(DateTime.Now.ToBinary() & 0xFFFFFFFF));
            var hash = id.ToString("X");

            var r = new Room(id);
            _instance._rooms.Add(hash, r);
            return r;
        }

        public static Room GetRoom(int rid, string auth)
        {
            Room result;
            if (!_instance._rooms.TryGetValue(auth, out result))
                return null;

            if(rid == result.Index)
                return result;

            return null;
        }
    }
}


--file C2S.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace CSEmu.Network.ChatServices
{
    [WZContract]
    public class CChatAuth : IChatMessage
    {
        [WZMember(0)] public ushort wzRoom { get; set; }

        [WZMember(1, typeof(BinaryStringSerializer), 10)] public string Auth { get; set; }

        public ushort Room => wzRoom.ShufleEnding();
    }
}


--file ChatMessageFactory.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Network;

namespace CSEmu.Network.ChatServices
{
    public interface IChatMessage
    { }
    internal class ChatMessageFactory : MessageFactory<ChatOpCode, IChatMessage>
    {
        public ChatMessageFactory()
        {
            Register<CChatAuth>(ChatOpCode.Auth);
        }
    }
}


--file ChatServices.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Handlers;

namespace CSEmu.Network.ChatServices
{
    public class ChatServices : MessageHandler
    {
        [MessageHandler(typeof(CChatAuth))]
        public void CChatAuth(CSSession session, CChatAuth message)
        {

        }
    }
}


--file S2C.cs
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace CSEmu.Network.ChatServices
{
    class S2C
    {
    }
}


--file CSSession.cs
﻿using System;
using System.Collections.Generic;
using System.Net.Sockets;
using System.Text;
using WebZen.Network;

namespace CSEmu.Network
{
    public class CSSession : WZClient
    {
        public CSSession(WZServer server, Socket socket, AsyncCallback onRecv)
            : base(server, socket, onRecv)
        { }

        public async void SendAsync(object message)
        {
            await Send(_server.Encode(message, ref _outSerial, this));
        }
    }

    public class CSSessionFactory : ISessionFactory
    {
        public WZClient Create(WZServer server, Socket socket, AsyncCallback onRecv)
        {
            return new CSSession(server, socket, onRecv);
        }
    }
}


--file ServerDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace CSEmu.Network.Data
{
    [WZContract]
    public class ServerDto
    {
        [WZMember(0)]
        public ushort Index { get; set; }

        [WZMember(1)]
        public byte Load { get; set; }

        [WZMember(2)]
        public byte Type { get; set; }
    }
}


--file FilteredMessageHandler.cs
﻿using BlubLib.Collections.Generic;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using WebZen.Handlers;
using WebZen.Network;

namespace CSEmu.Network
{
    public class FilteredMessageHandler<TSession> : MessageHandler
        where TSession : WZClient
    {
        public static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(FilteredMessageHandler<TSession>));
        private readonly IDictionary<Type, List<Predicate<TSession>>> _filter = new Dictionary<Type, List<Predicate<TSession>>>();
        private readonly IList<IMessageHandler> _messageHandlers = new List<IMessageHandler>();

        public override async Task<bool> OnMessageReceived(WZClient wzsession, object message)
        {
            List<Predicate<TSession>> predicates;
            _filter.TryGetValue(message.GetType(), out predicates);

            TSession session = (TSession)wzsession;

            if (predicates != null && predicates.Any(predicate => !predicate(session)))
            {
                Logger.Debug("Dropping message {messageName} from client {remoteAddress}", message.GetType().Name, session.ID);
                return false;
            }

            var handled = false;
            foreach (var messageHandler in _messageHandlers)
            {
                var result = await messageHandler.OnMessageReceived(wzsession, message);
                if (result)
                    handled = true;
            }

            return handled;
        }

        public FilteredMessageHandler<TSession> AddHandler(IMessageHandler handler)
        {
            _messageHandlers.Add(handler);
            return this;
        }

        public FilteredMessageHandler<TSession> RegisterRule<T>(params Predicate<TSession>[] predicates)
        {
            if (predicates == null)
                throw new ArgumentNullException(nameof(predicates));

            _filter.AddOrUpdate(typeof(T),
                new List<Predicate<TSession>>(predicates),
                (key, oldValue) =>
                {
                    oldValue.AddRange(predicates);
                    return oldValue;
                });
            return this;
        }

        public FilteredMessageHandler<TSession> RegisterRule<T>(Predicate<TSession> predicate)
        {
            _filter.AddOrUpdate(typeof(T),
                new List<Predicate<TSession>> { predicate },
                (key, oldValue) =>
                {
                    oldValue.Add(predicate);
                    return oldValue;
                });
            return this;
        }
    }
}

--file OPCodes.cs
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace CSEmu.Network
{
    enum MainOpCode : ushort
    {
        Join = 0xFF00,
        GSJoin = 0xFF10,
        GSKeep = 0xFF11,
        GSClientAdd = 0xFF12,
        GSClientChat = 0xFF13,
        GSClientRem = 0xFF14,
        ServerInfo = 0x03F4,
        ServerList = 0x06F4,
        Unk = 0xFFA9,
    }

    enum ChatOpCode : ushort
    {
        Auth = 0xFF00,
        Unk1,
        Unk2,
        Unk3,
        Message,
        Keep,
    }
}


--file C2S.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace CSEmu.Network.Services
{
    [WZContract]
    public class CServerList : IMainMessage
    {
    }

    [WZContract]
    public class CServerInfo : IMainMessage
    {
        [WZMember(0)]
        public ushort Index { get; set; }
    }

    [WZContract]
    public class CRegistryReq : IMainMessage
    {
        [WZMember(0)]
        public ushort Index { get; set; }

        [WZMember(1, 16)]
        public byte[] btAddress { get; set; }

        [WZMember(2)]
        public ushort Port { get; set; }

        [WZMember(3)]
        public byte Show { get; set; }

        [WZMember(4, 16)]
        public byte[] btToken { get; set; }

        [WZMember(5, 16)]
        public byte[] btName { get; set; }
        [WZMember(6)] public byte Type { get; set; }

        public string Address { get => btAddress.MakeString(); set => btAddress = value.GetBytes(); }
        public string Token { get => btToken.MakeString(); set => btToken = value.GetBytes(); }
        public string Name { get => btName.MakeString(); set => btName = value.GetBytes(); }
    }

    [WZContract]
    public class CKeepAlive : IMainMessage
    {
        [WZMember(0)]
        public ushort Index { get; set; }

        [WZMember(1)]
        public byte Load { get; set; }

        [WZMember(2, 16)]
        public byte[] btToken { get; set; }
        public string Token { get => btToken.MakeString(); set => btToken = value.GetBytes(); }
    }
}


--file MainMessageFactory.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Network;

namespace CSEmu.Network.Services
{
    public interface IMainMessage
    { }

    internal class MainMessageFactory : MessageFactory<MainOpCode, IMainMessage>
    {
        public MainMessageFactory()
        {
            // C2S
            Register<CServerList>(MainOpCode.ServerList);
            Register<CServerInfo>(MainOpCode.ServerInfo);

            // GS Messages
            Register<CRegistryReq>(MainOpCode.GSJoin);
            Register<CKeepAlive>(MainOpCode.GSKeep);
            Register<SCAdd>(MainOpCode.GSClientAdd);
            Register<SCChat>(MainOpCode.GSClientChat);
            Register<SCRem>(MainOpCode.GSClientRem);

            // S2C
            Register<SConnectResult>(MainOpCode.Join);
            Register<SServerList>(MainOpCode.ServerList);
            Register<SServerInfo>(MainOpCode.ServerInfo);
        }
    }
}


--file MainServices.cs
﻿using CSEmu.Network.Data;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WebZen.Handlers;
using WebZen.Util;

namespace CSEmu.Network.Services
{
    public class MainServices : MessageHandler
    {
        public static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(MainServices));

        [MessageHandler(typeof(CServerList))]
        public void ServerListHandler(CSSession session, CServerList message)
        {
            var servers = ServerManager.Instance.Servers
                .Where(x => x.Visible)
                .Select(x => new ServerDto { Index = x.Index, Load = x.Load, Type = x.Type })
                .ToArray();
            Logger.Information("Sending Server list {0} servers", servers.Length);
            session.SendAsync(new SServerList(servers));
        }

        [MessageHandler(typeof(CServerInfo))]
        public void ServerInfoHandler(CSSession session, CServerInfo message)
        {
            var server = ServerManager.Instance.GetServer(message.Index);
            Logger.Information("Forwarding to {0}", server.Name);
            session.SendAsync(new SServerInfo
            {
                Address = server.Address,
                Port = server.Port
            });
        }

        [MessageHandler(typeof(CRegistryReq))]
        public void RegistryHandler(CSSession session, CRegistryReq message)
        {
            ServerManager.Instance.Register(session, (byte)message.Index, message.Address, message.Port, message.Show != 0, message.Token, message.Name, message.Type);
            var arg = new CServerList();
            Program.server.Clients.ToList().ForEach(x => ServerListHandler(x, arg));
        }

        [MessageHandler(typeof(CKeepAlive))]
        public void KeepAliveHandler(CSSession session, CKeepAlive message)
        {
            ServerManager.Instance.Keep((byte)message.Index, message.Load, message.Token);
        }

        [MessageHandler(typeof(SCAdd))]
        public void SCAdd(CSSession session, SCAdd message)
        {
            Logger.Information("FriendSystem: [" + message.Server + "] " + message.btName.MakeString() + " ADD");
            Program.Clients.AddClient(message);
        }

        [MessageHandler(typeof(SCRem))]
        public void SCRem(CSSession session, SCRem message)
        {
            Program.Clients.RemClient(message);
        }
    }
}


--file S2C.cs
﻿using CSEmu.Network.Data;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace CSEmu.Network.Services
{
    [WZContract]
    public class SConnectResult : IMainMessage
    {
        [WZMember(0)]
        public byte Result { get; set; }

        public SConnectResult()
        { }

        public SConnectResult(byte result)
        {
            Result = result;
        }
    }

    [WZContract(LongMessage = true)]
    public class SServerList : IMainMessage
    {
        [WZMember(0)]
        public byte CountH { get; set; }

        [WZMember(1)]
        public byte CountL { get; set; }

        [WZMember(2, SerializerType = typeof(ArraySerializer))]
        public ServerDto[] List { get; set; }

        public SServerList()
        { }

        public SServerList(ServerDto[] list)
        {
            CountH = (byte)(list.Length >> 8);
            CountL = (byte)(list.Length & 0xff);
            List = list;
        }
    }

    [WZContract]
    public class SServerInfo : IMainMessage
    {
        [WZMember(0, 16)]
        public byte[] btAddress { get; set; }

        [WZMember(1)]
        public ushort Port { get; set; }

        public string Address
        {
            set => btAddress = value.GetBytes();
            get => btAddress.MakeString();
        }

        public SServerInfo()
        {
            btAddress = Array.Empty<byte>();
        }
    }

    [WZContract]
    public class SCAdd : IMainMessage
    {
        [WZMember(0)]
        public byte Server { get; set; }

        [WZMember(1, 10)]
        public byte[] btName { get; set; }
    }

    [WZContract]
    public class SCChat : IMainMessage
    {
        [WZMember(0)]
        public byte Server { get; set; }

        [WZMember(1, 10)]
        public byte[] btName { get; set; }

        [WZMember(2, 100)]
        public byte[] btChat { get; set; }
    }

    [WZContract]
    public class SCRem : IMainMessage
    {
        [WZMember(0)]
        public byte Server { get; set; }

        [WZMember(1, typeof(ArrayWithScalarSerializer<short>))]
        public CliRemDto[] List { get; set; }
    }

    [WZContract]
    public class CliRemDto : IMainMessage
    {
        [WZMember(0, 10)]
        public byte[] btName { get; set; }
    }
}


--file WZChatServer.cs
﻿using System;
using System.Collections.Generic;
using System.Net;
using System.Text;
using WebZen.Handlers;
using WebZen.Network;

namespace CSEmu.Network
{
    public class WZChatServer : WZServer
    {
        public WZChatServer(IPEndPoint address, MessageHandler[] handler, MessageFactory[] factories, bool useRijndael)
        {
            Initialize(address, handler, new CSSessionFactory(), factories, useRijndael);
            SimpleStream = true;
        }

        /*protected override void OnConnect(WZClient session)
        {
            var Session = session as CSSession;

            Session.SendAsync(new SConnectResult(1));
        }*/

        public override void OnDisconnect(WZClient session)
        {
            base.OnDisconnect(session);

            var Session = session as CSSession;
        }
    }
}


--file WZConnectServer.cs
﻿using CSEmu.Network.Services;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text;
using WebZen.Handlers;
using WebZen.Network;

namespace CSEmu.Network
{
    internal class WZConnectServer : WZServer
    {
        public IEnumerable<CSSession> Clients => _clients.Values.Select(x => x as CSSession);
        public WZConnectServer(IPEndPoint address, MessageHandler[] handler, MessageFactory[] factories, bool useRijndael)
        {
            Initialize(address, handler, new CSSessionFactory(), factories, useRijndael);
            SimpleStream = true;
        }

        protected override void OnConnect(WZClient session)
        {
            var Session = session as CSSession;
            
            Session.SendAsync(new SConnectResult(1));
        }

        public override void OnDisconnect(WZClient session)
        {
            base.OnDisconnect(session);

            var Session = session as CSSession;
            ServerManager.Instance.Unregister(Session);
        }
    }
}


--file .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


--file CSEmu.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("CSEmu")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("CSEmu")]
[assembly: System.Reflection.AssemblyTitleAttribute("CSEmu")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file .NETCoreApp,Version=v3.1.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v3.1", FrameworkDisplayName = ".NET Core 3.1")]


--file CSEmu.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("CSEmu")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("CSEmu")]
[assembly: System.Reflection.AssemblyTitleAttribute("CSEmu")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


--file CSEmu.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("CSEmu")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("CSEmu")]
[assembly: System.Reflection.AssemblyTitleAttribute("CSEmu")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file Program.cs
﻿using CSEmu.Network;
using CSEmu.Network.Services;
using Serilog;
using System;
using System.Net;
using WebZen.Handlers;
using WebZen.Network;
using System.Linq;
using System.Threading;
using MuEmu.Entity;
using System.Collections.Generic;
using CSEmu.XML;
using System.ComponentModel;

namespace CSEmu
{
    class Program
    {
        public static WZConnectServer server;
        public static WZChatServer WZChatServer;
        public static ClientManager Clients;
        private static readonly Dictionary<int, int> _classSuperior = new Dictionary<int, int>
        {
            { 1, 1 },
            { 5, 2 },
            { 10, 3 },
            { 30, 4 },
            { 50, 5 },
            { 100, 6 },
            { 200, 7 },
            { 300, 8 },
            { 9999, 9 },
        };
        private static readonly Dictionary<int, int> _class = new Dictionary<int, int>
        {
            { 6000, 10 },
            { 3000, 11 },
            { 1500, 12 },
            { 500, 13 },
            { 0, 14 }
        };
        static void Main(string[] args)
        {
            Serilog.Core.Logger logger = new LoggerConfiguration()
                .Destructure.ByTransforming<IPEndPoint>(endPoint => endPoint.ToString())
                .Destructure.ByTransforming<EndPoint>(endPoint => endPoint.ToString())
                .WriteTo.File("ConnectServer.txt")
                .WriteTo.Console(outputTemplate: "[{Level} {SourceContext}] {Message}{NewLine}{Exception}")
                .MinimumLevel.Debug()
                .CreateLogger();
            Log.Logger = logger;

            CSConfigDto xml;

            try
            {
                xml = XmlManagement.XmlLoader<CSConfigDto>("configuration.xml");
            }catch(Exception)
            {
                xml = fillFile(typeof(CSConfigDto), "xml") as CSConfigDto;
                XmlManagement.XmlSaver("configuration.xml", xml);
            }

            var mh = new MessageHandler[] {
                new FilteredMessageHandler<CSSession>()
                    .AddHandler(new MainServices())
            };

            var mf = new MessageFactory[]
            {
                new MainMessageFactory()
            };

            logger.Information("API Key for GameServers is {0}", xml.apiKey);
            GameContext.ConnectionString = $"Server={xml.DataBase.IP};port=3306;Database={xml.DataBase.Name};user={xml.DataBase.User};password={xml.DataBase.Password};Convert Zero Datetime=True;";
            logger.Information("Connection String is {0}", GameContext.ConnectionString);


            var Connip = new IPEndPoint(IPAddress.Parse(xml.IP), 44405);
            var Chatip = new IPEndPoint(IPAddress.Parse(xml.IPChat), 55980);
            server = new WZConnectServer(Connip, mh, mf, false);
            WZChatServer = new WZChatServer(Chatip, mh, mf, false);
            ServerManager.Initialize(xml.apiKey);
            Clients = new ClientManager();

            var thread = new Thread(SubSytem);
            thread.Start();

            while (true)
            {
                var input = Console.ReadLine();
                if (input == null)
                    break;

                if (input.Equals("exit", StringComparison.InvariantCultureIgnoreCase) ||
                    input.Equals("quit", StringComparison.InvariantCultureIgnoreCase) ||
                    input.Equals("stop", StringComparison.InvariantCultureIgnoreCase))
                    break;
            }

            thread.Abort();
        }

        public static object fillFile(Type tType, string propParent = "")
        {
            //var tType = typeof(T);
            var file = Activator.CreateInstance(tType);

            var membs = tType.GetProperties();
            foreach(var mem in membs)
            {
                var prop = tType.GetProperty(mem.Name);
                if(prop.PropertyType.IsClass && typeof(string) != prop.PropertyType)
                {
                    prop.SetValue(file, fillFile(prop.PropertyType, propParent + "." + prop.Name));
                    continue;
                }
                var defaultv = prop.GetValue(file);
                var converter = TypeDescriptor.GetConverter(prop.PropertyType);
                Log.Information("Set Value for {0} type {1}, Default value {2}", propParent+"."+mem.Name, prop.PropertyType.Name, defaultv);
                Log.Information("Clear for default");
                var read = Console.ReadLine();
                if (!string.IsNullOrEmpty(read))
                    prop.SetValue(file, converter.ConvertFrom(read));
            }

            return file;
        }

        private static void SubSytem()
        {
            while(true)
            {
                Thread.Sleep(60000);
                var now = DateTime.Now;
                if (now.Minute != 0)
                    return;

                switch (now.Hour)
                {
                    case 0:
                    case 2:
                    case 8:
                    case 12:
                    case 18:
                    case 22:
                        Log.Information("Updating Gens Clasification");
                        using (var db = new GameContext())
                        {
                            var duprians = from c in db.Gens
                                           where c.Influence == 1
                                           orderby c.Contribution descending
                                           select c;
                            var vanerts = from c in db.Gens
                                          where c.Influence == 2
                                          orderby c.Contribution descending
                                          select c;

                            var i = 1;
                            foreach (var c in duprians)
                            {
                                if (c.Contribution >= 10000)
                                {
                                    c.Class = _classSuperior.First(x => x.Key >= i).Value;
                                    c.Ranking = i++;
                                }
                                else
                                {
                                    c.Class = _class.First(x => x.Key <= c.Contribution).Value;
                                    c.Ranking = i++;
                                }
                            }

                            db.UpdateRange(duprians);
                            db.SaveChanges();

                            i = 1;
                            foreach (var c in vanerts)
                            {
                                if (c.Contribution >= 10000)
                                {
                                    c.Class = _classSuperior.First(x => x.Key >= i).Value;
                                    c.Ranking = i++;
                                }
                                else
                                {
                                    c.Class = _class.First(x => x.Key <= c.Contribution).Value;
                                    c.Ranking = i++;
                                }
                            }

                            db.UpdateRange(vanerts);
                            db.SaveChanges();
                        }
                        break;
                }
            }
        }
    }
}


--file ServerManager.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Serilog.Core;
using Serilog;
using CSEmu.Network;

namespace CSEmu
{
    public class ServerInfo
    {
        public ushort Index { get; set; }
        public string Address { get; set; }
        public string Name { get; set; }
        public ushort Port { get; set; }
        public byte Load { get; set; }
        public DateTime LastPush { get; set; }
        public bool Visible { get; set; }
        public byte Type { get; internal set; }
    }

    public class ServerManager
    {
        public static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(ServerManager));
        private Dictionary<ushort, ServerInfo> _servers;
        private Dictionary<CSSession, byte> _GSsessions;
        private string _token;

        public static ServerManager Instance { get; private set; }

        public ServerManager()
        {
            _servers = new Dictionary<ushort, ServerInfo>();
            _GSsessions = new Dictionary<CSSession, byte>();
        }

        public static void Initialize(string token)
        {
            if (Instance != null)
                throw new Exception("Already initialized");

            Instance = new ServerManager();
            Instance._token = token;
        }

        public void Register(CSSession session, byte index, string address, ushort port, bool display, string token, string name, byte type)
        {
            if(_token != token)
            {
                Logger.Error("Auth Token invalid");
                return;
            }

            lock (_servers)
            {
                _servers.Add(index, new ServerInfo { Index = index, Address = address, Port = port, LastPush = DateTime.Now, Visible = display, Name = name, Type = type });
                _GSsessions.Add(session, index);
            }

            Program.Clients.AddServer(index);

            Logger.Information("New server found [{0}]{4} {5} {1}:{2} {3}", index, address, port, display ? "SHOW":"HIDE", name, type==1?"NoPVP":"PVP");
        }

        public void Unregister(byte index)
        {
            lock (_servers)
            {
                _servers.Remove(index);
                var session = _GSsessions.Where(x => x.Value == index).Select(x => x.Key).FirstOrDefault();
                _GSsessions.Remove(session);
            }

            Program.Clients.RemServer(index);
            Logger.Information("Server {0} dead", index);
        }

        public void Unregister(CSSession session)
        {
            lock (_servers)
            {
                if (_GSsessions.ContainsKey(session))
                    Unregister(_GSsessions[session]);
            }
        }

        public void Keep(byte index, byte load, string token)
        {
            if (_token != token)
            {
                Logger.Error("Auth Token invalid");
                return;
            }

            lock (_servers)
            {
                _servers[index].LastPush = DateTime.Now;
                _servers[index].Load = load;
            }
        }

        public List<ServerInfo> Servers => GetServerList();

        public ServerInfo GetServer(ushort index)
        {
            lock (_servers)
            {
                return _servers[index];
            }
        }

        private List<ServerInfo> GetServerList()
        {
            List<byte> deadServers;
            lock (_servers)
            {
                deadServers = (from s in _servers
                                where DateTime.Now - s.Value.LastPush > TimeSpan.FromSeconds(30) && s.Value.Visible
                                select (byte)s.Key).ToList();
            }

            foreach(var s in deadServers)
            {
                Unregister(s);
            }

            lock (_servers)
            {
                return _servers.Select(x => x.Value).ToList();
            }
        }

        public void BroadCast(object message)
        {
            foreach(var gs in _GSsessions.Keys)
                gs.SendAsync(message);
        }
    }
}


--file CSConfigDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace CSEmu.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("ConnectServer")]
    public class CSConfigDto
    {
        [XmlElement] public string apiKey { get; set; } = "api-20220426";

        [XmlElement] public string IP { get; set; } = "127.0.0.1";

        [XmlElement] public string IPChat { get; set; } = "127.0.0.1";
        
        [XmlElement] public CSDataBaseDto DataBase { get; set; } = new CSDataBaseDto();
    }
    [XmlType(AnonymousType = true)]
    public class CSDataBaseDto
    {
        [XmlElement] public string IP { get; set; } = "127.0.0.1";
        [XmlElement] public string Name { get; set; } = "MuOnline";
        [XmlElement] public string User { get; set; } = "root";
        [XmlElement] public string Password { get; set; } = "";
    }
}


--file XmlManagement.cs
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml.Serialization;

namespace CSEmu
{
    internal static class XmlManagement
    {
        public static T XmlLoader<T>(string file)
        {
            var s = new XmlSerializer(typeof(T));
            using (var ts = File.OpenText(file))
                return (T)s.Deserialize(ts);
        }
        public static void XmlSaver<T>(string file, T xml)
        {
            var s = new XmlSerializer(typeof(T));
            using (var ts = File.OpenWrite(file))
                s.Serialize(ts, xml);
        }
    }
}


--file AntiHackMessageFactory.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Network;

namespace MU.Network.AntiHack
{
    public interface IAntiHackMessage
    { }

    public class AntiHackMessageFactory : MessageFactory<AHOpCode, IAntiHackMessage>
    {
        public AntiHackMessageFactory()
        {
            // C2S
            Register<CAHCheck>(AHOpCode.AHCheck);

            // S2C
            Register<SAHPreSharedKey>(AHOpCode.AHEncKey);
        }
    }
}


--file C2S.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MU.Network.AntiHack
{
    [WZContract]
    public class CAHCheck : IAntiHackMessage
    {
        [WZMember(0, 5)] public byte[] Data { get; set; }
    }
}


--file S2C.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MU.Network.AntiHack
{
    [WZContract]
    public class SAHPreSharedKey : IAntiHackMessage
    {
        [WZMember(0, 32)] public byte[] Key { get; set; }
    }
}


--file AuthMessageFactory.cs
﻿using MU.Resources;
using MySqlX.XDevAPI;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Network;

namespace MU.Network.Auth
{
    public interface IAuthMessage
    { }

    public class AuthMessageFactory : MessageFactory<CSOpCode, IAuthMessage>
    {
        public AuthMessageFactory(ServerSeason Season)
        {
            // C2S
            if(Season == ServerSeason.Season17Kor75)
                Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, true);

            Register<CIDAndPassS12>(CSOpCode.Login);
            Register<CCharacterList>(CSOpCode.CharacterList);
            Register<CCharacterMapJoin>(CSOpCode.JoinMap);
            Register<CCharacterMapJoin2>(CSOpCode.JoinMap2);
            Register<CCharacterCreate>(CSOpCode.CharacterCreate);
            Register<CCharacterDelete>(CSOpCode.CharacterDelete);
            Register<CServerMove>(CSOpCode.ServerMoveAuth);
            Register<CServerList>(CSOpCode.ChannelList);

            // S2C
            if(Season == ServerSeason.Season17Kor75)
                Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, false);

            Register<SServerList>(CSOpCode.ChannelList);
            Register<SEnableCreation>(CSOpCode.EnableCreate);
            Register<SJoinResult>(CSOpCode.JoinResult);
            Register<SJoinResultS16Kor>(CSOpCode.JoinResult);
            Register<SCharacterCreate>(CSOpCode.CharacterCreate);
            Register<SCharacterDelete>(CSOpCode.CharacterDelete);
            Register<SCharacterMapJoin2S12Eng>(CSOpCode.JoinMap2);
            Register<SCharacterMapJoin2S16Kor>(CSOpCode.JoinMap2);
            Register<SServerMove>(CSOpCode.ServerMove);
            Register<SCharacterList>(CSOpCode.CharacterList);
            Register<SCharacterListS9>(CSOpCode.CharacterList);
            Register<SCharacterListS12>(CSOpCode.CharacterList);
            Register<SCharacterListS16Kor>(CSOpCode.CharacterList);
            Register<SLoginResult>(CSOpCode.Login);
            Register<SCharacterMapJoin>(CSOpCode.JoinMap);
            Register<SCharacterMapJoin2>(CSOpCode.JoinMap2);
            VersionSelector.Register<SJoinResult>(ServerSeason.Season6Kor, CSOpCode.JoinResult);
            VersionSelector.Register<SJoinResultS16Kor>(ServerSeason.Season16Kor, CSOpCode.JoinResult);
            VersionSelector.Register<SCharacterMapJoin2>(ServerSeason.Season6Kor, CSOpCode.JoinMap2);
            VersionSelector.Register<SCharacterMapJoin2S12Eng>(ServerSeason.Season12Eng, CSOpCode.JoinMap2);
            VersionSelector.Register<SCharacterMapJoin2S16Kor>(ServerSeason.Season16Kor, CSOpCode.JoinMap2);
            VersionSelector.Register<SCharacterList>(ServerSeason.Season6Kor, CSOpCode.CharacterList);
            VersionSelector.Register<SCharacterListS9>(ServerSeason.Season9Eng, CSOpCode.CharacterList);
            VersionSelector.Register<SCharacterListS12>(ServerSeason.Season12Eng, CSOpCode.CharacterList);
            VersionSelector.Register<SCharacterListS16Kor>(ServerSeason.Season16Kor, CSOpCode.CharacterList);


            switch (Season)
            {
                /*case ServerSeason.Season17Kor75:
                    ChangeOPCode<CCharacterCreate>((CSOpCode)0x2652);
                    ChangeOPCode<CCharacterDelete>((CSOpCode)0x0652);
                    ChangeOPCode<SCharacterDelete>((CSOpCode)0x0782);
                    ChangeOPCode<CServerList>((CSOpCode)0x58F7);
                    ChangeOPCode<SServerList>((CSOpCode)0x3151);

                    ChangeOPCode<CIDAndPassS12>((CSOpCode)0x02F3);
                    ChangeOPCode<CCharacterList>((CSOpCode)0x6052);
                    ChangeOPCode<CCharacterMapJoin>((CSOpCode)0x0152);
                    ChangeOPCode<CCharacterMapJoin2>((CSOpCode)0x0052);
                    ChangeOPCode<SJoinResultS16Kor>((CSOpCode)0x003A);
                    ChangeOPCode<SLoginResult>((CSOpCode)0xFD3A);
                    ChangeOPCode<SCharacterListS16Kor>((CSOpCode)0x0482);
                    ChangeOPCode<SCharacterMapJoin>((CSOpCode)0x0582);
                    ChangeOPCode<SCharacterMapJoin2>(Data.ProtocolXChangeS17K75(CSOpCode.JoinMap2, false));//(CSOpCode)0x1482

                    ChangeOPCode<SEnableCreation>((CSOpCode)CSOpCode.EnableCreate);
                    //MiningSystemUnk 0x11C4
                    break;*/
                case ServerSeason.Season17Kor:
                    ChangeOPCode<CIDAndPassS12>(CSOpCode.LoginS17Kor);
                    ChangeOPCode<SLoginResult>(CSOpCode.LoginS17KorResp);
                    ChangeOPCode<CCharacterList>(CSOpCode.CharacterListS17Kor);
                    ChangeOPCode<SCharacterListS16Kor>(CSOpCode.CharacterListS17KorResp);
                    ChangeOPCode<CCharacterMapJoin>(CSOpCode.JoinMapS17Kor);
                    ChangeOPCode<SCharacterMapJoin>(CSOpCode.JoinMapS17KorResp);
                    ChangeOPCode<CCharacterMapJoin2>(CSOpCode.JoinMap2S17Kor);
                    ChangeOPCode<SCharacterMapJoin2>(CSOpCode.JoinMap2S17KorResp);
                    break;
                case ServerSeason.Season16Kor:
                case ServerSeason.Season12Eng:
                    //Register<SResets>(CSOpCode.Resets);
                    break;
                case ServerSeason.Season9Eng:
                    //Register<CIDAndPassS12>(CSOpCode.Login);
                    //Register<SResets>(CSOpCode.Resets);
                    //Register<SResetCharList>(CSOpCode.ResetList);
                    break;
                default:
                    ChangeType<CIDAndPass>(CSOpCode.Login, typeof(CIDAndPassS12));
                    break;
            }
        }
    }
}


--file Auth_C2S.cs
﻿using BlubLib.Serialization;
using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MU.Network.Auth
{
    [WZContract]
    public class CIDAndPass : IAuthMessage
    {
        [WZMember(0, 10)]
        public byte[] btAccount { get; set; }

        [WZMember(1, 10)]
        public byte[] btPassword { get; set; }

        [WZMember(2)]
        public uint TickCount { get; set; }

        [WZMember(3)]
        public ushort Padding { get; set; }

        [WZMember(4, typeof(BinaryStringSerializer), 5)]
        public string ClientVersion { get; set; }

        [WZMember(5, typeof(BinaryStringSerializer), 16)]
        public string ClientSerial { get; set; }

        public string Account => btAccount.MakeString();
        public string Password => btPassword.MakeString();
    }

    [WZContract]
    public class CIDAndPassS12 : IAuthMessage
    {
        [WZMember(0, 10)]
        public byte[] btAccount { get; set; }

        [WZMember(1, 20)]
        public byte[] btPassword { get; set; }

        [WZMember(3)]
        public uint TickCount { get; set; }

        [WZMember(4, typeof(BinaryStringSerializer), 5)]
        public string ClientVersion { get; set; }

        [WZMember(5, typeof(BinaryStringSerializer), 16)]
        public string ClientSerial { get; set; }

        public string Account => btAccount.MakeString();
        public string Password => btPassword.MakeString();
    }

    [WZContract]
    public class CCharacterList : IAuthMessage
    { }

    [WZContract]
    public class CServerList : IAuthMessage
    { }

    [WZContract]
    public class CCharacterCreate : IAuthMessage
    {
        [WZMember(0, typeof(BinaryStringSerializer), 10)]
        public string Name { get; set; }

        [WZMember(1)]
        public HeroClass Class { get; set; }
    }

    [WZContract]
    public class CCharacterDelete : IAuthMessage
    {
        [WZMember(0, typeof(BinaryStringSerializer), 10)]
        public string Name { get; set; }

        [WZMember(1, typeof(BinaryStringSerializer), 10)]
        public string JoominNumber { get; set; }
    }

    [WZContract]
    public class CCharacterMapJoin : IAuthMessage
    {
        [WZMember(0, typeof(BinaryStringSerializer), 10)]
        public string Name { get; set; }
    }

    [WZContract]
    public class CCharacterMapJoin2 : IAuthMessage
    {
        [WZMember(0, typeof(BinaryStringSerializer), 10)]
        public string Name { get; set; }
    }

    [WZContract]
    public class CServerMove : IAuthMessage
    {
        [WZMember(0, 12)] public byte[] btAccount { get; set; }
        [WZMember(1, typeof(BinaryStringSerializer), 12)] public string Character { get; set; }
        [WZMember(2)] public uint AuthCode1 { get; set; }
        [WZMember(3)] public uint AuthCode2 { get; set; }
        [WZMember(4)] public uint AuthCode3 { get; set; }
        [WZMember(5)] public uint AuthCode4 { get; set; }
        [WZMember(6)] public uint TickCount { get; set; }
        [WZMember(7, typeof(BinaryStringSerializer), 5)] public string ClientVersion { get; set; }
        [WZMember(8, typeof(BinaryStringSerializer), 16)] public string ClientSerial { get; set; }

        public string Account => btAccount.MakeString();
    }
}


--file Auth_S2C.cs
﻿using MU.DataBase;
using MU.Resources;
using MuEmu.Network.Data;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MU.Network.Auth
{
    [WZContract] // 0xC10CF10001IIIIVVVVVVVVVV
    public class SJoinResult : IAuthMessage
    {
        [WZMember(0)]
        public byte Result { get; set; }

        [WZMember(1)]
        public byte NumberH { get; set; }

        [WZMember(2)]
        public byte NumberL { get; set; }

        [WZMember(3, 5)]
        public byte[] ClientVersion { get; set; }

        public SJoinResult()
        {
            ClientVersion = Array.Empty<byte>();
        }

        public SJoinResult(byte result, int number, string clientVersion)
        {
            Result = result;
            NumberH = (byte)((number >> 8) & 0xff);
            NumberL = (byte)(number & 0xff);
            ClientVersion = clientVersion.GetBytes();
        }
    }

    [WZContract(/*ExtraEncode = typeof(WZExtraPacketEncodeS16Kor)*/)] // 0xC1
    public class SJoinResultS16Kor : IAuthMessage
    {
        [WZMember(0)]
        public byte Result { get; set; }

        [WZMember(1)]
        public byte junk1 { get; set; }

        [WZMember(2)]
        public byte NumberH { get; set; }

        [WZMember(3)]
        public uint junk2 { get; set; }

        [WZMember(4)]
        public byte NumberL { get; set; }

        [WZMember(5, 5)]
        public byte[] ClientVersion { get; set; }

        [WZMember(6)]
        public uint Key { get; set; }

        public SJoinResultS16Kor()
        {
            ClientVersion = Array.Empty<byte>();
        }

        public SJoinResultS16Kor(byte result, int number, string clientVersion)
        {
            Result = result;
            NumberH = (byte)((number >> 8) & 0xff);
            NumberL = (byte)(number & 0xff);
            ClientVersion = clientVersion.GetBytes();
        }
    }


    [WZContract]
    public class SLoginResult : IAuthMessage
    {
        [WZMember(1)]
        public LoginResult Result { get; set; }

        public SLoginResult()
        { }

        public SLoginResult(LoginResult result)
        {
            Result = result;
        }
    }

    [WZContract]
    public class SLoginResultS17 : IAuthMessage
    {
        [WZMember(0)]
        public byte UnkBYTE { get; set; }

        [WZMember(1)]
        public LoginResult Result { get; set; }

        [WZMember(2, typeof(BinarySerializer), 0x6)]
        public byte[] Unk { get; set; } = Array.Empty<byte>();

        public SLoginResultS17()
        { }

        public SLoginResultS17(LoginResult result)
        {
            Result = result;
        }
    }
    public abstract class CharList
    {
        public CharList()
        {

        }

        public CharList(byte maxClas, byte moveCnt, byte CharSlotCount, byte WhSlotCount)
        {

        }

        public abstract CharList AddChar(byte id, CharacterDto @char, byte[] charSet, GuildStatus gStatus);
    }

    [WZContract]
    public class SCharacterList : CharList, IAuthMessage
    {
        [WZMember(0)]
        public byte MaxClass { get; set; }

        [WZMember(1)]
        public byte MoveCount { get; set; }

        //public byte Count { get; set; }

        [WZMember(2, SerializerType = typeof(ArrayWithScalarSerializer<byte>))]
        public CharacterPreviewDto[] CharacterList { get; set; }

        public SCharacterList()
        {
            CharacterList = Array.Empty<CharacterPreviewDto>();
        }

        public SCharacterList(byte maxClas, byte moveCnt, byte CharSlotCount, byte WhSlotCount) : base(maxClas, moveCnt, CharSlotCount, WhSlotCount)
        {
            MaxClass = maxClas;
            MoveCount = moveCnt;
            CharacterList = Array.Empty<CharacterPreviewDto>();
        }

        public override CharList AddChar(byte id, CharacterDto @char, byte[] charSet, GuildStatus gStatus)
        {
            var l = CharacterList.ToList();
            l.Add(new CharacterPreviewDto(
                id, @char.Name, @char.Level, (ControlCode)@char.CtlCode, charSet.Take(18).ToArray(), gStatus
                ));
            CharacterList = l.ToArray();
            return this;
        }
    }

    [WZContract]
    public class SCharacterListS9 : CharList, IAuthMessage
    {
        [WZMember(0)]
        public byte MaxClass { get; set; }

        [WZMember(1)]
        public byte MoveCount { get; set; }

        [WZMember(2)]
        public byte Count { get; set; }

        [WZMember(3)]
        public byte WhExpansion { get; set; }

        [WZMember(5, SerializerType = typeof(ArraySerializer))]
        public CharacterPreviewS9Dto[] CharacterList { get; set; }

        public SCharacterListS9()
        {
            CharacterList = Array.Empty<CharacterPreviewS9Dto>();
        }

        public SCharacterListS9(byte maxClas, byte moveCnt, byte CharSlotCount, byte WhSlotCount) : base(maxClas, moveCnt, CharSlotCount, WhSlotCount)
        {
            MaxClass = maxClas;
            MoveCount = moveCnt;
            WhExpansion = WhSlotCount;
            CharacterList = Array.Empty<CharacterPreviewS9Dto>();
        }

        public override CharList AddChar(byte id, CharacterDto @char, byte[] charSet, GuildStatus gStatus)
        {
            var l = CharacterList.ToList();
            l.Add(new CharacterPreviewS9Dto(id, @char.Name, @char.Level, (ControlCode)@char.CtlCode, charSet.Take(18).ToArray(), gStatus, 3));
            CharacterList = l.ToArray();
            Count = (byte)CharacterList.Length;
            return this;
        }
    }

    [WZContract]
    public class SCharacterListS12 : CharList, IAuthMessage
    {
        [WZMember(0)] public byte MaxClass { get; set; }

        [WZMember(1)] public byte MoveCount { get; set; }

        [WZMember(2)] public byte Count { get; set; }

        [WZMember(3)] public byte CharacterSlotCount { get; set; }

        [WZMember(4)] public byte WhExpansion { get; set; }

        [WZMember(5, SerializerType = typeof(ArraySerializer))]
        public CharacterPreviewS12Dto[] CharacterList { get; set; }

        public SCharacterListS12()
        {
            CharacterList = Array.Empty<CharacterPreviewS12Dto>();
        }

        public SCharacterListS12(byte maxClas, byte moveCnt, byte CharSlotCount, byte WhSlotCount) : base(maxClas, moveCnt, CharSlotCount, WhSlotCount)
        {
            MaxClass = maxClas;
            MoveCount = moveCnt;
            CharacterSlotCount = CharSlotCount;
            WhExpansion = WhSlotCount;
            CharacterList = Array.Empty<CharacterPreviewS12Dto>();
        }

        public override CharList AddChar(byte id, CharacterDto @char, byte[] charSet, GuildStatus gStatus)
        {
            var l = CharacterList.ToList();
            l.Add(new CharacterPreviewS12Dto(id, @char.Name, @char.Level, (ControlCode)@char.CtlCode, charSet.Take(18).ToArray(), gStatus, 3));
            CharacterList = l.ToArray();
            Count = (byte)CharacterList.Length;
            return this;
        }
    }

    [WZContract(LongMessage = true)]
    public class SCharacterListS16Kor : CharList, IAuthMessage
    {
        [WZMember(0)] public byte unk1 { get; set; }
        [WZMember(1)] public byte MaxClass { get; set; }
        [WZMember(2)] public byte MoveCount { get; set; }
        [WZMember(3)] public byte Count { get; set; }
        [WZMember(4)] public byte CharacterSlotCount { get; set; }
        [WZMember(5)] public byte WhExpansion { get; set; }
        [WZMember(6, typeof(ArraySerializer))] public CharacterPreviewS16KorDto[] CharacterList { get; set; }

        public SCharacterListS16Kor()
        {
            CharacterList = Array.Empty<CharacterPreviewS16KorDto>();
        }

        public SCharacterListS16Kor(byte maxClas, byte moveCnt, byte CharSlotCount, byte WhSlotCount) : base(maxClas, moveCnt, CharSlotCount, WhSlotCount)
        {
            MaxClass = maxClas;
            MoveCount = moveCnt;
            CharacterSlotCount = CharSlotCount;
            WhExpansion = WhSlotCount;
            CharacterList = Array.Empty<CharacterPreviewS16KorDto>();
        }

        public override CharList AddChar(byte id, CharacterDto @char, byte[] charSet, GuildStatus gStatus)
        {
            var l = CharacterList.ToList();
            l.Add(new CharacterPreviewS16KorDto
            {
                CharSet = charSet,
                ControlCode = (ControlCode)@char.CtlCode,
                GuildStatus = gStatus,
                index = id,
                level = @char.Level,
                name = @char.Name,
                PKLevel = (byte)@char.PKLevel
            });
            CharacterList = l.ToArray();
            Count = (byte)CharacterList.Count();
            return this;
        }
    }

    [WZContract]
    public class SCharacterCreate : IAuthMessage
    {
        [WZMember(0)]
        public byte Result { get; set; } // 0: Error

        [WZMember(1, 10)]
        public byte[] btName { get; set; }

        [WZMember(2)]
        public byte Position { get; set; }

        [WZMember(3)]
        public ushort Level { get; set; }

        [WZMember(4)]
        public byte Class { get; set; }

        [WZMember(5, typeof(ArraySerializer))]
        public byte[] Equipament { get; set; }

        public SCharacterCreate()
        {
            btName = Array.Empty<byte>();
            Equipament = new byte[24];
        }

        public SCharacterCreate(byte result)
        {
            btName = Array.Empty<byte>();
            Equipament = new byte[24];

            Result = result;
        }

        public SCharacterCreate(byte result, string name, byte pos, ushort level, byte[] equip, byte @class)
        {
            btName = Array.Empty<byte>();
            Equipament = new byte[24];

            Result = result;
            Name = name;
            Position = pos;
            Level = level;
            Equipament = equip;
            Class = @class;
        }

        public string Name { get => btName.MakeString(); set => btName = value.GetBytes(); }
    }

    [WZContract]
    public class SCharacterDelete : IAuthMessage
    {
        [WZMember(0)]
        public CharacterDeleteResult Result { get; set; }
    }

    [WZContract]
    public class CharacterPreviewDto
    {
        [WZMember(0)] public byte ID { get; set; }//0

        [WZMember(1, 11)] public byte[] btName { get; set; }//1

        [WZMember(2)] public ushort Level { get; set; }//C,D

        [WZMember(3)] public ControlCode ControlCode { get; set; }//E

        [WZMember(4, 18)] public byte[] CharSet { get; set; }//F-20

        [WZMember(5)] public GuildStatus GuildStatus { get; set; }//21

        public CharacterPreviewDto() { }

        public CharacterPreviewDto(byte Id, string name, ushort level, ControlCode cc, byte[] charSet, GuildStatus gStatus)
        {
            ID = Id;
            btName = name.GetBytes();
            Level = level;
            ControlCode = cc;
            CharSet = charSet;
            GuildStatus = gStatus;
        }
    }

    [WZContract]
    public class CharacterPreviewS9Dto
    {
        [WZMember(0)]
        public byte ID { get; set; }

        [WZMember(1, 11)]
        public byte[] btName { get; set; }

        [WZMember(2)]
        public ushort Level { get; set; }

        [WZMember(3)]
        public ControlCode ControlCode { get; set; }

        [WZMember(4, 18)]
        public byte[] CharSet { get; set; }

        [WZMember(5)]
        public GuildStatus GuildStatus { get; set; }

        [WZMember(6)]
        public byte PKLevel { get; set; }

        [WZMember(7)]
        public byte unk { get; set; }

        public CharacterPreviewS9Dto() { }

        public CharacterPreviewS9Dto(byte Id, string name, ushort level, ControlCode cc, byte[] charSet, GuildStatus gStatus, byte pkLevel)
        {
            ID = Id;
            btName = name.GetBytes();
            Level = level;
            ControlCode = cc;
            CharSet = charSet;
            GuildStatus = gStatus;
            PKLevel = pkLevel;
        }
    }

    [WZContract]
    public class CharacterPreviewS12Dto
    {
        [WZMember(0)] public byte ID { get; set; }

        [WZMember(1, 11)] public byte[] btName { get; set; }

        [WZMember(2)] public ushort Level { get; set; }

        [WZMember(3)] public ControlCode ControlCode { get; set; }

        [WZMember(4, 18)] public byte[] CharSet { get; set; }

        [WZMember(5)] public GuildStatus GuildStatus { get; set; }

        [WZMember(6)] public byte PKLevel { get; set; }
        
        [WZMember(7)] public byte unk { get; set; }

        public CharacterPreviewS12Dto() { }

        public CharacterPreviewS12Dto(byte Id, string name, ushort level, ControlCode cc, byte[] charSet, GuildStatus gStatus, byte pkLevel)
        {
            ID = Id;
            btName = name.GetBytes();
            Level = level;
            ControlCode = cc;
            CharSet = charSet;
            GuildStatus = gStatus;
            PKLevel = pkLevel;
        }
    }

    [WZContract]
    public class CharacterPreviewS16KorDto
    {
        [WZMember(0)] public byte index { get; set; } // 0
        //MAX_CHARACTER_LENGTH + 1
        [WZMember(1, typeof(BinaryStringSerializer), 11)]
        public string name { get; set; } // 1
        [WZMember(2)] public ushort level { get; set; } // 12
        [WZMember(3)] public ControlCode ControlCode { get; set; } // 14
        //[MAX_PREVIEW_DATA]
        [WZMember(4, 20)]
        public byte[] CharSet { get; set; } // 15
        [WZMember(5)] public GuildStatus GuildStatus { get; set; } //35
        [WZMember(6)] public byte PKLevel { get; set; } //36
        [WZMember(7)] public byte unk37 { get; set; } //37
}

    [WZContract(Serialized = true)]
    public class SCharacterMapJoin : IAuthMessage
    {
        [WZMember(0, typeof(BinaryStringSerializer), 10)]
        public string Name { get; set; }

        [WZMember(1)]
        public byte Valid { get; set; }
    }

    [WZContract(Serialized = true)] // 0xC3
    public class SCharacterMapJoin2 : IAuthMessage
    {
        [WZMember(0)] public byte MapX { get; set; }//0
        [WZMember(1)] public byte MapY { get; set; }//1
        [WZMember(2)] public byte Map { get; set; }//2
        [WZMember(3)] public byte Direccion { get; set; }//3
        [WZMember(4)] public long Experience { get; set; }//4
        [WZMember(5)] public long NextExperience { get; set; }//c
        [WZMember(6)] public ushort LevelUpPoints { get; set; }//14
        [WZMember(7)] public ushort Str { get; set; }//16
        [WZMember(8)] public ushort Agi { get; set; }//18
        [WZMember(9)] public ushort Vit { get; set; }//1a
        [WZMember(10)] public ushort Ene { get; set; }//1c
        [WZMember(11)] public ushort Life { get; set; }//1e
        [WZMember(12)] public ushort MaxLife { get; set; }//20
        [WZMember(13)] public ushort Mana { get; set; }//22
        [WZMember(14)] public ushort MaxMana { get; set; }//24
        [WZMember(15)] public ushort Shield { get; set; }//26
        [WZMember(16)] public ushort MaxShield { get; set; }//28
        [WZMember(17)] public ushort Stamina { get; set; }//2a
        [WZMember(18)] public ushort MaxStamina { get; set; }//2c
        [WZMember(19)] public ushort unk { get; set; }
        [WZMember(20)] public uint Zen { get; set; }//2e
        [WZMember(21)] public byte PKLevel { get; set; }//36
        [WZMember(22)] public byte ControlCode { get; set; }//37
        [WZMember(23)] public short AddPoints { get; set; }//38
        [WZMember(24)] public short MaxAddPoints { get; set; }//3a 
        [WZMember(25)] public ushort Cmd { get; set; }//3c
        [WZMember(26)] public short MinusPoints { get; set; }//3e
        [WZMember(27)] public short MaxMinusPoints { get; set; }//40
        [WZMember(28)] public byte ExpandedInv { get; set; }//41
        [WZMember(29)] public uint Ruud { get; set; }//42
        //[WZMember(30)]
        //public byte ExpandedVault { get; set; }//44

        public SCharacterMapJoin2()
        {

        }

        public SCharacterMapJoin2(Maps mapID, byte x, byte y, byte direction, ushort strength, ushort agility, ushort vitality, ushort energy, ushort comm, long experience, long nextExperience, ushort hp, ushort hpMax, ushort mp, ushort mpMax, ushort shield, ushort maxShield, ushort bp, ushort bpMax, byte pk, short addPoints, short maxAddPoints, short minusPoints, short maxMinusPoints, ushort levelUpPoints, byte expandedInventory, uint Money, uint ruud, byte ctlCode)
        {
            Map = (byte)mapID;
            LevelUpPoints = levelUpPoints;
            Str = strength;
            Agi = agility;
            Vit = vitality;
            Ene = energy;
            Cmd = comm;
            Direccion = direction;
            Experience = experience.ShufleEnding();
            NextExperience = nextExperience.ShufleEnding();
            Life = hp;
            MaxLife = hpMax;
            Mana = mp;
            MaxMana = mpMax;
            Shield = shield;
            MaxShield = maxShield;
            Stamina = bp;
            MaxStamina = bpMax;
            Zen = Money;
            PKLevel = pk;
            AddPoints = addPoints;
            MaxAddPoints = maxAddPoints;
            MinusPoints = minusPoints;
            MaxMinusPoints = maxMinusPoints;
            ExpandedInv = expandedInventory;
            Ruud = ruud;
            ControlCode = ctlCode;
            MapX = x;
            MapY = y;
        }

        //45
        public Point Position
        {
            get => new Point(MapX, MapY);
            set
            {
                MapX = (byte)value.X;
                MapY = (byte)value.Y;
            }
        }
    }

    [WZContract(Serialized = true)] // 0xC3
    public class SCharacterMapJoin2S12Eng : IAuthMessage
    {
        [WZMember(0)] public byte MapX { get; set; }//0
        [WZMember(1)] public byte MapY { get; set; }//1
        [WZMember(2)] public byte Map { get; set; }//2
        [WZMember(3)] public byte Direccion { get; set; }//3
        [WZMember(4)] public long Experience { get; set; }//4
        [WZMember(5)] public long NextExperience { get; set; }//c
        [WZMember(6)] public ushort paddingC { get; set; }
        [WZMember(7)] public ushort LevelUpPoints { get; set; }//14
        [WZMember(8)] public ushort Str { get; set; }//16
        [WZMember(9)] public ushort Agi { get; set; }//18
        [WZMember(10)] public ushort Vit { get; set; }//1a
        [WZMember(11)] public ushort Ene { get; set; }//1c
        [WZMember(12)] public ushort Life { get; set; }//1e
        [WZMember(13)] public ushort MaxLife { get; set; }//20
        [WZMember(14)] public ushort Mana { get; set; }//22
        [WZMember(15)] public ushort MaxMana { get; set; }//24
        [WZMember(16)] public ushort Shield { get; set; }//26
        [WZMember(17)] public ushort MaxShield { get; set; }//28
        [WZMember(18)] public ushort Stamina { get; set; }//2a
        [WZMember(19)] public ushort MaxStamina { get; set; }//2c
        //[WZMember(20)] public ushort unk { get; set; }
        [WZMember(21)] public uint Zen { get; set; }//2e
        [WZMember(22)] public byte PKLevel { get; set; }//36
        [WZMember(23)] public byte ControlCode { get; set; }//37
        [WZMember(24)] public short AddPoints { get; set; }//38
        [WZMember(25)] public short MaxAddPoints { get; set; }//3a 
        [WZMember(26)] public ushort Cmd { get; set; }//3c
        [WZMember(27)] public short MinusPoints { get; set; }//3e
        [WZMember(28)] public short MaxMinusPoints { get; set; }//40
        [WZMember(29)] public byte ExpandedInv { get; set; }//41
        [WZMember(30)] public uint Ruud { get; set; }//42
        [WZMember(31)] public byte ExpandedVault { get; set; }//44

        public SCharacterMapJoin2S12Eng()
        {

        }

        public SCharacterMapJoin2S12Eng(Maps mapID, byte x, byte y, byte direction, ushort strength, ushort agility, ushort vitality, ushort energy, ushort comm, long experience, long nextExperience, ushort hp, ushort hpMax, ushort mp, ushort mpMax, ushort shield, ushort maxShield, ushort bp, ushort bpMax, byte pk, short addPoints, short maxAddPoints, short minusPoints, short maxMinusPoints, ushort levelUpPoints, byte expandedInventory, uint Money, uint ruud, byte ctlCode)
        {
            Map = (byte)mapID;
            LevelUpPoints = levelUpPoints;
            Str = strength;
            Agi = agility;
            Vit = vitality;
            Ene = energy;
            Cmd = comm;
            Direccion = direction;
            Experience = experience.ShufleEnding();
            NextExperience = nextExperience.ShufleEnding();
            Life = hp;
            MaxLife = hpMax;
            Mana = mp;
            MaxMana = mpMax;
            Shield = shield;
            MaxShield = maxShield;
            Stamina = bp;
            MaxStamina = bpMax;
            Zen = Money;
            PKLevel = pk;
            AddPoints = addPoints;
            MaxAddPoints = maxAddPoints;
            MinusPoints = minusPoints;
            MaxMinusPoints = maxMinusPoints;
            ExpandedInv = expandedInventory;
            Ruud = (ushort)ruud;
            ControlCode = ctlCode;
            MapX = x;
            MapY = y;
        }

        //45
        public Point Position
        {
            get => new Point(MapX, MapY);
            set
            {
                MapX = (byte)value.X;
                MapY = (byte)value.Y;
            }
        }
    }

    [WZContract(Serialized = true)] // 0xC3
    public class SCharacterMapJoin2S16Kor : IAuthMessage
    {
        [WZMember(0)] public byte MapX { get; set; }//4
        [WZMember(1)] public byte MapY { get; set; } //5
        [WZMember(2)] public Maps Map { get; set; } //6
        [WZMember(3)] public byte Direction { get; set; } //8
        [WZMember(4)] public long Experience { get; set; }// [8]; //9
        [WZMember(5)] public long NextExperience { get; set; }// [8]; //17
        [WZMember(6)] public byte unk1 { get; set; } //25
        [WZMember(7)] public ushort LevelUpPoints { get; set; } //26
        [WZMember(8)] public ushort Str { get; set; } //28
        [WZMember(9)] public ushort Agi { get; set; } //30
        [WZMember(10)] public ushort Vit { get; set; } //32
        [WZMember(11)] public ushort Ene { get; set; } //34
        [WZMember(12)] public ushort Life { get; set; } //36
        [WZMember(13)] public ushort MaxLife { get; set; } //38
        [WZMember(14)] public ushort Mana { get; set; } //40
        [WZMember(15)] public ushort MaxMana { get; set; } //42
        [WZMember(16)] public ushort Shield { get; set; } //44
        [WZMember(17)] public ushort MaxShield { get; set; } //46
        [WZMember(18)] public ushort Stamina { get; set; } //48
        [WZMember(19)] public ushort MaxStamina { get; set; } //50
        [WZMember(20)] public uint Zen { get; set; }  // 52
        [WZMember(21)] public byte PKLevel { get; set; } // 56
        [WZMember(22)] public byte ControlCode { get; set; } // 57
        [WZMember(23)] public short AddPoints { get; set; } // 58
        [WZMember(24)] public short MaxAddPoints { get; set; } // 60
        [WZMember(25)] public ushort Cmd { get; set; } // 62
        [WZMember(26)] public short MinusPoints { get; set; }  // 64
        [WZMember(27)] public short MaxMinusPoints { get; set; }  // 66
        [WZMember(28)] public byte ExpandedInv { get; set; }  // 68
        [WZMember(29)] public byte unk2 { get; set; } // 69
        [WZMember(30)] public byte unk3 { get; set; } // 70
        [WZMember(31)] public byte unk4 { get; set; } // 71
        [WZMember(32)] public uint Ruud { get; set; } // 72

        public SCharacterMapJoin2S16Kor() { }

        public SCharacterMapJoin2S16Kor(Maps mapID, byte x, byte y, byte direction, ushort strength, ushort agility, ushort vitality, ushort energy, ushort comm, long experience, long nextExperience, ushort hp, ushort hpMax, ushort mp, ushort mpMax, ushort shield, ushort maxShield, ushort bp, ushort bpMax, byte pk, short addPoints, short maxAddPoints, short minusPoints, short maxMinusPoints, ushort levelUpPoints, byte expandedInventory, uint money, uint ruud, byte ctlCode)
        {
            Map = mapID;
            MapX = x;
            MapY = y;
            Direction = direction;
            Str = strength;
            Agi = agility;
            Vit = vitality;
            Ene = energy;
            Cmd = comm;
            Experience = experience;
            NextExperience = nextExperience;
            Life = hp;
            MaxLife = hpMax;
            Mana = mp;
            MaxMana = mpMax;
            Shield = shield;
            MaxShield = maxShield;
            Stamina = bp;
            MaxStamina = bpMax;
            PKLevel = pk;
            AddPoints = addPoints;
            MaxAddPoints = maxAddPoints;
            MinusPoints = minusPoints;
            MaxMinusPoints = maxMinusPoints;
            LevelUpPoints = levelUpPoints;
            ExpandedInv = expandedInventory;
            Zen = money;
            Ruud = ruud;
        }
    }

    [WZContract]
    public class ServerDto
    {
        [WZMember(0)] public ushort server { get; set; }
        [WZMember(1)] public ushort data1 { get; set; }
        [WZMember(2)] public ushort data2 { get; set; }
        [WZMember(3)] public byte type { get; set; }
        [WZMember(4)] public byte gold { get; set; }
}

    [WZContract(LongMessage = true)]
    public class SServerList : IAuthMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<ushort>))] public ServerDto[] List { get; set; }
    }

    [WZContract]
    public class SServerMove : IAuthMessage
    {
        [WZMember(0, 16)] public byte[] IpAddress { get; set; }
        [WZMember(1)] public ushort ServerPort { get; set; }
        [WZMember(2)] public ushort ServerCode { get; set; }
        [WZMember(3)] public uint AuthCode1 { get; set; }
        [WZMember(4)] public uint AuthCode2 { get; set; }
        [WZMember(5)] public uint AuthCode3 { get; set; }
        [WZMember(6)] public uint AuthCode4 { get; set; }
    }

    [WZContract]
    public class SResetCharList : IAuthMessage
    {
        [WZMember(0, serializerType: typeof(ArraySerializer))] public ushort[] Resets { get; set; } = new ushort[5];
    }

    [WZContract]
    public class SResets : IAuthMessage
    {
        [WZMember(0)] public ushort Resets { get; set; }
    }

    [WZContract]
    public class SEnableCreation : IAuthMessage
    {
        [WZMember(0)]
        public EnableClassCreation EnableCreation { get; set; }
    }
}


--file CashShopMessageFactory.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Network;

namespace MU.Network.CashShop
{
    public interface ICashMessage
    { }

    public class CashShopMessageFactory : MessageFactory<CashOpCode, ICashMessage>
    {
        public CashShopMessageFactory(ServerSeason Season)
        {
            //C2S
            Register<CCashOpen>(CashOpCode.CashOpen);
            Register<CCashPoints>(CashOpCode.CashPointsS9);
            Register<CCashInventoryItem>(CashOpCode.CashInventoryCount);
            Register<CCashItemBuy>(CashOpCode.CashItemBuy);

            // S2C
            Register<SCashPointsS9>(CashOpCode.CashPointsS9);
            Register<SCashPoints>(CashOpCode.CashPoints);
            VersionSelector.Register<SCashPoints>(ServerSeason.Season6Kor, CashOpCode.CashPoints);
            VersionSelector.Register<SCashPointsS9>(ServerSeason.Season9Eng, CashOpCode.CashPoints);
            //VersionSelector.Register<SCashPointsS9>(ServerSeason.Season12Eng, CashOpCode.CashPoints);
            Register<SCashInit>(CashOpCode.CashInit);
            Register<SCashVersion>(CashOpCode.CashVersion);
            Register<SCashBanner>(CashOpCode.CashBanner);
            Register<SCashOpen>(CashOpCode.CashOpen);
            Register<SCashInventoryItem>(CashOpCode.CashInventoryCount);
            Register<SCashItemBuy>(CashOpCode.CashItemBuy);
            Register<SCashItemList>(CashOpCode.CashItemList);

            switch(Season)
            {
                case ServerSeason.Season17Kor75:
                    ChangeOPCode<SCashInit>(Data.ProtocolXChangeS17K75(CashOpCode.CashInit, false));
                    ChangeOPCode<SCashVersion>(Data.ProtocolXChangeS17K75(CashOpCode.CashVersion, false));
                    ChangeOPCode<SCashBanner>(Data.ProtocolXChangeS17K75(CashOpCode.CashBanner, false));
                    ChangeOPCode<SCashPointsS9>(Data.ProtocolXChangeS17K75(CashOpCode.CashPoints, false));
                    break;
            }
        }
    }
}


--file CashShop_C2S.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MU.Network.CashShop
{
    [WZContract]
    public class CCashOpen : ICashMessage
    { }
    [WZContract]
    public class CCashPoints : ICashMessage
    { }
    [WZContract]
    public class CCashInventoryItem : ICashMessage
    {
        [WZMember(0)]
        public int Page { get; set; }

        [WZMember(1)]
        public CSInventory InventoryType { get; set; }

        [WZMember(2)]
        public byte unk { get; set; }
    }
    [WZContract]
    public class CCashItemBuy : ICashMessage
    {
        [WZMember(0)]
        public int ItemIndex { get; set; }
        [WZMember(1)]
        public int Category { get; set; }
        [WZMember(2)]
        public int ItemOpt { get; set; }
        [WZMember(3)]
        public short ItemID { get; set; }
        [WZMember(4)]
        public CoinType Coin { get; set; }
    }
}


--file CashShop_S2C.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MU.Network.CashShop
{
    [WZContract]
    public class SCashPoints : ICashMessage
    {
        [WZMember(0)]
        public int CashPoints { get; set; }

        public SCashPoints()
        {

        }
        public SCashPoints(int wzCoinC, int wzCoinP, int goblinP)
        {
            CashPoints = wzCoinP;
        }
    }
    [WZContract]
    public class SCashPointsS9 : ICashMessage
    {
        [WZMember(0)]
        public byte ViewType { get; set; }
        [WZMember(1)]
        public long TotalCash { get; set; }
        [WZMember(2)]
        public long Cash_C { get; set; }
        [WZMember(3)]
        public long Cash_P { get; set; }
        [WZMember(4)]
        public long TotalPoint { get; set; }
        [WZMember(5)]
        public long GoblinPoint { get; set; }

        public SCashPointsS9()
        {

        }

        public SCashPointsS9(int wzCoinC, int wzCoinP, int goblinP)
        {
            ViewType = 0;
            TotalCash = wzCoinC;
            TotalPoint = goblinP + wzCoinP;
            GoblinPoint = goblinP;
            Cash_C = wzCoinC;
            Cash_P = wzCoinP;
        }
    }
    [WZContract]
    public class SCashInit : ICashMessage
    { }

    [WZContract]
    public class SCashVersion : ICashMessage
    {
        [WZMember(0)]
        public ushort Ver1 { get; set; }
        [WZMember(1)]
        public ushort Ver2 { get; set; }
        [WZMember(2)]
        public ushort Ver3 { get; set; }
    }

    [WZContract]
    public class SCashBanner : ICashMessage
    {
        [WZMember(0)]
        public ushort Ver1 { get; set; }
        [WZMember(1)]
        public ushort Ver2 { get; set; }
        [WZMember(2)]
        public ushort Ver3 { get; set; }
    }
    [WZContract]
    public class SCashOpen : ICashMessage
    {
        [WZMember(0)]
        public byte Result { get; set; }
    }

    [WZContract]
    public class SCashInventoryItem : ICashMessage
    {
        [WZMember(0)]
        public ushort TotalItemCount { get; set; }
        [WZMember(1)]
        public ushort CurrentItemCount { get; set; }
        [WZMember(2)]
        public ushort PageIndex { get; set; }
        [WZMember(3)]
        public ushort TotalPage { get; set; }
    }
    [WZContract]
    public class SCashItemBuy : ICashMessage
    {
        [WZMember(1)]
        public CSResult Result { get; set; }
        [WZMember(2)]
        public int Unknown { get; set; }
    }
    [WZContract]
    public class SCashItemList : ICashMessage
    {
        [WZMember(0)] public ushort aIndex { get; set; }
        [WZMember(1)] public CSInventory InvType { get; set; }
        [WZMember(2)] public byte InvNum { get; set; }
        [WZMember(3, typeof(BinaryStringSerializer), 11)] public string AccountID{ get; set; }
        [WZMember(4)] public int Result { get; set; }
        [WZMember(5, typeof(ArrayWithScalarSerializer<int>))] public SCashItemDto[] Items { get; set; }
    }

    [WZContract]
    public class SCashItemDto
    {
        [WZMember(0)] public int UniqueCode { get; set; }
        [WZMember(1)] public int AuthCode { get; set; }
        [WZMember(2)] public int UniqueID1 { get; set; }
        [WZMember(3)] public int UniqueID2 { get; set; }
        [WZMember(4)] public int UniqueID3 { get; set; }
        [WZMember(5)] public CSInventory InventoryType { get; set; }
        [WZMember(6, typeof(BinaryStringSerializer), 10)] public string GiftName{ get; set; }
        [WZMember(7, typeof(BinaryStringSerializer), 200)] public string Message{ get; set; }
    }
}


--file CastleSiege_C2S.cs
﻿using MU.Network.Event;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MU.Network.CastleSiege
{
    [WZContract]
    public class CSiegeState : IEventMessage
    { }
    [WZContract]
    public class CGuildRegisteInfo : IEventMessage
    { }
    [WZContract]
    public class CGuildMarkOfCastleOwner : IEventMessage
    { }
    [WZContract]
    public class CGuildRegiste : IEventMessage
    { }
    [WZContract]
    public class CSiegeGuildList : IEventMessage
    { }
    [WZContract]
    public class CSiegeRegisteMark : IEventMessage
    {
        [WZMember(0)] public byte ItemPos { get; set; }
    }
}


--file CastleSiege_S2C.cs
﻿using MU.Network.Event;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MU.Network.CastleSiege
{
    [WZContract]
    public class SLeftTimeAlarm : IEventMessage
    {
        public byte Hour { get; set; }    // 4
        public byte Minute { get; set; }	// 5
    }

    [WZContract]
    public class SSiegeState : IEventMessage
    {
		[WZMember(0)] public byte Result { get; set; }
		[WZMember(1)] public byte CastleSiegeState { get; set; }
		[WZMember(2)] public ushort StartYear { get; set; }
		[WZMember(3)] public byte StartMonth { get; set; }
		[WZMember(4)] public byte StartDay { get; set; }
		[WZMember(5)] public byte StartHour { get; set; }
		[WZMember(6)] public byte StartMinute { get; set; }
		[WZMember(7)] public ushort EndYear { get; set; }
		[WZMember(8)] public byte EndMonth { get; set; }
		[WZMember(9)] public byte EndDay { get; set; }
		[WZMember(10)] public byte EndHour { get; set; }
		[WZMember(11)] public byte EndMinute { get; set; }
		[WZMember(12)] public ushort SiegeStartYear { get; set; }
		[WZMember(13)] public byte SiegeStartMonth { get; set; }
		[WZMember(14)] public byte SiegeStartDay { get; set; }
		[WZMember(15)] public byte SiegeStartHour { get; set; }
		[WZMember(16)] public byte SiegeStartMinute { get; set; }
		[WZMember(17, typeof(BinaryStringSerializer), 8)] public string OwnerGuild { get; set; }
		[WZMember(18, typeof(BinaryStringSerializer), 10)] public string OwnerGuildMaster { get; set; }
		[WZMember(19)] public int StateLeftSec { get; set; }
	}

	[WZContract]
	public class SGuildRegisteInfo : IEventMessage
    {
		[WZMember(1)] public byte Result { get; set; }
		[WZMember(2, typeof(BinaryStringSerializer), 8)] public string GuildName { get; set; }
		[WZMember(3)] public int wzGuildMark { get; set; }
		[WZMember(4)] public byte IsGiveUp { get; set; }
		[WZMember(5)] public byte RegRank { get; set; }

		public int GuildMark { get => wzGuildMark.ShufleEnding(); set => wzGuildMark = value.ShufleEnding(); }
	}
	[WZContract]
	public class SGuildMarkOfCastleOwner : IEventMessage
    {
		[WZMember(0, 32)] public byte[] Mark { get; set; }
	}
	[WZContract]
	public class SGuildRegiste : IEventMessage
	{
		[WZMember(1)] public byte Result { get; set; }
		[WZMember(2, typeof(BinaryStringSerializer), 8)] public string GuildName { get; set; }
	}

	[WZContract]
	public class SiegueGuildDto
    {
		/*<thisrel this+0x0>*/ /*|0x8|*/
		[WZMember(0, typeof(BinaryStringSerializer), 8)] public string GuildName { get; set; }
		/*<thisrel this+0x8>*/ /*|0x4|*/
		[WZMember(1)] public int wzRegMarks { get; set; }
		/*<thisrel this+0xc>*/ /*|0x1|*/
		[WZMember(2)] public byte IsGiveUp { get; set; }
		/*<thisrel this+0xd>*/ /*|0x1|*/
		[WZMember(3)] public byte SeqNum { get; set; }

		public int RegMarks { get => wzRegMarks.ShufleEnding(); set => wzRegMarks = value.ShufleEnding(); }
	}
	[WZContract(LongMessage = true)]
	public class SSiegeGuildList : IEventMessage
	{
		[WZMember(1)] public byte Result { get; set; }
		[WZMember(2)] public byte Padding1 { get; set; }
		[WZMember(3)] public ushort Padding2 { get; set; }
		[WZMember(4, typeof(ArrayWithScalarSerializer<int>))] public SiegueGuildDto[] List { get; set; }
	}

	[WZContract]
	public class SSiegeRegisteMark : IEventMessage
	{
		[WZMember(1)] public byte Result { get; set; }
		[WZMember(2, typeof(BinaryStringSerializer), 8)] public string GuildName { get; set; }
		[WZMember(3)] public int wzGuildMark { get; set; }

		public int GuildMark { get => wzGuildMark.ShufleEnding(); set => wzGuildMark = value.ShufleEnding(); }
	}

	[WZContract]
	public class SJoinSideNotify : IEventMessage
	{
		[WZMember(1)] public byte Side { get; set; }
	}

	[WZContract]
	public class SCastleSiegeNotifyStart : IEventMessage
	{
		[WZMember(1)] public byte State { get; set; }
	}

	[WZContract]
	public class SCastleSiegeNotifySwitch : IEventMessage
	{
		[WZMember(0)] public ushort wzIndex { get; set; }
		[WZMember(1)] public ushort wzUserIndex { get; set; }
		[WZMember(2)] public byte State { get; set; }

		public ushort Index { get => wzIndex.ShufleEnding(); set => wzIndex = value.ShufleEnding(); }
		public ushort UserIndex { get => wzUserIndex.ShufleEnding(); set => wzUserIndex = value.ShufleEnding(); }
	}


	[WZContract]
	public class CastleSiegeMinimapDta : IEventMessage
	{
		[WZMember(0)] public byte X { get; set; }
		[WZMember(1)] public byte Y { get; set; }
	}

	[WZContract(LongMessage = true)]
	public class SCastleSiegeMinimapData : IEventMessage
	{
		[WZMember(0, typeof(ArrayWithScalarSerializer<int>))] public CastleSiegeMinimapDta[] List { get; set; }
	}


	[WZContract]
	public class CastleSiegeMinimapNPCDta : IEventMessage
	{
		[WZMember(0)] public byte Type { get; set; }
		[WZMember(1)] public byte X { get; set; }
		[WZMember(2)] public byte Y { get; set; }
	}

	[WZContract(LongMessage = true)]
	public class SCastleSiegeMinimapNPCData : IEventMessage
	{
		[WZMember(0, typeof(ArrayWithScalarSerializer<int>))] public CastleSiegeMinimapNPCDta[] List { get; set; }
	}

	[WZContract]
	public class SCastleSiegeNotifySwitchInfo : IEventMessage
	{
		[WZMember(0)] public ushort wzIndex { get; set; }
		[WZMember(1)] public byte State { get; set; }
		[WZMember(2)] public byte Side { get; set; }
		[WZMember(3, typeof(BinaryStringSerializer), 8)] public string GuildName { get; set; }
		[WZMember(4, typeof(BinaryStringSerializer), 10)] public string UserName { get; set; }
		public ushort Index { get => wzIndex.ShufleEnding(); set => wzIndex = value.ShufleEnding(); }
	}

	[WZContract]
	public class SCastleSiegeNotifyCrownState : IEventMessage
	{
		[WZMember(1)] public byte State { get; set; }
	}
}


--file FriendDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MuEmu.Network.Data
{
    [WZContract]
    public class FriendDto
    {
        [WZMember(0, 10)]
        public byte[] btName { get; set; }

        [WZMember(1)]
        public byte Server { get; set; }

        public string Name { get => btName.MakeString(); set => btName = value.GetBytes(); }
    }
}


--file GuildListDto.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MuEmu.Network.Data
{
    [WZContract]
    public class GuildListDto
    {
        [WZMember(0, 10)] public byte[] btName { get; set; }  // 0
        [WZMember(1)] public byte Number { get; set; }    // A
        [WZMember(2)] public byte ConnectAServer { get; set; }    // B
        [WZMember(3)] public GuildStatus btGuildStatus{ get; set; }   // C

        public string Name { get => btName.MakeString(); set => btName = value.GetBytes(); }
    }
}


--file GuildViewPortDto.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MuEmu.Network.Data
{
    [WZContract]
    public class GuildViewPortDto
    {
        [WZMember(0)]
        public int ID { get; set; }

        [WZMember(1)]
        public GuildStatus Status { get; set; }

        [WZMember(2)]
        public byte Type { get; set; }

        [WZMember(3)]
        public GuildRelation RelationShip { get; set; }

        [WZMember(4)]
        public ushort wzNumber { get; set; }

        [WZMember(5)]
        public byte CastleState { get; set; }

        public ushort Number { get => wzNumber.ShufleEnding(); set { wzNumber = value.ShufleEnding(); } }
    }
}


--file InventoryDto.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using WebZen.Serialization;

namespace MuEmu.Network.Data
{
    public interface IInventoryDto
    {
    }

    [WZContract]
    public class InventoryDto : IInventoryDto
    {
        [WZMember(0)]
        public byte Index { get; set; }

        [WZMember(1, 12)]
        public byte[] Item { get; set; }
        public InventoryDto()
        {

        }
        public InventoryDto(byte id, byte[] item)
        {
            Index = id;
            Item = item;
        }
    }
    [WZContract]
    public class InventoryS17Dto : IInventoryDto
    {
        [WZMember(0)]
        public byte Index { get; set; }

        [WZMember(1, 15)]
        public byte[] Item { get; set; }

        public InventoryS17Dto()
        {

        }
        public InventoryS17Dto(byte id, byte[] item)
        {
            Index = id;
            Item = item;
        }
    }
}


--file NewQuestInfoDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MuEmu.Network.Data
{
    [WZContract]
    public class NewQuestInfoDto
    {
        [WZMember(0)]
        public ushort Number { get; set; }
        [WZMember(1)]
        public ushort Quest { get; set; }
    }
}


--file PartyDto.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MuEmu.Network.Data
{
    public interface IPartyDto
    {
        public abstract IPartyDto Set(
            int number, 
            string name, 
            Maps map, 
            byte x, 
            byte y, 
            int life, 
            int maxLife, 
            int mana, 
            int maxMana,
            int channel,
            byte assistant);
    }
    [WZContract]
    public class PartyDto : IPartyDto
    {
        [WZMember(0, typeof(BinaryStringSerializer), 10)] public string Id { get; set; }
        [WZMember(1)] public byte Number { get; set; }
        [WZMember(2)] public byte Map { get; set; }
        [WZMember(3)] public byte X { get; set; }
        [WZMember(4)] public byte Y { get; set; }
        [WZMember(5)] public ushort Padding1 { get; set; }
        [WZMember(6)] public int Life { get; set; }
        [WZMember(7)] public int MaxLife { get; set; }

        public IPartyDto Set(int number, string name, Maps map, byte x, byte y, int life, int maxLife, int mana, int maxMana, int channel, byte assistant)
        {
            Number = (byte)number;
            Id = name;
            Map = (byte)Map;
            X = x;
            Y = y;
            Life = life;
            MaxLife = maxLife;
            return this;
        }
    }
    [WZContract]
    public class PartyS9Dto : PartyDto
    {
        [WZMember(8)]
        public int ServerChannel { get; set; }

        [WZMember(9)]
        public int Mana { get; set; }

        [WZMember(10)]
        public int MaxMana { get; set; }
    }

    [WZContract]
    public class PartyS16Dto : IPartyDto
    {
        [WZMember(0, typeof(BinaryStringSerializer), 10)] public string Id { get; set; }
        [WZMember(1)] public ushort Number { get; set; }
        [WZMember(2)] public ushort Level { get; set; }
        [WZMember(3)] public Maps Map { get; set; }
        [WZMember(4)] public byte X { get; set; }
        [WZMember(5)] public byte Y { get; set; }
        [WZMember(6)] public ushort Padding1 { get; set; }
        [WZMember(7)] public int Life { get; set; }
        [WZMember(8)] public int MaxLife { get; set; }
        [WZMember(9)] public int ServerChannel { get; set; }
        [WZMember(10)] public int Mana { get; set; }
        [WZMember(11)] public int MaxMana { get; set; }
        [WZMember(12)] public int Helper { get; set; }
        [WZMember(13)] public byte Assistant { get; set; }
        [WZMember(14)] public ushort unk42 { get; set; }

        public IPartyDto Set(int number, string name, Maps map, byte x, byte y, int life, int maxLife, int mana, int maxMana, int channel, byte assistant)
        {
            Number = (ushort)number;
            Id = name;
            Map = map;
            X = x;
            Y = y;
            Life = life;
            MaxLife = maxLife;
            Mana = mana;
            MaxMana = maxMana;
            ServerChannel = channel;
            Assistant = assistant;
            return this;
        }
    }
}


--file SpellDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MuEmu.Network.Data
{
    [WZContract]
    public class SpellDto
    {
        [WZMember(0)]
        public byte Index { get; set; }

        [WZMember(1)]
        public ushort Spell { get; set; }

        [WZMember(2)]
        public byte Padding { get; set; }
    }
}


--file VPChangeDto.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MuEmu.Network.Data
{
    [WZContract]
    public abstract class VPChangeAbs
    {
        [WZMember(0)]
        public byte NumberH { get; set; }

        [WZMember(1)]
        public byte NumberL { get; set; }

        [WZMember(2)]
        public byte X { get; set; }

        [WZMember(3)]
        public byte Y { get; set; }

        [WZMember(4)]
        public ushortle Skin { get; set; }

        [WZMember(6, 10)]
        public byte[] Id { get; set; } //10

        [WZMember(7)]
        public byte TX { get; set; }

        [WZMember(8)]
        public byte TY { get; set; }

        [WZMember(9)]
        public byte DirAndPkLevel { get; set; }
        //public ulong ViewSkillState;

        [WZMember(10, 18)]
        public byte[] CharSet { get; set; } //18

        public int Number
        {
            get => (NumberH << 8) | NumberL;
            set
            {
                NumberH = (byte)(value >> 8);
                NumberL = (byte)(value & 0xFF);
            }
        }

        public Point Position
        {
            get => new Point(X, Y);
            set
            {
                X = (byte)value.X;
                Y = (byte)value.Y;
            }
        }

        public Point TPosition
        {
            get => new Point(TX, TY);
            set
            {
                TX = (byte)value.X;
                TY = (byte)value.Y;
            }
        }

        public string Name
        {
            get => Id.MakeString();
            set => Id = value.GetBytes();
        }

    }

    [WZContract]
    public class VPChangeDto : VPChangeAbs
    {
        [WZMember(11, SerializerType = typeof(ArrayWithScalarSerializer<byte>))]
        //public byte SkillStateCount { get; set; }
        public byte[] ViewSkillState { get; set; } //Num_ViewSkillState

        public VPChangeDto()
        {
            CharSet = Array.Empty<byte>();
            Id = Array.Empty<byte>();
            ViewSkillState = Array.Empty<byte>();
        }
    }

    [WZContract]
    public class VPChangeS9Dto : VPChangeAbs
    {
        [WZMember(11)] public byte PentagramMainAttribute { get; set; }
        [WZMember(12)] public ushort wzMuunItem { get; set; }
        [WZMember(13)] public ushort wzMuunSubItem { get; set; }
        [WZMember(14)] public ushort wzMuunRideItem { get; set; }
        [WZMember(15)] public ushort wzLevel { get; set; }
        [WZMember(16)] public uint wzMaxLife { get; set; }
        [WZMember(17)] public uint wzCurLife { get; set; }
        [WZMember(18)] public ushort ServerCodeOfHomeWorld { get; set; }

        [WZMember(19, SerializerType = typeof(ArrayWithScalarSerializer<byte>))]
        public byte[] ViewSkillState { get; set; }

        public VPChangeS9Dto()
        {
            CharSet = Array.Empty<byte>();
            Id = Array.Empty<byte>();
            ViewSkillState = Array.Empty<byte>();
        }

        public ushort MuunItem { get => wzMuunItem.ShufleEnding(); set => wzMuunItem = value.ShufleEnding(); }
        public ushort MuunSubItem { get => wzMuunSubItem.ShufleEnding(); set => wzMuunSubItem = value.ShufleEnding(); }
        public ushort MuunRideItem { get => wzMuunRideItem.ShufleEnding(); set => wzMuunRideItem = value.ShufleEnding(); }
        public ushort Level { get => wzLevel.ShufleEnding(); set => wzLevel = value.ShufleEnding(); }
        public uint MaxLife { get => wzMaxLife.ShufleEnding(); set => wzMaxLife = value.ShufleEnding(); }
        public uint CurLife { get => wzCurLife.ShufleEnding(); set => wzCurLife = value.ShufleEnding(); }
    }
    [WZContract]
    public class VPChangeS12Dto : VPChangeAbs
    {
        [WZMember(11)] public byte PentagramMainAttribute { get; set; }
        [WZMember(12)] public ushortle MuunItem { get; set; }
        [WZMember(13)] public ushortle MuunSubItem { get; set; }
        [WZMember(14)] public ushortle MuunRideItem { get; set; }
        [WZMember(15)] public ushortle Level { get; set; }
        [WZMember(16)] public uint wzMaxLife { get; set; }
        [WZMember(17)] public uint wzCurLife { get; set; }
        [WZMember(18)] public ushort ServerCodeOfHomeWorld { get; set; }

        [WZMember(19, SerializerType = typeof(ArrayWithScalarSerializer<ushort>))]
        public SkillStates[] ViewSkillState { get; set; }

        public VPChangeS12Dto()
        {
            CharSet = Array.Empty<byte>();
            Id = Array.Empty<byte>();
            ViewSkillState = Array.Empty<SkillStates>();
        }
        public uint MaxLife { get => wzMaxLife.ShufleEnding(); set => wzMaxLife = value.ShufleEnding(); }
        public uint CurLife { get => wzCurLife.ShufleEnding(); set => wzCurLife = value.ShufleEnding(); }
    }
}


--file VPCreateDto.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MuEmu.Network.Data
{
    [WZContract]
    public abstract class VPCreateAbs
    {
        [WZMember(0)]
        public ushortle Number { get; set; }

        [WZMember(2)]
        public byte X { get; set; }

        [WZMember(3)]
        public byte Y { get; set; }

        public Point Position
        {
            get => new Point(X, Y);
            set
            {
                X = (byte)value.X;
                Y = (byte)value.Y;
            }
        }
        public object Player { get; set; }

        //[WZMember(4, 18)] public virtual byte[] CharSet { get; set; } //18
        //public ulong ViewSkillState;
    }

    [WZContract]
    public class VPCreateDto : VPCreateAbs
    {
        [WZMember(4, 18)] public byte[] CharSet { get; set; }

        [WZMember(5, typeof(BinaryStringSerializer), 10)]
        public string Name { get; set; } //10

        [WZMember(6)]
        public byte TX { get; set; }

        [WZMember(7)]
        public byte TY { get; set; }

        [WZMember(8)]
        public byte DirAndPkLevel { get; set; }

        public Point TPosition
        {
            get => new Point(TX, TY);
            set
            {
                TX = (byte)value.X;
                TY = (byte)value.Y;
            }
        }

        [WZMember(9, SerializerType = typeof(ArrayWithScalarSerializer<byte>))]
        public byte[] ViewSkillState { get; set; }

        public VPCreateDto()
        {
            CharSet = Array.Empty<byte>();
            //Id = Array.Empty<byte>();
            ViewSkillState = Array.Empty<byte>();
        }

    }

    [WZContract]
    public class VPCreateS9Dto : VPCreateAbs
    {
        [WZMember(4, 18)] public byte[] CharSet { get; set; }

        [WZMember(5, typeof(BinaryStringSerializer), 10)]
        public string Name { get; set; } //10

        [WZMember(6)]
        public byte TX { get; set; }

        [WZMember(7)]
        public byte TY { get; set; }

        [WZMember(8)]
        public byte DirAndPkLevel { get; set; }

        public Point TPosition
        {
            get => new Point(TX, TY);
            set
            {
                TX = (byte)value.X;
                TY = (byte)value.Y;
            }
        }
        [WZMember(9)] public byte PentagramMainAttribute { get; set; }
        [WZMember(10)] public ushort wzMuunItem { get; set; }
        [WZMember(11)] public ushort wzMuunSubItem { get; set; }
        [WZMember(12)] public ushort wzMuunRideItem { get; set; }
        [WZMember(13)] public ushort wzLevel { get; set; }
        [WZMember(14)] public uint wzMaxLife { get; set; }
        [WZMember(15)] public uint wzCurLife { get; set; }
        [WZMember(16)] public ushort ServerCodeOfHomeWorld { get; set; }
        [WZMember(17, SerializerType = typeof(ArrayWithScalarSerializer<byte>))] public byte[] ViewSkillState { get; set; }

        public VPCreateS9Dto()
        {
            CharSet = Array.Empty<byte>();
            //Id = Array.Empty<byte>();
            ViewSkillState = Array.Empty<byte>();
        }

        public ushort MuunItem { get => wzMuunItem.ShufleEnding(); set => wzMuunItem = value.ShufleEnding(); }
        public ushort MuunSubItem { get => wzMuunSubItem.ShufleEnding(); set => wzMuunSubItem = value.ShufleEnding(); }
        public ushort MuunRideItem { get => wzMuunRideItem.ShufleEnding(); set => wzMuunRideItem = value.ShufleEnding(); }
        public ushort Level { get => wzLevel.ShufleEnding(); set => wzLevel = value.ShufleEnding(); }
        public uint MaxLife { get => wzMaxLife.ShufleEnding(); set => wzMaxLife = value.ShufleEnding(); }
        public uint CurLife { get => wzCurLife.ShufleEnding(); set => wzCurLife = value.ShufleEnding(); }
    }

    [WZContract]
    public class VPCreateS12Dto : VPCreateAbs
    {
        [WZMember(4, 18)] public byte[] CharSet { get; set; }

        [WZMember(5, typeof(BinaryStringSerializer), 10)]
        public string Name { get; set; } //10

        [WZMember(6)]
        public byte TX { get; set; }

        [WZMember(7)]
        public byte TY { get; set; }

        [WZMember(8)]
        public byte DirAndPkLevel { get; set; }

        public Point TPosition
        {
            get => new Point(TX, TY);
            set
            {
                TX = (byte)value.X;
                TY = (byte)value.Y;
            }
        }
        [WZMember(9)] public byte PentagramMainAttribute { get; set; }
        [WZMember(10)] public ushortle MuunItem { get; set; }
        [WZMember(11)] public byte fill1 { get; set; }
        [WZMember(12)] public ushortle MuunSubItem { get; set; }
        [WZMember(13)] public byte fill2 { get; set; }
        [WZMember(14)] public ushortle MuunRideItem { get; set; }
        [WZMember(15)] public byte DarkSpirit { get; set; }
        [WZMember(16)] public ushortle Level { get; set; }
        [WZMember(17)] public uint wzMaxLife { get; set; }
        [WZMember(18)] public uint wzCurLife { get; set; }
        [WZMember(19)] public ushort ServerCodeOfHomeWorld { get; set; }
        [WZMember(20, SerializerType = typeof(ArrayWithScalarSerializer<ushort>))] public SkillStates[] ViewSkillState { get; set; }

        public VPCreateS12Dto()
        {
            CharSet = Array.Empty<byte>();
            //Id = Array.Empty<byte>();
            ViewSkillState = Array.Empty<SkillStates>();
        }

        public uint MaxLife { get => wzMaxLife.ShufleEnding(); set => wzMaxLife = value.ShufleEnding(); }
        public uint CurLife { get => wzCurLife.ShufleEnding(); set => wzCurLife = value.ShufleEnding(); }
    }
    [WZContract]
    public class VPCreateS16KorDto : VPCreateAbs
    {
        [WZMember(4, 20)] public byte[] CharSet { get; set; }
        [WZMember(5, typeof(BinaryStringSerializer), 10)] public string Name { get; set; } //10

        [WZMember(6)] public byte TX { get; set; }

        [WZMember(7)] public byte TY { get; set; }

        [WZMember(8)] public byte DirAndPkLevel { get; set; }

        public Point TPosition
        {
            get => new Point(TX, TY);
            set
            {
                TX = (byte)value.X;
                TY = (byte)value.Y;
            }
        }
        [WZMember(9)] public byte PentagramMainAttribute { get; set; }
        [WZMember(10)] public ushortle MuunItem { get; set; }
        [WZMember(11)] public byte fill1 { get; set; }
        [WZMember(12)] public ushortle MuunSubItem { get; set; }
        [WZMember(13)] public byte fill2 { get; set; }
        [WZMember(14)] public ushortle MuunRideItem { get; set; }
        [WZMember(15)] public byte DisplayMuun { get; set; }
        [WZMember(16)] public ushortle Mount { get; set; }
        [WZMember(17)] public byte DarkSpirit { get; set; }
        [WZMember(18)] public ushortle Level { get; set; }
        [WZMember(19)] public uint wzMaxLife { get; set; }
        [WZMember(20)] public uint wzCurLife { get; set; }
        [WZMember(21)] public byte unk61 { get; set; }
        [WZMember(22)] public ushort ServerCodeOfHomeWorld { get; set; }
        [WZMember(23)] public byte unk64 { get; set; }
        private byte vssc;
        [WZMember(24)] public byte ViewSkillStateCount { get => (byte)ViewSkillState.Length; set => vssc = value; }
        [WZMember(25)] public ushort unk66 { get; set; }
        [WZMember(26, SerializerType = typeof(ArraySerializer))] public SkillStates[] ViewSkillState { get; set; }

        public VPCreateS16KorDto()
        {
            CharSet = Array.Empty<byte>();
            //Id = Array.Empty<byte>();
            ViewSkillState = Array.Empty<SkillStates>();
        }

        public uint MaxLife { get => wzMaxLife.ShufleEnding(); set => wzMaxLife = value.ShufleEnding(); }
        public uint CurLife { get => wzCurLife.ShufleEnding(); set => wzCurLife = value.ShufleEnding(); }
    }
}


--file VPDestroyDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MuEmu.Network.Data
{
    [WZContract]
    public class VPDestroyDto
    {
        [WZMember(0)]
        public ushort Number { get; set; }

        public VPDestroyDto()
        { }

        public VPDestroyDto(ushort num)
        {
            Number = num.ShufleEnding();
        }
    }
}


--file VPICreateDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MuEmu.Network.Data
{
    [WZContract]
    public class VPICreateDto
    {
        [WZMember(0)]
        public ushort wzNumber { get; set; }

        [WZMember(1)]
        public byte X { get; set; }

        [WZMember(2)]
        public byte Y { get; set; }

        [WZMember(3, 12)]
        public byte[] ItemInfo { get; set; }
    }
}


--file VPMCreateDto.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MuEmu.Network.Data
{
    [WZContract]
    public abstract class VPMCreateAbs
    {
        [WZMember(0)]
        public ushortle Number { get; set; }

        [WZMember(2)]
        public ushortle Type { get; set; }

        [WZMember(4)]
        public byte X { get; set; }

        [WZMember(5)]
        public byte Y { get; set; }

        [WZMember(6)]
        public byte TX { get; set; }

        [WZMember(7)]
        public byte TY { get; set; }

        [WZMember(8)]
        public byte Path { get; set; }

        public Point Position
        {
            get => new Point(X, Y);
            set
            {
                X = (byte)value.X;
                Y = (byte)value.Y;
            }
        }

        public Point TPosition
        {
            get => new Point(TX, TY);
            set
            {
                TX = (byte)value.X;
                TY = (byte)value.Y;
            }
        }
    }

    [WZContract]
    public class VPMCreateDto : VPMCreateAbs
    {
        [WZMember(9, typeof(ArrayWithScalarSerializer<byte>))]
        public byte[] ViewSkillState { get; set; }

        public VPMCreateDto()
        {
            ViewSkillState = Array.Empty<byte>();
        }
    }

    [WZContract]
    public class VPMCreateS9Dto : VPMCreateAbs
    {
        [WZMember(9)]
        public Element PentagramMainAttribute { get; set; }
        [WZMember(10)]
        public ushortle Level { get; set; }
        [WZMember(11, typeof(ArraySerializer))]
        public byte[] wzMaxLife { get; set; }
        [WZMember(12, typeof(ArraySerializer))]
        public byte[] wzLife { get; set; }
        public uint MaxLife
        {
            get
            {
                uint result = 0;
                result |= (uint)wzMaxLife[0] << 24;//HB-HW
                result |= (uint)wzMaxLife[1] << 8;
                result |= (uint)wzMaxLife[2] << 16;
                result |= (uint)wzMaxLife[3];
                return result;
            }

            set
            {
                wzMaxLife = new byte[4];
                wzMaxLife[0] = (byte)(value >> 24);
                wzMaxLife[1] = (byte)(value >> 8);
                wzMaxLife[2] = (byte)(value >> 16);
                wzMaxLife[3] = (byte)(value);
            }
        }

        public uint Life
        {
            get
            {
                uint result = 0;
                result |= (uint)wzLife[0] << 24;//HB-HW
                result |= (uint)wzLife[1] << 8;
                result |= (uint)wzLife[2] << 16;
                result |= (uint)wzLife[3];
                return result;
            }

            set
            {
                wzLife = new byte[4];
                wzLife[0] = (byte)(value >> 24);
                wzLife[1] = (byte)(value >> 8);
                wzLife[2] = (byte)(value >> 16);
                wzLife[3] = (byte)(value);
            }
        }

        [WZMember(13, typeof(ArrayWithScalarSerializer<byte>))]
        public byte[] ViewSkillState { get; set; }

        public VPMCreateS9Dto()
        {
            ViewSkillState = Array.Empty<byte>();
        }        
    }

    [WZContract]
    public class VPMCreateS12Dto : VPMCreateAbs
    {
        [WZMember(9)]
        public Element PentagramMainAttribute { get; set; }
        [WZMember(10)]
        public ushortle Level { get; set; }
        [WZMember(11, typeof(ArraySerializer))]
        public byte[] wzMaxLife { get; set; }
        [WZMember(12, typeof(ArraySerializer))]
        public byte[] wzLife { get; set; }

        [WZMember(14, typeof(ArrayWithScalarSerializer<byte>))]
        public SkillStates[] ViewSkillState { get; set; }
        /*[WZMember(14)]
        public ushort padding { get; set; }*/


        public VPMCreateS12Dto()
        {
            ViewSkillState = new SkillStates[32];
        }

        public uint MaxLife
        {
            get
            {
                uint result = 0;
                result |= (uint)wzMaxLife[0] << 24;//HB-HW
                result |= (uint)wzMaxLife[1] << 8;
                result |= (uint)wzMaxLife[2] << 16;
                result |= (uint)wzMaxLife[3];
                return result;
            }

            set
            {
                wzMaxLife = new byte[4];
                wzMaxLife[0] = (byte)(value >> 24);
                wzMaxLife[1] = (byte)(value >> 8);
                wzMaxLife[2] = (byte)(value >> 16);
                wzMaxLife[3] = (byte)(value);
            }
        }

        public uint Life
        {
            get
            {
                uint result = 0;
                result |= (uint)wzLife[0] << 24;//HB-HW
                result |= (uint)wzLife[1] << 8;
                result |= (uint)wzLife[2] << 16;
                result |= (uint)wzLife[3];
                return result;
            }

            set
            {
                wzLife = new byte[4];
                wzLife[0] = (byte)(value >> 24);
                wzLife[1] = (byte)(value >> 8);
                wzLife[2] = (byte)(value >> 16);
                wzLife[3] = (byte)(value);
            }
        }
    }

    [WZContract]
    public class VPMCreateS16KorDto : VPMCreateAbs
    {
        [WZMember(9)] public Element PentagramMainAttribute { get; set; }
        [WZMember(10)] public byte CriticalDMGResistance { get; set; }
        [WZMember(11)] public byte ExcellentDMGResistance { get; set; }
        [WZMember(12)] public ushortle DebuffResistance { get; set; } = 0;
        [WZMember(13)] public byte DamageAbsorb { get; set; }
        [WZMember(14)] public byte Elite { get; set; } //??
        [WZMember(15)] public ushortle Level { get; set; }
        [WZMember(16, typeof(ArraySerializer))] public byte[] wzMaxLife { get; set; }
        [WZMember(17, typeof(ArraySerializer))] public byte[] wzLife { get; set; }

        [WZMember(18, typeof(ArrayWithScalarSerializer<ushort>))]
        public SkillStates[] ViewSkillState { get; set; }
        //[WZMember(18)]
        public ushort EffectCount { get => (ushort)ViewSkillState.Length; set => _len = value; }
        private ushort _len;

        public VPMCreateS16KorDto()
        {
            //ViewSkillState = new SkillStates[32];
        }

        public uint MaxLife
        {
            get
            {
                uint result = 0;
                result |= (uint)wzMaxLife[0] << 24;//HB-HW
                result |= (uint)wzMaxLife[1] << 8;
                result |= (uint)wzMaxLife[2] << 16;
                result |= (uint)wzMaxLife[3];
                return result;
            }

            set
            {
                wzMaxLife = new byte[4];
                wzMaxLife[0] = (byte)(value >> 24);
                wzMaxLife[1] = (byte)(value >> 8);
                wzMaxLife[2] = (byte)(value >> 16);
                wzMaxLife[3] = (byte)(value);
            }
        }

        public uint Life
        {
            get
            {
                uint result = 0;
                result |= (uint)wzLife[0] << 24;//HB-HW
                result |= (uint)wzLife[1] << 8;
                result |= (uint)wzLife[2] << 16;
                result |= (uint)wzLife[3];
                return result;
            }

            set
            {
                wzLife = new byte[4];
                wzLife[0] = (byte)(value >> 24);
                wzLife[1] = (byte)(value >> 8);
                wzLife[2] = (byte)(value >> 16);
                wzLife[3] = (byte)(value);
            }
        }
    }
}


--file EventMessageFactory.cs
﻿using MU.Network.CastleSiege;
using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Network;

namespace MU.Network.Event
{
    public interface IEventMessage
    { }

    public class EventMessageFactory : MessageFactory<EventOpCode, IEventMessage>
    {
        public EventMessageFactory(ServerSeason Season)
        {
            // C2S
            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, true);
            Register<CEventRemainTime>(EventOpCode.RemainTime);
            //LuckyCoins
            Register<CLuckyCoinsCount>(EventOpCode.LuckyCoinsCount);
            Register<CLuckyCoinsRegistre>(EventOpCode.LuckyCoinsRegistre);
            Register<CBloodCastleMove>(EventOpCode.BloodCastleEnter);

            // Crywolf
            Register<CCrywolfState>(EventOpCode.CrywolfState);
            Register<CCrywolfContract>(EventOpCode.CrywolfContract);
            Register<CCrywolfBenefit>(EventOpCode.CrywolfBenefit);
            // DevilSquare
            Register<CDevilSquareMove>(EventOpCode.DevilSquareMove);

            // ChaosCastle
            Register<CChaosCastleMove>(EventOpCode.ChaosCastleMove);

            Register<CKanturuStateInfo>(EventOpCode.KanturuState);
            Register<CKanturuEnterBossMap>(EventOpCode.KanturuEnter);
            Register<CImperialGuardianEnter>(EventOpCode.ImperialGuardianEnter);
            // MuRummy
            Register<CEventInventoryOpenS16>(EventOpCode.EventInventoryOpen);
            Register<CMuRummyStart>(EventOpCode.MuRummyStart);
            Register<CMuRummyPlayCard>(EventOpCode.MuRummyPlayCard);
            Register<CMuRummyMatch>(EventOpCode.MuRummyMatch);
            Register<CMuRummySpecialMatch>(EventOpCode.MuRummySpecialMatch);
            Register<CMuRummyThrow>(EventOpCode.MuRummyThrow);
            Register<CMuRummyExit>(EventOpCode.MuRummyExit);
            Register<CMuRummyReveal>(EventOpCode.MuRummyReveal);

            //MineSweeper
            Register<CMineSweeperOpen>(EventOpCode.MineSweeper);
            Register<CMineSweeperStart>(EventOpCode.MineSweeperStart);
            Register<CMineSweeperReveal>(EventOpCode.MineSweeperReveal);
            Register<CMineSweeperMark>(EventOpCode.MineSweeperMark);
            Register<CMineSweeperGetReward>(EventOpCode.MineSweeperGetReward);
            //JewelBingo
            //Register<CJewelBingoMove>(EventOpCode.JeweldryBingoState);
            Register<CJewelBingoStart>(EventOpCode.JeweldryBingoState);
            Register<CJewelBingoMove>(EventOpCode.JeweldryBingoInfo);
            Register<CJewelBingoBox>(EventOpCode.JeweldryBingoBox);
            Register<CJewelBingoSelect>(EventOpCode.JeweldryBingoPlayInfo);
            Register<CJewelBingoGetReward>(EventOpCode.JeweldryBingoPlayResult);
            //BallsAndCows
            Register<CBallsAndCowsStart>(EventOpCode.BallsAndCowsStart);
            Register<CBallsAndCowsPick>(EventOpCode.BallsAndCowsPick);
            Register<CEventItemGet>(EventOpCode.EventItemGet);
            Register<CEventItemThrow>(EventOpCode.EventItemThrow);
            Register<CAcheronEventEnter>(EventOpCode.AcheronEnterReq);
            //CastleSiege
            Register<CSiegeState>(EventOpCode.CastleSiegeState);
            Register<CGuildRegisteInfo>(EventOpCode.CastleSiegeGuildInfo);
            Register<CGuildMarkOfCastleOwner>(EventOpCode.CastleSiegeGuildMarkOfOwner);
            Register<CGuildRegiste>(EventOpCode.CastleSiegeRegiste);
            Register<CSiegeGuildList>(EventOpCode.CastleSiegeGuildList);
            Register<CSiegeRegisteMark>(EventOpCode.CastleSiegeRegisteMark);

            if (Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, false);
            Register<SCrywolfState>(EventOpCode.CrywolfState);
            Register<SCrywolfLeftTime>(EventOpCode.CrywolfLeftTime);
            Register<SCrywolfStatueAndAltarInfo>(EventOpCode.CrywolfStatueAndAltarInfo);
            Register<SCrywolfBossMonsterInfo>(EventOpCode.CrywolfBossMonsterInfo);
            Register<SCrywolfStageEffect>(EventOpCode.CrywolfStageEffect);
            Register<SCrywolfPersonalRank>(EventOpCode.CrywolfPersonalRank);
            Register<SCrywolfHeroList>(EventOpCode.CrywolfHeroList);


            // S2C
            Register<SEventRemainTime>(EventOpCode.RemainTime);
            //LuckyCoins
            Register<SLuckyCoinsCount>(EventOpCode.LuckyCoinsCount);
            Register<SLuckyCoinsRegistre>(EventOpCode.LuckyCoinsRegistre);
            // EventChip
            Register<SEventChipInfo>(EventOpCode.EventChipInfo);
            // BloodCastle
            Register<SBloodCastleMove>(EventOpCode.BloodCastleEnter);
            Register<SBloodCastleState>(EventOpCode.BloodCastleState);
            Register<SBloodCastleReward>(EventOpCode.BloodCastleReward);

            //DevilSquare
            Register<SDevilSquareSet>(EventOpCode.DevilSquareSet);
            Register<SDevilSquareResult>(EventOpCode.BloodCastleReward);

            // Crywolf
            Register<SCrywolfBenefit>(EventOpCode.CrywolfBenefit);

            // Kanturu
            Register<SKanturuStateInfo>(EventOpCode.KanturuState);
            Register<SKanturuStateChange>(EventOpCode.KanturuStateChange);
            Register<SKanturuBattleTime>(EventOpCode.KanturuBattleTime);
            Register<SKanturuMonsterUserCount>(EventOpCode.KanturuMonsterUserCount);
            Register<SKanturuBattleResult>(EventOpCode.KanturuBattleResult);
            Register<SKanturuWideAttack>(EventOpCode.KanturuWideAttack);

            // Imperial
            Register<SImperialEnterResult>(EventOpCode.ImperialGuardianEnterResult);
            Register<SImperialNotifyZoneTime>(EventOpCode.ImperialGuardianNotifyZoneTime);
            Register<SImperialNotifyZoneClear>(EventOpCode.ImperialGuardianNotifyZoneAllClear);

            // ArcaBattle
            Register<SArcaBattleState>(EventOpCode.ArcaBattleState);

            // Banner
            Register<SSendBanner>(EventOpCode.Banner);

            Register<SEventInventoryOpenS16>(EventOpCode.EventInventoryOpen);
            Register<SMuRummyStart>(EventOpCode.MuRummyStart);
            Register<SMuRummyMessage>(EventOpCode.MuRummyMessage);
            Register<SMuRummyPlayCard>(EventOpCode.MuRummyPlayCard);
            Register<SMuRummyMatch>(EventOpCode.MuRummyMatch);
            Register<SMuRummyCardList>(EventOpCode.MuRummyCardList);
            Register<SMuRummyReveal>(EventOpCode.MuRummyReveal);
            Register<SMuRummyExit>(EventOpCode.MuRummyExit);
            Register<SMineSweeperOpen>(EventOpCode.MineSweeper);
            Register<SMineSweeperStart>(EventOpCode.MineSweeperStart);
            Register<SMineSweeperCreateCell>(EventOpCode.MineSweeperCreateCell);
            Register<SMineSweeperReveal>(EventOpCode.MineSweeperReveal);
            Register<SMineSweeperMark>(EventOpCode.MineSweeperMark);
            Register<SMineSweeperEnd>(EventOpCode.MineSweeperEnd);
            Register<SMineSweeperGetReward>(EventOpCode.MineSweeperGetReward);

            Register<SJewelBingoState>(EventOpCode.JeweldryBingoState);
            Register<SJewelBingoInfo>(EventOpCode.JeweldryBingoInfo);
            Register<SJewelBingoBox>(EventOpCode.JeweldryBingoBox);
            Register<SJewelBingoPlayInfo>(EventOpCode.JeweldryBingoPlayInfo);
            Register<SJewelBingoPlayResult>(EventOpCode.JeweldryBingoPlayResult);

            Register<SBallsAndCowsOpen>(EventOpCode.BallsAndCowsOpen);
            Register<SBallsAndCowsStart>(EventOpCode.BallsAndCowsStart);
            Register<SBallsAndCowsResult>(EventOpCode.BallsAndCowsResult);

            //
            Register<SEventItemGet>(EventOpCode.EventItemGet);
            Register<SEventItemGetS16>(EventOpCode.EventItemGet);
            VersionSelector.Register<SEventItemGet>(Resources.ServerSeason.Season9Eng, EventOpCode.EventItemGet);
            VersionSelector.Register<SEventItemGetS16>(Resources.ServerSeason.Season16Kor, EventOpCode.EventItemGet);
            Register<SEventItemThrow>(EventOpCode.EventItemThrow);

            Register<SEventInventory>(EventOpCode.EventInventory);
            Register<SEventInventoryS17>(EventOpCode.EventInventory);
            VersionSelector.Register<SEventInventory>(ServerSeason.Season6Kor, EventOpCode.EventInventory);
            VersionSelector.Register<SEventInventoryS17>(ServerSeason.Season17Kor75, EventOpCode.EventInventory);

            // Acheron Guardian
            Register<SAcheronEventEnter>(EventOpCode.AcheronEnter);

            Register<SLeftTimeAlarm>(EventOpCode.CastleSiegeLeftTimeAlarm);
            Register<SSiegeState>(EventOpCode.CastleSiegeState);
            Register<SGuildRegisteInfo>(EventOpCode.CastleSiegeGuildInfo);
            Register<SGuildMarkOfCastleOwner>(EventOpCode.CastleSiegeGuildMarkOfOwner);
            Register<SGuildRegiste>(EventOpCode.CastleSiegeRegiste);
            Register<SSiegeGuildList>(EventOpCode.CastleSiegeGuildList);
            Register<SSiegeRegisteMark>(EventOpCode.CastleSiegeRegisteMark);
            Register<SJoinSideNotify>(EventOpCode.CastleSiegejoinSide);
            Register<SCastleSiegeNotifyStart>(EventOpCode.CastleSiegeNotifyStart);
            Register<SCastleSiegeNotifySwitch>(EventOpCode.CastleSiegeSwitchNotify);
            Register<SCastleSiegeMinimapData>(EventOpCode.CastleSiegeMinimap);
            Register<SCastleSiegeNotifySwitchInfo>(EventOpCode.CastleSiegeNotifySwitchInfo);
            Register<SCastleSiegeNotifyCrownState>(EventOpCode.CastleSiegeCrownState);
        }
    }
}


--file Event_C2S.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MU.Network.Event
{
    [WZContract]
    public class CEventRemainTime : IEventMessage
    {
        [WZMember(0)]
        public EventEnterType EventType { get; set; }

        [WZMember(1)]
        public byte ItemLevel { get; set; }
    }

    // LuckyCoins
    [WZContract]
    public class CLuckyCoinsCount : IEventMessage
    { }

    [WZContract]
    public class CLuckyCoinsRegistre : IEventMessage
    { }

    // BloodCastle
    [WZContract]
    public class CBloodCastleMove : IEventMessage
    {
        [WZMember(0)]
        public byte Bridge { get; set; }

        [WZMember(1)]
        public byte ItemPos { get; set; }
    }


    // Crywolf
    [WZContract]
    public class CCrywolfBenefit : IEventMessage
    { }

    [WZContract]
    public class CCrywolfContract : IEventMessage
    {
        [WZMember(0)]
        public ushort wzIndex { get; set; }
        public ushort Index => wzIndex.ShufleEnding();
    }

    [WZContract]
    public class CCrywolfState : IEventMessage
    { }

    // DevilSquare
    [WZContract]
    public class CDevilSquareMove : IEventMessage
    {
        [WZMember(0)] public byte SquareNumber { get; set; }  // 3
        [WZMember(1)] public byte InvitationItemPos { get; set; }	// 4
    }

    // ChaosCastle
    [WZContract]
    public class CChaosCastleMove : IEventMessage
    {
        [WZMember(0)] public byte SquareNumber { get; set; }  // 3
        [WZMember(1)] public byte InvitationItemPos { get; set; }	// 4
    }

    [WZContract]
    public class CKanturuStateInfo : IEventMessage
    { }

    [WZContract]
    public class CKanturuEnterBossMap : IEventMessage
    { }

    [WZContract]
    public class CImperialGuardianEnter : IEventMessage
    { }

    [WZContract]
    public class CEventInventoryOpenS16 : IEventMessage
    {
        [WZMember(0)] public byte Event { get; set; }
    }

    [WZContract(Serialized = true)]
    public class CEventItemGet : IEventMessage
    {
        [WZMember(0)] public ushort wzNumber { get; set; }
        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }
    }
    [WZContract]
    public class CEventItemThrow : IEventMessage
    {
        [WZMember(0)] public byte px { get; set; }
        [WZMember(1)] public byte py { get; set; }
        [WZMember(2)] public byte Ipos { get; set; }
    }

    [WZContract]
    public class CAcheronEventEnter : IEventMessage
    { }

    [WZContract]
    public class CMuRummyStart : IEventMessage
    {
        [WZMember(0)] public byte Type { get; set; }
    }

    [WZContract]
    public class CMuRummyPlayCard : IEventMessage
    {
        [WZMember(0)] public byte From { get; set; }
        [WZMember(1)] public byte To { get; set; }
    }
    [WZContract]
    public class CMuRummyMatch : IEventMessage
    {
        //C1 04 4D 14
    }
    [WZContract]
    public class CMuRummySpecialMatch : IEventMessage
    {
        //C1 04 4D 14
    }
    [WZContract]
    public class CMuRummyExit : IEventMessage
    {
        //C1 04 4D 15
    }
    [WZContract]
    public class CMuRummyReveal : IEventMessage
    {
        //C1 04 4D 11
    }
    [WZContract]
    public class CMuRummyThrow : IEventMessage
    {
        [WZMember(0)] public byte From { get; set; }
        //C1 04 4D 14
    }

    [WZContract]
    public class CMineSweeperOpen : IEventMessage
    { }

    [WZContract]
    public class CMineSweeperStart : IEventMessage
    { }

    [WZContract]
    public class CMineSweeperReveal : IEventMessage
    {
        [WZMember(0)] public byte Cell { get; set; }
    }

    [WZContract]
    public class CMineSweeperMark : IEventMessage
    {
        [WZMember(0)] public byte Cell { get; set; }
    }

    [WZContract]
    public class CMineSweeperGetReward : IEventMessage
    { }

    [WZContract]
    public class CJewelBingoMove : IEventMessage
    {
        [WZMember(0)] public byte Type { get; set; }
        [WZMember(1)] public JBType JewelType { get; set; }
        [WZMember(2)] public byte Slot { get; set; }
    }

    [WZContract]
    public class CJewelBingoBox : IEventMessage
    {
        [WZMember(0)] public byte Box { get; set; }
    }

    [WZContract]
    public class CJewelBingoStart : IEventMessage
    { }

    [WZContract]
    public class CJewelBingoSelect : IEventMessage
    {
        [WZMember(0)] public JBType JewelType { get; set; }
        [WZMember(1)] public byte Slot { get; set; }
    }

    [WZContract]
    public class CJewelBingoGetReward : IEventMessage
    { }

    [WZContract]
    public class CBallsAndCowsStart : IEventMessage
    { }

    [WZContract]
    public class CBallsAndCowsPick : IEventMessage
    {
        [WZMember(0, typeof(ArraySerializer))] public byte[] Numbers { get; set; }//5*3
    }
}

--file Event_S2C.cs
﻿using MU.Network.Game;
using MU.Resources;
using MuEmu.Network.Data;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MU.Network.Event
{
    [WZContract]
    public class SEventRemainTime : IEventMessage
    {
        [WZMember(0)]
        public EventEnterType EventType { get; set; }

        [WZMember(1)]
        public byte RemainTime { get; set; }

        [WZMember(2)]
        public byte EnteredUser { get; set; }

        [WZMember(3)]
        public byte RemainTime_LOW { get; set; }
    }

    // LuckyCoins
    [WZContract]
    public class SLuckyCoinsCount : IEventMessage
    {
        [WZMember(0)]
        public uint Count { get; set; }

        public SLuckyCoinsCount()
        { }

        public SLuckyCoinsCount(uint count)
        {
            Count = count;
        }
    }

    [WZContract]
    public class SLuckyCoinsRegistre : IEventMessage
    { }

    // EventChip
    [WZContract]
    public class SEventChipInfo : IEventMessage
    {
        [WZMember(0)]
        public byte Type { get; set; }

        [WZMember(1)]
        public ushort ChipCount { get; set; }

        [WZMember(2)]
        public short MutoNum1 { get; set; }

        [WZMember(3)]
        public short MutoNum2 { get; set; }

        [WZMember(4)]
        public short MutoNum3 { get; set; }

        public SEventChipInfo() { }

        public SEventChipInfo(byte type, ushort cp, short[] MutoNum)
        {
            Type = type;
            ChipCount = cp;
            MutoNum1 = MutoNum[0];
            MutoNum2 = MutoNum[1];
            MutoNum3 = MutoNum[2];
        }
    }

    // BloodCastle
    [WZContract]
    public class SBloodCastleMove : IEventMessage
    {
        [WZMember(0)]
        public byte Result { get; set; }

        public SBloodCastleMove() { }

        public SBloodCastleMove(byte result)
        {
            Result = result;
        }
    }

    [WZContract]
    public class SBloodCastleState : IEventMessage
    {
        [WZMember(0)]
        public byte State { get; set; }

        [WZMember(1)]
        public ushort RemainSec { get; set; }

        [WZMember(2)]
        public ushort MaxKillMonster { get; set; }

        [WZMember(3)]
        public ushort CurKillMonster { get; set; }

        [WZMember(4)]
        public ushort UserHaveWeapon { get; set; }
        
        [WZMember(5)]
        public byte Weapon { get; set; }


        public SBloodCastleState() { }

        public SBloodCastleState(byte state, ushort remainSec, ushort maxKillMonster, ushort curKillMonster, ushort userHaveWeapon, byte weapon)
        {
            State = state;
            RemainSec = remainSec;
            MaxKillMonster = maxKillMonster;
            CurKillMonster = curKillMonster;
            UserHaveWeapon = userHaveWeapon;
            Weapon = weapon;
        }
    }

    [WZContract]
    public class BCScore
    {
        [WZMember(0, 12)]
        public byte[] btName { get; set; }

        [WZMember(1)]
        public int Score { get; set; }

        [WZMember(2)]
        public int Experience { get; set; }

        [WZMember(3)]
        public int Zen { get; set; }

        public string Name { get => btName.MakeString(); set => btName = value.GetBytes(); }
    }

    [WZContract]
    public class SBloodCastleReward : IEventMessage
    {
        [WZMember(0)]
        public byte Winner { get; set; }

        [WZMember(1)]
        public byte Type { get; set; }

        [WZMember(2, SerializerType = typeof(ArraySerializer))]
        public BCScore[] ScoreTable { get; set; }

        public SBloodCastleReward() { ScoreTable = Array.Empty<BCScore>(); }

        public SBloodCastleReward(bool winner, byte type, BCScore[] scores)
        {
            Winner = (byte)(winner?0x01:0x00);
            Type = type;
            ScoreTable = scores;
        }
    }

    // Devil Square
    [WZContract]
    public class SDevilSquareSet : IEventMessage
    {
        [WZMember(0)]
        public DevilSquareState Type { get; set; }

        public SDevilSquareSet() { }

        public SDevilSquareSet(DevilSquareState type)
        {
            Type = type;
        }
    }

    [WZContract]
    public class DevilSquareScoreInfo
    {
        public byte rank;
        public object player;
        [WZMember(0,12)] public byte[] btName { get; set; }  // 0
        [WZMember(1)] public int TotalScore { get; set; } // C
        [WZMember(2)] public int BonusExp { get; set; }   // 10
        [WZMember(3)] public int BonusZen { get; set; }	// 14

        public string Name { get => btName.MakeString(); set => btName = value.GetBytes(); }
    }

    [WZContract]
    public class SDevilSquareResult :IEventMessage
    {
        [WZMember(0)]
        public byte MyRank { get; set; }    // 3
        //public byte Count; // 4
        [WZMember(1, typeof(ArrayWithScalarSerializer<byte>))]
        public DevilSquareScoreInfo[] Score { get; set; }	// 5
    }

    // Crywolf
    [WZContract]
    public class SCrywolfState : IEventMessage
    {
        [WZMember(0)]
        public byte Occupation { get; set; }
        [WZMember(1)]
        public byte State { get; set; }
    }
    [WZContract]
    public class SCrywolfLeftTime : IEventMessage
    {
        [WZMember(0)]
        public byte Hour { get; set; }
        [WZMember(1)]
        public byte Minute { get; set; }

        public TimeSpan TimeLeft { 
            get => TimeSpan.FromHours(Hour + Minute / 30.0f);
            set
            {
                Hour = (byte)value.Hours;
                Minute = (byte)value.Minutes;
            }
        }
    }
    [WZContract]
    public class SCrywolfStatueAndAltarInfo : IEventMessage
    {
        [WZMember(0)]
        public int StatueHP { get; set; }
        [WZMember(1,5)]
        public byte[] AltarState { get; set; }
    }
    [WZContract]
    public class SCrywolfBossMonsterInfo : IEventMessage
    {
        [WZMember(0)]
        public int MonsterHP { get; set; }
        [WZMember(1)]
        public byte Monster { get; set; }
    }
    [WZContract]
    public class SCrywolfStageEffect : IEventMessage
    {
        [WZMember(0)]
        public byte Active { get; set; }
    }
    [WZContract]
    public class SCrywolfPersonalRank : IEventMessage
    {
        [WZMember(0)]
        public byte Rank { get; set; }
        [WZMember(1)]
        public int Exp { get; set; }
    }
    [WZContract]
    public class SCrywolfHeroList : IEventMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))]
        public CrywolfHeroDto[] Heros { get; set; }
    }
    [WZContract]
    public class CrywolfHeroDto : IEventMessage
    {
        [WZMember(0)]
        public byte Rank { get; set; }

        [WZMember(1, 10)]
        public byte[] btName { get; set; }

        [WZMember(2)]
        public int Score { get; set; }

        [WZMember(3)]
        public HeroClass Class { get; set; }
    }

    [WZContract]
    public class SCrywolfBenefit : IEventMessage
    {
        [WZMember(0)]
        public byte PlusChaosRate { get; set; }

        public SCrywolfBenefit() { }

        public SCrywolfBenefit(byte pcr)
        {
            PlusChaosRate = pcr;
        }
    }

    // Kanturu
    [WZContract]
    public class SKanturuStateInfo : IEventMessage
    {
        [WZMember(0)] public KanturuState State { get; set; }
        [WZMember(1)] public byte btDetailState { get; set; } // 5
        [WZMember(2)] public byte btEnter { get; set; }   // 6
        [WZMember(3)] public byte btUserCount { get; set; }   // 7
        [WZMember(4)] public int iRemainTime { get; set; }	// 8
    }

    [WZContract]
    public class SKanturuStateChange : IEventMessage
    {
        [WZMember(0)] public KanturuState State { get; set; }
        [WZMember(1)] public byte btDetailState { get; set; }
    }

    [WZContract]
    public class SKanturuMonsterUserCount : IEventMessage
    {
        [WZMember(0)] public byte MonsterCount { get; set; }
        [WZMember(1)] public byte UserCount { get; set; }
    }

    [WZContract]
    public class SKanturuBattleTime : IEventMessage
    {
        //[WZMember(0)] public byte Padding02 { get; set; }
        [WZMember(1)] public int BattleTime { get; set; }
    }

    [WZContract]
    public class SKanturuBattleResult : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
    }

    [WZContract]
    public class SKanturuWideAttack : IEventMessage
    {
        [WZMember(0)] public ushortle ObjClass{get; set; } // 4
        [WZMember(1)] public byte Type { get; set; }	// 6
    }

    // Imperial
    [WZContract]
    public class SImperialEnterResult : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1)] public byte Day { get; set; } // 5
        [WZMember(2)] public byte State { get; set; }   // 6
        [WZMember(3)] public byte Unk { get; set; }   // 7
        [WZMember(4)] public ushort Index { get; set; }	// 8
        [WZMember(5)] public ushort EntryTime { get; set; }	// A
    }

    [WZContract]
    public class SImperialNotifyZoneTime : IEventMessage
    {
        [WZMember(0)] public byte MsgType { get; set; }
        [WZMember(1)] public byte DayOfWeek { get; set; }
        [WZMember(2)] public ushort ZoneIndex { get; set; }
        [WZMember(3)] public uint RemainTime { get; set; }
        [WZMember(4)] public uint RemainMonster { get; set; }
    }

    [WZContract]
    public class SImperialNotifyZoneClear : IEventMessage
    {
        [WZMember(0)] public uint Type { get; set; }
        [WZMember(1)] public uint RewardExp { get; set; }
    }

    // ArcaBattle
    [WZContract]
    public class SArcaBattleState : IEventMessage
    {
        [WZMember(0)] public byte State { get; set; }
    }

    [WZContract]
    public class SSendBanner : IEventMessage
    {
        [WZMember(0)] public BannerType Type { get; set; }
    }

    [WZContract]
    public class SEventInventoryOpenS16 : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1)] public EventInventoryType Id { get; set; }
        [WZMember(2)] public int EventTime { get; set; }
        [WZMember(3)] public byte Data { get; set; }
    }

    [WZContract(Serialized = true)]
    public class SEventItemGet : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1, 12)] public byte[] Item { get; set; }

        public SEventItemGet() { }
        public SEventItemGet(byte result, byte[] item, ushort index)
        {
            Result = result;
            Item = item;
        }
    }

    [WZContract(Serialized = true)]
    public class SEventItemGetS16 : IEventMessage
    {
        [WZMember(0)] public byte Junk1 { get; set; }
        [WZMember(1)] public byte Result { get; set; }
        [WZMember(2)] public byte IndexH { get; set; }
        [WZMember(3)] public byte Junk2 { get; set; }
        [WZMember(4)] public byte IndexL { get; set; }
        [WZMember(5, 12)] public byte[] Item { get; set; }

        public SEventItemGetS16() { }
        public SEventItemGetS16(byte result, byte[] item, ushort index)
        {
            Result = result;
            Item = item;
            IndexH = (byte)(index >> 8);
            IndexL = (byte)(index & 0xFF);
        }
    }

    [WZContract]
    public class SEventItemThrow : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1)] public byte Pos { get; set; }
    }

    [WZContract(LongMessage = true, Serialized = true)]
    public class SEventInventory : IInventory, IEventMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))] public InventoryDto[] Inventory { get; set; }

        public void LoadItems(IEnumerable<KeyValuePair<byte, byte[]>> items)
        {
            Inventory = items.Select(x => new InventoryDto(x.Key, x.Value)).ToArray();
        }
    }

    [WZContract(LongMessage = true, Serialized = true)]
    public class SEventInventoryS17 : IInventory, IEventMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))] public InventoryS17Dto[] Inventory { get; set; }
 
        public void LoadItems(IEnumerable<KeyValuePair<byte, byte[]>> items)
        {
            Inventory = items.Select(x => new InventoryS17Dto(x.Key, x.Value)).ToArray();
        }
    }

    [WZContract]
    public class SAcheronEventEnter : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
    }

    [WZContract]
    public class MuRummyCardInfo
    {
        [WZMember(0)] public byte Color { get; set; }
        [WZMember(1)] public byte Number { get; set; }
        [WZMember(2)] public byte Slot { get; set; }
    }

    [WZContract]
    public class SMuRummyStart : IEventMessage
    {
        [WZMember(0)] public ushortle Score { get; set; }
        [WZMember(1)] public byte CardCount { get; set; }
        [WZMember(2)] public byte SpecialCardCount { get; set; }
        [WZMember(3)] public byte Unk { get; set; }
        [WZMember(4)] public byte Type { get; set; }
        [WZMember(5, typeof(ArraySerializer))] public byte[] SlotStatus { get; set; } //10
        [WZMember(6, typeof(ArraySerializer))] public MuRummyCardInfo[] CardInfo { get; set; } //6
    }

    [WZContract]
    public class SMuRummyCardList : IEventMessage
    {
        [WZMember(0, typeof(ArraySerializer))] public MuRummyCardInfo[] CardInfo { get; set; } //6
    }

    [WZContract]
    public class SMuRummyReveal : IEventMessage
    {
        [WZMember(0, typeof(ArraySerializer))] public MuRummyCardInfo[] CardInfo { get; set; } //6
        [WZMember(1)] public byte CardCount { get; set; }
        [WZMember(2)] public byte SpecialCardCount { get; set; }
    }

    [WZContract]
    public class SMuRummyPlayCard : IEventMessage
    {
        [WZMember(0)] public byte From { get; set; }
        [WZMember(1)] public byte To { get; set; }
        [WZMember(2)] public byte Color { get; set; }
        [WZMember(3)] public byte Number { get; set; }
    }

    [WZContract]
    public class SMuRummyMatch : IEventMessage
    {
        [WZMember(0)] public ushortle Score { get; set; } = new ushortle(0);
        [WZMember(1)] public ushortle TotalScore { get; set; } = new ushortle(0);
        [WZMember(2)] public byte Result { get; set; }
    }
    [WZContract]
    public class SMuRummyExit : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        //C1 04 4D 15
    }

    [WZContract]
    public class SMuRummyMessage : IEventMessage
    {
        [WZMember(0)] public byte Index { get; set; }
        [WZMember(1)] public ushortle Value { get; set; } = new ushortle(0);
    }

    [WZContract]
    public class SMineSweeperOpen : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1)] public byte RemainBombs { get; set; }
        [WZMember(2)] public ushort Count { get; set; }
        [WZMember(3)] public ushort CurrentScore { get; set; }
        [WZMember(4, typeof(ArraySerializer))] public ushort[] Cells { get; set; }
    }

    [WZContract]
    public class SMineSweeperStart : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
    }

    [WZContract]
    public class SMineSweeperCreateCell : IEventMessage
    {
        [WZMember(0)] public uint Time { get; set; }
        [WZMember(1)] public byte X { get; set; }
        [WZMember(2)] public byte Y { get; set; }
        [WZMember(3)] public byte Effect { get; set; }
    }

    [WZContract]
    public class SMineSweeperReveal : IEventMessage
    {
        [WZMember(0)] public byte Cell { get; set; }
        [WZMember(1)] public ushortle Score { get; set; }
        [WZMember(4, typeof(ArrayWithScalarSerializer<byte>))] public ushort[] Cells { get; set; }
    }

    [WZContract]
    public class SMineSweeperMark : IEventMessage
    {
        [WZMember(0)] public byte Cell { get; set; }
        [WZMember(1)] public byte Result { get; set; }
        [WZMember(2)] public byte RemainBombs { get; set; }
    }

    [WZContract]
    public class SMineSweeperEnd : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1)] public byte Count { get; set; }
        [WZMember(2)] public ushort Score { get; set; }
        [WZMember(3)] public ushort BombsFound { get; set; }
        [WZMember(4)] public ushort BombsFailure { get; set; }
        [WZMember(5)] public ushort SteppedOnBomb { get; set; }
        [WZMember(6)] public ushort Clear { get; set; }
        [WZMember(7)] public ushort TotalScore { get; set; }
        [WZMember(8, typeof(ArraySerializer))] public ushort[] Cells { get; set; }
    }

    [WZContract]
    public class SMineSweeperGetReward : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
    }

    [WZContract]
    public class SJewelBingoState : IEventMessage
    {
        [WZMember(0)] public JBState State { get; set; }
    }

    [WZContract]
    public class SJewelBingoInfo : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1, typeof(ArraySerializer))] public JBType[] Grid { get; set; } // 25 (5*5)
        [WZMember(2, typeof(ArraySerializer))] public byte[] CurrentJewel { get; set; }// 6
    }

    [WZContract]
    public class SJewelBingoPlayInfo : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1, typeof(ArraySerializer))] public JBType[] Grid { get; set; } // 25 (5*5)
        [WZMember(2, typeof(ArraySerializer))] public byte[] MatchingJewel { get; set; }// 12
        [WZMember(3)] public JBType CurrentJewel { get; set; }
        [WZMember(4)] public byte JewelCount { get; set; }
        [WZMember(5)] public byte CurrentBox { get; set; }
    }

    [WZContract]
    public class SJewelBingoPlayResult : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1, typeof(ArraySerializer))] public JBType[] Grid { get; set; } // 25 (5*5)
        [WZMember(2, typeof(ArraySerializer))] public byte[] MatchingJewel { get; set; }// 12
        //[WZMember(3)] public byte unk { get; set; }
        [WZMember(4)] public ushort LuckyClear { get; set; }
        [WZMember(5)] public ushort NormalClear { get; set; }
        [WZMember(6)] public ushort JewelryClear { get; set; }
    }

    [WZContract]
    public class SJewelBingoBox : IEventMessage
    { }

    [WZContract]
    public class SBallsAndCowsOpen : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1)] public byte Junk { get; set; }
        [WZMember(2)] public ushort Score { get; set; }
        [WZMember(3, typeof(ArraySerializer))] public byte[] Strikes { get; set; } //5
        [WZMember(4, typeof(ArraySerializer))] public byte[] Ball { get; set; }//5
        [WZMember(5, typeof(ArraySerializer))] public byte[] Numbers { get; set; }//5*3
    }

    [WZContract]
    public class SBallsAndCowsStart : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
    }

    [WZContract]
    public class SBallsAndCowsResult : IEventMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1, typeof(ArraySerializer))] public byte[] Strikes{ get; set; } //5
        [WZMember(2, typeof(ArraySerializer))] public byte[] Ball { get; set; } //5
        [WZMember(3, typeof(ArraySerializer))] public byte[] Numbers { get; set; } //5*3
        [WZMember(4)] public byte Data4 { get; set; }
        [WZMember(5)] public byte Junk { get; set; }
        [WZMember(6)] public ushort Score { get; set; }
    }
}


--file GameMessageFactory.cs
﻿using MU.Network.Event;
using MU.Network.MuunSystem;
using MU.Network.Pentagrama;
using MU.Resources;
using MuEmu.Network.UBFSystem;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Network;

namespace MU.Network.Game
{
    public interface IGameMessage
    { }

    public class GameMessageFactory : MessageFactory<GameOpCode, IGameMessage>
    {
        public GameMessageFactory(ServerSeason Season)
        {
            // C2S
            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, true);
            Register<CCheckSum>(GameOpCode.GameSecurity);
            Register<CClientMessage>(GameOpCode.ClientMessage);
            Register<CCloseWindow>(GameOpCode.CloseWindow);
            Register<CCancelItemSale>(GameOpCode.CancelItemSale);
            Register<CCancelItemSaleClose>(GameOpCode.CancelItemSaleClose);
            Register<CCancelItemSaleItem>(GameOpCode.CancelItemSaleItem);
            Register<COpenBox>(GameOpCode.OpenBox);
            Register<CItemSplit>(GameOpCode.ItemSplit);
            Register<CAction>(GameOpCode.Rotation);
            Register<CInventory>(GameOpCode.Inventory);
            Register<CPointAdd>(GameOpCode.PointAdd);
            Register<CClientClose>(GameOpCode.ClientClose);
            Register<CMoveItem>(GameOpCode.MoveItem);
            Register<CUseItem>(GameOpCode.HealthUpdate); // Same OPCode
            Register<CEventEnterCount>(GameOpCode.EventEnterCount);
            Register<CTalk>(GameOpCode.Talk);
            Register<CWarehouseUseEnd>(GameOpCode.WarehouseUseEnd);
            Register<CBuy>(GameOpCode.Buy);
            Register<CSell>(GameOpCode.Sell);
            Register<CWarp>(GameOpCode.Warp);
            Register<CDataLoadOK>(GameOpCode.DataLoadOK);
            Register<CJewelMix>(GameOpCode.JewelMix);
            Register<CJewelUnMix>(GameOpCode.JewelUnMix);
            Register<CChaosBoxItemMixButtonClick>(GameOpCode.ChaosBoxItemMixButtonClick);
            Register<CChaosBoxUseEnd>(GameOpCode.ChaosBoxUseEnd);
            Register<CItemThrow>(GameOpCode.ItemThrow);
            Register<CItemModify>(GameOpCode.ItemModify);
            Register<CChangeSkin>(GameOpCode.ChangeSkin);
            Register<CNPCJulia>(GameOpCode.NPCJulia);
            Register<CItemGet>(GameOpCode.ItemGet);

            #region Client ChatMessages
            Register<CChatNickname>(GameOpCode.GeneralChat0);
            Register<CChatNumber>(GameOpCode.GeneralChat1);
            Register<CChatWhisper>(GameOpCode.WhisperChat);
            #endregion

            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, false);
            Register<SMapMoveCheckSum>(GameOpCode.MapMoveCheckSum);
            Register<SCancelItemSaleResult>(GameOpCode.CancelItemSaleItem);
            Register<SCancelItemSaleListS16>(GameOpCode.CancelItemSale);
            Register<SOpenBox>(GameOpCode.OpenBox);
            Register<SItemSplit>(GameOpCode.ItemSplit);

            #region Client PersonalShopMessages
            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, true);
            Register<CPShopSetItemPrice>(GameOpCode.PShopSetItemPrice);
            Register<CPShopRequestOpen>(GameOpCode.PShopRequestOpen);
            Register<CPShopRequestClose>(GameOpCode.PShopRequestClose);
            Register<CPShopRequestList>(GameOpCode.PShopRequestList);
            Register<CPShopRequestBuy>(GameOpCode.PShopRequestBuy);
            Register<CPShopCloseDeal>(GameOpCode.PShopCloseDeal);

            Register<CPShopSearch>(GameOpCode.PShopSearchS16Kor);
            Register<CPShopItemSearch>(GameOpCode.PShopItemSearchS16Kor);
            Register<CPShopItemSearch2>(GameOpCode.PShopItemSearch2S16Kor);
            Register<CPShopRequestList2S16Kor>(GameOpCode.PShopRequestList2S16Kor);
            Register<CPShopSetItemPriceS16Kor>(GameOpCode.PShopSetItemPriceS16Kor);
            Register<CPShopChangeStateS16Kor>(GameOpCode.PShopChangeState);
            Register<CPShopItemViewS16Kor>(GameOpCode.PShopItemViewS16Kor);
            Register<CPShopCancelItemSaleS16Kor>(GameOpCode.PShopCancelItemSaleS16Kor);

            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, false);
            Register<SPShopCancelItemSaleS16Kor>(GameOpCode.PShopCancelItemSaleS16Kor);
            Register<SPShopSearch>(GameOpCode.PShopSearchS16Kor);
            Register<SPShopItemSearch>(GameOpCode.PShopItemSearchS16Kor);
            Register<SPShopSellList>(GameOpCode.PShopRequestList2S16Kor);
            Register<SPShopSetItemPriceS16Kor>(GameOpCode.PShopSetItemPriceS16Kor);
            Register<SPShopChangeStateS16Kor>(GameOpCode.PShopChangeState);
            Register<SPShopItemViewS16Kor>(GameOpCode.PShopItemViewS16Kor);
            #endregion


            Register<SNPCDialog>(GameOpCode.NPCDialog);
            #region Client AttackMessages
            //Register<CAttackS5E2>(GameOpCode.Attack);

            VersionSelector.Register<SMagicDuration>(ServerSeason.Season6Kor, GameOpCode.MagicDuration);
            VersionSelector.Register<SMagicDurationS9Eng>(ServerSeason.Season9Eng, GameOpCode.MagicDuration);
            VersionSelector.Register<SMagicAttack>(ServerSeason.Season6Kor, GameOpCode.MagicAttack);
            VersionSelector.Register<SMagicAttackS9Eng>(ServerSeason.Season9Eng, GameOpCode.MagicAttack);
            VersionSelector.Register<SMagicAttackS12Eng>(ServerSeason.Season12Eng, GameOpCode.MagicAttack);

            switch (Season)
            {
                case ServerSeason.Season17Kor75:
                case ServerSeason.Season17Kor:
                case ServerSeason.Season16Kor:
                    if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, true);
                    Register<CBeattackS9>(GameOpCode.BeattackS16);
                    Register<CMove12Eng>(GameOpCode.Move12Eng);
                    Register<CAttack>(GameOpCode.Attack12Eng);
                    Register<CMagicAttackS9>(GameOpCode.MagicAttack);
                    Register<CMagicDurationS16>(GameOpCode.MagicDuration);
                    Register<CPositionSet>(GameOpCode.Position16Kor);
                    if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, false);
                    Register<SMove>(GameOpCode.Move12Eng);
                    Register<SMagicAttackS12Eng>(GameOpCode.MagicAttack);
                    Register<SMagicDurationS9Eng>(GameOpCode.MagicDuration);
                    break;
                case ServerSeason.Season12Eng:
                    Register<SMove>(GameOpCode.Move12Eng);
                    Register<CAttack>(GameOpCode.Attack12Eng);
                    Register<CBeattackS9>(GameOpCode.Position);
                    Register<CMagicAttackS9>(GameOpCode.MagicAttack);
                    Register<CMagicDurationS9>(GameOpCode.MagicDuration);
                    Register<SMagicAttackS12Eng>(GameOpCode.MagicAttack);
                    Register<SMagicDurationS9Eng>(GameOpCode.MagicDuration);
                    break;
                case ServerSeason.Season9Eng:// ENG
                    Register<CAttack>(GameOpCode.AttackEng);
                    Register<CMagicAttackS9>(GameOpCode.MagicAttack);
                    Register<CTeleportS9>(GameOpCode.Teleport);
                    Register<CMagicDurationS9>(GameOpCode.MagicDuration);
                    Register<CPositionSetS9>(GameOpCode.Position9Eng);
                    Register<CBeattackS9>(GameOpCode.Position);
                    Register<SMagicAttackS9Eng>(GameOpCode.MagicAttack);
                    Register<SMagicDurationS9Eng>(GameOpCode.MagicDuration);
                    Register<CMoveEng>(GameOpCode.MoveEng);
                    Register<SMove>(GameOpCode.MoveEng);
                    break;
                default:
                    Register<CAttack>(GameOpCode.Attack);
                    Register<CMagicAttack>(GameOpCode.MagicAttack);
                    Register<CMagicDuration>(GameOpCode.MagicDuration);
                    Register<CTeleport>(GameOpCode.Teleport);
                    Register<CPositionSet>(GameOpCode.Position);
                    Register<CBeattack>(GameOpCode.Beattack);
                    Register<CMove>(GameOpCode.Move);
                    Register<SMove>(GameOpCode.Move);
                    Register<SMagicDuration>(GameOpCode.MagicDuration);
                    Register<SMagicAttack>(GameOpCode.MagicAttack);
                    break;
            }

            if (Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, false);
            Register<SAttackResultS16Kor>(GameOpCode.Attack12Eng);
            Register<SAttackResultS12Eng>(GameOpCode.Attack12Eng);
            Register<SAttackResultS9Eng>(GameOpCode.AttackEng);
            Register<SAttackResult>(GameOpCode.Attack);
            VersionSelector.Register<SAttackResult>(ServerSeason.Season6Kor, GameOpCode.Attack);
            VersionSelector.Register<SAttackResultS9Eng>(ServerSeason.Season9Eng, GameOpCode.Attack);
            VersionSelector.Register<SAttackResultS12Eng>(ServerSeason.Season12Eng, GameOpCode.Attack);
            VersionSelector.Register<SAttackResultS16Kor>(ServerSeason.Season16Kor, GameOpCode.Attack);
            #endregion

            #region Client PartyMessages
            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, true);
            Register<CPartyRequest>(GameOpCode.PartyRequest);
            Register<CPartyRequestResult>(GameOpCode.PartyResult);
            Register<CPartyList>(GameOpCode.PartyList);
            Register<CPartyDelUser>(GameOpCode.PartyDelUser);
            #endregion

            #region Client DuelMessages
            Register<CDuelRequest>(GameOpCode.DuelRequest);
            Register<CDuelAnswer>(GameOpCode.DuelAnswer);
            Register<CDuelLeave>(GameOpCode.DuelLeave);
            Register<CDuelJoinRoom>(GameOpCode.DuelRoomJoin);
            Register<CDuelLeaveRoom>(GameOpCode.DuelRoomLeave);
            #endregion

            #region Client FriendMessages
            Register<CFriendList>(GameOpCode.FriendList);
            Register<CFriendAdd>(GameOpCode.FriendAdd);
            Register<CWaitFriendAddReq>(GameOpCode.FriendAddWait);

            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, false);
            Register<SFriendAddReq>(GameOpCode.FriendAdd);
            Register<SFriendAddSin>(GameOpCode.FriendAddWait);
            #endregion

            #region MasterSystemMessages
            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, true);
            Register<CMasterSkill>(GameOpCode.MasterLevelSkill);
            #endregion

            // S2C
            if (Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, false);
            Register<SInventory>(GameOpCode.Inventory);
            Register<SInventoryS17>(GameOpCode.Inventory);
            VersionSelector.Register<SInventory>(ServerSeason.Season6Kor, GameOpCode.Inventory);
            VersionSelector.Register<SInventoryS17>(ServerSeason.Season17Kor75, GameOpCode.Inventory);
            Register<SEquipament>(GameOpCode.Equipament);
            Register<SCheckSum>(GameOpCode.GameSecurity);
            Register<SWeather>(GameOpCode.Weather);
            Register<SSpells>(GameOpCode.Spells);
            Register<SSpellsS12Eng>(GameOpCode.Spells);
            Register<SQuestInfo>(GameOpCode.QuestInfo);
            Register<SFriends>(GameOpCode.FriendList);
            Register<SKillCount>(GameOpCode.KillCount);
            Register<SChatNickName>(GameOpCode.GeneralChat0);
            Register<SChatTarget>(GameOpCode.GeneralChat1);
            VersionSelector.Register<SSpells>(ServerSeason.Season6Kor, GameOpCode.Spells);
            VersionSelector.Register<SSpellsS12Eng>(ServerSeason.Season12Eng, GameOpCode.Spells);

            #region Server ViewPortMessages
            Register<SViewPortCreate>(GameOpCode.ViewPortCreate);
            Register<SViewPortCreateS9>(GameOpCode.ViewPortCreate);
            Register<SViewPortCreateS12>(GameOpCode.ViewPortCreate);
            Register<SViewPortCreateS16Kor>(GameOpCode.ViewPortCreate);
            Register<SViewPortChange>(GameOpCode.ViewPortChange);
            Register<SViewPortChangeS9>(GameOpCode.ViewPortChange);
            Register<SViewPortChangeS12>(GameOpCode.ViewPortChange);
            Register<SViewPortMonCreateS6Kor>(GameOpCode.ViewPortMCreate);
            Register<SViewPortMonCreateS9Eng>(GameOpCode.ViewPortMCreate);
            Register<SViewPortMonCreateS12Eng>(GameOpCode.ViewPortMCreate);
            Register<SVPortMonCreateS16Kor>(GameOpCode.ViewPortMCreate);
            Register<SViewPortDestroy>(GameOpCode.ViewPortDestroy);
            Register<SViewPortItemDestroy>(GameOpCode.ViewPortItemDestroy);
            VersionSelector.Register<SViewPortCreate>(ServerSeason.Season6Kor, GameOpCode.ViewPortCreate);
            VersionSelector.Register<SViewPortCreateS9>(ServerSeason.Season9Eng, GameOpCode.ViewPortCreate);
            VersionSelector.Register<SViewPortCreateS12>(ServerSeason.Season12Eng, GameOpCode.ViewPortCreate);
            VersionSelector.Register<SViewPortCreateS16Kor>(ServerSeason.Season16Kor, GameOpCode.ViewPortCreate);
            VersionSelector.Register<SViewPortMonCreateS6Kor>(ServerSeason.Season6Kor, GameOpCode.ViewPortMCreate);
            VersionSelector.Register<SViewPortMonCreateS9Eng>(ServerSeason.Season9Eng, GameOpCode.ViewPortMCreate);
            VersionSelector.Register<SViewPortMonCreateS12Eng>(ServerSeason.Season12Eng, GameOpCode.ViewPortMCreate);
            VersionSelector.Register<SVPortMonCreateS16Kor>(ServerSeason.Season16Kor, GameOpCode.ViewPortMCreate);
            #endregion

            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, true);
            Register<CWarehouseMoney>(GameOpCode.WarehouseMoney);

            if (Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, false);
            Register<SNotice>(GameOpCode.Notice);
            Register<SEventState>(GameOpCode.EventState);
            Register<SHeatlUpdate>(GameOpCode.HealthUpdate);
            Register<SHeatlUpdateS17>(GameOpCode.HealthUpdate);
            VersionSelector.Register<SHeatlUpdate>(ServerSeason.Season6Kor, GameOpCode.HealthUpdate);
            VersionSelector.Register<SHeatlUpdateS17>(ServerSeason.Season17Kor75,GameOpCode.HealthUpdate);
            Register<SManaUpdate>(GameOpCode.ManaUpdate);
            Register<SSkillKey>(GameOpCode.SkillKey);
            Register<SAction>(GameOpCode.Rotation);
            Register<SPositionSet>(GameOpCode.Position);
            Register<SPositionSetS9Eng>(GameOpCode.Position9Eng);
            Register<SPositionSetS16Kor>(GameOpCode.Position16Kor);
            Register<SPointAdd>(GameOpCode.PointAdd);
            Register<SCharRegen>(GameOpCode.CharRegen);
            Register<SCharRegenS12Eng>(GameOpCode.CharRegen);
            Register<SCharRegenS16Kor>(GameOpCode.CharRegen);
            Register<SLevelUp>(GameOpCode.LevelUp);
            Register<SClinetClose>(GameOpCode.ClientClose);
            Register<SMoveItem>(GameOpCode.MoveItem);
            Register<SMoveItemS16Kor>(GameOpCode.MoveItem);
            Register<SEventEnterCount>(GameOpCode.EventEnterCount);
            Register<SCloseMsg>(GameOpCode.ClientClose);
            Register<STalk>(GameOpCode.Talk);
            Register<SShopItemList>(GameOpCode.CloseWindow); // Same OPCode
            Register<SShopItemListS17>(GameOpCode.CloseWindow); // Same OPCode
            VersionSelector.Register<SShopItemList>(ServerSeason.Season6Kor, GameOpCode.CloseWindow);
            VersionSelector.Register<SShopItemListS17>(ServerSeason.Season17Kor, GameOpCode.CloseWindow);
            Register<SMonsterSoulShop>(GameOpCode.MonsterSoulShop);
            Register<SMonsterSoulAvailableShop>(GameOpCode.MonsterSoulAvailableShop);
            Register<STax>(GameOpCode.Tax);
            Register<SWarehouseMoney>(GameOpCode.WarehouseMoney);
            Register<SQuestWindow>(GameOpCode.QuestWindow);
            Register<SBuy>(GameOpCode.Buy);
            Register<SSell>(GameOpCode.Sell);
            Register<SItemGet>(GameOpCode.ItemGet);
            Register<SItemGetS12Eng>(GameOpCode.ItemGet);
            Register<SItemGetS16Kor>(GameOpCode.ItemGet);
            Register<STeleport>(GameOpCode.Teleport);
            Register<STeleportS12Eng>(GameOpCode.Teleport);
            Register<SViewSkillState>(GameOpCode.ViewSkillState);
            Register<SPeriodicEffectS12Eng>(GameOpCode.PeriodicEffect);
            Register<SInventoryItemDelete>(GameOpCode.InventoryItemDelete);
            Register<SJewelMix>(GameOpCode.JewelMix);
            Register<SCommand>(GameOpCode.Command);
            Register<SSetMapAttribute>(GameOpCode.SetMapAtt);
            Register<SItemThrow>(GameOpCode.ItemThrow);
            Register<SViewPortItemCreate>(GameOpCode.ViewPortItemCreate);
            Register<SViewPortPShop>(GameOpCode.ViewPortPShop);
            Register<SInventoryItemSend>(GameOpCode.OneItemSend);
            Register<SInventoryItemDurSend>(GameOpCode.InventoryItemDurUpdate);
            Register<SChaosBoxItemMixButtonClick>(GameOpCode.ChaosBoxItemMixButtonClick);
            Register<SDamage>(GameOpCode.Damage);
            Register<SKillPlayer>(GameOpCode.KillPlayer);
            Register<SKillPlayerEXT>(GameOpCode.KillPlayerEXT);
            Register<SDiePlayer>(GameOpCode.DiePlayer);
            Register<SEffect>(GameOpCode.Effect);
            Register<SItemModify>(GameOpCode.ItemModify);
            Register<SItemUseSpecialTime>(GameOpCode.ItemUseSpecialTime);
            Register<SPShopSetItemPrice>(GameOpCode.PShopSetItemPrice);
            Register<SPShopRequestOpen>(GameOpCode.PShopRequestOpen);
            Register<SPShopRequestClose>(GameOpCode.PShopRequestClose);
            Register<SPShopRequestList>(GameOpCode.PShopRequestList);
            Register<SPShopRequestListS9Eng>(GameOpCode.PShopRequestList);
            Register<SPShopRequestBuy>(GameOpCode.PShopRequestBuy);
            Register<SPShopRequestSold>(GameOpCode.PShopRequestSold);
            Register<SPShopAlterVault>(GameOpCode.PShopAlterVault);
            VersionSelector.Register<SPositionSet>(ServerSeason.Season6Kor, GameOpCode.Position);
            VersionSelector.Register<SPositionSetS9Eng>(ServerSeason.Season9Eng, GameOpCode.Position);
            VersionSelector.Register<SPositionSetS16Kor>(ServerSeason.Season16Kor, GameOpCode.Position);
            VersionSelector.Register<SCharRegen>(ServerSeason.Season6Kor, GameOpCode.CharRegen);
            VersionSelector.Register<SCharRegenS12Eng>(ServerSeason.Season12Eng, GameOpCode.CharRegen);
            VersionSelector.Register<SCharRegenS16Kor>(ServerSeason.Season16Kor, GameOpCode.CharRegen);
            VersionSelector.Register<SMoveItem>(ServerSeason.Season6Kor, GameOpCode.MoveItem);
            VersionSelector.Register<SMoveItemS16Kor>(ServerSeason.Season16Kor, GameOpCode.MoveItem);
            VersionSelector.Register<STeleport>(ServerSeason.Season6Kor, GameOpCode.Teleport);
            VersionSelector.Register<STeleportS12Eng>(ServerSeason.Season12Eng, GameOpCode.Teleport);
            VersionSelector.Register<SItemGetS16Kor>(ServerSeason.Season16Kor, GameOpCode.ItemGet);
            VersionSelector.Register<SItemGetS12Eng>(ServerSeason.Season12Eng, GameOpCode.ItemGet);
            VersionSelector.Register<SItemGet>(ServerSeason.Season6Kor, GameOpCode.ItemGet);
            VersionSelector.Register<SPShopRequestList>(ServerSeason.Season6Kor, GameOpCode.PShopRequestList);
            VersionSelector.Register<SPShopRequestListS9Eng>(ServerSeason.Season9Eng, GameOpCode.PShopRequestList);

            #region Server PartyMessages
            Register<SPartyResult>(GameOpCode.PartyResult);
            Register<SPartyList>(GameOpCode.PartyList);
            Register<SPartyListS9>(GameOpCode.PartyList);
            Register<SPartyListS16>(GameOpCode.PartyList);
            Register<SPartyDelUser>(GameOpCode.PartyDelUser);
            Register<SPartyLifeAll>(GameOpCode.PartyLifeUpdate);
            VersionSelector.Register<SPartyList>(ServerSeason.Season6Kor, GameOpCode.PartyList);
            VersionSelector.Register<SPartyListS9>(ServerSeason.Season9Eng, GameOpCode.PartyList);
            VersionSelector.Register<SPartyListS16>(ServerSeason.Season16Kor, GameOpCode.PartyList);
            #endregion

            #region Server DuelMessages
            Register<SDuelAnsDuelInvite>(GameOpCode.DuelRequest);
            Register<SDuelAnswerReq>(GameOpCode.DuelAnswer);
            Register<SDuelAnsExit>(GameOpCode.DuelLeave);
            Register<SDuelBroadcastScore>(GameOpCode.DuelScoreBroadcast);
            Register<SDuelBroadcastHP>(GameOpCode.DuelHPBroadcast);
            Register<SDuelChannelList>(GameOpCode.DuelChannelList);
            Register<SDuelRoomJoin>(GameOpCode.DuelRoomJoin);
            Register<SDuelRoomBroadcastJoin>(GameOpCode.DuelRoomJoinBroadcast);
            Register<SDuelRoomLeave>(GameOpCode.DuelRoomLeave);
            Register<SDuelRoomBroadcastLeave>(GameOpCode.DuelRoomLeaveBroadcast);
            Register<SDuelRoomBroadcastObservers>(GameOpCode.DuelRoomObserversBroadcast);
            Register<SDuelBroadcastResult>(GameOpCode.DuelResultBroadcast);
            Register<SDuelBroadcastRound>(GameOpCode.DuelRoundBroadcast);
            #endregion

            #region Server MasterLevelMessages
            Register<SMasterInfo>(GameOpCode.MasterLevelInfo);
            Register<SMasterLevelUp>(GameOpCode.MasterLevelUp);
            Register<SMasterLevelSkillS9ENG>(GameOpCode.MasterLevelSkill);
            Register<SMasterLevelSkillListS9ENG>(GameOpCode.MasterLevelSkills);
            Register<SMajesticInfo>(GameOpCode.MajesticInfo);
            Register<SMajesticStatsInfo>(GameOpCode.MajesticStatsInfo);
            #endregion

            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, true);
            Register<CTradeRequest>(GameOpCode.TradeRequest);
            Register<CTradeResponce>(GameOpCode.TradeResponce);
            Register<CTradeMoney>(GameOpCode.TradeMoney);
            Register<CTradeButtonOk>(GameOpCode.TradeButtonOk);
            Register<CTradeButtonCancel>(GameOpCode.TradeButtonCancel);

            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, false);
            Register<STradeResult>(GameOpCode.TradeButtonCancel);
            Register<STradeMoney>(GameOpCode.TradeMoney);
            Register<STradeResponce>(GameOpCode.TradeResponce);
            Register<STradeOtherAdd>(GameOpCode.TradeOtherAdd);
            Register<STradeOtherMoney>(GameOpCode.TradeOtherMoney);
            Register<STradeRequest>(GameOpCode.TradeRequest);

            #region MuunSystem
            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, true);
            Register<CMuunItemExchange>(GameOpCode.MuunItemExchange);
            Register<CMuunItemGet>(GameOpCode.MuunItemGet);
            Register<CMuunItemRideSelect>(GameOpCode.MuunItemRideSelect);
            Register<CMuunItemSell>(GameOpCode.MuunItemSell);
            Register<CMuunItemUse>(GameOpCode.MuunItemUse);

            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, false);
            Register<SMuunRideVP>(GameOpCode.MuunRideViewPort);
            Register<SMuunItemGet>(GameOpCode.MuunItemGet);
            #endregion


            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, true);
            Register<CUsePopUpType>(GameOpCode.PopUpType);
            Register<CMemberPosInfoStart>(GameOpCode.MemberPosInfoStart);
            Register<CMemberPosInfoStop>(GameOpCode.MemberPosInfoStop);
            Register<CMuHelperState>(GameOpCode.MuHelperSwitch);
            Register<CMUBotData>(GameOpCode.MuHelper);
            Register<CQuestExp>(GameOpCode.QuestExp);
            Register<CShadowBuff>(GameOpCode.ShadowBuff);
            Register<CGremoryCaseOpenS16>(GameOpCode.GremoryCaseOpenS16);
            Register<CGremoryCaseOpen>(GameOpCode.GremoryCaseOpen);
            Register<CGremoryCaseUseItem>(GameOpCode.GremoryCaseUse);
            Register<CPShopSearchItem>(GameOpCode.PShopSearchItem);
            Register<CAcheronEnterReq>(GameOpCode.AcheronEnter);
            Register<CRefineJewelReq>(GameOpCode.RefineJewel);
            Register<CPentagramaJewelIn>(GameOpCode.PentagramaJewelIn);
            Register<CPetInfo>(GameOpCode.PetInfo);
            Register<CPetCommand>(GameOpCode.PetCommand);
            Register<CInventoryEquipament>(GameOpCode.InventoryEquipament);
            Register<CSXInfo>(GameOpCode.SXInfo);
            Register<CFavoritesList>(GameOpCode.FavoritesList);
            Register<CPartyMRegister>(GameOpCode.PartyMatchingRegister);
            Register<CPartyMSearch>(GameOpCode.PartyMatchingSearch);
            Register<CPartyMJoin>(GameOpCode.PartyMatchingJoin);
            Register<CPartyMJoinData>(GameOpCode.PartyMatchingJoinData);
            Register<CPartyMJoinList>(GameOpCode.PartyMatchingJoinList);
            Register<CPartyMAccept>(GameOpCode.PartyMatchingAccept);
            Register<CPartyMCancel>(GameOpCode.PartyMatchingCancel);
            Register<CPartyLeaderChange>(GameOpCode.PartyLeaderChange);
            Register<CHuntingRecordRequest>(GameOpCode.HuntingRecordRequest);
            Register<CHuntingRecordClose>(GameOpCode.HuntingRecordClose);
            Register<CHuntingRecordVisibility>(GameOpCode.HuntingRecordVisibility);
            Register<CRuudBuy>(GameOpCode.Ruudbuy);
            Register<CMossMerchantOpenBox>(GameOpCode.MossMerchantOpenBox);

            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, false);
            Register<SUBFInfo>(GameOpCode.UBFInfo);
            Register<SRuudBuy>(GameOpCode.Ruudbuy);
            Register<SRuudSend>(GameOpCode.RuudSend);
            Register<SHuntingRecordList>(GameOpCode.HuntingRecordRequest);
            Register<SHuntingRecordDay>(GameOpCode.HuntingRecordDay);
            Register<SHuntingRecordTime>(GameOpCode.HuntingRecordCurrent);
            Register<SMossMerchantOpen>(GameOpCode.MossMerchant);
            Register<SMossMerchantOpenBox>(GameOpCode.MossMerchantOpenBoxReward);
            Register<SPartyMJoinNotify>(GameOpCode.PartyJoinNotify);
            Register<SPartyMCancel>(GameOpCode.PartyMatchingCancel);
            Register<SPartyMJoinList>(GameOpCode.PartyMatchingJoinList);
            Register<SPartyMJoin>(GameOpCode.PartyMatchingJoin);
            Register<SPartyMRegister>(GameOpCode.PartyMatchingRegister);
            Register<SPartyMSearch>(GameOpCode.PartyMatchingSearch);
            Register<SEventNotificationS16Kor>(GameOpCode.Eventnotification);
            Register<SXElementalData>(GameOpCode.SXElementalData);
            Register<SXCharacterInfo>(GameOpCode.SXCharacterInfo);
            Register<SXUpPront>(GameOpCode.SXUpPront);
            Register<SNQWorldLoad>(GameOpCode.NewQuestWorldLoad);
            Register<SNQWorldList>(GameOpCode.NewQuestWorldList);
            Register<SPKLevel>(GameOpCode.PKLevel);
            Register<SMonsterSkillS9Eng>(GameOpCode.MonsterSkill);
            Register<SEquipamentChange>(GameOpCode.EquipamentChange);
            Register<SExpEventInfo>(GameOpCode.ExpEventInfo);
            Register<SPetAttack>(GameOpCode.PetAttack);
            Register<SPetInfo>(GameOpCode.PetInfo);
            Register<SPentagramJewelIn>(GameOpCode.PentagramaJewelIn);
            Register<SPentagramJewelInOut>(GameOpCode.PentagramaJewelInOut);
            Register<SPentagramJewelInfo>(GameOpCode.PentagramaJInfo);
            Register<SElementalDamage>(GameOpCode.ElementDamage);
            Register<SNeedSpiritMap>(GameOpCode.NeedSpiritMap);
            Register<SPShopSearchItem>(GameOpCode.PShopSearchItem);
            Register<SGremoryCaseUseItem>(GameOpCode.GremoryCaseUse);
            Register<SGremoryCaseOpenS16>(GameOpCode.GremoryCaseOpenS16);
            Register<SGremoryCaseOpen>(GameOpCode.GremoryCaseOpen);
            Register<SGremoryCaseReceiveItem>(GameOpCode.GremoryCaseReceive);
            Register<SGremoryCaseNotice>(GameOpCode.GremoryCaseNotice);
            Register<SGremoryCaseDelete>(GameOpCode.GremoryCaseDelete);
            Register<SGremoryCaseDeleteS16>(GameOpCode.GremoryCaseDelete);
            Register<SGremoryCaseList>(GameOpCode.GremoryCaseList);
            Register<SChainMagic>(GameOpCode.ChainMagic);
            Register<SMuHelperState>(GameOpCode.MuHelperSwitch);
            Register<SAttackSpeed>(GameOpCode.AttackSpeed);
            Register<SLifeInfo>(GameOpCode.LifeInfo);
            Register<SMuunInventory>(GameOpCode.MuunInventory);
            Register<SMuunInventoryS17>(GameOpCode.MuunInventory);
            VersionSelector.Register<SMuunInventory>(ServerSeason.Season6Kor, GameOpCode.MuunInventory);
            VersionSelector.Register<SMuunInventoryS17>(ServerSeason.Season17Kor, GameOpCode.MuunInventory);
            Register<SUBFPopUpType>(GameOpCode.PopUpType);
            Register<SMiniMapNPC>(GameOpCode.MiniMapNPC);
            Register<SPeriodItemCount>(GameOpCode.PeriodItemCount);
            Register<SPentagramaJewelInfo>(GameOpCode.PentagramaJInfo);

            VersionSelector.Register<SGremoryCaseDelete>(ServerSeason.Season6Kor, GameOpCode.GremoryCaseDelete);
            VersionSelector.Register<SGremoryCaseDeleteS16>(ServerSeason.Season16Kor, GameOpCode.GremoryCaseDelete);
            switch (Season)
            {
                case ServerSeason.Season16Kor:
                    ChangeOPCode<CFavoritesList>(GameOpCode.FavoritesListS16Kor);
                    break;
            }
        }
    }
}


--file Game_C2S.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MU.Network.Game
{
    [WZContract]
    public class CCheckSum : IGameMessage
    {
        [WZMember(0)]
        public ushort Key { get; set; }
    }

    [WZContract]
    public class CClientMessage : IGameMessage
    {
        [WZMember(0)]
        public HackCheck Flag { get; set; }
    }

    [WZContract]
    public class CCloseWindow : IGameMessage
    { }

    [WZContract]
    public class CCancelItemSale : IGameMessage
    { }

    [WZContract]
    public class CCancelItemSaleClose : IGameMessage
    { }

    [WZContract]
    public class CCancelItemSaleItem : IGameMessage
    {
        [WZMember(0)] public byte IndexCode { get; set; }
        [WZMember(1)] public ushort Unk { get; set; }
        [WZMember(2)] public byte ItemCount { get; set; }
        [WZMember(3)] public uint ExpireSec { get; set; }
        [WZMember(4)] public int RequireMoney { get; set; }
        [WZMember(5)] public int Unk2 { get; set; }
    }

    [WZContract]
    public class CTeleport : IGameMessage
    {
        [WZMember(0)] public byte Unk { get; set; }
        [WZMember(1)] public ushort MoveNumber { get; set; }
        [WZMember(2)] public byte X { get; set; }
        [WZMember(3)] public byte Y { get; set; }
        [WZMember(4)] public byte Unk2 { get; set; }

        //public ushort MoveNumber => wzMoveNumber.ShufleEnding();
    }

    [WZContract]
    public class CTeleportS9 : IGameMessage
    {
        [WZMember(0)] public byte fix { get; set; }
        [WZMember(1)] public ushort MoveNumber { get; set; }
        [WZMember(2)] public byte X { get; set; }
        [WZMember(3)] public byte Y { get; set; }

        //public ushort MoveNumber => wzMoveNumber.ShufleEnding();
    }

    [WZContract]
    public class CAction : IGameMessage
    {
        [WZMember(0)]
        public byte Dir { get; set; }

        [WZMember(1)]
        public byte ActionNumber { get; set; }

        //[WZMember(2)]
        public ushort btTarget { get; set; }

        public ushort Target
        {
            get => btTarget.ShufleEnding();
            set
            {
                btTarget = value.ShufleEnding();
            }
        }
    }

    [WZContract]
    public class CMove : IGameMessage
    {
        [WZMember(0)]
        public byte X { get; set; } // 3

        [WZMember(1)]
        public byte Y { get; set; } // 4

        [WZMember(2, 8)]
        public byte[] Path { get; set; }   // 5 - 8
    }

    [WZContract]
    public class CMoveEng : IGameMessage
    {
        [WZMember(0)]
        public byte X { get; set; } // 3

        [WZMember(1)]
        public byte Y { get; set; } // 4

        [WZMember(2, 8)]
        public byte[] Path { get; set; }   // 5 - 8
    }

    [WZContract]
    public class CMove12Eng : IGameMessage
    {
        [WZMember(0)]
        public byte X { get; set; } // 3

        [WZMember(1)]
        public byte Y { get; set; } // 4

        [WZMember(2, 8)]
        public byte[] Path { get; set; }   // 5 - 8
    }

    [WZContract]
    public class CChatNickname : IGameMessage
    {
        [WZMember(0, 10)]
        public byte[] Character { get; set; } // 3

        [WZMember(1, 60)]
        public byte[] Message { get; set; } // 4
    }

    [WZContract]
    public class CChatNumber : IGameMessage
    {
        [WZMember(0)]
        public ushort wzNumber { get; set; } // 3

        [WZMember(1, 60)]
        public byte[] Message { get; set; } // 4

        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }
    }

    [WZContract]
    public class CChatWhisper : IGameMessage
    {
        [WZMember(0, 10)]
        public byte[] btId { get; set; }    // 3

        [WZMember(1, 60)]
        public byte[] btMessage { get; set; }   // D  

        public string Id => btId.MakeString();

        public string Message => btMessage.MakeString();
    };

    [WZContract]
    public class CPositionSet : IGameMessage
    {
        [WZMember(0)]
        public byte X { get; set; }

        [WZMember(1)]
        public byte Y { get; set; }

        public Point Position => new Point(X, Y);
    }

    [WZContract]
    public class CPositionSetS9 : IGameMessage
    {
        [WZMember(0)]
        public byte X { get; set; }

        [WZMember(1)]
        public byte Y { get; set; }

        public Point Position => new Point(X, Y);
    }

    [WZContract]
    public class CPointAdd : IGameMessage
    {
        [WZMember(0)]
        public PointAdd Type { get; set; }
    }

    [WZContract]
    public class CClientClose : IGameMessage
    {
        [WZMember(0)]
        public ClientCloseType Type { get; set; }
    }

    [WZContract]
    public class CMoveItem : IGameMessage
    {
        [WZMember(0)]
        public MoveItemFlags sFlag { get; set; }

        [WZMember(1)]
        public byte Source { get; set; }

        [WZMember(2, 12)]
        public byte[] ItemInfo { get; set; }

        [WZMember(3)]
        public MoveItemFlags tFlag { get; set; }

        [WZMember(4)]
        public byte Dest { get; set; }
    }

    [WZContract]
    public class CUseItem : IGameMessage
    {
        [WZMember(0)]
        public byte Source { get; set; }

        [WZMember(1)]
        public byte Dest { get; set; }

        [WZMember(2)]
        public byte Type { get; set; }
    }

    [WZContract]
    public class CItemGet : IGameMessage
    {
        [WZMember(0)]
        public ushort wzNumber { get; set; }

        public ushort Number => wzNumber.ShufleEnding();
    }

    [WZContract]
    public class CEventEnterCount : IGameMessage
    {
        [WZMember(0)]
        public EventEnterType Type { get; set; }
    }

    [WZContract]
    public class CTalk : IGameMessage
    {
        [WZMember(0)]
        public ushort Number { get; set; }
    }

    [WZContract]
    public class CWarehouseUseEnd : IGameMessage
    { }

    [WZContract]
    public class CBuy : IGameMessage
    {
        [WZMember(0)]
        public byte Position { get; set; }
    }

    [WZContract]
    public class CSell : IGameMessage
    {
        [WZMember(0)]
        public byte Position { get; set; }
    }

    [WZContract]
    public class CAttack : IGameMessage
    {
        [WZMember(0)]
        public ushort wzNumber { get; set; }   // 3,4

        [WZMember(1)]
        public byte AttackAction { get; set; }  // 5

        [WZMember(2)]
        public byte DirDis { get; set; }    // 6

        public ushort Number => wzNumber.ShufleEnding();
    }

    [WZContract]
    public class CAttackS5E2 : IGameMessage
    {
        [WZMember(0)]
        public byte AttackAction { get; set; }  // 5

        [WZMember(1)]
        public byte DirDis { get; set; }    // 6

        [WZMember(2)]
        public ushort Number { get; set; }   // 3,4
    }

    [WZContract]
    public class CMagicAttack : IGameMessage
    {
        [WZMember(0)]
        public ushort wzMagicNumber { get; set; }

        [WZMember(1)]
        public ushort wzTarget { get; set; }

        [WZMember(2)]
        public byte Dis { get; set; }

        public ushort Target { get => wzTarget.ShufleEnding(); set => wzTarget = value.ShufleEnding(); }
        public Spell MagicNumber { get => (Spell)wzMagicNumber.ShufleEnding(); set => wzMagicNumber = ((ushort)value).ShufleEnding(); }
    }

    [WZContract]
    public class CMagicAttackS9 : IGameMessage
    {
        [WZMember(0)]
        public byte TargetH { get; set; }

        [WZMember(1)]
        public byte MagicNumberH { get; set; }
        [WZMember(2)]
        public byte TargetL { get; set; }

        [WZMember(3)]
        public byte MagicNumberL { get; set; }

        public ushort Target => (ushort)(TargetH << 8 | TargetL);
        public Spell MagicNumber => (Spell)(MagicNumberH << 8 | MagicNumberL);
    }

    [WZContract]
    public class CMagicDuration : IGameMessage
    {
        [WZMember(0)]
        public ushort wzMagicNumber { get; set; }
        [WZMember(1)]
        public byte X { get; set; }
        [WZMember(2)]
        public byte Y { get; set; }
        [WZMember(3)]
        public byte Dir { get; set; }
        [WZMember(4)]
        public byte Dis { get; set; }
        [WZMember(5)]
        public byte TargetPos { get; set; }

        [WZMember(6)]
        public ushort wzTarget { get; set; }

        [WZMember(7)]
        public byte MagicKey { get; set; }

        [WZMember(8, 5)]
        public byte[] Unk { get; set; }

        public ushort Target { get => wzTarget.ShufleEnding(); set => wzTarget = value.ShufleEnding(); }
        public Spell MagicNumber
        {
            get => (Spell)wzMagicNumber.ShufleEnding();
            set => wzMagicNumber = ((ushort)value).ShufleEnding();
        }
    }

    [WZContract]
    public class CMagicDurationS9 : IGameMessage
    {
        [WZMember(0)] public byte X { get; set; }
        [WZMember(1)] public byte MagicNumberH { get; set; }
        [WZMember(2)] public byte Y { get; set; }
        [WZMember(3)] public byte MagicNumberL { get; set; }
        [WZMember(4)] public byte Dir { get; set; }

        [WZMember(5)] public byte TargetH { get; set; }
        [WZMember(6)] public byte Dis { get; set; }

        [WZMember(7)] public byte TargetL { get; set; }

        [WZMember(8)] public byte TargetPos { get; set; }

        [WZMember(9)] public byte MagicKey { get; set; }

        public ushort Target => (ushort)(TargetH << 8 | TargetL);
        public Spell MagicNumber => (Spell)(MagicNumberH << 8 | MagicNumberL);
    }

    [WZContract]
    public class CMagicDurationS16 : IGameMessage
    {
        [WZMember(0)] public int X { get; set; }
        [WZMember(1)] public byte MagicNumberH { get; set; }
        [WZMember(2)] public int Y { get; set; }
        [WZMember(3)] public byte MagicNumberL { get; set; }
        [WZMember(4)] public byte Dir { get; set; }

        [WZMember(5)] public byte TargetH { get; set; }
        [WZMember(6)] public byte Dis { get; set; }

        [WZMember(7)] public byte TargetL { get; set; }

        [WZMember(8)] public byte TargetPos { get; set; }

        [WZMember(9)] public byte MagicKey { get; set; }
        //[WZMember(10)] public uint AttackTime { get; set; }

        public ushort Target => (ushort)(TargetH << 8 | TargetL);
        public Spell MagicNumber => (Spell)(MagicNumberH << 8 | MagicNumberL);
    }

    [WZContract]
    public class CBeattackDto
    {
        [WZMember(0)] public ushort wzNumber { get; set; }
        [WZMember(1)] public byte MagicKey { get; set; }

        public ushort Number => wzNumber.ShufleEnding();
    }

    [WZContract]
    public class CBeattack : IGameMessage
    {
        [WZMember(0)] public ushort wzMagicNumber { get; set; }
        [WZMember(1)] public byte X { get; set; }
        [WZMember(2)] public byte Y { get; set; }
        [WZMember(3)] public byte Serial { get; set; }
        //[WZMember(1)] public byte Count { get; set; }
        [WZMember(4, typeof(ArrayWithScalarSerializer<byte>))] public CBeattackDto[] Beattack { get; set; }

        public Spell MagicNumber => (Spell)wzMagicNumber.ShufleEnding();
        public Point Position => new Point(X, Y);
    }

    [WZContract]
    public class CBeattackS9Dto
    {
        [WZMember(0)] public byte NumberH { get; set; }   // 0
        [WZMember(1)] public byte MagicKey { get; set; }  // 1
        [WZMember(2)] public byte NumberL { get; set; }	// 2

        public ushort Number => (ushort)(NumberH << 8 | NumberL);
    }

    [WZContract]
    public class CBeattackS9 : IGameMessage
    {
        [WZMember(0)] public byte MagicNumberH { get; set; }
        [WZMember(1)] public byte Count { get; set; }
        [WZMember(2)] public byte MagicNumberL { get; set; }
        [WZMember(3)] public byte X { get; set; }
        [WZMember(4)] public byte Serial { get; set; }
        [WZMember(5)] public byte Y { get; set; }
        //[WZMember(1)] public byte Count { get; set; }
        [WZMember(6, typeof(ArraySerializer))] public CBeattackS9Dto[] Beattack { get; set; }

        public Spell MagicNumber => (Spell)(MagicNumberH << 8 | MagicNumberL);
        public Point Position => new Point(X, Y);
    }

    [WZContract]
    public class CWarp : IGameMessage
    {
        [WZMember(0)]
        public int iCheckVal { get; set; }

        [WZMember(1)]
        public ushort MoveNumber { get; set; }
    }

    [WZContract]
    public class CDataLoadOK : IGameMessage
    { }

    [WZContract]
    public class CJewelMix : IGameMessage
    {
        [WZMember(0)]
        public byte JewelType { get; set; }

        [WZMember(1)]
        public byte JewelMix { get; set; }
    }

    [WZContract]
    public class CJewelUnMix : IGameMessage
    {
        [WZMember(0)]
        public byte JewelType { get; set; }

        [WZMember(1)]
        public byte JewelLevel { get; set; }

        [WZMember(2)]
        public byte JewelPos { get; set; }
    }

    [WZContract]
    public class CChaosBoxItemMixButtonClick : IGameMessage
    {
        //0xC1
        //0x05
        //0x86
        [WZMember(0)] public ChaosMixType Type { get; set; }
        [WZMember(1)] public byte Info { get; set; }
    }

    [WZContract]
    public class CChaosBoxItemMixButtonClickS5 : IGameMessage // Season 5 reference
    {
        [WZMember(0)] public ChaosMixType Type { get; set; }
        [WZMember(1)] public byte Info { get; set; }
    }

    [WZContract]
    public class CChaosBoxUseEnd : IGameMessage
    { }

    [WZContract]
    public class CInventory : IGameMessage
    { }

    [WZContract]
    public class CSkillKey : IGameMessage
    {
        [WZMember(0)]
        public byte subcode { get; set; }   // 3

        [WZMember(1, 20)]
        public byte[] SkillKey { get; set; }  // 4

        [WZMember(2)]
        public byte GameOption { get; set; }    // E

        [WZMember(3)]
        public byte QkeyDefine { get; set; }    // F

        [WZMember(4)]
        public byte WkeyDefine { get; set; }    // 10

        [WZMember(5)]
        public byte EkeyDefine { get; set; }    // 11

        [WZMember(6)]
        public byte ChatWindow { get; set; }    // 13

        [WZMember(7)]
        public byte RkeyDefine { get; set; }

        [WZMember(8)]
        public uint QWERLevelDefine { get; set; }
    }

    [WZContract]
    public class CItemThrow : IGameMessage
    {
        [WZMember(0)]
        public byte MapX { get; set; }   // 3

        [WZMember(1)]
        public byte MapY { get; set; }  // 4

        [WZMember(2)]
        public byte Source { get; set; }    // 5
    }

    [WZContract]
    public class CItemModify : IGameMessage
    {
        [WZMember(0)] public byte Position { get; set; }

        [WZMember(1)] public byte ReqPosition { get; set; }
    }

    [WZContract]
    public class CPShopSetItemPrice : IGameMessage
    {
        [WZMember(0)] public byte Position { get; set; }
        [WZMember(1)] public uint Price { get; set; }
        [WZMember(2)] public ushort JewelOfBlessPrice { get; set; }
        [WZMember(3)] public ushort JewelOfSoulPrice { get; set; }
        [WZMember(4)] public ushort JewelOfChaosPrice { get; set; }
    }

    [WZContract]
    public class CPShopSetItemPriceS16Kor : IGameMessage
    {
        [WZMember(0)] public byte Slot { get; set; }
        [WZMember(1)] public byte Changed { get; set; }
        [WZMember(2)] public uint Price { get; set; }
        [WZMember(3)] public uint JewelOfBlessPrice { get; set; }
        [WZMember(4)] public uint JewelOfSoulPrice { get; set; }
        [WZMember(5)] public uint Item1 { get; set; }
        [WZMember(6)] public uint Item2 { get; set; }
        [WZMember(7)] public uint Item3 { get; set; }
        [WZMember(8)] public uint Item4 { get; set; }
        [WZMember(9)] public uint Item5 { get; set; }

        private IEnumerable<uint> getItems()
        {
            var list = new List<uint>();
            if (Item1 != 0xffffffff) list.Add(Item1);
            if (Item2 != 0xffffffff) list.Add(Item2);
            if (Item3 != 0xffffffff) list.Add(Item3);
            if (Item4 != 0xffffffff) list.Add(Item4);
            if (Item5 != 0xffffffff) list.Add(Item5);

            return list;
        }

        public IEnumerable<uint> Items => getItems();
    }

    [WZContract]
    public class CPShopRequestOpen : IGameMessage
    {
        [WZMember(0, 36)] public byte[] btName { get; set; }

        public string Name => btName.MakeString();
    }

    [WZContract]
    public class CPShopRequestClose : IGameMessage
    { }

    [WZContract]
    public class CPShopRequestList : IGameMessage
    {
        [WZMember(0)] public ushort wzNumber { get; set; }
        [WZMember(1, 10)] public byte[] btName { get; set; }
        public ushort Number => wzNumber.ShufleEnding();
        public string Name => btName.MakeString();
    }

    [WZContract(LongMessage = true)]
    public class CPShopSearch : IGameMessage
    {
        [WZMember(0)] public uint Number { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class CPShopItemSearch : IGameMessage
    {
        [WZMember(0)] public uint Number { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class CPShopItemSearch2 : IGameMessage
    {
        [WZMember(0, typeof(BinaryStringSerializer), 65)] public string Name { get; set; }
        [WZMember(1)] public uint Number { get; set; }
        [WZMember(2)] public ushort Item { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class CPShopRequestList2S16Kor : IGameMessage
    {
        [WZMember(0)] public uint Number { get; set; }
        [WZMember(1, typeof(BinaryStringSerializer), 11)] public string Seller { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class CPShopChangeStateS16Kor : IGameMessage
    {
        [WZMember(0)] public uint Number { get; set; }
        [WZMember(1)] public byte State { get; set; }
        [WZMember(2, typeof(BinaryStringSerializer), 11)] public string Seller { get; set; }
        [WZMember(3, typeof(BinaryStringSerializer), 45)] public string Description { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class CPShopCancelItemSaleS16Kor : IGameMessage
    {
        [WZMember(0)] public uint Number { get; set; }
        [WZMember(1, typeof(BinaryStringSerializer), 11)] public string Seller { get; set; }
        [WZMember(2)] public byte Slot { get; set; }
        [WZMember(3, typeof(ArrayWithScalarSerializer<uint>))] public ItemViewS16Dto[] Items { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class CPShopItemViewS16Kor : IGameMessage
    {
        [WZMember(0)] public uint Number { get; set; }
        [WZMember(1, typeof(BinaryStringSerializer), 11)] public string Seller { get; set; }
        [WZMember(2)] public byte Slot { get; set; }
    }

    [WZContract]
    public class CPShopRequestBuy : IGameMessage
    {
        [WZMember(0)] public ushort wzNumber { get; set; }
        [WZMember(1, 10)] public byte[] btName { get; set; }
        [WZMember(2)] public byte Position { get; set; }

        public ushort Number => wzNumber.ShufleEnding();
        public string Name => btName.MakeString();
    }

    [WZContract]
    public class CPShopCloseDeal : IGameMessage
    {
        [WZMember(0)] public ushort wzNumber { get; set; }
        [WZMember(1, 10)] public byte[] btName { get; set; }

        public ushort Number => wzNumber.ShufleEnding();
        public string Name => btName.MakeString();
    }

    [WZContract]
    public class CPartyList : IGameMessage
    {

    }

    [WZContract]
    public class CPartyRequest : IGameMessage
    {
        [WZMember(0)]
        public ushort wzNumber { get; set; }

        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }
    }

    [WZContract]
    public class CPartyRequestResult : IGameMessage
    {
        [WZMember(0)]
        public byte Result { get; set; }

        [WZMember(1)]
        public ushort wzNumber { get; set; }

        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }
    }

    [WZContract]
    public class CPartyDelUser : IGameMessage
    {
        [WZMember(0)]
        public byte Index { get; set; }
    }

    [WZContract]
    public class CDuelRequest : IGameMessage
    {
        [WZMember(0)] public ushort wzNumber { get; set; }
        [WZMember(1, 10)] public byte[] btName { get; set; }

        public CDuelRequest() { }
        public CDuelRequest(ushort number, string name)
        {
            wzNumber = number.ShufleEnding();
            btName = name.GetBytes();
        }
    }

    [WZContract]
    public class CDuelAnswer : IGameMessage
    {
        [WZMember(0)] public byte DuelOK { get; set; }
        [WZMember(1)] public ushort wzNumber { get; set; }

        public ushort Number => wzNumber.ShufleEnding();
    }

    [WZContract]
    public class CDuelLeave : IGameMessage { }

    [WZContract]
    public class CDuelJoinRoom : IGameMessage 
    {
        [WZMember(0)] public byte Room { get; set; }
    }

    [WZContract]
    public class CDuelLeaveRoom : IGameMessage
    {
        [WZMember(0)] public byte Room { get; set; }
    }

    #region Friend
    [WZContract]
    public class CFriendList : IGameMessage { }

    [WZContract]
    public class CFriendAdd : IGameMessage
    {
        [WZMember(0,10)] public byte[] btName { get; set; }

        public string Name => btName.MakeString();
    }
    #endregion

    [WZContract]
    public class CMasterSkill : IGameMessage
    {
        [WZMember(0)]
        public Spell MasterSkill { get; set; }

        [WZMember(1)]
        public ushort MasterEmpty { get; set; }
    }

    [WZContract]
    public class CTradeRequest : IGameMessage
    {
        [WZMember(0)]
        public ushort wzNumber { get; set; }

        public ushort Number { get => wzNumber.ShufleEnding(); }
    }

    [WZContract]
    public class CTradeResponce : IGameMessage
    {
        [WZMember(0)]
        public byte Result { get; set; }

        /*[WZMember(1, 10)]
        public byte[] szId { get; set; }

        [WZMember(2)]
        public ushort Level { get; set; }

        [WZMember(3)]
        public int GuildNumber { get; set; }*/
    }

    [WZContract]
    public class CTradeMoney : IGameMessage
    {
        [WZMember(0)]
        public uint Money { get; set; }
    }

    [WZContract]
    public class CTradeButtonOk : IGameMessage
    {
        [WZMember(0)]
        public byte Flag { get; set; }
    }

    [WZContract]
    public class CTradeButtonCancel : IGameMessage
    { }

    [WZContract]
    public class CFriendAddReq : IGameMessage
    {
        [WZMember(0, 10)] public byte[] btName { get; set; }

        public string Name { get => btName.MakeString(); set => btName = value.GetBytes(); }
    }

    [WZContract]
    public class CWaitFriendAddReq : IGameMessage
    {
        [WZMember(0)] public byte Result { get; set; }

        [WZMember(1, 10)] public byte[] btName { get; set; }

        public string Name { get => btName.MakeString(); set => btName = value.GetBytes(); }
    }

    [WZContract]
    public class CMemberPosInfoStart : IGameMessage
    { }

    [WZContract]
    public class CMemberPosInfoStop : IGameMessage
    { }

    [WZContract]
    public class CNPCJulia : IGameMessage
    { }

    [Flags]
    public enum HuntingFlags19 : byte
    {
        AutoPotion=0x01,
        DrainLife = 0x04,
        LongDistanceC = 0x08,
        OriginalPosition = 0x10,
        UseSkillClosely = 0x20,
        Party = 0x40,
        PreferenceOfParty = 0x80,
    }

    [Flags]
    public enum HuntingFlags1A : byte
    {
        BuffTimeParty = 0x01,
        BuffDuration = 0x04,
        Delay = 0x08,
        Condition = 0x10,
        MonsterAttacking = 0x20,
        Cond1 = 0x40,
        Cond2 = 0x80,
        Cond3 = 0xC0,
    }

    [Flags]
    public enum HuntingFlags1B : byte
    {
        Delay = 0x01,
        Condition = 0x02,
        MonsterAttacking = 0x04,
        Cond1 = 0x08,
        Cond2 = 0x10,
        Cond3 = 0x18,
        Repair = 0x20,
        PickAllNearItems = 0x40,
        PickSelectedItems = 0x80,
    }

    [Flags]
    public enum HuntingFlags1C : byte
    {
        Delay = 0x01,
        Condition = 0x02,
        AutoAcceptFriend = 0x04,
        AutoAcceptGuild = 0x08,
        UseElitePotion = 0x10,
        UseSkillClosely = 0x20,
        UseRegularAttackArea = 0x40,
        PickSelectedItems = 0x80,
    }

    [Flags]
    public enum OptainingFlags:byte
    {
        Unk = 0x01,
        Jewels = 0x08,
        SetItem = 0x10,
        ExcellentItem = 0x20,
        Zen = 0x40,
        ExtraItem = 0x80,
    }

    [WZContract(LongMessage = true)]
    public class CMUBotData : IGameMessage
    {
        /*[WZMember(0, typeof(BinarySerializer), 257)]
        public byte[] Data { get; set; }*/
        [WZMember(0)] public byte Data0 { get; set; }
        [WZMember(1)] public OptainingFlags OptainingFlags { get; set; }
        [WZMember(2)] public byte Data2 { get; set; }
        [WZMember(3)] public byte OPDelayTime { get; set; }
        [WZMember(4)] public ushort BasicSkill { get; set; }
        [WZMember(6)] public ushort ActivationSkill { get; set; }
        [WZMember(8)] public ushort DelayTime { get; set; }
        [WZMember(0xA)] public ushort ActivationSkill2 { get; set; }
        [WZMember(0xC)] public ushort DelayTime2 { get; set; }
        [WZMember(0xE)] public ushort Unk0E { get; set; }
        [WZMember(0x10)] public ushort Buff1 { get; set; }
        [WZMember(0x12)] public ushort Buff2 { get; set; }
        [WZMember(0x14)] public ushort Buff3 { get; set; }
        [WZMember(0x16)] public byte Unk16 { get; set; }
        [WZMember(0x17)] public byte AutoPotion_Heal { get; set; }
        [WZMember(0x18)] public byte AutoDrainLife_Party { get; set; }
        [WZMember(0x19)] public HuntingFlags19 Flags19 { get; set; }
        [WZMember(0x1A)] public HuntingFlags1A Flags1A { get; set; }
        [WZMember(0x1B)] public HuntingFlags1B Flags1B { get; set; }
        [WZMember(0x1C)] public HuntingFlags1C Flags1C { get; set; }
        [WZMember(0x1D, typeof(BinarySerializer), 36)] public byte[] Data1D { get; set; }
        [WZMember(0x41, typeof(BinaryStringSerializer), 16)] public string ExtraItem1 { get; set; }
        [WZMember(0x51, typeof(BinaryStringSerializer), 16)] public string ExtraItem2 { get; set; }
        [WZMember(0x61, typeof(BinaryStringSerializer), 16)] public string ExtraItem3 { get; set; }
        [WZMember(0x71, typeof(BinaryStringSerializer), 16)] public string ExtraItem4 { get; set; }
        [WZMember(0x81, typeof(BinaryStringSerializer), 16)] public string ExtraItem5 { get; set; }
        [WZMember(0x91, typeof(BinaryStringSerializer), 16)] public string ExtraItem6 { get; set; }
        [WZMember(0xA1, typeof(BinaryStringSerializer), 16)] public string ExtraItem7 { get; set; }
        [WZMember(0xB1, typeof(BinaryStringSerializer), 16)] public string ExtraItem8 { get; set; }
        [WZMember(0xC1, typeof(BinaryStringSerializer), 16)] public string ExtraItem9 { get; set; }
        [WZMember(0xD1, typeof(BinaryStringSerializer), 16)] public string ExtraItem10 { get; set; }
        [WZMember(0xE1, typeof(BinaryStringSerializer), 16)] public string ExtraItem11 { get; set; }
        [WZMember(0xF1, typeof(BinaryStringSerializer), 16)] public string ExtraItem12 { get; set; }
        public int AutoDrainLife
        {
            get => AutoDrainLife_Party & 0x0F;
            set
            {
                AutoDrainLife_Party &= 0xF0;
                AutoDrainLife_Party |= (byte)value;
            }
        }
        public int AutoPartyHeal
        {
            get => (AutoDrainLife_Party >> 4) & 0x0F;
            set
            {
                AutoDrainLife_Party &= 0x0F;
                AutoDrainLife_Party |= (byte)(value << 4);
            }
        }
        public int AutoPotion
        {
            get => AutoPotion_Heal & 0x0F;
            set
            {
                AutoPotion_Heal &= 0xF0;
                AutoPotion_Heal |= (byte)value;
            }
        }
        public int AutoHeal
        {
            get => (AutoPotion_Heal >> 4) & 0x0F;
            set
            {
                AutoPotion_Heal &= 0x0F;
                AutoPotion_Heal |= (byte)(value << 4);
            }
        }
        public int HuntingRange
        {
            get => Data2 & 0x0F;
            set
            {
                Data2 &= 0xF0;
                Data2 |= (byte)value;
            }
        }
        public int OptainingRange
        {
            get => (Data2>>4) & 0x0F;
            set
            {
                Data2 &= 0x0F;
                Data2 |= (byte)(value<<4);
            }
        }
    }

    [WZContract]
    public class CMuHelperState : IGameMessage
    {
        [WZMember(0)]
        public byte State { get; set; }
    }

    [WZContract]
    public class CQuestExp : IGameMessage
    { }

    [WZContract]
    public class CShadowBuff : IGameMessage
    { }

    [WZContract]
    public class CGremoryCaseOpen : IGameMessage
    { }

    [WZContract]
    public class CGremoryCaseOpenS16 : IGameMessage
    {
        [WZMember(0)] public byte Unk { get; set; }
    }

    [WZContract]
    public class CGremoryCaseUseItem : IGameMessage
    {
        //Packet C1 11 4F 02 [98 1D] [00 00] [2B 00 00 00] [00 00 00 00] 02
        [WZMember(0)] public ushort Item { get; set; }
        [WZMember(1)] public ushort Unk { get; set; }
        [WZMember(3)] public uint Serial { get; set; }
        [WZMember(4)] public uint Slot { get; set; }
        [WZMember(5)] public GremoryStorage Inventory { get; set; }
    }

    [WZContract]
    public class CAcheronEnterReq : IGameMessage
    { }

    [WZContract]
    public class CRefineJewelReq : IGameMessage
    {
        [WZMember(0)] public byte Type { get; set; }
    }

    [WZContract]
    public class CPentagramaJewelIn : IGameMessage
    {
        [WZMember(0)] public int PentagramPos { get; set; }
        [WZMember(1)] public int JewelPos { get; set; }
    }

    [WZContract]
    public class CPShopSearchItem : IGameMessage
    {
        [WZMember(0)] public int iLastCount { get; set; }
        [WZMember(1)] public short sSearchItem { get; set; }
    }

    [WZContract]
    public class CPetInfo : IGameMessage
    {
        [WZMember(0)] public byte PetType { get; set; }   // 3
        [WZMember(1)] public byte InvenType { get; set; } // 4
        [WZMember(2)] public byte nPos { get; set; }	// 5
    }

    [WZContract]
    public class CPetCommand : IGameMessage
    {
        [WZMember(0)] public byte PetType { get; set; }   // 3
        [WZMember(1)] public PetMode Command { get; set; }   // 4
        [WZMember(2)] public ushort wzNumber { get; set; }   // 5

        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }   // 5
    };

    [WZContract]
    public class CInventoryEquipament : IGameMessage
    {
        [WZMember(0)] public byte ItemPos { get; set; }
        [WZMember(1)] public UseItemFlag Type { get; set; }
    }

    [WZContract]
    public class CSXInfo : IGameMessage
    { }

    [WZContract]
    public class CNewQuest : IGameMessage
    { }

    [WZContract]
    public class CWarehouseMoney : IGameMessage
    {
        //0xC1
        //0x08
        //0x81
        [WZMember(0)] public byte Type { get; set; }
        [WZMember(1)] public uint Money { get; set; }
    }
    [WZContract]
    public class CFavoritesList : IGameMessage
    {
        //0xC1
        //0x1C
        //0x6D,0x01
        [WZMember(1, typeof(ArrayWithScalarSerializer<int>))] public int[] Region { get; set; }
    }

    [WZContract]
    public class COpenBox : IGameMessage
    {
        [WZMember(0)] public byte Slot { get; set; }
        [WZMember(1)] public byte data2 { get; set; }
        [WZMember(2)] public byte type { get; set; }
    }

    [WZContract]
    public class CItemSplit : IGameMessage
    {
        [WZMember(1)] public byte Slot { get; set; }
        [WZMember(2)] public byte Type { get; set; }
        [WZMember(3)] public byte Amount { get; set; }
    }



    [WZContract]
    public class CPartyMRegister : IGameMessage
    {
        [WZMember(0, typeof(BinaryStringSerializer), 41)] public string Text { get; set; }
        [WZMember(1, typeof(BinaryStringSerializer), 5)] public string Password { get; set; }
        [WZMember(2)] public ushort MinLevel { get; set; }
        [WZMember(3)] public ushort MaxLevel { get; set; }
        [WZMember(4)] public bool NeedPassword { get; set; }
        [WZMember(5)] public bool AutAccept { get; set; }
        [WZMember(6)] public bool EnergyElf { get; set; }
        [WZMember(7)] public byte padding { get; set; }
    }
    [WZContract]
    public class CPartyMSearch : IGameMessage
    {
        [WZMember(1)] public uint Page { get; set; }
        [WZMember(2, typeof(BinaryStringSerializer), 11)] public string Search { get; set; }
        [WZMember(3)] public byte Flags { get; set; }
    }
    [WZContract]
    public class CPartyMJoin : IGameMessage
    {
        [WZMember(1, typeof(BinaryStringSerializer), 11)] public string Leader { get; set; }
        [WZMember(2, typeof(BinaryStringSerializer), 5)] public string Password { get; set; }
        [WZMember(3)] public bool NeedsPassword { get; set; }
        [WZMember(4)] public bool Random { get; set; }
        [WZMember(5)] public byte AutomaticHelper { get; set; }
    }
    [WZContract]
    public class CPartyMJoinData : IGameMessage
    {
        [WZMember(1)] public byte Slot { get; set; }
        [WZMember(2)] public byte Type { get; set; }
        [WZMember(3)] public byte Amount { get; set; }
    }
    [WZContract]
    public class CPartyMJoinList : IGameMessage
    { }
    [WZContract]
    public class CPartyMAccept : IGameMessage
    {
        [WZMember(0, typeof(BinaryStringSerializer), 11)] public string Applicant { get; set; }
        [WZMember(1)] public bool Accept { get; set; }
    }
    [WZContract]
    public class CPartyMCancel : IGameMessage
    {
        [WZMember(1)] public byte Type { get; set; }
    }
    [WZContract]
    public class CPartyLeaderChange : IGameMessage
    {
        [WZMember(1)] public byte Slot { get; set; }
        [WZMember(2)] public byte Type { get; set; }
        [WZMember(3)] public byte Amount { get; set; }
    }

    [WZContract]
    public class CHuntingRecordRequest : IGameMessage
    {
        [WZMember(1)] public byte Map { get; set; }
        [WZMember(2)] public ushort index { get; set; }
        [WZMember(3)] public ushort unk { get; set; }
    }

    [WZContract]
    public class CHuntingRecordClose : IGameMessage
    { }

    [WZContract]
    public class CHuntingRecordVisibility : IGameMessage
    {
        [WZMember(1)] public byte Visible { get; set; }
    }

    [WZContract]
    public class CMossMerchantOpenBox : IGameMessage
    {
        [WZMember(0)] public byte Section {get; set;}
    }

    [WZContract]
    public class CChangeSkin : IGameMessage
    {
        [WZMember(0)] public byte Skin { get; set; }
    }

    [WZContract]
    public class CRuudBuy : IGameMessage
    {
        [WZMember(0)] public byte Slot { get; set; }
    }
}


--file Game_S2C.cs
﻿using BlubLib.Serialization.Serializers;
//using MU.DataBase;
using MU.Network.Auth;
using MU.Resources;
using MuEmu.Network.Data;
using MuEmu.Resources.Game;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Globalization;
using System.Linq;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MU.Network.Game
{
    public interface IInventory
    {
        public void LoadItems(IEnumerable<KeyValuePair<byte, byte[]>> items);
    }

    [WZContract(LongMessage = true, Serialized = true)]
    public class SInventory : IInventory, IGameMessage
    {
        [WZMember(0, SerializerType = typeof(ArrayWithScalarSerializer<byte>))]
        public InventoryDto[] Inventory { get; set; }

        public SInventory()
        {
            Inventory = Array.Empty<InventoryDto>();
        }

        public SInventory(object[] inv)
        {
            Inventory = inv as InventoryDto[];
        }

        public void LoadItems(IEnumerable<KeyValuePair<byte, byte[]>> items)
        {
            Inventory = items.Select(x => new InventoryDto(x.Key, x.Value)).ToArray();
        }
    }

    [WZContract(LongMessage = true, Serialized = true)]
    public class SInventoryS17 : IInventory, IGameMessage
    {
        [WZMember(0, SerializerType = typeof(ArrayWithScalarSerializer<byte>))]
        public InventoryS17Dto[] Inventory { get; set; }

        public SInventoryS17()
        {
            Inventory = Array.Empty<InventoryS17Dto>();
        }

        public SInventoryS17(object[] inv)
        {
            Inventory = inv as InventoryS17Dto[];
        }

        public void LoadItems(IEnumerable<KeyValuePair<byte, byte[]>> items)
        {
            Inventory = items.Select(x => new InventoryS17Dto(x.Key, x.Value)).ToArray();
        }
    }

    [WZContract(LongMessage = true, Serialized = true)]
    public class SMuunInventory : IGameMessage
    {
        [WZMember(0, SerializerType = typeof(ArrayWithScalarSerializer<byte>))]
        public InventoryDto[] Inventory { get; set; }

        public SMuunInventory()
        {
            Inventory = Array.Empty<InventoryDto>();
        }

        public SMuunInventory(IEnumerable<KeyValuePair<byte, byte[]>> inv)
        {
            Inventory = inv.Select(x => new InventoryDto(x.Key, x.Value)).ToArray();
        }
    }

    [WZContract(LongMessage = true, Serialized = true)]
    public class SMuunInventoryS17 : IGameMessage
    {
        [WZMember(0, SerializerType = typeof(ArrayWithScalarSerializer<byte>))]
        public InventoryS17Dto[] Inventory { get; set; }

        public SMuunInventoryS17()
        {
            Inventory = Array.Empty<InventoryS17Dto>();
        }

        public SMuunInventoryS17(IEnumerable<KeyValuePair<byte, byte[]>> inv)
        {
            Inventory = inv.Select(x => new InventoryS17Dto(x.Key, x.Value)).ToArray();
        }
    }

    [WZContract]
    public class SEquipament : IGameMessage
    {
        [WZMember(0)]
        public ushort Number { get; set; }

        [WZMember(1, 18)]
        public byte[] CharSet { get; set; }

        public SEquipament()
        {
            CharSet = Array.Empty<byte>();
        }
    }

    [WZContract]
    public class SCheckSum : IGameMessage
    {
        [WZMember(0)]
        public byte Padding { get; set; }

        [WZMember(1)]
        public ushort Key { get; set; }
    }

    [WZContract]
    public class SMapMoveCheckSum:IGameMessage
    {
        [WZMember(0)] public uint key { get; set; }
    }

    [WZContract]
    public class SWeather : IGameMessage
    {
        [WZMember(0)]
        public byte Weather { get; set; }

        public SWeather() { }
        public SWeather(byte weather)
        {
            Weather = weather;
        }
    }

    [WZContract]
    public class SQuestInfo : IGameMessage
    {
        [WZMember(0)]
        public byte Count { get; set; }

        [WZMember(1, SerializerType = typeof(ArraySerializer))]
        public byte[] State { get; set; }
    }

    [WZContract]
    public class SSpells : IGameMessage
    {
        [WZMember(0)]
        public byte Count { get; set; }

        [WZMember(1)]
        public byte ListType { get; set; }

        [WZMember(2, SerializerType = typeof(ArraySerializer))]
        public SpellDto[] Spells { get; set; }

        public SSpells()
        {
            Spells = Array.Empty<SpellDto>();
        }

        public SSpells(byte listType, SpellDto[] spells)
        {
            Count = (byte)spells.Length;
            ListType = listType;
            Spells = spells;
        }

        public SSpells(byte listType, SpellDto spell)
        {
            Count = (byte)0xFE;
            ListType = listType;
            Spells = new SpellDto[] { spell };
        }
    }

    [WZContract(LongMessage = true)]
    public class SSpellsS12Eng : IGameMessage
    {
        [WZMember(0)]
        public byte Count { get; set; }

        [WZMember(1)]
        public byte ListType { get; set; }

        [WZMember(2, SerializerType = typeof(ArraySerializer))]
        public SpellDto[] Spells { get; set; }

        public SSpellsS12Eng()
        {
            Spells = Array.Empty<SpellDto>();
        }

        public SSpellsS12Eng(byte listType, SpellDto[] spells)
        {
            Count = (byte)spells.Length;
            ListType = listType;
            Spells = spells;
        }

        public SSpellsS12Eng(byte listType, SpellDto spell)
        {
            Count = (byte)0xFE;
            ListType = listType;
            Spells = new SpellDto[] { spell };
        }
    }

    [WZContract(LongMessage = true)]
    public class SFriends : IGameMessage
    {
        [WZMember(0)]
        public byte MemoCount { get; set; }

        [WZMember(1)]
        public byte MailTotal { get; set; }

        [WZMember(4, SerializerType = typeof(ArrayWithScalarSerializer<byte>))]
        public FriendDto[] Friends { get; set; }

        public SFriends()
        {
            Friends = Array.Empty<FriendDto>();
            MailTotal = 50;
        }
    }

    [WZContract]
    public class SFriendReques : IGameMessage
    {
        [WZMember(0, 10)]
        public byte[] btName { get; set; }

        public string Name { get => btName.MakeString(); set => btName = value.GetBytes(); }
    }

    [WZContract]
    public class SLetter : IGameMessage
    {
        [WZMember(0)]
        public ushort Index { get; set; }

        [WZMember(1, 10)]
        public byte[] btSender { get; set; }

        [WZMember(2, 30)]
        public byte[] btDate { get; set; }

        [WZMember(3, 32)]
        public byte[] btSubject { get; set; }

        [WZMember(4)]
        public LetterStatus Status { get; set; }

        public string Sender { get => btSender.MakeString(); set => btSender = value.GetBytes(); }
        public DateTimeOffset Date { get => DateTimeOffset.Parse(btDate.MakeString()); set => btDate = value.ToString().GetBytes(); }
        public string Subject { get => btSubject.MakeString(); set => btSubject = value.GetBytes(); }
    }

    [WZContract]
    public class SKillCount : IGameMessage
    {
        [WZMember(0)]
        public byte KillCount { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SViewPortCreate : IGameMessage
    {
        [WZMember(0, SerializerType = typeof(ArrayWithScalarSerializer<byte>))]
        public VPCreateDto[] ViewPort { get; set; }

        public SViewPortCreate()
        {
            ViewPort = Array.Empty<VPCreateDto>();
        }
        public SViewPortCreate(IEnumerable<VPCreateAbs> viewPort)
        {
            ViewPort = viewPort.Select(x => (VPCreateDto)x).ToArray();
        }
    }

    [WZContract(LongMessage = true)]
    public class SViewPortCreateS9 : IGameMessage
    {
        [WZMember(0, SerializerType = typeof(ArrayWithScalarSerializer<byte>))]
        public VPCreateS9Dto[] ViewPort { get; set; }

        public SViewPortCreateS9()
        {
            ViewPort = Array.Empty<VPCreateS9Dto>();
        }
        public SViewPortCreateS9(IEnumerable<VPCreateAbs> viewPort)
        {
            ViewPort = viewPort.Select(x => (VPCreateS9Dto)x).ToArray();
        }
    }

    [WZContract(LongMessage = true)]
    public class SViewPortCreateS12 : IGameMessage
    {
        [WZMember(0, SerializerType = typeof(ArrayWithScalarSerializer<byte>))]
        public VPCreateS12Dto[] ViewPort { get; set; }

        public SViewPortCreateS12()
        {
            ViewPort = Array.Empty<VPCreateS12Dto>();
        }
        public SViewPortCreateS12(IEnumerable<VPCreateAbs> viewPort)
        {
            ViewPort = viewPort.Select(x => (VPCreateS12Dto)x).ToArray();
        }
    }
    [WZContract(LongMessage = true)]
    public class SViewPortCreateS16Kor : IGameMessage
    {
        [WZMember(0, SerializerType = typeof(ArrayWithScalarSerializer<byte>))]
        public VPCreateS16KorDto[] ViewPort { get; set; }

        public SViewPortCreateS16Kor()
        {
            ViewPort = Array.Empty<VPCreateS16KorDto>();
        }
        public SViewPortCreateS16Kor(IEnumerable<VPCreateAbs> viewPort)
        {
            ViewPort = viewPort.Select(x => (VPCreateS16KorDto)x).ToArray();
        }
    }

    [WZContract(LongMessage = true)]
    public class SViewPortChange : IGameMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))]
        public VPChangeAbs[] ViewPort { get; set; }

        public SViewPortChange()
        {
            ViewPort = Array.Empty<VPChangeDto>();
        }
    }

    [WZContract(LongMessage = true)]
    public class SViewPortChangeS9 : IGameMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))]
        public VPChangeS9Dto[] ViewPort { get; set; }

        public SViewPortChangeS9()
        {
            ViewPort = Array.Empty<VPChangeS9Dto>();
        }
    }

    [WZContract(LongMessage = true)]
    public class SViewPortChangeS12 : IGameMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))]
        public VPChangeS12Dto[] ViewPort { get; set; }

        public SViewPortChangeS12()
        {
            ViewPort = Array.Empty<VPChangeS12Dto>();
        }
    }

    [WZContract(LongMessage = true)]
    public class SViewPortMonCreateS6Kor : IGameMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))]
        public VPMCreateDto[] ViewPort { get; set; }

        public SViewPortMonCreateS6Kor()
        {
            ViewPort = Array.Empty<VPMCreateDto>();
        }
        public SViewPortMonCreateS6Kor(IEnumerable<object> vp)
        {
            ViewPort = vp.Select(x => (VPMCreateDto)x).ToArray();
        }
    }

    [WZContract(LongMessage = true)]
    public class SViewPortMonCreateS9Eng : IGameMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))]
        public VPMCreateS9Dto[] ViewPort { get; set; }

        public SViewPortMonCreateS9Eng()
        {
            ViewPort = Array.Empty<VPMCreateS9Dto>();
        }
        public SViewPortMonCreateS9Eng(IEnumerable<object> vp)
        {
            ViewPort = vp.Select(x => (VPMCreateS9Dto)x).ToArray();
        }
    }

    [WZContract(LongMessage = true)]
    public class SViewPortMonCreateS12Eng : IGameMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))]
        public VPMCreateS12Dto[] ViewPort { get; set; }

        public SViewPortMonCreateS12Eng()
        {
            ViewPort = Array.Empty<VPMCreateS12Dto>();
        }
        public SViewPortMonCreateS12Eng(IEnumerable<object> vp)
        {
            ViewPort = vp.Select(x => (VPMCreateS12Dto)x).ToArray();
        }
    }

    [WZContract(LongMessage = true)]
    public class SVPortMonCreateS16Kor : IGameMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))]
        public VPMCreateS16KorDto[] ViewPort { get; set; }

        public SVPortMonCreateS16Kor()
        {
            ViewPort = Array.Empty<VPMCreateS16KorDto>();
        }
        public SVPortMonCreateS16Kor(IEnumerable<object> vp)
        {
            ViewPort = new VPMCreateS16KorDto[vp.Count()];
            for(var n =0; n < vp.Count(); n++)
            {
                ViewPort[n] = (VPMCreateS16KorDto)vp.ElementAt(n);
            }
        }
    }

    [WZContract(LongMessage = true)]
    public class SViewPortItemCreate : IGameMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))]
        public VPICreateDto[] ViewPort { get; set; }

        public SViewPortItemCreate()
        {
            ViewPort = Array.Empty<VPICreateDto>();
        }

        public SViewPortItemCreate(VPICreateDto[] array)
        {
            ViewPort = array;
        }
    }

    [WZContract]
    public class SViewPortDestroy : IGameMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))]
        public VPDestroyDto[] ViewPort { get; set; }

        public SViewPortDestroy()
        {
            ViewPort = Array.Empty<VPDestroyDto>();
        }

        public SViewPortDestroy(VPDestroyDto[] VPDelete)
        {
            ViewPort = VPDelete;
        }
    }

    [WZContract(LongMessage = true)]
    public class SViewPortItemDestroy : IGameMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))]
        public VPDestroyDto[] ViewPort { get; set; }
    }

    [WZContract]
    public class VPPShopDto
    {
        [WZMember(0)] public ushort wzNumber { get; set; }
        [WZMember(1, 36)] public byte[] btName { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SViewPortPShop : IGameMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))] public VPPShopDto[] VPShops { get; set; }
    }

    [WZContract]
    public class SNotice : IGameMessage
    {
        [WZMember(0)]
        public NoticeType type { get; set; }//3

        [WZMember(1)]
        public byte btCount { get; set; }//4

        [WZMember(2)]
        public byte Padding { get; set; }//5

        [WZMember(3)]
        public ushort wDelay { get; set; }//6,7

        [WZMember(4)]
        public int dwColor { get; set; }//8,9,A,B

        [WZMember(5)]
        public byte btSpeed { get; set; }//C

        [WZMember(6, SerializerType = typeof(ArraySerializer))]
        public byte[] btNotice { get; set; } // D,D+(1-256)

        [WZMember(7)]
        public byte nullTerm { get; set; }//C

        public SNotice()
        {
            btNotice = Array.Empty<byte>();
        }

        public SNotice(NoticeType _type, string text)
        {
            type = _type;
            Notice = text;
        }

        public string Notice
        {
            get => btNotice.MakeString();
            set => btNotice = value.GetBytes();
        }
    }

    [WZContract]
    public class SEventState : IGameMessage
    {
        [WZMember(0)]
        public byte State { get; set; }

        [WZMember(1)]
        public MapEvents Event { get; set; }

        public SEventState()
        { }

        public SEventState(MapEvents @event, bool running)
        {
            State = (byte)(running ? 0x01 : 0x00);
            Event = @event;
        }
    }

    [WZContract]
    public class SHeatlUpdate : IGameMessage
    {
        [WZMember(0)] public RefillInfo Pos { get; set; }

        [WZMember(1)] public ushort HP { get; set; }

        [WZMember(2)] public byte Flag { get; set; }

        [WZMember(3)] public ushort SD { get; set; }

        public ushort Health { get => HP.ShufleEnding(); set => HP = value.ShufleEnding(); }

        public ushort Shield { get => SD.ShufleEnding(); set => SD = value.ShufleEnding(); }

        public SHeatlUpdate()
        { }

        public SHeatlUpdate(RefillInfo pos, ushort hp, ushort sd, bool flag)
        {
            Pos = pos;
            Health = hp;
            Shield = sd;
            Flag = 0;
        }
    }


    [WZContract]
    public class SHeatlUpdateS17 : IGameMessage
    {
        [WZMember(0)] public RefillInfo Pos { get; set; }

        [WZMember(1)] public uint HP { get; set; }

        [WZMember(2)] public byte Flag { get; set; }

        [WZMember(3)] public uint SD { get; set; }

        public uint Health { get => HP.ShufleEnding(); set => HP = value.ShufleEnding(); }

        public uint Shield { get => SD.ShufleEnding(); set => SD = value.ShufleEnding(); }

        public SHeatlUpdateS17()
        { }

        public SHeatlUpdateS17(RefillInfo pos, uint hp, uint sd, bool flag)
        {
            Pos = pos;
            HP = hp;
            SD = sd;
            Flag = 0;
        }
    }

    [WZContract]
    public class SManaUpdate : IGameMessage
    {
        [WZMember(0)] public RefillInfo Pos { get; set; }

        [WZMember(1)] public ushort MP { get; set; }

        [WZMember(2)] public ushort BP { get; set; }

        public ushort Mana { get => MP.ShufleEnding(); set => MP = value.ShufleEnding(); }

        public ushort Stamina { get => BP.ShufleEnding(); set => BP = value.ShufleEnding(); }

        public SManaUpdate()
        { }

        public SManaUpdate(RefillInfo pos, ushort mana, ushort bp/*, bool flag*/)
        {
            Pos = pos;
            Mana = mana;
            Stamina = bp;
        }
    }

    [WZContract]
    public class SSkillKey : IGameMessage
    {
        [WZMember(0, 20)]
        public byte[] SkillKey { get; set; }

        [WZMember(1)]
        public byte GameOption { get; set; }

        [WZMember(2)]
        public byte Q_Key { get; set; }

        [WZMember(3)]
        public byte W_Key { get; set; }

        [WZMember(4)]
        public byte E_Key { get; set; }

        [WZMember(5)]
        public byte ChatWindow { get; set; }

        [WZMember(6)]
        public byte R_Key { get; set; }

        public SSkillKey()
        {
            SkillKey = new byte[20];
            for (var i = 0; i < 20; i++)
                SkillKey[i] = 0xFF;
        }
    }

    [WZContract]
    public class SAction : IGameMessage
    {
        [WZMember(0)]
        public ushort Number { get; set; }   // 3,4

        [WZMember(1)]
        public byte Dir { get; set; }  // 5

        [WZMember(2)]
        public byte ActionNumber { get; set; }  // 6

        [WZMember(3)]
        public ushort Target { get; set; } // 7,8

        public SAction()
        { }

        public SAction(ushort number, byte dir, byte action, ushort target)
        {
            Number = number.ShufleEnding();
            Dir = dir;
            ActionNumber = action;
            Target = target.ShufleEnding();
        }
    }

    [WZContract]
    public class SMove : IGameMessage
    {
        [WZMember(0)]
        public ushort wzNumber { get; set; }   // 3,4

        [WZMember(1)]
        public byte X { get; set; } // 5

        [WZMember(2)]
        public byte Y { get; set; } // 6

        [WZMember(3)]
        public byte Path { get; set; }	// 7

        public SMove()
        { }

        public SMove(ushort number, byte x, byte y, byte path)
        {
            wzNumber = number.ShufleEnding();
            X = x;
            Y = y;
            Path = path;
        }
    }

    [WZContract]
    public class SPositionSet : IGameMessage
    {
        [WZMember(0)]
        public ushort wzNumber { get; set; }

        [WZMember(1)]
        public byte X { get; set; }

        [WZMember(2)]
        public byte Y { get; set; }

        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }

        public SPositionSet() { }

        public SPositionSet(ushort number, Point pos)
        {
            Number = number;
            X = (byte)pos.X;
            Y = (byte)pos.Y;
        }
    }

    [WZContract]
    public class SPositionSetS16Kor : IGameMessage
    {
        [WZMember(0)]
        public ushortle Number { get; set; }

        [WZMember(1)]
        public byte X { get; set; }

        [WZMember(2)]
        public byte Y { get; set; }

        public SPositionSetS16Kor() { }

        public SPositionSetS16Kor(ushort number, Point pos)
        {
            Number = number;
            X = (byte)pos.X;
            Y = (byte)pos.Y;
        }
    }

    [WZContract]
    public class SPositionSetS9Eng : IGameMessage
    {
        [WZMember(0)]
        public ushortle Number { get; set; }

        [WZMember(1)]
        public byte X { get; set; }

        [WZMember(2)]
        public byte Y { get; set; }

        public SPositionSetS9Eng() { }

        public SPositionSetS9Eng(ushort number, Point pos)
        {
            Number = number;
            X = (byte)pos.X;
            Y = (byte)pos.Y;
        }
    }

    [WZContract]
    public class SPointAdd : IGameMessage
    {
        [WZMember(0)]
        public byte Result { get; set; }

        [WZMember(1)]
        public byte Padding { get; set; }

        [WZMember(2)]
        public ushort MaxLifeAndMana { get; set; }

        [WZMember(3)]
        public ushort MaxShield { get; set; }

        [WZMember(4)]
        public ushort MaxStamina { get; set; }
    }

    [WZContract]
    public class SLevelUp : IGameMessage
    {
        [WZMember(0)]
        public ushort Level { get; set; }

        [WZMember(1)]
        public ushort LevelUpPoints { get; set; }

        [WZMember(2)]
        public ushort MaxLife { get; set; }

        [WZMember(3)]
        public ushort MaxMana { get; set; }

        [WZMember(4)]
        public ushort MaxShield { get; set; }

        [WZMember(5)]
        public ushort MaxBP { get; set; }

        [WZMember(6)]
        public ushort AddPoint { get; set; }

        [WZMember(7)]
        public ushort MaxAddPoint { get; set; }

        [WZMember(8)]
        public ushort MinusPoint { get; set; }

        [WZMember(9)]
        public ushort MaxMinusPoint { get; set; }
    }

    [WZContract]
    public class SClinetClose : IGameMessage
    {
        [WZMember(0)]
        public ClientCloseType Type { get; set; }
    }

    [WZContract(Serialized = true)]
    public class SMoveItem : IGameMessage
    {
        [WZMember(0)]
        public byte Result { get; set; }

        [WZMember(1)]
        public byte Position { get; set; }

        [WZMember(2, 12)]
        public byte[] ItemInfo { get; set; }
    }

    [WZContract(Serialized = true/*, ExtraEncode = typeof(WZExtraPacketEncodeS16Kor)*/)]
    public class SMoveItemS16Kor : IGameMessage
    {
        [WZMember(0)] public byte junk1 { get; set; }
        [WZMember(1)] public byte Result { get; set; }
        [WZMember(2)] public byte junk2 { get; set; }

        [WZMember(3)] public byte Position { get; set; }

        [WZMember(4, 12)]
        public byte[] ItemInfo { get; set; }
    }

    [WZContract]
    public class SEventEnterCount : IGameMessage
    {
        [WZMember(0)]
        public EventEnterType Type { get; set; }

        [WZMember(1)]
        public byte Left { get; set; }
    }

    [WZContract(Serialized = true)]
    public class SCloseMsg : IGameMessage
    {
        [WZMember(0)]
        public ClientCloseType Type { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SShopItemList : IGameMessage
    {
        [WZMember(0)]
        public byte ListType { get; set; }

        [WZMember(1, SerializerType = typeof(ArrayWithScalarSerializer<byte>))]
        public InventoryDto[] Inventory { get; set; }

        public SShopItemList()
        {
            Inventory = Array.Empty<InventoryDto>();
        }

        public SShopItemList(byte lt, IEnumerable<KeyValuePair<byte,byte[]>> inv)
        {
            ListType = lt;
            Inventory = inv.Select(x => new InventoryDto(x.Key, x.Value)).ToArray();
        }
    }

    [WZContract(LongMessage = true)]
    public class SShopItemListS17 : IGameMessage
    {
        [WZMember(0)]
        public byte ListType { get; set; }

        [WZMember(1, SerializerType = typeof(ArrayWithScalarSerializer<byte>))]
        public InventoryS17Dto[] Inventory { get; set; }

        public SShopItemListS17()
        {
            Inventory = Array.Empty<InventoryS17Dto>();
        }

        public SShopItemListS17(byte lt, IEnumerable<KeyValuePair<byte, byte[]>> inv)
        {
            ListType = lt;
            Inventory = inv.Select(x => new InventoryS17Dto(x.Key, x.Value)).ToArray();
        }
    }

    [WZContract()]
    public class SMonsterSoulShop : IGameMessage
    {
        [WZMember(0)]
        public byte Result { get; set; }
    }

    [WZContract()]
    public class SMonsterSoulAvailableShop : IGameMessage
    {
        [WZMember(0)]
        public uint Amount { get; set; }
    }

    [WZContract(Serialized = true)]
    public class STalk : IGameMessage
    {
        [WZMember(0)] public NPCWindow Result { get; set; }

        [WZMember(1)] public byte Level1 { get; set; }

        [WZMember(2)] public byte Level2 { get; set; }

        [WZMember(3)] public byte Level3 { get; set; }

        [WZMember(4)] public byte Level4 { get; set; }

        [WZMember(5)] public byte Level5 { get; set; }

        [WZMember(6)] public byte Level6 { get; set; }

        [WZMember(7)] public byte Level7 { get; set; }
    }

    [WZContract]
    public class STax : IGameMessage
    {
        [WZMember(0)]
        public TaxType Type { get; set; }

        [WZMember(1)]
        public byte Rate { get; set; }
    }

    [WZContract]
    public class SWarehouseMoney : IGameMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        /// <summary>
        /// Warehouse Money
        /// </summary>
        [WZMember(1)]
        public int wMoney { get; set; }

        /// <summary>
        /// Inventory Money
        /// </summary>
        [WZMember(2)]
        public uint iMoney { get; set; }

        public SWarehouseMoney()
        { }

        public SWarehouseMoney(bool _result, int _wMoney, uint _iMoney)
        {
            Result = (byte)(_result ? 1 : 0);
            wMoney = _wMoney;
            iMoney = _iMoney;
        }
    }

    [WZContract(Serialized = true)]
    public class SQuestWindow : IGameMessage
    {
        [WZMember(0)]
        public byte Type { get; set; }

        [WZMember(1)]
        public byte SubType { get; set; }

        [WZMember(2, 6)]
        public byte[] Unknow { get; set; }

        public SQuestWindow()
        {
            Unknow = Array.Empty<byte>();
        }
    }

    [WZContract]
    public class SCommand : IGameMessage
    {
        [WZMember(0)]
        public ServerCommandType Type { get; set; }

        [WZMember(1)]
        public byte Arg1 { get; set; }

        [WZMember(2)]
        public byte Arg2 { get; set; }

        public SCommand() { }

        public SCommand(ServerCommandType type, params byte[] args)
        {
            Type = type;
            if (args.Length > 0)
                Arg1 = args[0];
            if (args.Length > 1)
                Arg1 = args[1];
        }
    }

    [WZContract]
    public class SBuy : IGameMessage
    {
        [WZMember(0)]
        public byte Result { get; set; }

        [WZMember(1, 12)]
        public byte[] ItemInfo { get; set; }
    }

    [WZContract]
    public class SSell : IGameMessage
    {
        [WZMember(0)]
        public byte Result { get; set; }

        [WZMember(1)]
        public uint Money { get; set; }
    }

    [WZContract(Serialized = true)]
    public class SItemGet : IGameMessage
    {
        /// <summary>
        /// 0xFE: Zen
        /// </summary>
        [WZMember(0)]
        public byte Result { get; set; }

        [WZMember(1, 12)]
        public byte[] ItemInfo { get; set; }
        public SItemGet()
        {
            ItemInfo = Array.Empty<byte>();
        }

        public SItemGet(uint money, ushort itIndex)
        {
            Result = 0xFE;
            ItemInfo = BitConverter.GetBytes(money).Reverse().ToArray();
        }

        public SItemGet(byte result, byte[] info, ushort itIndex)
        {
            ItemInfo = info;
            Result = result;
        }
    }

    [WZContract(Serialized = true)]
    public class SItemGetS12Eng : IGameMessage
    {
        /// <summary>
        /// 0xFE: Zen
        /// </summary>
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1)] public ushortle ItemRes { get; set; }

        [WZMember(2, 12)] public byte[] ItemInfo { get; set; }
        public SItemGetS12Eng()
        {
            ItemRes = 0xffff;
            ItemInfo = Array.Empty<byte>();
        }

        public SItemGetS12Eng(uint money, ushort itIndex)
        {
            ItemRes = itIndex;
            Result = 0xFE;
            ItemInfo = BitConverter.GetBytes(money).Reverse().ToArray();
        }

        public SItemGetS12Eng(byte result, byte[] info, ushort itIndex)
        {
            ItemInfo = info;
            ItemRes = itIndex;
            Result = result;
        }
    }

    [WZContract(Serialized = true)]
    public class SItemGetS16Kor : IGameMessage
    {
        /// <summary>
        /// 0xFE: Zen
        /// </summary>
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1)] public byte ItemResH { get; set; }
        [WZMember(2)] public byte unk { get; set; }
        [WZMember(3)] public byte ItemResL { get; set; }
        [WZMember(4, 12)] public byte[] ItemInfo { get; set; }
        public SItemGetS16Kor()
        {
            ItemResH = 0xff;
            ItemResL = 0xff;
            ItemInfo = Array.Empty<byte>();
        }

        public SItemGetS16Kor(uint money, ushort itIndex)
        {
            ItemResH = (byte)(itIndex >> 8);
            ItemResL = (byte)(itIndex & 0xff);
            Result = 0xFE;
            ItemInfo = BitConverter.GetBytes(money).Reverse().ToArray();
        }

        public SItemGetS16Kor(byte result, byte[] info, ushort itIndex)
        {
            ItemResH = (byte)(itIndex >> 8);
            ItemResL = (byte)(itIndex & 0xff);
            ItemInfo = info;
            Result = result;
        }
    }

    [WZContract]
    public class SChatNickName : IGameMessage
    {
        [WZMember(0, 10)]
        public byte[] NickName { get; set; }

        [WZMember(1, typeof(ArraySerializer))]
        public byte[] Message { get; set; }

        [WZMember(2)]
        public byte NullTerminator { get; set; }

        public SChatNickName()
        {
            NickName = Array.Empty<byte>();
            Message = Array.Empty<byte>();
        }

        public SChatNickName(string Target, string message)
        {
            NickName = Target.GetBytes();
            Message = message.GetBytes();
        }
    }

    [WZContract]
    public class SChatTarget : IGameMessage
    {
        [WZMember(0)]
        public ushort Number { get; set; }

        [WZMember(1, typeof(ArraySerializer))]
        public byte[] Message { get; set; }

        [WZMember(2)]
        public byte NullTerminator { get; set; }

        public SChatTarget()
        {
            Message = Array.Empty<byte>();
        }

        public SChatTarget(ushort Target, string message)
        {
            Number = Target.ShufleEnding();
            Message = message.GetBytes();
        }
    }

    [WZContract(Serialized = true)]
    public class STeleport : IGameMessage
    {
        // C3:1C
        [WZMember(0)]
        public byte Unk { get; set; }

        [WZMember(1)]
        public ushort Type { get; set; }

        [WZMember(2)]
        public byte Map { get; set; } // 4

        [WZMember(3)]
        public byte MapX { get; set; }  // 5

        [WZMember(4)]
        public byte MapY { get; set; }  // 6

        [WZMember(5)]
        public byte Dir { get; set; }   // 7

        public STeleport()
        { }

        public STeleport(ushort type, Maps map, Point position, byte dir)
        {
            Type = type;
            Map = (byte)map;
            MapX = (byte)position.X;
            MapY = (byte)position.Y;
            Dir = dir;
        }
    };

    [WZContract(Serialized = true)]
    public class STeleportS12Eng : IGameMessage
    {
        // C3:1C
        [WZMember(0)]
        public byte Unk { get; set; }

        [WZMember(1)]
        public ushort Type { get; set; }

        [WZMember(2)]
        public Maps Map { get; set; } // 4

        [WZMember(3)]
        public byte MapX { get; set; }  // 5

        [WZMember(4)]
        public byte MapY { get; set; }  // 6

        [WZMember(5)]
        public byte Dir { get; set; }   // 7

        public STeleportS12Eng()
        { }

        public STeleportS12Eng(ushort type, Maps map, Point position, byte dir)
        {
            Type = type;
            Map = map;
            MapX = (byte)position.X;
            MapY = (byte)position.Y;
            Dir = dir;
        }
    };

    [WZContract]
    public class SViewSkillState : IGameMessage
    {
        [WZMember(0)]
        public byte State { get; set; }

        [WZMember(1)]
        public ushortle Number { get; set; }

        [WZMember(2)]
        public byte SkillIndex { get; set; }

        public SViewSkillState() { }

        public SViewSkillState(byte state, ushort number, byte skillIndex)
        {
            State = state;
            Number = number;
            SkillIndex = skillIndex;
        }
    }

    [WZContract]
    public class SPeriodicEffectS12Eng : IGameMessage
    {
        [WZMember(0)] public byte padding3 { get; set; }//3
        [WZMember(1)] public ushort group { get; set; }//4
        [WZMember(2)] public ushort value { get; set; }//6
        [WZMember(3)] public byte state { get; set; }//8
        [WZMember(4)] public byte padding9 { get; set; }//9
        [WZMember(5)] public ushort paddingA { get; set; }//10
        [WZMember(6)] public uint time { get; set; }//12
        [WZMember(7)] public ushort effect { get; set; } //16 Season 12 WORD, 9 BYTE
        [WZMember(8, 12)] public byte[] ItemInfo { get; set; } //18 Season 9
        [WZMember(9)] public ushort padding1E { get; set; }//30
        [WZMember(10)] public ushort wEffectValue { get; set; } //32 Season X addon
        [WZMember(11)] public ushort padding22 { get; set; }//34
    }

    [WZContract]
    public class SInventoryItemDelete : IGameMessage
    {
        [WZMember(0)] public byte IPos { get; set; }    // 3
        [WZMember(1)] public byte Flag { get; set; }    // 4

        public SInventoryItemDelete() { }
        public SInventoryItemDelete(byte pos, byte flag)
        {
            IPos = pos;
            Flag = flag;
        }
    }

    [WZContract]
    public class SInventoryItemSend : IGameMessage
    {
        [WZMember(0)]
        public byte Pos { get; set; }   // 4

        [WZMember(1, 12)]
        public byte[] ItemInfo { get; set; }	// 5
    }

    [WZContract]
    public class SInventoryItemDurSend : IGameMessage
    {
        [WZMember(0)]
        public byte IPos { get; set; }  // 3

        [WZMember(1)]
        public byte Dur { get; set; }   // 4

        [WZMember(2)]
        public byte Flag { get; set; }	// 5
    }

    [WZContract]
    public class SJewelMix : IGameMessage
    {
        [WZMember(0)] public byte Result { get; set; }    // 3

        public SJewelMix() { }

        public SJewelMix(byte result)
        {
            Result = result;
        }
    }

    [WZContract]
    public class SSetMapAttribute : IGameMessage
    {
        [WZMember(0)]
        public byte Type { get; set; }

        [WZMember(1)]
        public MapAttributes MapAtt { get; set; }

        [WZMember(2)]
        public byte MapSetType { get; set; }

        [WZMember(3, typeof(ArrayWithScalarSerializer<byte>))]
        //public byte Count { get; set; }
        public MapRectDto[] Changes { get; set; }


        public SSetMapAttribute() { Changes = Array.Empty<MapRectDto>(); }

        public SSetMapAttribute(byte type, MapAttributes att, byte setType, MapRectDto[] changes)
        {
            Type = type;
            MapAtt = att;
            MapSetType = setType;
            Changes = changes;
        }
    }

    [WZContract]
    public class MapRectDto
    {
        [WZMember(0)]
        public byte StartX { get; set; }

        [WZMember(1)]
        public byte StartY { get; set; }

        [WZMember(2)]
        public byte EndX { get; set; }

        [WZMember(3)]
        public byte EndY { get; set; }
    }

    [WZContract]
    public class SItemThrow : IGameMessage
    {
        [WZMember(0)]
        public byte Result { get; set; }

        [WZMember(1)]
        public byte Source { get; set; }
    }

    [WZContract]
    public class SChaosBoxItemMixButtonClick : IGameMessage
    {
        [WZMember(0)]
        public ChaosBoxMixResult Result { get; set; }

        [WZMember(1, 12)]
        public byte[] ItemInfo { get; set; }
    }

    [WZContract]
    public class SDamage : IGameMessage
    {
        [WZMember(0)]
        public ushort wzDamage { get; set; }

        public ushort Damage { get => wzDamage.ShufleEnding(); set => wzDamage = value.ShufleEnding(); }

        public SDamage() { }

        public SDamage(ushort dmg)
        {
            Damage = dmg;
        }
    }

    [WZContract(Serialized = true)]
    public class SKillPlayer : IGameMessage
    {
        [WZMember(0)]
        public ushort wzNumber { get; set; }

        [WZMember(1)]
        public ushort wzExp { get; set; }

        [WZMember(2)]
        public ushort wzDamage { get; set; }

        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }
        public ushort Exp { get => wzExp.ShufleEnding(); set => wzExp = value.ShufleEnding(); }
        public ushort Damage { get => wzDamage.ShufleEnding(); set => wzDamage = value.ShufleEnding(); }

        public SKillPlayer() { }

        public SKillPlayer(ushort number, ushort exp, ushort dmg)
        {
            Number = (ushort)(number | 0x80);
            Exp = exp;
            Damage = dmg;
        }
    }

    [WZContract(Serialized = true)]
    public class SKillPlayerEXT : IGameMessage
    {
        [WZMember(0)]
        public ushort wzNumber { get; set; }

        [WZMember(1)]
        public byte padding { get; set; }

        [WZMember(2)]
        public ushort ExpH { get; set; }

        [WZMember(3)]
        public ushort ExpL { get; set; }

        [WZMember(4)]
        public ushort wzDamage { get; set; }

        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }
        public int Exp { get => ExpH<<16 | ExpL; set
            {
                ExpH = (ushort)(value >> 16);
                ExpL = (ushort)(value & 0xFFFF);
            }
        }
        public ushort Damage { get => wzDamage.ShufleEnding(); set => wzDamage = value.ShufleEnding(); }

        public SKillPlayerEXT() { }

        public SKillPlayerEXT(ushort number, int exp, ushort dmg)
        {
            Number = (ushort)(number | 0x80);
            Exp = exp;
            Damage = dmg;
        }
    }

    [WZContract]
    public class SAttackResult : IGameMessage
    {
        [WZMember(0)]
        public ushort wzNumber { get; set; }

        [WZMember(1)]
        public ushort wzDamage { get; set; }

        [WZMember(2)]
        public byte DamageType { get; set; }

        [WZMember(3)]
        public ushort wzDamageShield { get; set; }

        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }
        public ushort Damage { get => wzDamage.ShufleEnding(); set => wzDamage = value.ShufleEnding(); }
        public ushort DamageShield { get => wzDamageShield.ShufleEnding(); set => wzDamageShield = value.ShufleEnding(); }

        public SAttackResult() { }

        public SAttackResult(ushort number, ushort dmg, DamageType dmgType, ushort dmgShield)
        {
            Number = number;
            Damage = dmg;
            DamageShield = dmgShield;
            DamageType = (byte)dmgType;
        }
    }

    [WZContract]
    public class SAttackResultS9Eng : IGameMessage
    {
        [WZMember(0)]
        public ushort wzNumber { get; set; }

        [WZMember(1)]
        public ushort wzDamage { get; set; }

        [WZMember(2)]
        public ushort DamageType { get; set; }

        [WZMember(3)]
        public ushort wzDamageShield { get; set; }

        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }
        public ushort Damage { get => wzDamage.ShufleEnding(); set => wzDamage = value.ShufleEnding(); }
        public ushort DamageShield { get => wzDamageShield.ShufleEnding(); set => wzDamageShield = value.ShufleEnding(); }

        public SAttackResultS9Eng() { }

        public SAttackResultS9Eng(ushort number, ushort dmg, DamageType dmgType, ushort dmgShield)
        {
            Number = number;
            Damage = dmg;
            DamageShield = dmgShield;
            DamageType = (ushort)dmgType;
        }
    }

    [WZContract]
    public class SAttackResultS12Eng : IGameMessage
    {

        [WZMember(0)]
        public ushortle Number { get; set; }

        [WZMember(1)]
        public ushortle Damage { get; set; }

        [WZMember(2)]
        public ushort DamageType { get; set; }

        [WZMember(3)]
        public ushortle DamageShield { get; set; }

        public SAttackResultS12Eng() { }

        public SAttackResultS12Eng(ushort number, ushort dmg, DamageType dmgType, ushort dmgShield)
        {
            Number = number;
            Damage = dmg;
            DamageShield = dmgShield;
            DamageType = (ushort)dmgType;
        }
    }

    [WZContract]
    public class SAttackResultS16Kor : IGameMessage
    {

        [WZMember(0)] public ushortle Number { get; set; }
        [WZMember(1, typeof(ArraySerializer))] public byte[] unk1 { get; set; } = new byte[3];
        [WZMember(2)] public int Damage { get; set; }
        [WZMember(3)] public ushortle DamageType { get; set; }
        [WZMember(4)] public ushortle DamageShield { get; set; }
        [WZMember(5)] public Element Attribute { get; set; }

        public SAttackResultS16Kor() { }

        public SAttackResultS16Kor(ushort number, ushort dmg, DamageType dmgType, ushort dmgShield)
        {
            Number = number;
            Damage = dmg;
            DamageShield = dmgShield;
            DamageType = (ushort)dmgType;
        }
    }

    [WZContract(Serialized = true)]
    public class SMagicAttack : IGameMessage
    {
        [WZMember(0)]
        public ushort wzMagicNumber { get; set; }

        [WZMember(1)]
        public ushort wzSource { get; set; }

        [WZMember(2)]
        public ushort wzTarget { get; set; }

        public SMagicAttack() { }

        public SMagicAttack(Spell magic, ushort source, ushort target)
        {
            wzMagicNumber = ((ushort)magic).ShufleEnding();
            wzSource = source.ShufleEnding();
            wzTarget = target.ShufleEnding();
        }
    }

    [WZContract(Serialized = true)]
    public class SMagicAttackS9Eng : IGameMessage
    {
        [WZMember(0)]
        public ushort wzSource { get; set; }

        [WZMember(1)]
        public ushort wzMagicNumber { get; set; }

        [WZMember(2)]
        public ushort wzTarget { get; set; }

        public SMagicAttackS9Eng() { }

        public SMagicAttackS9Eng(Spell magic, ushort source, ushort target)
        {
            wzMagicNumber = ((ushort)magic).ShufleEnding();
            wzSource = source.ShufleEnding();
            wzTarget = target.ShufleEnding();
        }
    }

    [WZContract(Serialized = true)]
    public class SMagicAttackS12Eng : SMagicAttackS9Eng, IGameMessage
    {
        public SMagicAttackS12Eng() { }
        public SMagicAttackS12Eng(Spell magic, ushort source, ushort target) : base(magic, source, target) { }
    }

    [WZContract(Serialized = true)]
    public class SMagicDuration : IGameMessage
    {
        [WZMember(0)]
        public ushort MagicNumber { get; set; }

        [WZMember(1)]
        public ushort wzNumber { get; set; }

        [WZMember(2)]
        public byte X { get; set; }

        [WZMember(3)]
        public byte Y { get; set; }

        [WZMember(4)]
        public byte Dis { get; set; }

        public SMagicDuration() { }

        public SMagicDuration(Spell magic, ushort Number, byte x, byte y, byte dis)
        {
            MagicNumber = ((ushort)magic).ShufleEnding();
            wzNumber = Number.ShufleEnding();
            X = x;
            Y = y;
            Dis = dis;
        }
    }

    [WZContract(Serialized = true)]
    public class SMagicDurationS9Eng : IGameMessage
    {
        [WZMember(0)]
        public byte X { get; set; }

        [WZMember(1)]
        public byte Y { get; set; }

        [WZMember(2)]
        public byte Dis { get; set; }

        [WZMember(3)]
        public byte MagicNumberH { get; set; }

        [WZMember(4)]
        public byte NumberH { get; set; }

        [WZMember(5)]
        public byte MagicNumberL { get; set; }

        [WZMember(6)]
        public byte NumberL { get; set; }

        public SMagicDurationS9Eng() { }

        public SMagicDurationS9Eng(Spell magic, ushort Number, byte x, byte y, byte dis)
        {
            var mag = BitConverter.GetBytes((ushort)magic);
            MagicNumberH = mag[1];
            MagicNumberL = mag[0];
            mag = BitConverter.GetBytes(Number);
            NumberH = mag[1];
            NumberL = mag[0];
            X = x;
            Y = y;
            Dis = dis;
        }
    }

    [WZContract]
    public class SChainMagic : IGameMessage
    {
        [WZMember(0)] public ushortle Magic { get; set; }
        [WZMember(1)] public ushort UserIndex { get; set; }
        [WZMember(2)] public byte Padding { get; set; }
        [WZMember(3, typeof(ArrayWithScalarSerializer<byte>))] public ushort[] Targets { get; set; }
    }

    [WZContract]
    public class SDiePlayer : IGameMessage
    {
        [WZMember(0)]
        public ushort wzNumber { get; set; }

        [WZMember(1)]
        public byte Skill { get; set; }

        [WZMember(2)]
        public ushort wzKiller { get; set; }

        public SDiePlayer() { }
        public SDiePlayer(ushort number, byte skill, ushort killer)
        {
            wzNumber = number.ShufleEnding();
            Skill = skill;
            wzKiller = killer.ShufleEnding();
        }
    }

    [WZContract]
    public class SEffect : IGameMessage
    {
        [WZMember(0)] public ushort wzNumber { get; set; }
        [WZMember(1)] public ClientEffect Effect { get; set; }

        public SEffect()
        {

        }

        public SEffect(ushort Target, ClientEffect effect)
        {
            wzNumber = Target.ShufleEnding();
            Effect = effect;
        }
    }

    [WZContract]
    public class SItemModify : IGameMessage
    {
        [WZMember(0)] public byte Padding { get; set; }

        [WZMember(1)] public int Money { get; set; }
    }

    [WZContract]
    public class SItemUseSpecialTime : IGameMessage
    {
        [WZMember(0)] public byte Number { get; set; }
        [WZMember(1)] public ushort Time { get; set; }
    }

    //0xC1 0x40
    // SAME CPartyRequest

    //0xC1 0x41
    [WZContract]
    public class SPartyResult : IGameMessage
    {
        [WZMember(0)]
        public PartyResults Result { get; set; }

        public SPartyResult() { }

        public SPartyResult(PartyResults res)
        {
            Result = res;
        }
    }

    //0xC1 0x42
    [WZContract]
    public class SPartyList : IGameMessage
    {
        [WZMember(0)]
        public PartyResults Result { get; set; }

        [WZMember(1, typeof(ArrayWithScalarSerializer<byte>))]
        public PartyDto[] PartyMembers { get; set; }

        public SPartyList()
        {
            PartyMembers = Array.Empty<PartyDto>();
        }

        public SPartyList(IEnumerable<IPartyDto> vs)
        {
            PartyMembers = vs.Select(x => (PartyDto)x).ToArray();
        }
    }

    //0xC1 0x42
    [WZContract]
    public class SPartyListS9 : IGameMessage
    {
        [WZMember(0)]
        public PartyResults Result { get; set; }

        [WZMember(1, typeof(ArrayWithScalarSerializer<byte>))]
        public PartyS9Dto[] PartyMembers { get; set; }

        public SPartyListS9()
        {
            PartyMembers = Array.Empty<PartyS9Dto>();
        }

        public SPartyListS9(IEnumerable<IPartyDto> vs)
        {
            PartyMembers = vs.Select(x => (PartyS9Dto)x).ToArray();
        }
    }
    //0xC1 0x42
    [WZContract]
    public class SPartyListS16 : IGameMessage
    {
        [WZMember(0)]
        public PartyResults Result { get; set; }

        [WZMember(1, typeof(ArrayWithScalarSerializer<byte>))]
        public PartyS16Dto[] PartyMembers { get; set; }

        public SPartyListS16()
        {
            PartyMembers = Array.Empty<PartyS16Dto>();
        }

        public SPartyListS16(IEnumerable<IPartyDto> vs)
        {
            PartyMembers = vs.Select(x => (PartyS16Dto)x).ToArray();
        }
    }

    [WZContract]
    public class SPartyDelUser : IGameMessage
    {
    }

    [WZContract]
    public class SPartyLife
    {
        [WZMember(0)] public byte Life { get; set; }
        [WZMember(1)] public byte Mana { get; set; }
        [WZMember(2, 10)] public byte[] btName { get; set; }
        [WZMember(3)] public byte Channel { get; set; }

        public string Name { get => btName.MakeString(); set => btName = value.GetBytes(); }
    }

    [WZContract]
    public class SPartyLifeAll : IGameMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))]
        public SPartyLife[] PartyLives { get; set; }

        public SPartyLifeAll()
        {
            PartyLives = Array.Empty<SPartyLife>();
        }
    }

    [WZContract]
    public class SCharRegen : IGameMessage
    {
        [WZMember(0)] public byte MapX { get; set; }
        [WZMember(1)] public byte MapY { get; set; }
        [WZMember(2)] public byte MapNumber { get; set; }
        [WZMember(3)] public byte Dir { get; set; }
        [WZMember(4)] public ushort Life { get; set; }
        [WZMember(5)] public ushort Mana { get; set; }
        [WZMember(6)] public ushort wShield { get; set; }
        [WZMember(7)] public ushort BP { get; set; }
        //[WZMember(8)] public ulong unk1 { get; set; }
        [WZMember(9)] public ulong Exp { get; set; }
        [WZMember(10)] public ulong Money { get; set; }

        public SCharRegen()
        { }
        public SCharRegen(Maps map, byte x, byte y, byte dir, ushort life, ushort mana, ushort shield, ushort bp, uint exp, ulong money)
        {
            MapNumber = (byte)map;
            MapX = x;
            MapY = y;
            Dir = dir;
            Life = life;//.ShufleEnding();
            Mana = mana;//.ShufleEnding();
            wShield = shield;//.ShufleEnding();
            BP = bp;//.ShufleEnding();
            Exp = ((ulong)exp);//.ShufleEnding();
            Money = money;//.ShufleEnding();
        }
    }

    [WZContract]
    public class SCharRegenS12Eng : IGameMessage
    {
        [WZMember(0)] public byte MapX { get; set; }
        [WZMember(1)] public byte MapY { get; set; }
        [WZMember(2)] public ushort MapNumber { get; set; }
        [WZMember(3)] public byte Dir { get; set; }
        [WZMember(4)] public ushort Life { get; set; }
        [WZMember(5)] public ushort Mana { get; set; }
        [WZMember(6)] public ushort wShield { get; set; }
        [WZMember(7)] public ushort BP { get; set; }
        //[WZMember(8)] public ulong unk1 { get; set; }
        [WZMember(9)] public ulong Exp { get; set; }
        [WZMember(10)] public ulong Money { get; set; }

        public SCharRegenS12Eng()
        { }
        public SCharRegenS12Eng(Maps map, byte x, byte y, byte dir, ushort life, ushort mana, ushort shield, ushort bp, uint exp, ulong money)
        {
            MapNumber = (ushort)map;
            MapX = x;
            MapY = y;
            Dir = dir;
            Life = life;//.ShufleEnding();
            Mana = mana;//.ShufleEnding();
            wShield = shield;//.ShufleEnding();
            BP = bp;//.ShufleEnding();
            Exp = ((ulong)exp);//.ShufleEnding();
            Money = money;//.ShufleEnding();
        }
    }

    [WZContract]
    public class SCharRegenS16Kor : IGameMessage
    {
        [WZMember(0)] public byte MapX { get; set; }
        [WZMember(1)] public byte MapY { get; set; }
        [WZMember(2)] public ushort MapNumber { get; set; }
        [WZMember(3)] public byte Dir { get; set; }
        [WZMember(4)] public byte LabyrinthId { get; set; }
        [WZMember(5)] public ushort Life { get; set; }
        [WZMember(6)] public ushort Mana { get; set; }
        [WZMember(7)] public ushort wShield { get; set; }
        [WZMember(8)] public ushort BP { get; set; }
        //[WZMember(8)] public ulong unk1 { get; set; }
        [WZMember(9)] public ulong Exp { get; set; }
        [WZMember(10)] public ushort Align { get; set; }
        [WZMember(11)] public uint Money { get; set; }

        public SCharRegenS16Kor()
        { }
        public SCharRegenS16Kor(Maps map, byte x, byte y, byte dir, ushort life, ushort mana, ushort shield, ushort bp, uint exp, ulong money)
        {
            MapNumber = (ushort)map;
            MapX = x;
            MapY = y;
            Dir = dir;
            Life = life;//.ShufleEnding();
            Mana = mana;//.ShufleEnding();
            wShield = shield;//.ShufleEnding();
            BP = bp;//.ShufleEnding();
            Exp = ((ulong)exp);//.ShufleEnding();
            Money = (uint)money;//.ShufleEnding();
        }
    }

    // 0xC1 0xAA 0x01
    [WZContract]
    public class SDuelAnsDuelInvite : IGameMessage
    {
        [WZMember(0)] public DuelResults Result { get; set; }
        [WZMember(1)] public ushort wzNumber { get; set; }
        [WZMember(2, 10)] public byte[] btName { get; set; }

        public SDuelAnsDuelInvite() { }
        public SDuelAnsDuelInvite(DuelResults result, ushort number, string name)
        {
            Result = result;
            wzNumber = number.ShufleEnding();
            btName = name.GetBytes();
        }
    }

    // 0xC1 0xAA 0x02
    [WZContract]
    public class SDuelAnswerReq : CDuelRequest
    {
        public SDuelAnswerReq() { }
        public SDuelAnswerReq(ushort number, string name)
        {
            wzNumber = number.ShufleEnding();
            btName = name.GetBytes();
        }
    }

    // 0xC1 0xAA 0x03
    [WZContract]
    public class SDuelAnsExit : SDuelAnsDuelInvite
    {
        public SDuelAnsExit() { }
        public SDuelAnsExit(DuelResults results)
        {
            Result = results;
        }
        public SDuelAnsExit(DuelResults results, ushort id, string name)
        {
            Result = results;
            wzNumber = id.ShufleEnding();
            btName = name.GetBytes();
        }
    }

    // 0xC1 0xAA 0x04
    [WZContract]
    public class SDuelBroadcastScore : IGameMessage
    {
        [WZMember(0)] public ushort wzChallenger { get; set; }
        [WZMember(1)] public ushort wzChallenged { get; set; }
        [WZMember(2)] public byte ChallengerScore { get; set; }
        [WZMember(3)] public byte ChallengedScore { get; set; }

        public SDuelBroadcastScore() { }
        public SDuelBroadcastScore(ushort challenger, ushort challenged, byte challengerScore, byte challengedScore)
        {
            wzChallenger = challenger.ShufleEnding();
            wzChallenged = challenged.ShufleEnding();
            ChallengerScore = challengerScore;
            ChallengedScore = challengedScore;
        }
    }

    // 0xC1 0xAA 0x05
    [WZContract]
    public class SDuelBroadcastHP : IGameMessage
    {
        [WZMember(0)] public ushort wzChallenger { get; set; }
        [WZMember(1)] public ushort wzChallenged { get; set; }
        [WZMember(2)] public byte ChallengerHP { get; set; }
        [WZMember(3)] public byte ChallengedHP { get; set; }
        [WZMember(4)] public byte ChallengerShield { get; set; }
        [WZMember(5)] public byte ChallengedShield { get; set; }

        public SDuelBroadcastHP() { }
        public SDuelBroadcastHP(ushort challenger, ushort challenged, byte challengerHP, byte challengedHP, byte challengerShield, byte challengedShield)
        {
            wzChallenger = challenger.ShufleEnding();
            wzChallenged = challenged.ShufleEnding();
            ChallengerHP = challengerHP;
            ChallengedHP = challengedHP;
            ChallengerShield = challengerShield;
            ChallengedShield = challengedShield;
        }
    }

    [WZContract]
    public class DuelChannel
    {
        [WZMember(0, 10)]
        public byte[] btNameA { get; set; }
        [WZMember(1, 10)]
        public byte[] btNameB { get; set; }
        [WZMember(2)]
        public byte bStart { get; set; }
        [WZMember(3, 10)]
        public byte bWatch { get; set; }

        public DuelChannel()
        {
            btNameA = Array.Empty<byte>();
            btNameB = Array.Empty<byte>();
        }

        public DuelChannel(string nameA, string nameB, bool start, bool watch)
        {
            btNameA = nameA.GetBytes();
            btNameB = nameB.GetBytes();
            bStart = (byte)(start ? 1 : 0);
            bWatch = (byte)(watch ? 1 : 0);
        }
    }

    // 0xC1 0xAA 0x06
    [WZContract]
    public class SDuelChannelList : IGameMessage
    {
        [WZMember(0, typeof(ArraySerializer))]
        public DuelChannel[] Channels { get; set; }

        public SDuelChannelList()
        {
            Channels = new DuelChannel[4];
        }
        public SDuelChannelList(DuelChannel[] channels)
        {
            if (channels.Length != 4)
                throw new Exception("Channels != 4");

            Channels = channels;
        }
    }

    // 0xC1 0xAA 0x07
    [WZContract]
    public class SDuelRoomJoin : IGameMessage
    {
        [WZMember(0)]
        public DuelResults Results { get; set; }
        [WZMember(1)]
        public byte Room { get; set; }
        [WZMember(2,10)]
        public byte[] btChallenger { get; set; }
        [WZMember(3,10)]
        public byte[] btChallenged { get; set; }
        [WZMember(4)]
        public ushort wzChallenger { get; set; }
        [WZMember(5)]
        public ushort wzChallenged { get; set; }

        public SDuelRoomJoin() { }
        public SDuelRoomJoin(DuelResults result, byte room, string challengerName, string challengedName, ushort challengerId, ushort challengedId)
        {
            Results = result;
            Room = room;
            btChallenged = challengedName.GetBytes();
            btChallenger = challengerName.GetBytes();
            wzChallenged = challengedId.ShufleEnding();
            wzChallenger = challengerId.ShufleEnding();
        }
    }

    // 0xC1 0xAA 0x08
    [WZContract]
    public class SDuelRoomBroadcastJoin : IGameMessage
    {
        [WZMember(0,10)]
        public byte[] btObserver { get; set; }

        public SDuelRoomBroadcastJoin() { }
        public SDuelRoomBroadcastJoin(string observer)
        {
            btObserver = observer.GetBytes();
        }
    }

    // 0xC1 0xAA 0x09
    [WZContract]
    public class SDuelRoomLeave : IGameMessage
    {
        [WZMember(0)]
        public DuelResults Results { get; set; }

        public SDuelRoomLeave() { }
        public SDuelRoomLeave(DuelResults result)
        {
            Results = result;
        }
    }

    // 0xC1 0xAA 0x0A
    [WZContract]
    public class SDuelRoomBroadcastLeave : IGameMessage
    {
        [WZMember(0, 10)]
        public byte[] btObserver { get; set; }

        public SDuelRoomBroadcastLeave() { }
        public SDuelRoomBroadcastLeave(string observer)
        {
            btObserver = observer.GetBytes();
        }
    }

    [WZContract]
    public class SDuelRoomObserver
    {
        [WZMember(0, 10)]
        public byte[] btObserver { get; set; }

        public SDuelRoomObserver()
        {
            btObserver = Array.Empty<byte>();
        }
    }

    // 0xC1 0xAA 0x0B
    [WZContract]
    public class SDuelRoomBroadcastObservers : IGameMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))]
        public SDuelRoomObserver[] Observers { get; set; }
        public SDuelRoomBroadcastObservers()
        {
            Array.Empty<SDuelRoomObserver>();
        }
        public SDuelRoomBroadcastObservers(string[] observer)
        {
            Observers = observer.Select(x => new SDuelRoomObserver() { btObserver = x.GetBytes() }).ToArray();
        }
    }

    // 0xC1 0xAA 0x0C
    [WZContract]
    public class SDuelBroadcastResult : IGameMessage
    {
        [WZMember(0, 10)] public byte[] btWinner { get; set; }
        [WZMember(1, 10)] public byte[] btLoser { get; set; }
        public SDuelBroadcastResult()
        { 
            btWinner = Array.Empty<byte>();
            btLoser = Array.Empty<byte>();
        }
        public SDuelBroadcastResult(string winner, string loser)
        {
            btWinner = winner.GetBytes();
            btLoser = loser.GetBytes();
        }
    }

    // 0xC1 0xAA 0x0D
    [WZContract]
    public class SDuelBroadcastRound : IGameMessage
    {
        [WZMember(0)] public byte Flag { get; set; }
    }

    [WZContract]
    public class SPShopSetItemPrice : IGameMessage
    {
        [WZMember(0)] public PShopResult Result { get; set; }
        [WZMember(1)] public byte Position { get; set; }

        public SPShopSetItemPrice()
        { }

        public SPShopSetItemPrice(PShopResult res, byte pos)
        {
            Result = res;
            Position = pos;
        }
    }

    [WZContract]
    public class SPShopRequestOpen : IGameMessage
    {
        [WZMember(0)] public PShopResult Result { get; set; }

        public SPShopRequestOpen()
        { }

        public SPShopRequestOpen(PShopResult res)
        {
            Result = res;
        }
    }

    [WZContract]
    public class SPShopRequestClose : IGameMessage
    {
        [WZMember(0)] public PShopResult Result { get; set; }

        [WZMember(1)] public ushort wzNumber { get; set; }

        public SPShopRequestClose()
        { }

        public SPShopRequestClose(PShopResult res, ushort numb)
        {
            Result = res;
            wzNumber = numb.ShufleEnding();
        }
    }


    [WZContract]
    public class PShopItem
    {
        [WZMember(0)] public byte Pos { get; set; }
        [WZMember(1, 15)] public byte[] Item { get; set; } // Padding Size 3 item byte size 12
        [WZMember(4)] public uint Price { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SPShopRequestList : IGameMessage
    {
        [WZMember(0)] public PShopResult Result { get; set; }
        [WZMember(1)] public ushort wzNumber { get; set; }
        [WZMember(2, typeof(BinaryStringSerializer), 10)] public string Name { get; set; }
        [WZMember(3, typeof(BinaryStringSerializer), 36)] public string ShopName { get; set; }
        [WZMember(4, typeof(ArrayWithScalarSerializer<byte>))] public PShopItem[] Items { get; set; }

        public SPShopRequestList()
        {
            Result = PShopResult.Disabled;
            wzNumber = 0xffff;
            Items = Array.Empty<PShopItem>();
        }
        public SPShopRequestList(PShopResult res)
        {
            Result = res;
            wzNumber = 0xffff;
            Items = Array.Empty<PShopItem>();
        }

        public SPShopRequestList(PShopResult res, ushort numb, string name, string shopName, PShopItem[] it)
        {
            Name = name;
            ShopName = shopName;
            Result = res;
            wzNumber = numb.ShufleEnding();
            Items = it;
        }
    }

    [WZContract]
    public class PShopItemS9Eng : PShopItem
    {
        [WZMember(5)] public ushort BlessValue { get; set; }
        [WZMember(7)] public ushort SoulValue { get; set; }
        [WZMember(9)] public ushort ChaosValue { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SPShopRequestListS9Eng : IGameMessage
    {
        [WZMember(0)] public PShopResult Result { get; set; }

        [WZMember(1)] public ushort wzNumber { get; set; }
        [WZMember(2, 10)] public byte[] btName { get; set; }
        [WZMember(3, 36)] public byte[] btShopName { get; set; }
        [WZMember(4, typeof(ArrayWithScalarSerializer<byte>))] public PShopItemS9Eng[] Items { get; set; }

        public SPShopRequestListS9Eng()
        {
            Result = PShopResult.Disabled;
            wzNumber = 0xffff;
            Items = Array.Empty<PShopItemS9Eng>();
        }
        public SPShopRequestListS9Eng(PShopResult res)
        {
            Result = res;
            wzNumber = 0xffff;
            Items = Array.Empty<PShopItemS9Eng>();
        }

        public SPShopRequestListS9Eng(PShopResult res, ushort numb, string name, string shopName, PShopItemS9Eng[] it)
        {
            btName = name.GetBytes();
            btShopName = shopName.GetBytes();
            Result = res;
            wzNumber = numb.ShufleEnding();
            Items = it;
        }
    }

    [WZContract]
    public class SPShopSearchDto
    {
        [WZMember(0, typeof(BinaryStringSerializer), 11)]
        public string Seller { get; set; }
        [WZMember(1, typeof(BinaryStringSerializer), 45)]
        public string Description { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SPShopSearch : IGameMessage
    {
        [WZMember(0)] public uint Number { get; set; }
        [WZMember(1)] public uint Count { get; set; }
        [WZMember(2)] public ushort Padding { get; set; }
        [WZMember(3, typeof(ArraySerializer))] public SPShopSearchDto[] List { get; set; }
    }

    [WZContract]
    public class SPShopItemSearchDto
    {
        [WZMember(0, typeof(BinaryStringSerializer), 11)]
        public string Seller { get; set; }
        [WZMember(1)] public byte Slot { get; set; }
        [WZMember(2)] public byte Bundle { get; set; }
        [WZMember(3, 12)] public byte[] ItemInfo{ get; set; }
        [WZMember(4)] public uint Zen { get; set; }
        [WZMember(5)] public uint JOBless { get; set; }
        [WZMember(6)] public uint JOSoul { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SPShopItemSearch : IGameMessage
    {
        [WZMember(0)] public uint Number { get; set; }
        [WZMember(1)] public uint Count { get; set; }
        [WZMember(2)] public byte Padding { get; set; }
        [WZMember(3)] public byte Result { get; set; }
        [WZMember(4, typeof(ArraySerializer))] public SPShopItemSearchDto[] List { get; set; }
    }

    [WZContract]
    public class SPShopItemSellListDto
    {
        /*[WZMember(0, typeof(BinaryStringSerializer), 11)]
        public string Seller { get; set; }*/
        [WZMember(1)] public byte Slot { get; set; }
        [WZMember(2)] public byte Bundle { get; set; }
        [WZMember(3, 12)] public byte[] ItemInfo { get; set; }
        [WZMember(4)] public uint Zen { get; set; }
        [WZMember(5)] public uint JOBless { get; set; }
        [WZMember(6)] public uint JOSoul { get; set; }
    }

    [WZContract(LongMessage = true, Serialized = true)]
    public class SPShopSellList : IGameMessage
    {
        //0xC2 SS SS 7C SH:5
        [WZMember(0)] public uint Number { get; set; }//5
        [WZMember(1)] public byte Result { get; set; }//9
        [WZMember(2, typeof(BinaryStringSerializer), 45)]//10
        public string Description { get; set; }
        [WZMember(3)] public byte state { get; set; }//55
        [WZMember(4, typeof(ArrayWithScalarSerializer<uint>))] //public uint Count { get; set; }
        public SPShopItemSellListDto[] List { get; set; }
    }

    [WZContract(LongMessage = true, Serialized = true)]
    public class SPShopChangeStateS16Kor : IGameMessage
    {
        [WZMember(0)] public uint Number { get; set; }
        [WZMember(1)] public byte Result { get; set; }
        [WZMember(2)] public byte State { get; set; }
    }

    [WZContract(LongMessage = true, Serialized = true)]
    public class SPShopSetItemPriceS16Kor : IGameMessage
    {
        [WZMember(0)] public byte Number { get; set; }
        [WZMember(1)] public byte Result { get; set; }
        [WZMember(2)] public byte Slot { get; set; }
        [WZMember(3)] public byte Bundle { get; set; }
        [WZMember(4,12)] public byte[] ItemInfo { get; set; }
        [WZMember(5)] public uint Zen { get; set; }
        [WZMember(6)] public uint JOBless { get; set; }
        [WZMember(7)] public uint JOSoul { get; set; }
    }

    [WZContract]
    public class SPShopRequestBuy : IGameMessage
    {
        [WZMember(0)] public PShopResult Result { get; set; }

        [WZMember(1)] public ushort wzNumber { get; set; }
        [WZMember(2, 12)] public byte[] Item { get; set; }
        [WZMember(3)] public byte ItemPos { get; set; }

        public SPShopRequestBuy()
        {
            Result = PShopResult.Disabled;
            wzNumber = 0xffff;
            Item = Array.Empty<byte>();
        }
        public SPShopRequestBuy(PShopResult res)
        {
            Result = res;
            wzNumber = 0xffff;
            Item = Array.Empty<byte>();
        }

        public SPShopRequestBuy(PShopResult res, ushort numb, byte[] it, byte itemPos)
        {
            Result = res;
            wzNumber = numb.ShufleEnding();
            Item = it;
            ItemPos = itemPos;
        }
    }

    [WZContract]
    public class SPShopRequestSold : IGameMessage
    {
        //[WZMember(0)] public PShopResult Result { get; set; }

        [WZMember(1)] public byte ItemPos { get; set; }
        [WZMember(2, 10)] public byte[] btName { get; set; }

        public SPShopRequestSold()
        {
            //Result = PShopResult.Disabled;
            ItemPos = 0xff;
            btName = Array.Empty<byte>();
        }
        public SPShopRequestSold(PShopResult res, byte itemPost, string name)
        {
            //Result = res;
            ItemPos = itemPost;
            btName = name.GetBytes();
        }
    }

    [WZContract]
    public class SPShopAlterVault : IGameMessage
    {
        [WZMember(0)] public byte type { get; set; }
    }

    [WZContract]
    public class SMasterInfo : IGameMessage
    {
        public SMasterInfo() { }
        public SMasterInfo(ushort level, long experience, long nextExperience, ushort points, ushort maxHealth, ushort maxShield, ushort maxMana, ushort maxStamina)
        {
            Level = level;
            Experience = experience.ShufleEnding();
            NextExperience = nextExperience.ShufleEnding();
            Points = points;
            MaxHealth = maxHealth;
            MaxShield = maxShield;
            MaxMana = maxMana;
            MaxBP = maxStamina;
        }

        //PBMSG_HEAD2 h;
        [WZMember(0)] public ushort Level { get; set; }

        [WZMember(1)] public long Experience { get; set; }// [8]
        [WZMember(2)] public long NextExperience { get; set; }// [8];

        [WZMember(3)] public ushort Points { get; set; }

        [WZMember(4)] public ushort MaxHealth { get; set; }
        [WZMember(5)] public ushort MaxMana { get; set; }
        [WZMember(6)] public ushort MaxShield { get; set; }
        [WZMember(7)] public ushort MaxBP { get; set; }
    }

    [WZContract]
    public class MajesticInfoDto
    {
        [WZMember(0)] public byte Section { get; set; }
        [WZMember(1)] public ushort Id { get; set; }
        [WZMember(2)] public byte Level { get; set; }
        [WZMember(3)] public float CurrentValue { get; set; }
        [WZMember(4)] public float NextValue { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SMajesticInfo : IGameMessage
    {
        [WZMember(0)] public ushort Points { get; set; }
        [WZMember(1, typeof(ArrayWithScalarSerializer<uint>))] public MajesticInfoDto[] SkillList { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SMajesticStatsInfo : IGameMessage
    {
        [WZMember(1, typeof(ArrayWithScalarSerializer<uint>))] public MajesticInfoDto[] SkillList { get; set; }
    }

    [WZContract]
    public class SMasterLevelUp : IGameMessage
    {
        public SMasterLevelUp() { }
        public SMasterLevelUp(ushort level, ushort pointLevelAdd, ushort points, ushort maxPoints, ushort maxHealth, ushort maxShield, ushort maxMana, ushort maxStamina)
        {
            Level = level;
            PointLevelAdd = pointLevelAdd;
            Points = points;
            MaxPoints = maxPoints;
            MaxHealth = maxHealth;
            MaxShield = maxShield;
            MaxMana = maxMana;
            MaxStamina = maxStamina;
        }

        //PBMSG_HEAD2 h;
        [WZMember(0)] public ushort Level { get; set; }
        [WZMember(1)] public ushort PointLevelAdd { get; set; }
        [WZMember(2)] public ushort Points { get; set; }
        [WZMember(3)] public ushort MaxPoints { get; set; }
        [WZMember(4)] public ushort MaxHealth { get; set; }
        [WZMember(5)] public ushort MaxMana { get; set; }
        [WZMember(6)] public ushort MaxShield { get; set; }
        [WZMember(7)] public ushort MaxStamina { get; set; }
    }

    [WZContract]
    public class SMasterLevelSkillS9ENG : IGameMessage
    {
        [WZMember(0)] public byte Result { get; set; }//4
        [WZMember(1)] public byte padding { get; set; }//5
        [WZMember(2)] public ushort MasterLevelPoint { get; set; }//6,7
        [WZMember(3)] public byte MasterSkillUIIndex { get; set; }//8
        [WZMember(4)] public byte padding2 { get; set; }//9
        [WZMember(5)] public ushort padding3 { get; set; }//A,B
        [WZMember(6)] public int dwMasterSkillIndex { get; set; }     // C
        [WZMember(7)] public int dwMasterSkillLevel { get; set; }         // 10
        [WZMember(8)] public float fMasterSkillCurValue { get; set; }         // 14
        [WZMember(9)] public float fMasterSkillNextValue { get; set; }		// 18
    }

    [WZContract(LongMessage = true)]
    public class SMasterLevelSkillListS9ENG : IGameMessage
    {
        [WZMember(0)] public byte Padding1 { get; set; }//5
        [WZMember(1)] public ushort Padding2 { get; set; }//6,7
        [WZMember(2, typeof(ArrayWithScalarSerializer<int>))] public MasterSkillInfoDto[] Skills { get; set; }//8
    }

    [WZContract]
    public class MasterSkillInfoDto
    {
        [WZMember(0)] public byte MasterSkillUIIndex { get; set; }//0
        [WZMember(1)] public byte MasterSkillLevel { get; set; }//1
        [WZMember(2)] public ushort fill { get; set; }//2,3
        [WZMember(3)] public float MasterSkillCurValue { get; set; }//4
        [WZMember(4)] public float MasterSkillNextValue { get; set; }//8
        [WZMember(5)] public int btUnk { get; set; }//12
    }

    [WZContract(Serialized = true)]
    public class STradeRequest : IGameMessage
    {
        [WZMember(0, 10)]
        public byte[] szId { get; set; }

        public string Id { get => szId.MakeString(); set => szId = value.GetBytes(); }
    }

    [WZContract]
    public class STradeMoney: IGameMessage
    {
        [WZMember(0)]
        public byte Result { get; set; }
    }

    [WZContract]
    public class STradeOtherMoney : IGameMessage
    {
        [WZMember(0)]
        public uint Money { get; set; }
    }

    [WZContract]
    public class STradeResult : IGameMessage
    {
        [WZMember(0)]
        public TradeResult Result { get; set; }
    }

    [WZContract]
    public class STradeOtherAdd : IGameMessage
    {
        [WZMember(0)]
        public byte Position { get; set; }

        [WZMember(1, 12)]
        public byte[] ItemInfo { get; set; }
    }

    [WZContract]
    public class STradeResponce : IGameMessage
    {
        [WZMember(0)]
        public byte Result { get; set; }

        [WZMember(1, 10)]
        public byte[] szId { get; set; }

        [WZMember(2)]
        public ushort Level { get; set; }

        [WZMember(3)]
        public int GuildNumber { get; set; }
    }

    [WZContract]
    public class SFriendAddReq : IGameMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1, 10)] public byte[] btName { get; set; } // 4
        [WZMember(2)] public byte State { get; set; } // E

        public string Name { get => btName.MakeString(); set => btName = value.GetBytes(); }
    }

    [WZContract]
    public class SFriendAddSin : IGameMessage
    {
        [WZMember(0, 10)] public byte[] btName { get; set; } // 4

        public string Name { get => btName.MakeString(); set => btName = value.GetBytes(); }
    }

    [WZContract]
    public class SMiniMapNPC : IGameMessage
    {
        [WZMember(0)] public byte btIdentNo { get; set; }
        [WZMember(1)] public byte btIsNpc { get; set; }
        [WZMember(2)] public MiniMapTag btTag { get; set; }
        [WZMember(3)] public byte btType { get; set; }
        [WZMember(4)] public byte btPosX { get; set; }
        [WZMember(5)] public byte btPosY { get; set; }
        [WZMember(6, typeof(BinaryStringSerializer), 31)] public string szName { get; set; }

        public SMiniMapNPC()
        {
            szName = "";
        }

        public SMiniMapNPC(Point Position, byte ident, MiniMapTag tag, byte addType, string Name)
        {
            btPosX = (byte)Position.X;
            btPosY = (byte)Position.Y;
            btTag = tag;
            btType = addType;
            btIdentNo = ident;
            szName = Name;
            btIsNpc = 1;
        }

        public SMiniMapNPC(Rectangle Door, byte ident, MiniMapTag tag, byte addType, Maps map)
        {
            btPosX = (byte)Door.X;
            btPosY = (byte)Door.Y;
            btTag = tag;
            btType = addType;
            btIdentNo = ident;
            szName = "To " + map;
            btIsNpc = 0;
        }
    }

    [WZContract]
    public class SPeriodItemCount : IGameMessage
    {
        [WZMember(0)] public byte Count { get; set; }
    }

    [WZContract]
    public class SLifeInfo : IGameMessage
    {
        [WZMember(0)] public ushort wzNumber { get; set; }
        [WZMember(1)] public uint wzMaxLife { get; set; }
        [WZMember(2)] public uint wzLife { get; set; }
        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }
        public uint MaxLife { get => wzMaxLife.ShufleEnding(); set => wzMaxLife = value.ShufleEnding(); }
        public uint Life { get => wzLife.ShufleEnding(); set => wzLife = value.ShufleEnding(); }
    }

    [WZContract]
    public class SMuHelperState : IGameMessage
    {
        [WZMember(0)]
        public byte Time { get; set; }
        [WZMember(1)]
        public byte TimeMultipler { get; set; }
        [WZMember(2)]
        public ushort padding { get; set; }
        [WZMember(3)]
        public uint Money { get; set; }
        [WZMember(4)]
        public byte Status { get; set; }

        public ushort usTime { 
            get => (ushort)(TimeMultipler * 0xff + Time); 
            set
            {
                Time = (byte)(value % 0xff);
                TimeMultipler = (byte)(value / 0xff);
            }                
         }
    }

    [WZContract]
    public class SAttackSpeed : IGameMessage
    {
        [WZMember(0)]
        public uint AttackSpeed { get; set; }
        [WZMember(1)]
        public uint MagicSpeed { get; set; }
    }

    [WZContract(Serialized = true)]
    public class SNPCDialog : IGameMessage
    {
        [WZMember(0)] public ushort NPC { get; set; } //4
        [WZMember(1)] public ushort Alingment { get; set; }// 6
        [WZMember(2)] public uint Contribution { get; set; } // 8
    }

    [WZContract]
    public class SGremoryCaseOpen : IGameMessage
    {
        [WZMember(0)] public byte Result { get; set; }
    }

    [WZContract]
    public class SGremoryCaseOpenS16 : IGameMessage
    {
        [WZMember(0)] public byte Result { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SGremoryCaseList : IGameMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))]
        public GCItemDto[] List { get; set; }
    }

    [WZContract]
    public class SGremoryCaseReceiveItem : IGameMessage
    {
        [WZMember(0)]
        public GCItemDto Item { get; set; }
    }

    [WZContract]
    public class SGremoryCaseNotice : IGameMessage
    {
        [WZMember(0)]
        public GremoryNotice Status { get; set; }
    }

    [WZContract]
    public class SGremoryCaseDelete : IGameMessage
    {
        [WZMember(0)] public GremoryStorage StorageType { get; set; }
        [WZMember(1)] public ushort ItemNumber { get; set; }
        [WZMember(2)] public uint AuthCode { get; set; }
        [WZMember(3)] public uint ItemGUID { get; set; }
    }

    [WZContract]
    public class SGremoryCaseDeleteS16 : IGameMessage
    {
        [WZMember(0)] public GremoryStorage StorageType { get; set; }
        [WZMember(1)] public byte Unk { get; set; }
        [WZMember(2)] public ushort ItemNumber { get; set; }
        [WZMember(3)] public uint AuthCode { get; set; }
        [WZMember(4)] public uint ItemGUID { get; set; }
        [WZMember(5)] public uint Slot { get; set; }
    }

    [WZContract]
    public class GCItemDto
    {
        [WZMember(0)] public GremoryStorage RewardInventory { get; set; }
        [WZMember(1)] public GremorySource RewardSource { get; set; }
        [WZMember(2)] public ushort Padding { get; set; }
        [WZMember(3)] public uint ItemGUID { get; set; }
        [WZMember(4, 12)] public byte[] ItemInfo { get; set; }
        [WZMember(5)] public uint AuthCode { get; set; }
        [WZMember(6)] public uint ExpireTime { get; set; }
        [WZMember(7)] public uint Unk { get; set; }
        [WZMember(8)] public uint Unk1 { get; set; }
        [WZMember(9)] public uint Unk2 { get; set; }
        [WZMember(10)] public uint Unk3 { get; set; }
    }

    [WZContract]
    public class SGremoryCaseUseItem : IGameMessage
    {
        public enum GCResult : byte {
            Success,
            Error,
            Error2,
            DatabaseError,
            NotEnoughtSpace,
            ClosingGremoryCaseError,
        }
        [WZMember(0)] public GCResult Result { get; set; }
        [WZMember(1)] public GremoryStorage Inventory { get; set; }
        [WZMember(2)] public ushort Item { get; set; }
        [WZMember(3)] public uint Unk { get; set; }
        [WZMember(4)] public uint Serial { get; set; }
        [WZMember(5)] public uint Slot { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SPShopSearchItem : IGameMessage
    {
        [WZMember(0)] public int iPShopCnt { get; set; }
        [WZMember(1)] public byte btContinueFlag { get; set; }
        [WZMember(2, typeof(ArraySerializer))] public SPShopSearchItemDto[] List { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SPShopSearchItemS16Kor : IGameMessage
    {
        [WZMember(0)] public int iPShopCnt { get; set; }
        [WZMember(1)] public byte btContinueFlag { get; set; }
        [WZMember(2, typeof(ArraySerializer))] public SPShopSearchItemDto[] List { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SPShopCancelItemSaleS16Kor : IGameMessage
    {
        [WZMember(0)] public uint Data { get; set; }
        [WZMember(1)] public byte Result { get; set; }
        [WZMember(2)] public byte Slot { get; set; }
    }

    [WZContract]
    public class SPShopSearchItemDto
    {
        [WZMember(0)] public ushort wzNumber { get; set; }
        [WZMember(1, typeof(BinaryStringSerializer), 11)] public string szName { get; set; } //11
        [WZMember(2, typeof(BinaryStringSerializer), 37)] public string szPShopText { get; set; } //[37];

        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }
    }

    [WZContract]
    public class GRefineJewel : IGameMessage
    {

    }

    [WZContract]
    public class PentagramJewelDto
    {
        [WZMember(1)] public byte JewelPos { get; set; }
        [WZMember(2)] public byte JewelIndex { get; set; }
        [WZMember(3)] public byte MainAttribute { get; set; }
        [WZMember(4)] public byte ItemType { get; set; }
        [WZMember(5)] public ushort ItemIndex { get; set; }
        [WZMember(6)] public byte Level { get; set; }
        [WZMember(7)] public byte Rank1OptionNum { get; set; }
        [WZMember(8)] public byte Rank1Level { get; set; }
        [WZMember(9)] public byte Rank2OptionNum { get; set; }
        [WZMember(10)] public byte Rank2Level { get; set; }
        [WZMember(11)] public byte Rank3OptionNum { get; set; }
        [WZMember(12)] public byte Rank3Level { get; set; }
        [WZMember(13)] public byte Rank4OptionNum { get; set; }
        [WZMember(14)] public byte Rank4Level { get; set; }
        [WZMember(15)] public byte Rank5OptionNum { get; set; }
        [WZMember(16)] public byte Rank5Level { get; set; }
    }

    [WZContract]
    public class SPentagramJewelIn : IGameMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1)] public PentagramJewelDto Info { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SPentagramJewelInfo : IGameMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1)] public byte JewelCnt { get; set; }
        [WZMember(2)] public byte JewelPos { get; set; }
        [WZMember(3, typeof(ArraySerializer))] public PentagramJewelDto[] JewelsDto { get; set; }

        public SPentagramJewelInfo() { }
        public SPentagramJewelInfo(byte jPos, PentagramJewelDto[] array)
        {
            var subArray = array.Where(x => x.JewelPos == jPos).ToArray();
            JewelsDto = subArray;
            Result = (byte)(subArray.Length > 0 ? 1 : 0);
            JewelCnt = (byte)subArray.Length;
            JewelPos = jPos;
        }
    }

    [WZContract]
    public class SPentagramJewelInOut : IGameMessage
    {
        [WZMember(0)] public byte Result { get; set; }
    }

    [WZContract]
    public class SElementalDamage : IGameMessage
    {
        [WZMember(0)] public ushort wzNumber { get; set; }
        [WZMember(1)] public Element Element { get; set; }
        [WZMember(2)] public ushort wzTarget { get; set; }
        [WZMember(3)] public uint Damage { get; set; }

        public ushort Number { set => wzNumber = value.ShufleEnding(); get => wzNumber.ShufleEnding(); }
        public ushort Target { set => wzTarget = value.ShufleEnding(); get => wzTarget.ShufleEnding(); }
    }

    [WZContract]
    public class SNeedSpiritMap : IGameMessage
    { }

    [WZContract]
    public class SPetInfo : IGameMessage
    {
        [WZMember(0)] public byte PetType { get; set; }   // 3
        [WZMember(1)] public byte InvenType { get; set; } // 4
        [WZMember(2)] public byte nPos { get; set; }  // 5
        [WZMember(3)] public byte Level { get; set; } // 6
        [WZMember(4)] public byte padding { get; set; } // 6
        [WZMember(5)] public int Exp { get; set; }    // 8
        [WZMember(6)] public byte Dur { get; set; }
    }

    [WZContract]
    public class SPetAttack:IGameMessage
    {
        [WZMember(0)] public byte PetType { get; set; }   //	3
        [WZMember(1)] public byte SkillType { get; set; } // 4
        [WZMember(2)] public ushort wzNumber { get; set; } // 5
        [WZMember(3)] public ushort wzTargetNumber { get; set; } // 7
        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }   // 5
        public ushort TargetNumber { get => wzTargetNumber.ShufleEnding(); set => wzTargetNumber = value.ShufleEnding(); }   // 5
    }

    [WZContract]
    public class SExpEventInfo : IGameMessage
    {
        [WZMember(0)] public ushort PCBangRate { get; set; }
        [WZMember(1)] public ushort EventExp { get; set; }
        [WZMember(2)] public ushort GoldChannel { get; set; }
    }

    [WZContract]
    public class SEquipamentChange : IGameMessage
    {
        [WZMember(0)] public ushort wzNumber { get; set; }   // 3
        [WZMember(1, 12)] public byte[] ItemInfo{ get; set; }   // 5
        [WZMember(2)] public Element Element { get; set; }
    }

    [WZContract]
    public class SXUpPront : IGameMessage
    {
        [WZMember(0)] public ushort Str{ get; set; }
        [WZMember(1)] public ushort AddStr{ get; set; }
        [WZMember(2)] public ushort Dex{ get; set; }
        [WZMember(3)] public ushort AddDex{ get; set; }
        [WZMember(4)] public ushort Vit{ get; set; }
        [WZMember(5)] public ushort AddVit{ get; set; }
        [WZMember(6)] public ushort Ene{ get; set; }
        [WZMember(7)] public ushort AddEne{ get; set; }
        [WZMember(8)] public ushort Leadership{ get; set; }
        [WZMember(9)] public ushort AddLeadership{ get; set; }
        [WZMember(10)] public float mPrec { get; set; }
    }

    [WZContract]
    public class SXElementalData : IGameMessage
    {
        [WZMember(0)] public int PVMDamageMin{ get; set; }
        [WZMember(1)] public int PVMDamageMax { get; set; }
        [WZMember(2)] public int PVPDamageMin{ get; set; }
        [WZMember(3)] public int PVPDamageMax { get; set; }
        [WZMember(4)] public int PVMAttackSuccessRate{ get; set; }
        [WZMember(5)] public int PVPAttackSuccessRate { get; set; }
        [WZMember(6)] public int PVMDefense{ get; set; }
        [WZMember(7)] public int PVPDefense{ get; set; }
        [WZMember(8)] public int PVMDefenseSuccessRate{ get; set; }
        [WZMember(9)] public int PVPDefenseSuccessRate { get; set; }
        [WZMember(10)] public int Unk1{ get; set; }
        [WZMember(11)] public int Unk2 { get; set; }
        [WZMember(12)] public int Unk3 { get; set; }
        [WZMember(13)] public int Unk4 { get; set; }
        [WZMember(14)] public int Unk5 { get; set; }
        [WZMember(15)] public int Unk6 { get; set; }
        [WZMember(16)] public int Unk7 { get; set; }
        [WZMember(17)] public int Unk8 { get; set; }
        [WZMember(18)] public int CriticalDamageRate{ get; set; }
        [WZMember(19)] public int PVMIncreaseDamage{ get; set; }
        [WZMember(20)] public int PVPIncreaseDamage { get; set; }
        [WZMember(21)] public int PVMAbsorbDamage{ get; set; }
        [WZMember(22)] public int PVPAbsorbDamage { get; set; }
        [WZMember(23)] public int AbsorbShield{ get; set; }
        [WZMember(24)] public int AbsorbHP{ get; set; }
        [WZMember(25)] public int BleedingDamage{ get; set; }
        [WZMember(26)] public int Paralyzing{ get; set; }
        [WZMember(27)] public int Bind{ get; set; }
        [WZMember(28)] public int Punish{ get; set; }
        [WZMember(29)] public int Blind{ get; set; }
        [WZMember(30)] public int Res_to_str_elem{ get; set; }
        [WZMember(31)] public int Res_to_elem_dmg{ get; set; }
        [WZMember(32)] public int AddAttackDamage{ get; set; }
        [WZMember(33)] public int AddDefense{ get; set; }
    }

    [WZContract]
    public class SXCharacterInfo : IGameMessage
    {
        //0-3
        /*237*/
        /// <summary>
        /// CriticalDamage Is %
        /// </summary>
        [WZMember(0)] public ushort CriticalDamage{ get; set; }//ÐÒÔËÒ»»÷Ôö¼ÓÉËº¦
        /*239*/
        /// <summary>
        /// ExcellentDamage Is +DMG
        /// </summary>
        [WZMember(1)] public ushort ExcellentDamage{ get; set; }//×¿Ô½Ò»»÷Ôö¼ÓÉËº¦
        /*241*/
        [WZMember(2)] public ushort SkillDamageBonus{ get; set; }//¼¼ÄÜ¹¥»÷Á¦Ôö¼Ó
        /*243*/
        [WZMember(3)] public ushort Defense{ get; set; }//»ù±¾·ÀÓùÁ¦
        /*245*/
        [WZMember(4)] public ushort Str{ get; set; }//Á¦Á¿    //12
        /*247*/
        [WZMember(5)] public ushort AddStr{ get; set; }//¸½¼ÓÁ¦Á¿
        /*249*/
        [WZMember(6)] public ushort Dex{ get; set; }//Ãô½Ý  //16
        /*251*/
        [WZMember(7)] public ushort AddDex{ get; set; }//¸½¼ÓÃô½Ý
        /*253*/
        [WZMember(8)] public ushort Vit{ get; set; }//ÌåÁ¦	 //20
        /*255*/
        [WZMember(9)] public ushort AddVit{ get; set; }//¸½¼ÓÌåÁ¦
        /*257*/
        [WZMember(10)] public ushort Energy{ get; set; }//ÖÇÁ¦  //24
        /*259*/
        [WZMember(11)] public ushort AddEnergy{ get; set; }//¸½¼ÓÖÇÁ¦
        /*261*/
        [WZMember(12)] public ushort Leadership{ get; set; }//Í³ÂÊ   //28
        /*263*/
        [WZMember(13)] public ushort AddLeadership{ get; set; }
        /*265*/
        [WZMember(14)] public ushort SDAttack{ get; set; }//Ï®»÷Ê±SD±ÈÂÊ%
        /*267*/
        [WZMember(15)] public ushort IgnoreShieldGaugeRate{ get; set; }//SDÎÞÊÓ¼¸ÂÊ%
        /*269*/
        [WZMember(16)] public ushort SDAttack1{ get; set; }//¹¥»÷Ê±SD±ÈÂÊ%
        /*271*/
        [WZMember(17)] public ushort MoneyAmountDropRate{ get; set; }//»ñµÃ½ð±ÒÔö¼ÓÂÊ%
        /*273*/
        [WZMember(18)] public float IgnoreDefenseRate{ get; set; }//ÎÞÊÓ·ÀÓùÁ¦¼¸ÂÊ%
        /*277*/
        [WZMember(19)] public float HPRecovery{ get; set; } //ÉúÃü×Ô¶¯»Ö¸´Á¿
        /*281*/
        [WZMember(20)] public float MPRecovery{ get; set; }//Ä§·¨»Ö¸´Á¿
        /*285*/
        [WZMember(21)] public float StunRate{ get; set; }//Êø¸¿¼¸ÂÊ
        /*289*/
        [WZMember(22)] public float ResistStunRate{ get; set; }//Êø¸¿µÖ¿¹¼¸ÂÊ%
        /*293*/
        [WZMember(23)] public float fTripleDamageRationInfo{ get; set; }
        /*297*/
        [WZMember(24)] public float ShieldDamageReduction{ get; set; }//¶ÜÅÆÎüÊÕÉËº¦
        /*301*/
        [WZMember(25)] public float fMonsterDieGetHP_info{ get; set; }//¹ÖÎïËÀÍöÉúÃü»Ö¸´Á¿
        /*305*/
        [WZMember(26)] public float fMonsterDieGetMana_info{ get; set; }//¹ÖÎïËÀÍöÄ§·¨»Ö¸´Á¿
        /*309*/
        [WZMember(27)] public float fMonsterDieGetSD_info{ get; set; }//¹ÖÎïËÀÍöSD»Ö¸´Á¿
        /*313*/
        [WZMember(28)] public float SDRecovery{ get; set; }//SD×Ô¶¯»Ö¸´Á¿
        /*317*/
        [WZMember(29)] public float DefensiveFullMPRestoreRate{ get; set; }//Ä§·¨ÖµÍêÈ«»Ö¸´¼¸ÂÊ
        /*321*/
        [WZMember(30)] public float DefensiveFullHPRestoreRate{ get; set; }//ÉúÃüÍêÈ«»Ö¸´¼¸ÂÊ
        /*325*/
        [WZMember(31)] public float OffensiveFullSDRestoreRate{ get; set; }//SDÍêÈ«»Ö¸´¼¸ÂÊ
        /*329*/
        [WZMember(32)] public float BPRecovery{ get; set; }//AG×Ô¶¯»Ö¸´Á¿
        /*333*/
        [WZMember(33)] public float fWingDamageAbsorb_info{ get; set; }//ÉËº¦ÎüÊÕÂÊ
        /*337*/
        [WZMember(34)] public float BlockRate{ get; set; }//¶Ü·ÀÓù¼¸ÂÊ
        /*341*/
        [WZMember(35)] public float ParryRate{ get; set; }//ÎäÆ÷¸ñµµ¼¸ÂÊ
        /*345*/
        [WZMember(36)] public float AbsorbLife{ get; set; }//ÉúÃüÁ¦ÎüÊÕÁ¿
        /*349*/
        [WZMember(37)] public float AbsorbSD{ get; set; }//SDÎüÊÕÁ¿
        /*353*/
        [WZMember(38)] public float FullDamageReflectRate{ get; set; }//·´µ¯¹¥»÷¼¸ÂÊ
        /*357*/
        [WZMember(39)] public float fWingDamageIncRate_info{ get; set; }//ÉËº¦Ìá¸ßÂÊ
        /*361*/
        [WZMember(40)] public float MPConsumptionRate{ get; set; }//Ä§·¨Ê¹ÓÃ¼õÉÙÂÊ
        /*365*/
        [WZMember(41)] public float CriticalDamageRate{ get; set; }//ÐÒÔËÒ»»÷ÉËº¦¼¸ÂÊ
        /*369*/
        [WZMember(42)] public float ExcellentDamageRate{ get; set; }//×¿Ô½Ò»»÷ÉËº¦¼¸ÂÊ
        /*373*/
        [WZMember(43)] public float DoubleDamageRate{ get; set; }//Ë«±¶ÉËº¦¼¸ÂÊ
        /*377*/
        [WZMember(44)] public float TripleDamageRate { get; set; }
        /*381*/
        [WZMember(45)] public byte DamageReduction{ get; set; }//ÉËº¦¼õÉÙÂÊ
        /*382*/
        [WZMember(46)] public byte BPConsumptionRate{ get; set; }//AGÊ¹ÓÃ¼õÉÙÂÊ
        /*383*/
        [WZMember(47)] public byte DamageReflect{ get; set; }//ÉËº¦·´ÉäÂÊ
        /*384*/	
        [WZMember(48)] public byte AGUsageRate { get; set; }
        /*384*/
        [WZMember(49)] public byte unk37 { get; set; }
        /*384*/
        [WZMember(50)] public byte unk38 { get; set; }
        /*384*/
        [WZMember(51)] public byte unk39 { get; set; }
        /*384*/
        [WZMember(52)] public byte unk3a { get; set; }
    }
    [WZContract]
    public class SNQWorldLoad : IGameMessage
    { }

    [WZContract]
    public class SNQWorldListDto
    {
        [WZMember(0)] public ushort QuestIndex { get; set; }
        [WZMember(1)] public byte TagetNumber { get; set; }
        [WZMember(2)] public byte QuestState { get; set; }
    }

    [WZContract]
    public class SNQWorldList : IGameMessage
    {        
        [WZMember(0)] public SNQWorldListDto Quest { get; set; }
    }

    [WZContract]
    public class SPKLevel : IGameMessage
    {
        [WZMember(0)] public ushortle Index { get; set; }
        [WZMember(1)] public PKLevel PKLevel { get; set; }
    }
    [WZContract]
    public class SMonsterSkillS9Eng : IGameMessage
    {
        [WZMember(0)] public ushort MonsterSkillNumber { get; set; }  // 3
        [WZMember(1)] public ushort ObjIndex { get; set; } // 4
        [WZMember(2)] public ushort TargetObjIndex { get; set; }	// 6
    }
    [WZContract]
    public class SEventNotificationS16Kor : IGameMessage
    {
        [WZMember(0)] public EventIcon EventID { get; set; }  // 3
        [WZMember(1)] public byte Active { get; set; } // 4
    }

    [WZContract]
    public class SOpenBox : IGameMessage
    {
        [WZMember(0)] public OBResult Result { get; set; }  // 3
        [WZMember(1)] public int Slot { get; set; } // 4
    }

    [WZContract]
    public class SItemSplit : IGameMessage
    {
        [WZMember(0)] public byte Id { get; set; }
        [WZMember(1)] public byte Result { get; set; }
    }

    [WZContract]
    public class SPartyMRegister : IGameMessage
    {
        [WZMember(0)] public int Result { get; set; }
    }

    [WZContract]
    public class PartyMSearchMemberDto
    {
        [WZMember(0, typeof(BinaryStringSerializer), 11)] public string Name { get; set; } //0
        [WZMember(1)] public ushort Level { get; set; } //0
        [WZMember(2)] public ushort Race { get; set; } //0
    }

    [WZContract]
    public class PartyMSearchDto
    {
        [WZMember(0, typeof(BinaryStringSerializer), 41)] public string Text { get; set; } //0
        [WZMember(1)] public byte Gens { get; set; } //0
        [WZMember(2)] public bool Password { get; set; } //0
        [WZMember(3)] public byte Count { get; set; } //0
        [WZMember(4)] public ushort MinLevel { get; set; } //0
        [WZMember(5)] public ushort MaxLevel { get; set; } //0
        [WZMember(6, typeof(ArraySerializer))] public PartyMSearchMemberDto[] Members { get; set; } //0
    }

    [WZContract(LongMessage = true)]
    public class SPartyMSearch : IGameMessage
    {
        [WZMember(0)] public uint Count { get; set; }
        [WZMember(1)] public uint Page { get; set; }
        [WZMember(2)] public uint MaxPage { get; set; }
        [WZMember(3)] public int Result { get; set; }
        [WZMember(4, typeof(ArraySerializer))] public PartyMSearchDto[] List { get; set; }
    }
    [WZContract]
    public class SPartyMJoin : IGameMessage
    {
        [WZMember(0)] public int Result { get; set; }
        [WZMember(1)] public bool UsePassword { get; set; }
        [WZMember(2)] public byte Gens { get; set; }
        [WZMember(3, typeof(BinaryStringSerializer), 11)] public string Name{ get; set; }
        [WZMember(4, typeof(BinaryStringSerializer), 41)] public string Text{ get; set; }
    }
    [WZContract]
    public class SPartyMJoinNotify : IGameMessage
    { }

    [WZContract]
    public class PartyMJoinListDto : IGameMessage
    {
        [WZMember(0, typeof(BinaryStringSerializer), 11)] public string Name { get; set; }
        [WZMember(1)] public byte Race { get; set; }
        [WZMember(2)] public int Level { get; set; }
        [WZMember(3)] public int Data { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SPartyMJoinList : IGameMessage
    {
        [WZMember(0)] public byte unk5 { get; set; }
        [WZMember(1)] public ushort unk6 { get; set; }
        [WZMember(2)] public int Count { get; set; }
        [WZMember(3)] public int Result { get; set; }
        [WZMember(4, typeof(ArraySerializer))] public PartyMJoinListDto[] List { get; set; }
    }

    [WZContract]
    public class SPartyMCancel : IGameMessage
    {
        [WZMember(1)] public int Type { get; set; }
        [WZMember(2)] public int Result { get; set; }
    }

    [WZContract]
    public class SHuntingRecordDay : IGameMessage
    {
        [WZMember(1)] public byte Id { get; set; }
        [WZMember(2)] public int Year { get; set; }
        [WZMember(3)] public byte Month { get; set; }
        [WZMember(4)] public byte Day { get; set; }
        [WZMember(5)] public int Level { get; set; }
        [WZMember(6)] public int Duration { get; set; }
        [WZMember(7)] public long Damage { get; set; }
        [WZMember(8)] public long ElementalDamage { get; set; }
        [WZMember(9)] public int Healing { get; set; }
        [WZMember(10)] public int KilledCount { get; set; }
        [WZMember(11)] public long Experience { get; set; }

        public void SetDT(DateTime dt)
        {
            Year = dt.Year;
            Month = (byte)dt.Month;
            Day = (byte)dt.Day;
        }
    }

    [WZContract]
    public class HuntingRecordListDto
    {
        //[WZMember(0, typeof(ArraySerializer))] public byte[] Unk1 { get; set; } = new byte[4] { 1,2,3,4 }; //0
        [WZMember(1)] public uint Id { get; set; } //6,7
        [WZMember(2)] public uint Year { get; set; } //3
        [WZMember(3)] public byte Month { get; set; } //4
        [WZMember(4)] public byte Day { get; set; } //5
        [WZMember(5)] public uint Level { get; set; } //8, 00 05 00 00
        [WZMember(6)] public uint Duration { get; set; }
        [WZMember(7)] public long Damage { get; set; }
        [WZMember(8)] public long ElementalDamage { get; set; }
        [WZMember(9)] public uint Healing { get; set; }
        [WZMember(10)] public uint KilledCount { get; set; }
        [WZMember(11)] public ulong Experience { get; set; }
        //[WZMember(12, typeof(ArraySerializer))] public byte[] Unk1 { get; set; } = new byte[3] { 1, 2, 3 };
    }

    [WZContract]
    public class SHuntingRecordList : IGameMessage
    {
        [WZMember(0)] public ushortle Unk { get; set; } = new ushortle();
        //[WZMember(1)] public ushort Count { get; set; }
        [WZMember(3, typeof(ArrayWithScalarSerializer<ushort>))] public HuntingRecordListDto[] List { get; set; }
    }

    [WZContract]
    public class SHuntingRecordTime : IGameMessage
    {
        [WZMember(0)] public int Time { get; set; }
        [WZMember(1)] public long Damage { get; set; }
        [WZMember(2)] public long ElementalDamage { get; set; }
        [WZMember(3)] public int Healing { get; set; }
        [WZMember(4)] public int KilledCount { get; set; }
        [WZMember(5)] public long Experience { get; set; }
    }

    [WZContract(Dump = true)]
    public class SMossMerchantOpen : IGameMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))] public byte[] List { get; set; }
    }

    [WZContract]
    public class SMossMerchantOpenBox : IGameMessage
    {
        [WZMember(0, typeof(ArraySerializer))] public byte[] ItemInfo { get; set; }
    }

    [WZContract]
    public class CancelItemSaleInfoDto
    {
        [WZMember(0)] public uint ExpireSec { get; set; }
        //[WZMember(1)] public byte Unk { get; set; }
        [WZMember(2, 12)] public byte[] ItemInfo{ get; set; } //[12]
        [WZMember(3)] public ushort ItemCount { get; set; }
        [WZMember(4)] public int RequireMoney { get; set; }
        [WZMember(5)] public byte IndexCode { get; set; }
}

    [WZContract(LongMessage = true)]
    public class SCancelItemSaleListS16 : IGameMessage
    {
        //PSWMSG_HEAD h;
        //[WZMember(0)] public byte Result { get; set; }
        //BYTE btItemCnt;
        [WZMember(1, typeof(ArrayWithScalarSerializer<ushortle>))] public CancelItemSaleInfoDto[] ItemList { get;set; }
    }

    [WZContract]
    public class SCancelItemSaleResult : IGameMessage
    {
        [WZMember(0)] public byte Result { get; set; }
    }


    [WZContract]
    public class ItemViewS16Dto
    {
        [WZMember(0, 12)] public byte[] ItemInfo { get; set; }
    }

    [WZContract(LongMessage = true, Serialized = true)]
    public class SPShopItemViewS16Kor : IGameMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1)] public byte Slot { get; set; }
        [WZMember(2)] public uint Zen { get; set; }
        [WZMember(3)] public uint JOBless { get; set; }
        [WZMember(4)] public uint JOSoul { get; set; }

        [WZMember(5, typeof(ArrayWithScalarSerializer<uint>))] public ItemViewS16Dto[] Items { get; set; }
    }

    [WZContract()]
    public class SRuudBuy : IGameMessage
    {
        public byte Result { get; set; }
    }

    [WZContract()]
    public class SRuudSend : IGameMessage
    {
        public uint Ruud { get; set; }
        public uint AddRuud { get; set; }
        public byte Add { get; set; }
    }
}



--file GensMessageFactory.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Network;

namespace MU.Network.GensSystem
{
    public interface IGensMessage { }
    public class GensMessageFactory : MessageFactory<GensOpCode, IGensMessage>
    {
        public GensMessageFactory(ServerSeason Season)
        {
            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, true);
            Register<CRequestJoin>(GensOpCode.RequestJoin);
            Register<CRequestLeave>(GensOpCode.RequestLeave);
            Register<CRequestMemberInfo>(GensOpCode.RequestMemberInfo);
            Register<CRequestReward>(GensOpCode.RequestReward);

            if (Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, false);
            Register<SRequestJoin>(GensOpCode.RequestJoin);
            Register<SGensSendInfoS9>(GensOpCode.SendGensInfo);
            Register<SViewPortGens>(GensOpCode.ViewPortGens);
            Register<SRegMember>(GensOpCode.RegMember);
            Register<SGensLeaveResult>(GensOpCode.RemoveMember);
            Register<SGensReward>(GensOpCode.RewardSend);
            //Register<SGensBattleZoneData>(GensOpCode.BattleZoneData);
        }
    }
}


--file Gens_C2S.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MU.Network.GensSystem
{
    [WZContract]
    public class CRequestJoin : IGensMessage
    {
        [WZMember(0)] public GensType Influence { get; set; }
    }
    [WZContract]
    public class CRequestLeave : IGensMessage
    {
        //[WZMember(0)] public byte Result { get; set; }
    }

    [WZContract]
    public class CRequestMemberInfo : IGensMessage
        {}

    [WZContract]
    public class CRequestReward : IGensMessage
    {
        [WZMember(0)] public byte Reward { get; set; }
    }
}


--file Gens_S2C.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MU.Network.GensSystem
{
    [WZContract]
    public class SGensSendInfoS9 : IGensMessage
    {
        [WZMember(0)] public GensType Influence { get; set; }
        [WZMember(1)] public byte aligment1 { get; set; }
        [WZMember(2)] public byte aligment2 { get; set; }
        [WZMember(3)] public byte aligment3 { get; set; }
        [WZMember(4)] public int Ranking { get; set; }
        [WZMember(5)] public int Class { get; set; }
        [WZMember(6)] public int ContributePoint { get; set; }
        [WZMember(7)] public int NextContributePoint { get; set; }
    }
    [WZContract]
    public class SRequestJoin : IGensMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1)] public GensType Influence { get; set; }
        [WZMember(2)] public ushort wzIndex { get; set; }
        public SRequestJoin()
        { }

        public SRequestJoin(byte result, GensType influence, ushort index)
        {
            Result = result;
            Influence = influence;
            wzIndex = index.ShufleEnding();
        }
    }
    [WZContract]
    public class SRegMember : IGensMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1)] public GensType Influence { get; set; }
        public SRegMember()
        { }

        public SRegMember(byte result, GensType influence)
        {
            Result = result;
            Influence = influence;
        }
    }

    [WZContract]
    public class VPGensDto
    {
        [WZMember(0)] public GensType Influence { get; set; }     // +0x0(0x1)
        [WZMember(1)] public ushort wzNumber { get; set; }     // +0x1(0x2)
        [WZMember(2)] public byte aligment { get; set; }     // +0x3(0x1)
        [WZMember(3)] public int iGensRanking { get; set; }     // +0x4(0x4)
        [WZMember(4)] public int iGensClass { get; set; }       // +0x8(0x4)
        [WZMember(5)] public int iContributePoint { get; set; } // +0xc(0x4)
    }

    [WZContract(LongMessage = true)]
    public class SViewPortGens : IGensMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))] public VPGensDto[] VPGens { get; set; }
    }

    [WZContract]
    public class SGensLeaveResult : IGensMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1)] public ushort wIndex { get; set; }

        public SGensLeaveResult() { }
        public SGensLeaveResult(byte result, ushort Index)
        {
            Result = result;
            wIndex = Index.ShufleEnding();
        }
    }

    [WZContract]
    public class SGensReward : IGensMessage
    {
        [WZMember(0)] public byte ItemType { get; set; }
    }

    [WZContract]
    public class SGensBattleZoneData : IGensMessage
    {
        [WZMember(0, typeof(ArraySerializer))] public ushort[] MapList { get; set; } = new ushort[103];
        [WZMember(1, typeof(ArraySerializer))] public int[] WarpList { get; set; } = new int[60];
    }
}


--file C2S.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MU.Network.Global
{
    [WZContract]
    public class CLiveClient : IGlobalMessage
    { }
}


--file GlobalMessageFactory.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Network;

namespace MU.Network.Global
{
    public interface IGlobalMessage
    { }

    public class GlobalMessageFactory : MessageFactory<GlobalOpCode, IGlobalMessage>
    {
        public GlobalMessageFactory(ServerSeason Season)
        {
            // C2S
            Register<CLiveClient>(GlobalOpCode.LiveClient);

            // S2C

            switch (Season)
            {
                case ServerSeason.Season17Kor75:
                    ChangeOPCode<CLiveClient>(GlobalOpCode.LiveClientS17K75);
                    break;
                default:
                    break;
            }
        }        
    }
}


--file S2C.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MU.Network.Global
{
    [WZContract]
    public class SResult : IGlobalMessage
    {
        [WZMember(1)]
        public byte Result { get; set; }

        public SResult()
        { }

        public SResult(byte result)
        {
            Result = result;
        }
    }
}


--file GuildMessageFactory.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Network;

namespace MU.Network.Guild
{
    public interface IGuildMessage
    { }

    public class GuildMessageFactory : MessageFactory<GuildOpCode, IGuildMessage>
    {
        public GuildMessageFactory(ServerSeason Season)
        {
            // C2S
            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, true);
            Register<CGuildRequest>(GuildOpCode.GuildRequest);
            Register<CGuildInfoSave>(GuildOpCode.GuildSaveInfo);
            Register<CGuildReqViewport>(GuildOpCode.GuildReqViewport);
            Register<CGuildListAll>(GuildOpCode.GuildListAll);
            Register<CGuildRequestAnswer>(GuildOpCode.GuildResult);
            Register<CGuildSetStatus>(GuildOpCode.GuildSetStatus);
            Register<CGuildRemoveUser>(GuildOpCode.RemoveUser);
            Register<CUnionList>(GuildOpCode.GuildUnionList);
            Register<CRelationShipJoinBreakOff>(GuildOpCode.GuildRelationShip);
            Register<CGuildMatchingListSearch>(GuildOpCode.GuildMatchingListSearch);
            Register<CGuildMatchingList>(GuildOpCode.GuildMatchingList);
            Register<CGuildMatchingRegister>(GuildOpCode.GuildMatchingRegister);
            Register<CGuildMatchingRegisterCancel>(GuildOpCode.GuildMatchingRegisterCancel);
            Register<CGuildMatchingJoin>(GuildOpCode.GuildMatchingJoin);
            Register<CGuildMatchingJoinAccept>(GuildOpCode.GuildMatchingJoinAccept);
            Register<CGuildMatchingJoinCancel>(GuildOpCode.GuildMatchingJoinCancel);
            Register<CGuildMatchingJoinList>(GuildOpCode.GuildMatchingJoinList);
            Register<CGuildMatchingJoinInfo>(GuildOpCode.GuildMatchingJoinInfo);


            // S2C
            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, false);
            Register<SGuildMasterQuestion>(GuildOpCode.MasterQuestion);
            Register<SGuildViewPort>(GuildOpCode.GuildViewPort);
            Register<SGuildAnsViewport>(GuildOpCode.GuildReqViewport);
            Register<SGuildList>(GuildOpCode.GuildListAll);
            Register<SGuildListS9>(GuildOpCode.GuildListAll);

            VersionSelector.Register<SGuildList>(Resources.ServerSeason.Season6Kor, GuildOpCode.GuildListAll);
            VersionSelector.Register<SGuildListS9>(Resources.ServerSeason.Season9Eng, GuildOpCode.GuildListAll);

            Register<SGuildCreateResult>(GuildOpCode.GuildSaveInfo);
            Register<SGuildResult>(GuildOpCode.GuildResult);
            Register<SGuildSetStatus>(GuildOpCode.GuildSetStatus);
            Register<SGuildRemoveUser>(GuildOpCode.RemoveUser);
            Register<SRelationShipJoinBreakOff>(GuildOpCode.GuildRelationShipAns);
            Register<SUnionList>(GuildOpCode.GuildUnionList);

            Register<SGuildMatchingList>(GuildOpCode.GuildMatchingList);
            Register<SGuildMatchingRegister>(GuildOpCode.GuildMatchingRegister);
            Register<SGuildMatchingRegisterCancel>(GuildOpCode.GuildMatchingRegisterCancel);
            Register<SGuildMatchingJoin>(GuildOpCode.GuildMatchingJoin);
            Register<SGuildMatchingAccept>(GuildOpCode.GuildMatchingJoinAccept);
            Register<SGuildMatchingJoinList>(GuildOpCode.GuildMatchingJoinList);
            Register<SGuildMatchingJoinInfo>(GuildOpCode.GuildMatchingJoinInfo);
            Register<SGuildMatchingNotify>(GuildOpCode.GUildMatchingNotify);
            Register<SGuildMatchingNotifyMaster>(GuildOpCode.GUildMatchingNotifyMaster);
        }
    }
}


--file Guild_C2S.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MU.Network.Guild
{
    [WZContract]
    public class CGuildInfoSave : IGuildMessage
    {
        [WZMember(0)] public byte Type { get; set; }

        [WZMember(1, 8)] public byte[] btName { get; set; }

        [WZMember(2, 32)] public byte[] Mark { get; set; }

        public string Name => btName.MakeString();
    }

    [WZContract]
    public class CGuildReqViewport : IGuildMessage
    {
        [WZMember(0)] public byte Padding { get; set; }
        [WZMember(1)] public int Guild { get; set; }
    }

    [WZContract]
    public class CGuildListAll : IGuildMessage
    { }

    [WZContract]
    public class CGuildRequest : IGuildMessage
    {
        [WZMember(0)] public ushort wzNumber { get; set; }

        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }
    }

    [WZContract]
    public class CGuildRequestAnswer : IGuildMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1)] public ushort wzNumber { get; set; }
        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }
    }

    [WZContract]
    public class CGuildSetStatus : IGuildMessage
    {
        [WZMember(0)] public byte Type { get; set; }
        [WZMember(1)] public GuildStatus Status { get; set; }
        [WZMember(2,10)] public byte[] btName { get; set; }

        public string Name => btName.MakeString();
    }

    [WZContract]
    public class CGuildRemoveUser : IGuildMessage
    {
        [WZMember(0, typeof(BinaryStringSerializer), 10)] public string Name { get; set; }
        [WZMember(1, typeof(BinaryStringSerializer), 20)] public string JoominNumber { get; set; }
    }

    [WZContract]
    public class CRelationShipJoinBreakOff : IGuildMessage
    {
        [WZMember(0)] public GuildRelationShipType RelationShipType { get; set; }    // 3
        [WZMember(1)] public GuildUnionRequestType RequestType { get; set; } // 4
        [WZMember(2)] public ushort wzTargetUserIndex { get; set; }    // 5-6
        [WZMember(3)] public byte Padding { get; set; }
        [WZMember(4, typeof(BinaryStringSerializer), 8)] public string Guild { get; set; }

        public ushort TargetUserIndex { get => wzTargetUserIndex.ShufleEnding(); set => wzTargetUserIndex = value.ShufleEnding(); }
    };

    [WZContract]
    public class CUnionList : IGuildMessage
    { };

    [WZContract]
    public class CGuildMatchingList : IGuildMessage
    {
        [WZMember(0)] public int Page { get; set; }
    }

    [WZContract]
    public class CGuildMatchingListSearch : IGuildMessage
    {
        [WZMember(0)] public int Page { get; set; }
        [WZMember(1, typeof(BinaryStringSerializer), 11)] public string Text { get; set; }
    }

    [WZContract]
    public class CGuildMatchingRegister : IGuildMessage
    {
        [WZMember(0, typeof(BinaryStringSerializer), 41)] public string Text { get; set; }
        [WZMember(1)] public GMInterestType InterestType { get; set; }
        [WZMember(2)] public GMLevelRange LevelRange { get; set; }
        [WZMember(3)] public ushortle Class { get; set; }
    }
    
    [WZContract]
    public class CGuildMatchingRegisterCancel : IGuildMessage
    {

    }

    [WZContract]
    public class CGuildMatchingJoin : IGuildMessage
    {
        [WZMember(0)] public int GuildID { get; set; }
    }

    [WZContract]
    public class CGuildMatchingJoinCancel : IGuildMessage
    {
    }

    [WZContract]
    public class CGuildMatchingJoinAccept : IGuildMessage
    {
        [WZMember(0)] public int Type { get; set; }
        [WZMember(1, typeof(BinaryStringSerializer), 11)] public string Name { get; set; }
    }

    [WZContract]
    public class CGuildMatchingJoinList : IGuildMessage
    {
    }

    [WZContract]
    public class CGuildMatchingJoinInfo : IGuildMessage
    {
    }
}


--file Guild_S2C.cs
﻿using MU.Resources;
using MuEmu.Network.Data;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;
using System.Linq;

namespace MU.Network.Guild
{
    [WZContract(LongMessage = true)]
    public class SGuildViewPort : IGuildMessage
    {
        [WZMember(0, SerializerType = typeof(ArrayWithScalarSerializer<byte>))]
        public GuildViewPortDto[] Guilds { get; set; }

        public SGuildViewPort()
        {
            Guilds = Array.Empty<GuildViewPortDto>();
        }
    }

    [WZContract]
    public class SGuildMasterQuestion : IGuildMessage
    {

    }

    [WZContract]
    public class SGuildCreateResult : IGuildMessage
    {
        [WZMember(0)] public byte Result { get; set; }

        [WZMember(1)] public byte GuildType { get; set; }
    }

    [WZContract]
    public class SGuildAnsViewport : IGuildMessage
    {
        // 0xC1 // 0
        // Size // 1
        // 0x66 // 2
        [WZMember(0)] public byte padding { get; set; } // 3
        [WZMember(1)] public int GuildNumber { get; set; }    // 4
        [WZMember(2)] public byte btGuildType { get; set; }   // 8
        [WZMember(3,8)] public byte[] btUnionName { get; set; }  // 9
        [WZMember(4,8)] public byte[] btGuildName { get; set; }  // 11
        [WZMember(5,32)] public byte[] Mark { get; set; }	// 19

        public string UnionName { get => btUnionName.MakeString(); set => btUnionName = value.GetBytes(); }
        public string GuildName { get => btGuildName.MakeString(); set => btGuildName = value.GetBytes(); }
    }

    [WZContract(LongMessage = true)]
    public class SGuildList : IGuildMessage
    {
        [WZMember(0)] public byte Result { get; set; }    // 4
        [WZMember(1)] public byte Count { get; set; } // 5
        [WZMember(2)] public ushort Padding { get; set; } // 6, 7
        [WZMember(3)] public int TotalScore { get; set; } // 8, 9, A, B
        [WZMember(4)] public byte Score { get; set; } // C
        [WZMember(5, typeof(BinaryStringSerializer), 8)] public string RivalGuild { get; set; }	// D
        [WZMember(6)] public ushort Padding2 { get; set; }

        [WZMember(7, SerializerType = typeof(ArraySerializer))]
        public GuildListDto[] Members { get; set; }

        public SGuildList()
        {
            Members = Array.Empty<GuildListDto>();
            RivalGuild = "";
        }

        public SGuildList(byte result)
        {
            Result = result;
            Members = Array.Empty<GuildListDto>();
            RivalGuild = "";
        }

        public SGuildList(byte result, byte score, int totalScore, List<GuildListDto> members, List<string> rivals)
        {
            Result = result;
            Score = score;
            TotalScore = totalScore;
            Members = members.ToArray();
            Count = (byte)Members.Length;

            RivalGuild = rivals.FirstOrDefault();
        }
    }

    [WZContract]
    public class GuildRivalDto
    {
        [WZMember(0, typeof(BinaryStringSerializer), 8)] public string RivalGuild { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SGuildListS9 : IGuildMessage
    {
        [WZMember(0)] public byte Result { get; set; }    // 4
        [WZMember(1)] public byte Count { get; set; } // 5
        [WZMember(2)] public ushort Padding { get; set; } // 6, 7
        [WZMember(3)] public int TotalScore { get; set; } // 8, 9, A, B
        [WZMember(4)] public byte Score { get; set; } // C
        [WZMember(5, typeof(ArraySerializer))] public GuildRivalDto[] Rivals { get; set; }	// D
        //[WZMember(6, typeof(BinaryStringSerializer), 8)] public string RivalGuild2 { get; set; }	// D
        //[WZMember(7, typeof(BinaryStringSerializer), 8)] public string RivalGuild3 { get; set; }	// D
        //[WZMember(8, typeof(BinaryStringSerializer), 8)] public string RivalGuild4 { get; set; }	// D
        //[WZMember(9, typeof(BinaryStringSerializer), 8)] public string RivalGuild5 { get; set; }	// D
        [WZMember(10)] public ushort Padding2 { get; set; }
        [WZMember(11)] public byte Padding3 { get; set; }

        [WZMember(12, SerializerType = typeof(ArraySerializer))]
        public GuildListDto[] Members { get; set; }

        public SGuildListS9()
        {
            Members = Array.Empty<GuildListDto>();
            Rivals = new GuildRivalDto[] {
                new GuildRivalDto { RivalGuild = "" },
                new GuildRivalDto { RivalGuild = "" },
                new GuildRivalDto { RivalGuild = "" },
                new GuildRivalDto { RivalGuild = "" },
                new GuildRivalDto { RivalGuild = "" },
            };
        }

        public SGuildListS9(byte result)
        {
            Result = result;
            Members = Array.Empty<GuildListDto>();
            Rivals = new GuildRivalDto[] {
                new GuildRivalDto { RivalGuild = "" },
                new GuildRivalDto { RivalGuild = "" },
                new GuildRivalDto { RivalGuild = "" },
                new GuildRivalDto { RivalGuild = "" },
                new GuildRivalDto { RivalGuild = "" },
            };
        }

        public SGuildListS9(byte result, byte score, int totalScore, List<GuildListDto> members, List<string> rivals)
        {
            Result = result;
            Score = score;
            TotalScore = totalScore;
            Members = members.ToArray();
            Count = (byte)Members.Length;

            var riv = rivals.ToList();

            while (riv.Count < 5)
                riv.Add("");

            Rivals = riv.Select(x => new GuildRivalDto { RivalGuild = x }).ToArray();
        }
    }

    [WZContract]
    public class SGuildResult : IGuildMessage
    {
        [WZMember(0)] public GuildResult Result { get; set; }

        public SGuildResult() { }
        public SGuildResult(GuildResult res) { Result = res; }
    }

    [WZContract]
    public class SGuildSetStatus : IGuildMessage
    {
        [WZMember(0)] public byte Type { get; set; }
        [WZMember(1)] public GuildResult Result { get; set; }
        [WZMember(2, 10)] public byte[] btName { get; set; }

        public string Name => btName.MakeString();

        public SGuildSetStatus() { }

        public SGuildSetStatus(byte type, GuildResult res, string name)
        {
            Type = type;
            Result = res;

            btName = name.GetBytes();
        }
    }

    [WZContract]
    public class SGuildRemoveUser : IGuildMessage
    {
        [WZMember(0)] public GuildResult Result { get; set; }

        public SGuildRemoveUser() { }

        public SGuildRemoveUser(GuildResult res)
        {
            Result = res;
        }
    }

    [WZContract]
    public class SRelationShipJoinBreakOff : IGuildMessage
    {
        [WZMember(0)] public GuildRelationShipType RelationShipType { get; set; }    // 3
        [WZMember(1)] public GuildUnionRequestType RequestType { get; set; } // 4
        [WZMember(2)] public byte Result { get; set; } // 4
        [WZMember(3)] public ushort wzTargetUserIndex { get; set; }    // 5-6
    };

    [WZContract]
    public class UnionListDto
    {
        [WZMember(0)] public byte MemberNum { get; set; }   // 0
        [WZMember(1, 32)] public byte[] Mark { get; set; }  // 1
        [WZMember(2, typeof(BinaryStringSerializer), 8)] public string GuildName { get; set; }  // 21
    }

    [WZContract(LongMessage = true)]
    public class SUnionList : IGuildMessage
    {
        [WZMember(0)] public byte Count { get; set; }   // 4
        [WZMember(1)] public byte Result { get; set; }  // 5
        [WZMember(2)] public byte RivalMemberNum { get; set; }  // 6
        [WZMember(3)] public byte UnionMemberNum { get; set; }	// 7
        [WZMember(4, typeof(ArraySerializer))] public UnionListDto[] List { get; set; }
    };

    [WZContract]
    public class SGuildMatchingRegister : IGuildMessage
    {
        [WZMember(0)] public uint Result { get; set; }
    }

    [WZContract]
    public class SGuildMatchingRegisterCancel : IGuildMessage
    {
        [WZMember(0)] public uint Result { get; set; }
    }


    [WZContract]
    public class SGuildMatchingJoin : IGuildMessage
    {
        [WZMember(0)] public int Result { get; set; }
    }

    [WZContract]
    public class SGuildMatchingAccept : IGuildMessage
    {
        [WZMember(0, typeof(BinaryStringSerializer), 12)] public string Name { get; set; }
        [WZMember(1)] public int Type { get; set; }
        [WZMember(2)] public int Result { get; set; }
    }

    [WZContract]
    public class SGuildMatchingJoinInfo : IGuildMessage
    {
        [WZMember(0, typeof(BinaryStringSerializer), 11)] public string MasterName { get; set; }
        [WZMember(1, typeof(BinaryStringSerializer), 9)] public string GuildName { get; set; }
        [WZMember(2)] public int Result { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class SGuildMatchingJoinList : IGuildMessage
    {
        [WZMember(0, typeof(ArraySerializer))] public byte[] padding { get; set; } = new byte[3];
        [WZMember(1)] public int Count { get; set; }
        [WZMember(2)] public int Result { get; set; }
        [WZMember(3, typeof(ArraySerializer))] public GuildMatchingJoinListDto[] List { get; set; }
    }

    [WZContract]
    public class GuildMatchingJoinListDto : IGuildMessage
    {
        [WZMember(0, typeof(BinaryStringSerializer), 11)] public string Name { get; set; }
        [WZMember(1)] public byte Class { get; set; }
        [WZMember(2)] public uint Level { get; set; }
        [WZMember(3)] public uint Padding { get; set; }

    }

    [WZContract]
    public class SGuildMatchingNotify : IGuildMessage
    {
        [WZMember(0)] public uint Result { get; set; }
    }

    [WZContract]
    public class SGuildMatchingNotifyMaster : IGuildMessage
    {
        [WZMember(0)] public uint Result { get; set; }
    }
    [WZContract(LongMessage = true)]
    public class SGuildMatchingList : IGuildMessage
    {
        [WZMember(0, typeof(ArraySerializer))] public byte[] Padding { get; set; } = new byte[3];
        [WZMember(1)] public int CurrentPage { get; set; }
        [WZMember(2)] public int MaxPage { get; set; }
        [WZMember(3)] public int Count { get; set; }
        [WZMember(4)] public uint Result { get; set; }
        [WZMember(5, typeof(ArraySerializer))] public GuildMatchingListDto[] List { get; set; }
    }
    [WZContract]
    public class GuildMatchingListDto
    {
        [WZMember(0, typeof(BinaryStringSerializer), 41)] public string Text { get; set; }// [GUILD_MATCHING_TEXT_LENGTH + 1]; //0
        [WZMember(1, typeof(BinaryStringSerializer), 11)] public string Name { get; set; }//[MAX_CHARACTER_LENGTH + 1]; //41
        [WZMember(2, typeof(BinaryStringSerializer), 9)] public string GuildName { get; set; }//[MAX_GUILD_NAME_LENGTH + 1]; //52
        [WZMember(3)] public byte MembersCount { get; set; } //61
        [WZMember(4)] public byte MasterClass { get; set; } //62
        [WZMember(5)] public GMInterestType InterestType { get; set; } //63
        [WZMember(6)] public GMLevelRange LevelRange { get; set; } //64
        [WZMember(7)] public byte Padding { get; set; } //65
        [WZMember(8)] public GMClass ClassType { get; set; } //66
        [WZMember(9)] public uint MasterLevel { get; set; } //68
        [WZMember(10)] public uint BoardNumber { get; set; } //72
        [WZMember(11)] public int GuildId { get; set; } //76
        [WZMember(12)] public int Gens { get; set; } //80
    }
}


--file Muun_C2S.cs
﻿using MU.Network.Game;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MU.Network.MuunSystem
{
    [WZContract(Serialized = true)]
    public class CMuunItemGet : IGameMessage
    {
        [WZMember(0)] public ushort wzNumber { get; set; }
        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }
    }

    [WZContract]
    public class CMuunItemUse : IGameMessage
    {
        [WZMember(0)] public byte inventoryPos { get; set; }
        [WZMember(1)] public byte invenrotyTarget { get; set; }
        [WZMember(2)] public byte btItemUseType { get; set; }
    }

    [WZContract(Serialized = true)]
    public class CMuunItemSell : IGameMessage
    {
        [WZMember(0)] public byte inventoryPos { get; set; }
    }

    [WZContract]
    public class CMuunItemRideSelect : IGameMessage
    {
        [WZMember(0)] public ushort wzNumber { get; set; }
        public ushort Number { get => wzNumber.ShufleEnding(); set => wzNumber = value.ShufleEnding(); }
    }

    [WZContract]
    public class CMuunItemExchange : IGameMessage
    {
        [WZMember(0)] public byte select { get; set; }
    }
}


--file Muun_S2C.cs
﻿using MU.Network.Game;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MU.Network.MuunSystem
{
    [WZContract]
    public class SMuunRideVP : IGameMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))] public MuunRideVPDto[] ViewPort { get; set; }
    }

    [WZContract]
    public class MuunRideVPDto
    {
        [WZMember(0)] public ushort wzNumber { get; set; }
        [WZMember(1)] public ushort wzMuunRideItem { get; set; }

        public MuunRideVPDto()
        {

        }
        public MuunRideVPDto(ushort Number, ushort MuunItem)
        {
            wzNumber = Number.ShufleEnding();
            wzMuunRideItem = MuunItem.ShufleEnding();
        }
    }

    [WZContract(Serialized = true)]
    public class SMuunItemGet : IGameMessage
    {
        [WZMember(0)] public byte Result { get; set; }
        [WZMember(1, 12)] public byte[] Item { get; set; }
    }
}


--file .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


--file MU.Network.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("MU.Network")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("MU.Network")]
[assembly: System.Reflection.AssemblyTitleAttribute("MU.Network")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file .NETCoreApp,Version=v3.1.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v3.1", FrameworkDisplayName = ".NET Core 3.1")]


--file MU.Network.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("MU.Network")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("MU.Network")]
[assembly: System.Reflection.AssemblyTitleAttribute("MU.Network")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


--file MU.Network.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("MU.Network")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("MU.Network")]
[assembly: System.Reflection.AssemblyTitleAttribute("MU.Network")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file OPCodes.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MU.Network
{
    internal class Data
    {
        internal byte oldOPCode;
        internal byte newC2S;
        internal byte newS2C;
        internal IEnumerable<byte> oldSub;
        internal IEnumerable<byte> c2sSub;
        internal IEnumerable<byte> s2cSub;

        internal Dictionary<byte, byte> toClient = new Dictionary<byte, byte>();
        internal Dictionary<byte, byte> toServer = new Dictionary<byte, byte>();

        internal static List<Data> datas = new List<Data>
        {
            new Data(0xF1,0xF3,0x3A,
            new byte[]{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x12,0xFD,0xFE},
            new byte[]{0x00,0x02,0x01,0x03,0x04,0x05,0x06,0x12,0xFD,0xFE},
            new byte[]{0x00,0xFD,0xFE,0x03,0x04,0x05,0x06,0x12,0x02,0x01}
            ),
            new Data(0xF3,0x52,0x82,
            new byte[]{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x30,0x31,0x34,0x35,0x40,0x50,0x51,0x52,0x53,0x60},
            new byte[]{0x60,0x26,0x06,0x00,0x04,0x05,0x15,0x07,0x08,0x10,0x11,0x16,0x13,0x14,0x01,0x21,0x20,0x12,0x22,0x23,0x24,0x25,0x26,0x31,0x02,0x34,0x35,0x40,0x50,0x51,0x03,0x03,0x30},
            new byte[]{0x04,0x00,0x07,0x14,0x20,0x60,0x25,0x06,0x15,0x26,0x53,0x12,0x52,0x51,0x05,0x30,0x23,0x21,0x50,0x34,0x08,0x13,0x32,0x10,0x31,0x03,0x22,0x35,0x11,0x01,0x16,0x24,0x40}
            ),
            new Data(0x00,0x4A,0x00),
            new Data(0x03,0x31,0x00),
            new Data(0x0E,0x24,0x0E),
            new Data(0x18,0x83,0x53),
            new Data(0x19,0x26,0x19),
            new Data(0x22,0xC1,0x32),
            new Data(0x23,0xB2,0xCB),
            new Data(0x24,0x3A,0x41),
            new Data(0x26,0xC2,0x55),
            new Data(0x30,0x90,0x4A),
            new Data(0x31,0xC0,0x31),
            new Data(0x32,0xB7,0x9F),
            new Data(0x33,0x97,0x33),
            new Data(0x34,0x57,0x18),
            new Data(0x36,0x43,0xF1),
            new Data(0x37,0x61,0x22),
            new Data(0x3A,0x19,0x54),
            new Data(0x3C,0xCA,0xC6),
            new Data(0x3D,0xE5,0x3D),
            new Data(0x3E,0x33,0x71,
            new byte[]{0x01,0x03,0x07,0x08,0x09,0x10,0x11,0x20,0x21,0x22},
            Array.Empty<byte>(),
            new byte[]{0x01,0x30,0x39,0x32,0x09,0x03,0x11,0x20,0x21,0x22}
            ),
            new Data(0x3F,0x9D,0x36,
            new byte[]{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x10},
            Array.Empty<byte>(),
            new byte[]{0x06,0x01,0x02,0x12,0x04,0x05,0x06,0x07,0x00}
            ),
            new Data(0x40,0xE2,0x40),
            new Data(0x41,0x41,0xEC),
            new Data(0x43,0x34,0x43),
            new Data(0x4A,0x42,0x86),
            new Data(0x4B,0x4B,0xA0),
            new Data(0x4C,0xC4,0xB1,
            new byte[]{0x00,0x01,0x02,0x03,0x10,0x11},
            Array.Empty<byte>(),
            new byte[]{0x10,0x01,0x02,0x03,0x00,0x11}
            ),
            new Data(0x4D,0x03,0x87,
            new byte[]{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x30,0x31,0x32,0x33,0x34,0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47},
            new byte[]{0x2B,0x0F,0x02,0x03,0x04,0x05,0x06,0x31,0x19,0x3B,0x33,0x27,0x00,0x2C,0x16,0x17,0x18,0x30,0x28,0x2D,0x38,0x26,0x3A,0x28,0x29,0x28,0x28,0x28,0x28,0x12,0x01,0x15,0x32,0x33,0x34,0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47},
            new byte[]{ 0x36, 0x11, 0x3B, 0x42, 0x45, 0x15, 0x03, 0x14, 0x3C, 0x33, 0x27, 0x0F, 0x2B, 0x16, 0x12, 0x2E, 0x29, 0x19, 0x06, 0x25, 0x2C, 0x01, 0x46, 0x44, 0x31, 0x2D, 0x00, 0x28, 0x24, 0x40, 0x05, 0x30, 0x48, 0x10, 0x26, 0x43, 0x02, 0x23, 0x38, 0x18, 0x17, 0x34, 0x39 }
            ),
            new Data(0x50,0xC3,0x96),
            new Data(0x51,0x0E,0xC3),
            new Data(0x52,0x4C,0xB7),
            new Data(0x53,0x50,0x9A),
            new Data(0x54,0xA7,0x54), // FIX THIS
            new Data(0x55,0x40,0x55), // FIX THIS
            new Data(0x61,0xC8,0x61),
            new Data(0x66,0x72,0x66),
            new Data(0x71,0x22,0x4C), // FIX THIS
            new Data(0x73,0x73,0xC0), // FIX THIS
            new Data(0x81,0x73,0x91),
            new Data(0x82,0xEC,0x95),
            new Data(0x83,0x86,0xB3),
            new Data(0x86,0x55,0x52),
            new Data(0x87,0x01,0x95),
            new Data(0x90,0x90,0x3E),
            new Data(0x91,0x66,0x30),
            new Data(0x95,0x95,0xA2),
            new Data(0x96,0x96,0xBD),
            new Data(0x97,0x81,0x97),
            new Data(0x9A,0x18,0xF3),
            new Data(0xA0,0xB1,0x81),
            new Data(0xA2,0x51,0x83),
            new Data(0xA7,0x9F,0x3F),
            new Data(0xA9,0xCB,0xE5),
            new Data(0xB1,0x4B,0x73,
            new byte[]{0x00,0x01},
            new byte[]{0x00,0x01},
            new byte[]{0x00,0x01}
            ),
            new Data(0xB2,0x30,0xCA,
            new byte[]{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20},
            new byte[]{},
            new byte[]{0x01,0x07,0x02,0x06,0x1B,0x13,0x17,0x1D,0x03,0x05,0x20,0x04,0x18,0x1A,0x11,0x15,0x1F,0x1C,0x10,0x08,0x1E,0x00,0x1C,0x16,0x19,0x12,0x09}
            ),
            new Data(0xB3,0xA0,0x4B),
            new Data(0xB7,0x3E,0xC2,
            new byte[]{0x00,0x01,0x02,0x04},
            new byte[]{0x00,0x01,0x02,0x04},
            new byte[]{0x03,0x00,0x01,0x04}
            ),
            new Data(0xBD,0x3C,0xC8,
            new byte[]{0x00,0x02,0x03,0x04,0x05,0x07,0x08,0x09,0x0C},
            new byte[]{0x00,0x02,0x09,0x04,0x05,0x07,0x08,0x03,0x0C},
            new byte[]{0x04,0x02,0x09,0x05,0x0C,0x00,0x08,0x07,0x03}
            ),
            new Data(0xC0,0x3D,0xC7),
            new Data(0xC1,0x96,0x4D),
            new Data(0xC2,0x32,0x24),
            new Data(0xC3,0x53,0x34),
            new Data(0xC4,0xC9,0x5A),
            new Data(0xC5,0x23,0xF7),
            new Data(0xC6,0xC6,0xC4),
            new Data(0xC7,0xC5,0x90),
            new Data(0xC8,0x71,0x23),
            new Data(0xC9,0xA9,0xC9),
            new Data(0xCA,0xB3,0x3C),
            new Data(0xCB,0xC7,0xE2),
            new Data(0xE5,0x91,0xA7),
            new Data(0xEC,0xF7,0x51,
            new byte[]{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x10,0x25,0x26,0x27,0x28,0x29,0x30,0x31,0x33,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x60,0x61,0x62},
            new byte[]{0x57,0x70,0x54,0x07,0x04,0x75,0x33,0x31,0x01,0x10,0x25,0x26,0x71,0x28,0x29,0x30,0x31,0x33,0x08,0x50,0x27,0x53,0x51,0x56,0x56,0x58,0x59,0x60,0x73,0x62},
            new byte[]{ 0x60, 0x04, 0x07, 0x08, 0x30, 0x63, 0x73, 0x50, 0x53, 0x25, 0x75, 0x00, 0x27, 0x62, 0x01, 0x54, 0x31, 0x33, 0x71, 0x51, 0x52, 0x06, 0x55, 0x72, 0x28, 0x31, 0x10, 0x05, 0x61, 0x74 }
            ),
        };

        public Data(
            byte old, 
            byte C2S, 
            byte S2C, 
            IEnumerable<byte> _oldSub, 
            IEnumerable<byte> _c2sSub, 
            IEnumerable<byte> _s2cSub)
        {
            oldOPCode = old;
            newC2S = C2S;
            newS2C = S2C;

            oldSub = _oldSub;
            c2sSub = _c2sSub;
            s2cSub = _s2cSub;

            if (_c2sSub.Count() == _oldSub.Count())
                for (var i = 0; i < _oldSub.Count(); i++)
                {
                    toClient.Add(_oldSub.ElementAt(i), _c2sSub.ElementAt(i));
                }

            if (_s2cSub.Count() == _oldSub.Count())
                for (var i = 0; i < _oldSub.Count(); i++)
                {
                    toServer.Add(_oldSub.ElementAt(i), _s2cSub.ElementAt(i));
                }
        }

        public Data(
            byte old,
            byte C2S,
            byte S2C)
        {
            oldOPCode = old;
            newC2S = C2S;
            newS2C = S2C;

            oldSub = Array.Empty<byte>();
            c2sSub = Array.Empty<byte>();
            s2cSub = Array.Empty<byte>();
        }

        public ushort ToClient(ushort opcode)
        {
            var subHead = (byte)((opcode & 0xFF00) >> 8);
            if (toClient.Any())
            {
                if (toClient.TryGetValue(subHead, out var client))
                    return (ushort)(newC2S | (client << 8));
            }
            return (ushort)(newC2S | (subHead << 8));
        }

        public ushort ToServer(ushort opcode)
        {
            var subHead = (byte)((opcode & 0xFF00) >> 8);
            if (toServer.Any())
            {
                if (toServer.TryGetValue(subHead, out var client))
                    return (ushort)(newS2C | (client << 8));
            }
            return (ushort)(newS2C | (subHead << 8));
        }


        public static T ProtocolXChangeS17K75<T>(T opcodeOld, bool fromClient) where T : Enum
        {
            var tmp = (ushort)(object)opcodeOld;
            var head = (byte)(tmp & 0xff);

            var data = datas.FirstOrDefault(x => x.oldOPCode == head);
            if (data == null) return opcodeOld;

            return (T)(object)(fromClient ? data.ToClient(tmp) : data.ToServer(tmp));
        }
    }
    public enum ConOpCode : ushort
    {
        CSWelcome = 0x0100,
        GSJoin = 0xFF10,
        GSKeep = 0xFF11,
        GSClientAdd = 0xFF12,
        GSClientChat = 0xFF13,
        GSClientRem = 0xFF14,
        ServerList = 0x06F4,
    }


    public enum GlobalOpCode : ushort
    {
        LiveClient = 0xFF0E,
        LiveClientS17K75 = 0xFF24,
    }

    public enum AHOpCode : ushort
    {
        AHCheck = 0x11FA,
        AHEncKey = 0x00FA,
    }

    public enum CSOpCode : ushort
    {
        JoinResult = 0x00F1,
        Login = 0x01F1,
        LoginS17Kor = 0x020E,
        LoginS17KorResp = 0xFEF1,
        CharacterList = 0x00F3,
        CharacterListS17Kor = 0x154A,
        CharacterListS17KorResp = 0x1452,
        CharacterCreate = 0x01F3,
        CharacterDelete = 0x02F3,
        JoinMap2 = 0x03F3,
        JoinMap = 0x15F3,
        JoinMapS17Kor = 0x604A,
        JoinMapS17KorResp = 0x1652,
        JoinMap2S17Kor = 0x024A,
        JoinMap2S17KorResp = 0x2452,
        ServerMove = 0x00B1,
        ServerMoveAuth = 0x01B1,

        ResetList = 0x0AFA,
        Resets = 0x0BFA,
        EnableCreate = 0x00DE,
        ChannelList = 0x57EC,
    }

    public enum GameOpCode : ushort
    {
        MapMoveCheckSum = 0x018E,
        Warp = 0x028E,

        DuelRequest = 0x01AA,
        DuelAnswer = 0x02AA,
        DuelLeave = 0x03AA,
        DuelScoreBroadcast = 0x04AA,
        DuelHPBroadcast = 0x05AA,
        DuelChannelList = 0x06AA,
        DuelRoomJoin = 0x07AA,
        DuelRoomJoinBroadcast = 0x08AA,
        DuelRoomLeave = 0x09AA,
        DuelRoomLeaveBroadcast = 0x0AAA,
        DuelRoomObserversBroadcast = 0x0BAA,
        DuelResultBroadcast = 0x0CAA,
        DuelRoundBroadcast = 0x0DAA,

        ItemSplit = 0x00E8,

        Tax = 0x1AB2,
        KillCount = 0x01B8,
        ClientClose = 0x02F1,
        ClientMessage = 0x03F1,
        ClientMessageS17K75 = 0x03F3,
        Eventnotification = 0xFEF1,
        CharRegen = 0x04F3,
        LevelUp = 0x5F3,
        PointAdd = 0x06F3,
        Damage = 0x07F3,
        Inventory = 0x10F3,
        Spells = 0x11F3,
        DataLoadOK = 0x12F3,
        Equipament = 0x13F3,
        OneItemSend = 0x14F3,
        SkillKey = 0x30F3,
        Command = 0x40F3,

        MasterLevelInfo = 0x50F3,
        MasterLevelUp = 0x51F3,
        MasterLevelSkill = 0x52F3,

        //NewQuestInfo = 0x1AF6,
        QuestDetails = 0x1BF6,
        QuestWindow = 0x01F9,
        JewelMix = 0x00BC,
        JewelUnMix = 0x01BC,
        GeneralChat0 = 0xFF00,
        GeneralChat1 = 0xFF01,
        WhisperChat = 0xFF02,
        GameSecurity = 0xFF03,
        ViewSkillState = 0xFF07,
        EventState = 0xFF0B,
        Notice = 0xFF0D,
        Weather = 0xFF0F,
        Beattack = 0xFF10,
        BeattackS16 = 0xFFD3,
        ViewPortCreate = 0xFF12,
        ViewPortMCreate = 0xFF13,
        ViewPortDestroy = 0xFF14,
        AttackResult = 0xFF15,
        KillPlayer = 0xFF16,
        DiePlayer = 0xFF17,
        Rotation = 0xFF18,
        MagicAttack = 0xFF19,
        Teleport = 0xFF1C,
        MagicDuration = 0xFF1E,
        ViewPortMCall = 0xFF1F,
        ViewPortItemCreate = 0xFF20,
        ViewPortItemDestroy = 0xFF21,
        ItemGet = 0xFF22,
        ItemThrow = 0xFF23,
        MoveItem = 0xFF24,
        HealthUpdate = 0xFF26,
        ManaUpdate = 0xFF27,
        InventoryItemDelete = 0xFF28,
        ItemUseSpecialTime = 0xFF29,
        InventoryItemDurUpdate = 0xFF2A,
        PeriodicEffect = 0xFF2D,
        Talk = 0xFF30,
        CloseWindow = 0xFF31,
        CancelItemSale = 0x006F,
        CancelItemSaleClose = 0x016F,
        CancelItemSaleItem = 0x026F,
        Buy = 0xFF32,
        Sell = 0xFF33,
        ItemModify = 0xFF34,
        TradeRequest = 0xFF36,
        TradeResponce = 0xFF37,
        TradeOtherAdd = 0xFF39,
        TradeMoney = 0xFF3A,
        TradeOtherMoney = 0xFF3B,
        TradeButtonOk = 0xFF3C,
        TradeButtonCancel = 0xFF3D,
        ViewPortPShop = 0x003F,
        PShopSetItemPrice = 0x013F,
        PShopRequestOpen = 0x023F,
        PShopRequestClose = 0x033F,
        PShopRequestList = 0x053F,
        PShopRequestBuy = 0x063F,
        PShopAlterVault = 0xA8FA,
        PShopCloseDeal = 0x073F,
        PShopRequestSold = 0x083F,
        PShopSearchItem = 0x31EC,
        PartyRequest = 0xFF40,
        PartyResult = 0xFF41,
        PartyList = 0xFF42,
        PartyDelUser = 0x0FF43,
        PartyLifeUpdate = 0x0FF44,
        ViewPortChange = 0xFF45,
        SetMapAtt = 0xFF46,
        Effect = 0xFF48,
        ViewPortGuildCreate = 0xFF65,
        WarehouseMoney = 0xFF81,
        WarehouseUseEnd = 0xFF82,
        ChaosBoxItemMixButtonClick = 0xFF86,
        ChaosBoxUseEnd = 0xFF87,
        EventEnterCount = 0xFF9F,
        QuestInfo = 0xFFA0,

        FriendList = 0xFFC0,
        FriendAdd = 0xFFC1,
        FriendAddWait = 0xFFC2,
        FriendDel = 0xC3,
        FriendState = 0xC4,
        LetterSend = 0xC5,
        AddLetter = 0xFFC6,
        LetterRead = 0xC7,
        LetterDel = 0xC8,
        LetterList = 0xC9,

        OpenBox = 0xF2D0,

        Move = 0xFFD3,
        MoveEng = 0xFFD4,
        Move12Eng = 0xFFD7,
        Attack = 0xFFD7,
        AttackEng = 0xFF11,
        Position = 0xFFDF,
        Position9Eng = 0xFF15,

        MiniMapNPC = 0x03E7,
        PeriodItemCount = 0x11D2,

        PentagramaJInfo = 0x01EE,
        UBFInfo = 0x01CD,
        PopUpType = 0x26F3,

        MemberPosInfoStart = 0x01E7,
        MemberPosInfoStop = 0x02E7,
        LifeInfo = 0x10EC,
        NPCJulia = 0x17BF,
        MuHelperSwitch = 0x51BF,
        MuHelper = 0xFFAE,
        AttackSpeed = 0x30EC,
        KillPlayerEXT = 0xFF9C,
        NPCDialog = 0x01F9,
        QuestExp = 0x30F6,
        ShadowBuff = 0x31F6,
        ChainMagic = 0x0ABF,

        GremoryCaseList = 0x004F,
        GremoryCaseReceive = 0x014F,
        GremoryCaseUse = 0x024F,
        GremoryCaseDelete = 0x034F,
        GremoryCaseNotice = 0x044F,
        GremoryCaseOpen = 0x054F,
        AcheronEnter = 0x20F8,
        RefineJewel = 0x02EC,
        PentagramaJewelIn = 0x00EC,
        PentagramaJewelInOut = 0x04EC,
        ElementDamage = 0xFFD8,
        NeedSpiritMap = 0x21F8,
        PetInfo = 0xFFA9,
        MasterLevelSkills = 0x53F3,
        ExpEventInfo = 0x52BF,

        MuunItemGet = 0x004E,
        MuunInventory = 0x024E,
        MuunItemUse = 0x084E,
        MuunItemSell = 0x094E,
        MuunItemRideSelect = 0x114E,
        MuunItemExchange = 0x134E,
        MuunRideViewPort = 0x144E,
        PetCommand = 0xFFA7,
        PetAttack = 0xFFA8,
        InventoryEquipament = 0x20BF,
        EquipamentChange = 0xFF25,
        Attack12Eng = 0xFFDF,
        SXUpPront = 0x25EC,
        SXElementalData = 0x26EC,
        SXInfo = 0x27EC,
        SXCharacterInfo = 0x29EC,
        NewQuestWorldLoad = 0x20F6,
        NewQuestWorldList = 0x50F6,
        PKLevel = 0x08F3,
        MonsterSkill = 0x0069,
        FavoritesList = 0x016D,
        FavoritesListS16Kor = 0x0459,

        PartyMatchingRegister = 0x00EF,
        PartyMatchingSearch = 0x01EF,
        PartyMatchingJoin = 0x02EF,
        PartyMatchingJoinData = 0x03EF,
        PartyMatchingJoinList = 0x04EF,
        PartyMatchingAccept = 0x05EF,
        PartyMatchingCancel = 0x06EF,
        PartyLeaderChange = 0x07EF,
        PartyJoinNotify = 0x08EF,
        HuntingRecordRequest = 0x50EC,
        HuntingRecordClose = 0x51EC,
        HuntingRecordVisibility = 0x52EC,
        HuntingRecordDay = 0x53EC,
        HuntingRecordCurrent = 0x55EC,
        MossMerchant = 0x1170,
        MossMerchantOpenBox = 0x1070,
        MossMerchantOpenBoxReward = 0x1270,
        GremoryCaseOpenS16 = 0x06CD,

        MiningSystemUnk = 0x204C,
        MajesticInfo = 0x027E,
        MajesticStatsInfo = 0x067E,
        Position16Kor = 0xFF10,

        PShopSearchS16Kor = 0x007C,
        PShopItemSearchS16Kor = 0x017C,
        PShopItemSearch2S16Kor = 0x037C,
        PShopRequestList2S16Kor = 0x067C,
        PShopItemViewS16Kor = 0x077C,
        PShopSetItemPriceS16Kor = 0x087C,
        PShopCancelItemSaleS16Kor = 0x097C,
        PShopChangeState = 0x0A7C,
        ChangeSkin = 0x21F3,
        MonsterSoulShop = 0x424D,
        MonsterSoulAvailableShop = 0x464D,
        Ruudbuy = 0xF0D0,
        RuudOpenBox = 0xF1D0,
        RuudSend = 0xF1D0,
    }

    public enum GensOpCode : ushort
    {
        RequestJoin = 0x01F8,
        RegMember = 0x02F8,
        RequestLeave = 0x03F8,
        ViewPortGens = 0x05F8,
        SendGensInfo = 0x07F8,
        RequestReward = 0x09F8,
        RemoveMember = 0x7F9,
        RewardSend = 0x0AF8,
        RequestMemberInfo = 0x0BF8,
    }

    public enum GuildOpCode : ushort
    {
        GuildRequest = 0xFF50,
        GuildResult = 0xFF51,
        GuildListAll = 0xFF52,
        RemoveUser = 0xFF53,
        MasterQuestion = 0xFF54,
        GuildSaveInfo = 0xFF55,
        GuildViewPort = 0xFF65,
        GuildReqViewport = 0xFF66,
        GuildSetStatus = 0xFFE1,
        GuildRelationShip = 0xFFE5,
        GuildRelationShipAns = 0xFFE6,
        GuildUnionList = 0xFFE9,

        GuildMatchingList = 0x00ED,
        GuildMatchingListSearch = 0x01ED,
        GuildMatchingRegister = 0x02ED,
        GuildMatchingRegisterCancel = 0x03ED,
        GuildMatchingJoin = 0x04ED,
        GuildMatchingJoinAccept = 0x06ED,
        GuildMatchingJoinCancel = 0x05ED,
        GuildMatchingJoinList = 0x07ED,
        GuildMatchingJoinInfo = 0x08ED,
        GUildMatchingNotify = 0x09ED,
        GUildMatchingNotifyMaster = 0x10ED,
    }

    public enum EventOpCode : ushort
    {
        RemainTime = 0xFF91,
        LuckyCoinsCount = 0x0BBF,
        LuckyCoinsRegistre = 0x0CBF,

        DevilSquareMove = 0xFF90,
        DevilSquareSet = 0xFF92,

        BloodCastleReward = 0xFF93,

        EventChipInfo = 0xFF94,

        BloodCastleEnter = 0xFF9A,
        BloodCastleState = 0xFF9B,

        ChaosCastleMove = 0x01AF,

        CrywolfState = 0x00BD,
        CrywolfStatueAndAltarInfo = 0x02BD,
        CrywolfContract = 0x03BD,
        CrywolfLeftTime = 0x04BD,
        CrywolfBossMonsterInfo = 0x05BD,
        CrywolfStageEffect = 0x06BD,
        CrywolfPersonalRank = 0x07BD,
        CrywolfHeroList = 0x08BD,
        CrywolfBenefit = 0x09BD,

        KanturuState = 0x00D1,
        KanturuEnter = 0x01D1,
        KanturuStateChange = 0x03D1,
        KanturuBattleResult = 0x04D1,
        KanturuBattleTime = 0x05D1,
        KanturuWideAttack = 0x06D1,
        KanturuMonsterUserCount = 0x07D1,

        ImperialGuardianEnter = 0x01F7,
        ImperialGuardianEnterResult = 0x02F7,
        ImperialGuardianNotifyZoneTime = 0x04F7,
        ImperialGuardianNotifyZoneAllClear = 0x06F7,

        ArcaBattleState = 0x38F8,
        Banner = 0x184D,

        CastleSiegeLeftTimeAlarm = 0x1EB2,
        CastleSiegeState = 0x00B2,
        CastleSiegeRegiste = 0x01B2,
        CastleSiegeGuildInfo = 0x03B2,
        CastleSiegeRegisteMark = 0x04B2,
        CastleSiegeSwitchNotify = 0x14B2,
        CastleSiegeCrownState = 0x16B2,
        CastleSiegeNotifyStart = 0x17B2,
        CastleSiegejoinSide = 0x19B2,
        CastleSiegeNotifySwitchInfo = 0x20B2,
        CastleSiegeGuildMarkOfOwner = 0x02B9,
        CastleSiegeGuildList = 0xFFB4,
        CastleSiegeMinimap = 0xFFB6,

        AcheronEnterReq = 0x4BF8,
        AcheronEnter = 0x4CF8,

        EventInventoryOpen = 0x0F4D,
        EventItemGet = 0x004D,
        EventItemThrow = 0x014D,
        EventInventory = 0x024D,

        // MiniGames
        MuRummyStart = 0x104D,
        MuRummyReveal = 0x114D,
        MuRummyPlayCard = 0x124D,
        MuRummyThrow = 0x134D,
        MuRummyMatch = 0x144D,
        MuRummySpecialMatch = 0x194D,
        MuRummyExit = 0x154D,
        MuRummyCardList = 0x164D,
        MuRummyMessage = 0x174D,

        MineSweeperStart = 0x234D,
        MineSweeperReveal = 0x244D,
        MineSweeperMark = 0x254D,
        MineSweeperEnd = 0x264D,
        MineSweeper = 0x274D,
        MineSweeperGetReward = 0x284D,
        MineSweeperCreateCell = 0x294D,

        BallsAndCowsStart = 0x304D,
        BallsAndCowsPick = 0x314D,
        BallsAndCowsOpen = 0x334D,
        BallsAndCowsResult = 0x344D,

        JeweldryBingoState = 0x2A4D,
        JeweldryBingoInfo = 0x2B4D,
        JeweldryBingoBox = 0x2C4D,
        JeweldryBingoPlayInfo = 0x2D4D,
        JeweldryBingoPlayResult = 0x2E4D,
    }
    public enum CashOpCode : ushort
    {
        CashItems = 0x05D0,
        CashPoints = 0x04F5,

        CashInit = 0x00D2,
        CashPointsS9 = 0x01D2,
        CashOpen = 0x02D2,
        CashItemBuy = 0x03D2,
        CashItemGif = 0x04D2,
        CashInventoryCount = 0x05D2,
        CashItemList = 0x06D2,
        CashVersion = 0x0CD2,
        CashBanner = 0x15D2,
    }

    public enum PCPShopOpCode : ushort
    {
        PCPShopPoints = 0x04D0,
        PCPShopBuy = 0x05D0,
        PCPShopInfo = 0x06D0,
        PCPShopItems = 0xFF31,
    }

    public enum QuestOpCode : ushort
    {
        SetQuest = 0xFFA1,
        SetQuestState = 0xFFA2,
        QuestPrize = 0xFFA3,
        QuestKillCount = 0xFFA4,
        QuestSurvivalTime = 0x01A5,
        QuestExp = 0x00F6,
        QuestSwitchListNPC = 0x0AF6,
        QuestExpInfo = 0x0BF6,
        QuestExpInfoAsk = 0x0CF6,
        QuestExpComplete = 0x0DF6,
        QuestEXPProgress = 0x1BF6,
        QuestExpProgressList = 0x1AF6,
        QuestEXPEventItemEPList = 0x21F6,
        QuestSwitchListEvent = 0x03F6,
        QuestSwitchListItem = 0x04F6,
        QuestMUTalk = 0x71F6,
        QuestMUAccept = 0x72F6,
        CentQuestTest = 0x203E,
        CentQuestSummon = 0x213E,
        CentQuestMove = 0x223E,
    }
}


--file PCPShopMessageFactory.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Network;

namespace MU.Network.PCPShop
{
    public interface IPCPShopMessage
    { }
    public class PCPShopMessageFactory : MessageFactory<PCPShopOpCode, IPCPShopMessage>
    {
        public PCPShopMessageFactory(ServerSeason Season)
        {
            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, true);
            Register<CPCPShopItems>(PCPShopOpCode.PCPShopInfo);
            Register<CPCPShopBuy>(PCPShopOpCode.PCPShopBuy);

            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, false);
            Register<SPCPShopInfo>(PCPShopOpCode.PCPShopInfo);
            Register<SPCPShopItems>(PCPShopOpCode.PCPShopItems);
            Register<SPCPShopPoints>(PCPShopOpCode.PCPShopPoints);
        }     
    }
}


--file PCPShop_C2S.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MU.Network.PCPShop
{
    [WZContract]
    public class CPCPShopItems : IPCPShopMessage
    { }

    [WZContract]
    public class CPCPShopBuy : IPCPShopMessage
    {
        [WZMember(0)]
        public byte Position { get; set; }
    }
}


--file PCPShop_S2C.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MU.Network.PCPShop
{
    [WZContract]
    public class SPCPShopPoints : IPCPShopMessage
    {
        [WZMember(0)]
        public ushort Points { get; set; }
        [WZMember(1)]
        public ushort MaxPoints { get; set; }

        public SPCPShopPoints()
        { }

        public SPCPShopPoints(ushort points, ushort maxPoints)
        {
            Points = points;
            MaxPoints = maxPoints;
        }

    }

    [WZContract]
    public class SPCPShopInfo : IPCPShopMessage
    {
        [WZMember(0)]
        public byte Unk { get; set; }

    }

    [WZContract(LongMessage = true)]
    public class SPCPShopItems : IPCPShopMessage
    {
        [WZMember(0)]
        public ushort wzCount { get; set; }

        public ushort Count { get => wzCount.ShufleEnding(); set => wzCount = value.ShufleEnding(); }

        [WZMember(1, typeof(ArraySerializer))]
        public PCPShopItemDto[] itemDtos { get; set; }

        public SPCPShopItems()
        {
            itemDtos = Array.Empty<PCPShopItemDto>();
            Count = 0;
        }

        public SPCPShopItems(PCPShopItemDto[] items)
        {
            itemDtos = items;
            Count = (ushort)items.Count();
        }
    }

    [WZContract]
    public class PCPShopItemDto
    {
        [WZMember(0)]
        public byte Position { get; set; }
        [WZMember(1)]
        public byte Index { get; set; }
        [WZMember(2)]
        public byte Opts { get; set; }
        [WZMember(3)]
        public byte Dur { get; set; }
        [WZMember(4)]
        public byte unk1 { get; set; }
        [WZMember(5)]
        public byte Exc { get; set; }
        [WZMember(6)]
        public byte Type16 { get; set; }
        [WZMember(7)]
        public SocketOption NewOpt1 { get; set; }
        [WZMember(8)]
        public SocketOption NewOpt2 { get; set; }
        [WZMember(9)]
        public SocketOption NewOpt3 { get; set; }
        [WZMember(10)]
        public SocketOption NewOpt4 { get; set; }
        [WZMember(11)]
        public SocketOption NewOpt5 { get; set; }
        [WZMember(12)]
        public byte unk2 { get; set; }
    }
}


--file Pentagrama_S2C.cs
﻿using MU.Network.Game;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MU.Network.Pentagrama
{
	[WZContract(LongMessage = true)]
    public class SPentagramaJewelInfo : IGameMessage
    {
        [WZMember(0)] public byte Result { get; set; }
		[WZMember(1)] public byte JewelCnt { get; set; }
		[WZMember(2)] public byte JewelPos { get; set; }

		[WZMember(3, typeof(ArraySerializer))] public PentagramaJewelDto[] List { get; set; }
	}

	[WZContract]
    public class PentagramaJewelDto
	{
        [WZMember(0)] public byte Result { get; set; }
		[WZMember(1)] public byte JewelPos { get; set; }
		[WZMember(2)] public byte JewelIndex { get; set; }
		[WZMember(3)] public byte MainAttribute { get; set; }
		[WZMember(4)] public byte ItemType { get; set; }
		[WZMember(5)] public ushort ItemIndex { get; set; }
		[WZMember(6)] public byte Level { get; set; }
		[WZMember(7)] public byte Rank1OptionNum { get; set; }
		[WZMember(8)] public byte Rank1Level { get; set; }
		[WZMember(9)] public byte Rank2OptionNum { get; set; }
		[WZMember(10)] public byte Rank2Level { get; set; }
		[WZMember(11)] public byte Rank3OptionNum { get; set; }
		[WZMember(12)] public byte Rank3Level { get; set; }
		[WZMember(13)] public byte Rank4OptionNum { get; set; }
		[WZMember(14)] public byte Rank4Level { get; set; }
		[WZMember(15)] public byte Rank5OptionNum { get; set; }
		[WZMember(16)] public byte Rank5Level { get; set; }
	}
}


--file QuestSystemMessageFactory.cs
﻿using MU.Network.Game;
using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Network;

namespace MU.Network.QuestSystem
{
    public interface IQuestMessage
    { }

    public class QuestSystemMessageFactory : MessageFactory<QuestOpCode, IQuestMessage>
    {
        public QuestSystemMessageFactory(ServerSeason Season)
        {
            // C2S
            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, true);
            Register<CSetQuestState>(QuestOpCode.SetQuestState);
            Register<CQuestEXP>(QuestOpCode.QuestSwitchListNPC);
            Register<CQuestEXPProgressList>(QuestOpCode.QuestExpProgressList);
            Register<CQuestEXPProgress>(QuestOpCode.QuestExpInfo);
            Register<CQuestEXPComplete>(QuestOpCode.QuestExpComplete); 
            Register<CNewQuestInfo>(QuestOpCode.QuestEXPProgress);
            Register<CQuestEXPEventItemEPList>(QuestOpCode.QuestEXPEventItemEPList);
            Register<CQuestNPCTalk>(QuestOpCode.QuestMUTalk);
            Register<CQuestNPCAccept>(QuestOpCode.QuestMUAccept);
            Register<CCentTestStart>(QuestOpCode.CentQuestTest);
            Register<CCentBattleStart>(QuestOpCode.CentQuestSummon);
            Register<CCentMove>(QuestOpCode.CentQuestMove);

            // S2C
            if(Season == ServerSeason.Season17Kor75) Converter = (opCode) => Data.ProtocolXChangeS17K75(opCode, false);
            Register<SSetQuest>(QuestOpCode.SetQuest);
            Register<SMonsterKillS16>(QuestOpCode.QuestKillCount);
            Register<SSendQuestPrize>(QuestOpCode.QuestPrize);
            Register<SSetQuestState>(QuestOpCode.SetQuestState);
            Register<SQuestSwitchListNPC>(QuestOpCode.QuestSwitchListNPC);
            Register<SQuestSwitchListEvent>(QuestOpCode.QuestSwitchListEvent);
            Register<SQuestSwitchListItem>(QuestOpCode.QuestSwitchListItem);
            Register<SQuestEXP>(QuestOpCode.QuestExp);
            Register<SQuestEXPProgressList>(QuestOpCode.QuestExpProgressList);
            Register<SSendQuestEXPProgress>(QuestOpCode.QuestExpInfo);
            Register<SSendQuestEXPProgressAsk>(QuestOpCode.QuestExpInfoAsk);
            Register<SSendQuestEXPInfo>(QuestOpCode.QuestEXPProgress);
            Register<SSendQuestEXPComplete>(QuestOpCode.QuestExpComplete);
            Register<SQuestSurvivalTime>(QuestOpCode.QuestSurvivalTime);
            Register<SQuestNPCAccept>(QuestOpCode.QuestMUAccept);
            Register<SQuestNPCTalk>(QuestOpCode.QuestMUTalk);
            Register<SNewQuestInfo>(QuestOpCode.QuestExpProgressList);
        }
    }
}


--file Quest_C2S.cs
﻿using MU.Network.Game;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MU.Network.QuestSystem
{
    [WZContract]
    public class CSetQuestState : IQuestMessage
    {
        [WZMember(0)] public byte Index { get; set; }
        [WZMember(1)] public byte State { get; set; }
    }
    [WZContract]
    public class CQuestEXP : IQuestMessage
    {
        [WZMember(0)] public uint Index { get; set; }
        [WZMember(1)] public byte Result { get; set; }
    }
    [WZContract]
    public class CQuestEXPProgress : IQuestMessage
    {
        [WZMember(0)] public uint Index { get; set; }
        [WZMember(1)] public byte Result { get; set; }
    }
    [WZContract]
    public class CQuestEXPComplete : IQuestMessage
    {
        [WZMember(0)] public uint Index { get; set; }
    }

    [WZContract]
    public class CQuestEXPProgressList : IQuestMessage
    { }

    [WZContract]
    public class SNewQuestInfo : IQuestMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))]
        public uint[] QuestList { get; set; }

        public SNewQuestInfo()
        {
            QuestList = Array.Empty<uint>();
        }
    }

    [WZContract]
    public class CQuestEXPEventItemEPList : IQuestMessage
    { }

    [WZContract]
    public class CNewQuestInfo : IQuestMessage
    {
        [WZMember(0)]
        public uint dwQuestInfoIndexID { get; set; }
    }

    [WZContract]
    public class CQuestNPCTalk : IQuestMessage
    {
        [WZMember(0)] public ushort NPC { get;set; }
    }


    [WZContract]
    public class CQuestNPCAccept : IQuestMessage
    {
        [WZMember(0)] public uint QuestInfoIndex { get; set; }
    }


    [WZContract]
    public class CCentTestStart : IQuestMessage
    { }

    [WZContract]
    public class CCentBattleStart : IQuestMessage
    { }

    [WZContract]
    public class CCentMove : IQuestMessage
    { }
}


--file Quest_S2C.cs
﻿using MU.Resources;
using MuEmu.Network.Data;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MU.Network.QuestSystem
{
    [WZContract]
    public class SSetQuest : IQuestMessage
    {
        [WZMember(0)] public byte Index { get; set; }
        [WZMember(1)] public byte State { get; set; }
    }
    [WZContract]
    public class MonsterKillCountDto
    {
        [WZMember(0)] public uint Monster { get; set; }
        [WZMember(1)] public uint Count { get; set; }
    }
    [WZContract]
    public class SMonsterKillS16 : IQuestMessage
    {
        [WZMember(0)] public byte Unk { get; set; }
        [WZMember(1)] public byte Result { get; set; }
        [WZMember(2)] public byte QuestId { get; set; }
        [WZMember(3)] public ushort Unk2 { get; set; }
        [WZMember(4, typeof(ArraySerializer))] public MonsterKillCountDto[] KillCount { get; set; } = new MonsterKillCountDto[5];
    }
    [WZContract]
    public class SSetQuestState : IQuestMessage
    {
        [WZMember(0)] public byte Index { get; set; }
        [WZMember(1)] public byte Result { get; set; }
        [WZMember(2)] public byte State { get; set; }

        public SSetQuestState()
        {

        }

        public SSetQuestState(byte id, byte result, byte state)
        {
            Index = id;
            Result = result;
            State = state;
        }
    }
    [WZContract]
    public class SSendQuestPrize : IQuestMessage
    {
        [WZMember(0)] public ushort Number { get; set; }
        [WZMember(1)] public QuestCompensation Type { get; set; }
        [WZMember(2)] public byte Count { get; set; }

        public SSendQuestPrize()
        {

        }

        public SSendQuestPrize(ushort id, QuestCompensation type, byte count)
        {
            Number = id.ShufleEnding();
            Type = type;
            Count = count;
        }
    }

    [WZContract]
    public class SQuestSwitchListNPC : IQuestMessage
    {
        [WZMember(0)] public ushort NPC { get; set; }
        [WZMember(1, serializerType:typeof(ArrayWithScalarSerializer<ushort>))]
        public uint[] QuestList { get; set; }
    }

    [WZContract]
    public class SQuestSwitchListEvent : IQuestMessage
    {
        [WZMember(0)] public ushort NPC { get; set; }
        [WZMember(1, serializerType: typeof(ArrayWithScalarSerializer<ushort>))]
        public uint[] QuestList { get; set; }
    }

    [WZContract]
    public class SQuestSwitchListItem : IQuestMessage
    {
        [WZMember(0)] public ushort NPC { get; set; }
        [WZMember(1, serializerType: typeof(ArrayWithScalarSerializer<ushort>))]
        public uint[] QuestList { get; set; }
    }

    [WZContract]
    public class SQuestEXP : IQuestMessage
    {
        [WZMember(0)] public byte Result { get; set; }
    }

    [WZContract]
    public class SSendQuestEXPProgress : IQuestMessage
    {
        [WZMember(0)] public uint dwQuestInfoIndexID { get; set; }
        /*[WZMember(1)] public byte AskCnt { get; set; }
        [WZMember(2)] public byte RewardCnt { get; set; }
        [WZMember(3)] public byte RandRewardCnt { get; set; }*/
    }

    [WZContract]
    public class SSendQuestEXPProgressAsk : IQuestMessage
    {
        [WZMember(0)] public uint dwQuestInfoIndexID { get; set; }
        [WZMember(1)] public byte AskCnt { get; set; }
        [WZMember(2)] public byte RewardCnt { get; set; }
        [WZMember(3)] public byte RandRewardCnt { get; set; }
        [WZMember(5, typeof(ArraySerializer))] public AskInfoDto[] Asks { get; set; }
        [WZMember(6, typeof(ArraySerializer))] public RewardInfoDto[] Rewards { get; set; }
    }

    [WZContract]
    public class AskInfoDto
    {
        [WZMember(0)] public AskType Type { get; set; }
        [WZMember(1)] public ushort Index { get; set; }
        [WZMember(2)] public uint Value { get; set; }
        [WZMember(3)] public uint CurrentValue { get; set; }
        [WZMember(4, typeof(BinarySerializer), 12)] public byte[] ItemInfo { get; set; } = Array.Empty<byte>();
    }

    [WZContract]
    public class RewardInfoDto
    {
        [WZMember(0)] public RewardType Type { get; set; }
        [WZMember(1)] public ushort Index { get; set; }
        [WZMember(2)] public uint Value { get; set; }
        [WZMember(4, typeof(BinarySerializer), 12)] public byte[] ItemInfo { get; set; } = Array.Empty<byte>();
    }

    [WZContract]
    public class SSendQuestEXPComplete : IQuestMessage
    {
        [WZMember(0)] public uint dwQuestInfoIndexID { get; set; }
        [WZMember(1)] public byte Result { get; set; }
    }

    [WZContract]
    public class SSendQuestEXPInfo : SSendQuestEXPProgressAsk
    { }

    [WZContract]
    public class SQuestEXPProgressList : IQuestMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<byte>))] public uint[] QuestInfoIndexID { get; set; }
    }

    [WZContract]
    public class QuestNPCTalkDto : IQuestMessage
    {
        [WZMember(0)] public uint QuestInfoIndex { get; set; }
        //[WZMember(1)] public ushort QuestID { get; set; }
        [WZMember(4)] public QuestState State { get; set; }
        [WZMember(5)] public byte unk { get; set; }
    }

    [WZContract]
    public class SQuestNPCTalk : IQuestMessage
    {
        [WZMember(0, typeof(ArrayWithScalarSerializer<ushort>))] public QuestNPCTalkDto[] QuestList { get; set; }
    }

    [WZContract]
    public class SQuestNPCAccept : IQuestMessage
    {
        [WZMember(0)] public uint QuestInfoIndex { get; set; }
        [WZMember(1)] public byte Result { get; set; }
    }

    [WZContract]
    public class SQuestSurvivalTime : IQuestMessage
    {
        [WZMember(0)] public QSType Type { get; set; }
        [WZMember(1)] public byte Increase { get; set; }
        [WZMember(2)] public ushort Unk { get; set; }
        [WZMember(3)] public uint Time { get; set; }
    }
}


--file UBF_C2S.cs
﻿using MU.Network.Game;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MuEmu.Network.UBFSystem
{
    [WZContract]
    public class CUsePopUpType : IGameMessage
    {
    }
}


--file UBF_S2C.cs
﻿using MU.Network.Game;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MuEmu.Network.UBFSystem
{
    [WZContract]
    public class SUBFInfo : IGameMessage
    {
        public byte Result { get; set; }
    }

    [WZContract]
    public class SUBFPopUpType : IGameMessage
    {
        public int Type { get; set; }
    }
}


--file VersionSelector.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using WebZen.Network;
using BlubLib;

namespace MU.Network
{
    public class VersionSelector
    {
        private ServerSeason _activeSeason;
        private Dictionary<ushort, Type> _active;
        private Dictionary<ServerSeason, Dictionary<ushort, Type>> _types = new Dictionary<ServerSeason, Dictionary<ushort, Type>>();
        private Dictionary<Type, ushort> _opCodeLookUp = new Dictionary<Type, ushort>();

        private static VersionSelector s_instance;

        private VersionSelector(ServerSeason s) { _activeSeason = s; }

        public static void Initialize(ServerSeason s)
        {
            if(s_instance == null)
                s_instance = new VersionSelector(s);
        }

        /// <summary>
        /// Associate a class with a server version
        /// </summary>
        /// <typeparam name="_T">Class Type of message</typeparam>
        /// <param name="season">server version</param>
        /// <param name="opCode">The message operation code</param>
        public static void Register<_T>(ServerSeason season, Enum opCode)
            where _T : new()
        {
            if(!s_instance._types.ContainsKey(season))
                s_instance._types.Add(season, new Dictionary<ushort, Type>());

            var usOpCode = Convert.ToUInt16(opCode);

            s_instance._types[season].Add(usOpCode, typeof(_T));
            s_instance._opCodeLookUp.Add(typeof(_T), usOpCode);

            if (s_instance._active == null && season == s_instance._activeSeason)
                s_instance._active = s_instance._types[season];

        }

        /// <summary>
        /// Create a message version matched with current server version
        /// </summary>
        /// <typeparam name="_T">Class Type of message</typeparam>
        /// <param name="args">Constructor Args</param>
        /// <returns>Instance of message</returns>
        public static object CreateMessage<_T>(params object[] args)
            where _T : new()
        {
            var result = s_instance._opCodeLookUp[typeof(_T)];
            if (s_instance._active?.ContainsKey(result)??false)
            {
                var type = s_instance._active[result];
                return Activator.CreateInstance(type, args);
            }

            try
            {
                var subType = (from d in s_instance._types
                               where d.Value.ContainsKey(result) && d.Key <= s_instance._activeSeason
                               select d)
                            .OrderByDescending(x => x.Key)
                            .First()
                            .Value[result];

                return Activator.CreateInstance(subType, args);
            }catch (Exception)
            {
                return Activator.CreateInstance(typeof(_T), args);
            }            
        }
    }
}


--file Gate.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MU.Resources.BMD
{
    [WZContract]
    public class GateBMD
    {
        [WZMember(0)] public GateType Flag { get; set; }
        [WZMember(1)] public byte Map { get; set; }
        [WZMember(2)] public byte X1 { get; set; }
        [WZMember(3)] public byte Y1 { get; set; }
        [WZMember(4)] public byte X2 { get; set; }
        [WZMember(5)] public byte Y2 { get; set; }
        [WZMember(6)] public ushort GateNumber { get; set; }
        [WZMember(7)] public byte Dir { get; set; }
        [WZMember(8)] public byte BZone { get; set; }
        [WZMember(9)] public ushort Level { get; set; }
        [WZMember(10)] public ushort BZLevel { get; set; }
    }
}


--file MoveReq.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MuEmu.Resources.BMD
{
    [WZContract]
    public class MoveReqBMD
    {
        [WZMember(0)]
        public int MoveNumber { get; set; }

        [WZMember(1, 32)]
        public byte[] btServerName { get; set; }

        [WZMember(2, 32)]
        public byte[] btClientName { get; set; }

        [WZMember(3)]
        public int Level { get; set; }

        [WZMember(4)]
        public int Zen { get; set; }

        [WZMember(5)]
        public int Gate { get; set; }

        public string ServerName { get => btServerName.MakeString(); set => btServerName = value.GetBytes(); }
        public string ClientName { get => btClientName.MakeString(); set => btClientName = value.GetBytes(); }
    }

    [WZContract]
    public class MoveReqBMDS9Eng
    {
        [WZMember(0)]
        public int MoveNumber { get; set; }

        [WZMember(1, typeof(BinaryStringSerializer), 32)]
        public string ServerName { get; set; }

        [WZMember(2, typeof(BinaryStringSerializer), 32)]
        public string ClientName { get; set; }

        [WZMember(3)]
        public int Level { get; set; }

        [WZMember(4)]
        public int Level2 { get; set; }

        [WZMember(5)]
        public int Zen { get; set; }

        [WZMember(6)]
        public int Gate { get; set; }
    }
}


--file Constants.cs
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace MU.Resources
{
    public enum QSType : byte
    {
        TimeLimit = 1,
        RemainingTime,
        HuntingTime,
        QuestSurvivalTime = 5,
    }
    public enum CharacterDeleteResult : byte
    {
        Error,
        Success,
        WrongSecurityCode,
    }
    // Event Inventory Flags
    public enum EventInventoryType : byte
    {
        None = 0,
        BattleCore = 1,
        Egg = 2,
        Evomon = 3,
        LunarRabbit = 4,
        XMas = 5,
        NewYear = 6,
        MuRummy = 7,
        FindBombs = 8,
        JeweldryBingo = 9,
        Blossom = 10,
        BallsAndCows = 11,
    };
    // JewelBingo State
    public enum JBState : byte
    {
        Open,
        State1,
        State2,
        BoxSelect,
        Playing,
        State5,
        State6,
        InsuficientCardDeck = 0x0E,
    }

    public enum JBType : byte
    {
        Bless,
        Soul,
        Life,
        Creation,
        Harmony,
        Chaos,
        Empty = 0xff,
    }

    [Flags]
    public enum GMInterestType : byte
    {
        LevelUp = 1,
        EventMap,
        PvP = 4,
        ArcaWar = 8,
        CastleSiege = 16,
    }
    [Flags]
    public enum GMLevelRange : byte
    {
        L1T100 = 1,
        L101T200 = 2,
        L201T300 = 4,
        L301T400 = 8,
        L400 = 16,
    }
    [Flags]
    public enum GMClass : ushort
    {
        DarkKnight = 1,
        Elf = 2,
        DarkWizard = 4,
        MagicGladiator = 8,
        DarkLord = 16,
        Summoner = 32,
        RageFighter = 64,
        GrowLancer = 128,
        RuneWizard = 256,
        Slayer = 512,
    }
    public enum PKLevel : byte
    {
        Hero2,
        Hero1,
        Hero,
        Commoner,
        Warning,
        Warning2,
        Murderer,
    }

    public enum EventIcon : byte
    {
        ChaosCastle = 1,
        BloodCastle = 2,
        DevilSquare = 3,
        IllusionTemple = 6,
        Doppelganger = 7,
    }

    public enum UseItemFlag : byte
    {
        Apply = 0xFE,
        Remove = 0xFF,
    }

    public enum OBResult : int
    {
        OKInvent = 2,
        OKEvent,
        FullZen = 0xFD,
        FullInventory,
        UnableToUse,
    }
    public enum GERepeatType
    {
        None,
        Annually,
        Monthly,
        Weekly,
        Daily,
    }
    public enum GuildUnionRequestType : byte
    {
        Join = 1,
        BreakOff,
    }
    public enum GuildRelationShipType : byte
    {
        Union = 1,
        Rivals,
    }
    public enum ItemType : byte
    {
        Sword,
        Axe,
        Scepter,
        Spear,
        BowOrCrossbow,
        Staff,
        Shield,
        Helm,
        Armor,
        Pant,
        Gloves,
        Boots,
        Wing_Orb_Seed,
        Missellaneo,
        Potion,
        Scroll,
        End,

        Invalid = 0xff
    };
    public enum SpecialNumber : ushort
    {
        AditionalDamage = 80,
        AditionalMagic = 81,
        SuccessFullBlocking = 82,
        AditionalDefense = 83,
        CriticalDamage = 84,
        RecoverLife = 85,
        ExcellentOption = 86,
        AddLife = 100,
        AddMana = 101,
        AddStamina = 103,
        AddLeaderShip = 105,
        CurseDamage = 113,
        AddMaxMana = 172,
        AddMaxStamina = 173,
        SetAttribute = 0xC3,
        AddStrength = 196,
        AddAgility = 197,
        AddEnergy = 198,
        AddVitality = 199,
    }
    public enum PetMode : byte
    {
        Normal = 0x0,
        AttackRandom = 0x1,
        AttackWithMaster = 0x2,
        AttackTarget = 0x3,

    };
    public enum CoinType : int
    {
        GPoints = 0,
        WCoin = 508,
    }

    public enum CSResult : byte
    {
        Ok,
        InsuficientWCoint = 1,
        InsuficientSpace = 2,
        ItemSouldOut,
        ItemIsNotCurrentAvailable,
        ItemIsNotLongerAvailable,
        ItemCannotBeBought,
        EventItemsCannotBeBought,
        MaxBoughtExceeded,
        IncorrectWCoinType,
    }

    public enum CSInventory : byte
    {
        Gift = 71,
        Storage = 83,
    }

    // Only Supported versions added
    public enum ServerSeason
    {
        Season6Kor,
        Season9Eng,
        Season12Eng,
        Season16Kor,
        Season17Kor,
        Season17Kor75,
    }
    public enum GremoryStorage : byte
    {
        Server = 1,
        Character,
        //Mobil,
        //PersonalStore,
    }
    public enum GremorySource : byte
    {
        ChaosCastle = 1,
        BloodCastle = 2,
        IllusionTemple = 3,
        DoppleGanger = 4,
        ChaosCastleSurvival = 5,
        TormentedSquare = 6,
        IllusionTempleLeague = 7,
        ChaosCastleSurvival2 = 8,
        TormentedSquareLeague = 9,
        ChaosCastleUBF = 10,
        EvomonReward = 12,
        DevilSquare = 13,
        ImperialFortress = 14,
        HYESUNG = 15,
        ProvidedElementalCombination = 16,
        Event = 17,
        LaberythOfDimensions = 18,
        Quest = 19,
        Mobil = 20,
        GMReward = 100
    }
    public enum GremoryNotice : byte
    {
        ItemAboutToExpire = 1,
        InventoryToBeFilled = 5,
        InventoryFull = 6,
    }
    public enum Element : byte
    {
        None,
        Fire,
        Water,
        Earth,
        Wind,
        Dark,
    }
    public enum GensType : byte
    {
        None,
        Duprian,
        Vanert,
    }
    public enum Messages
    {
        Server_Cfg,
        Server_Title,
        Server_MySQL_Error,
        Server_Error,
        Server_CSServer_Error,
        Server_Disconnecting_Accounts,
        Server_Ready,
        Server_GlobalAnnouncement,
        Server_MapAnnouncement,
        Server_NoEventMapAnnouncement,
        Server_Close,
        RCache_Initialized,
        RCache_Loading_Items,
        RCache_Loading_Spells,
        RCache_Loading_Maps,
        RCache_Loading_DefClass,
        RCache_Loading_Shops,
        RCache_Loading_NPCs,
        RCache_Loading_JoHs,
        RCache_Loading_Gates,
        RCache_Loading_Quests,
        RCache_Loading_ChaosMixs,
        MonsterMng_Loading,
        MonsterMng_Loading2,
        MonsterMng_Types,
        MonsterMng_Loaded,
        BC_Closed,
        BC_Open,
        BC_DoorKiller,
        BC_StatueKiller,
        DS_Closed,
        Chat_Player_Offline,
        Game_Close,
        Game_Close_Message,
        Game_Vault_active,
        Game_NoQuestAvailable,
        Game_DefaultNPCMessage,
        Game_Warp,
        Game_Warp2,
        Game_ChaosBoxMixError,
        Game_MonsterOutOfRange,
        BC_MonstersKilled,
        BC_BossKilled,
        BC_Open2,
        BC_WeaponOwner,
        BC_Winner,
        BC_Time,
        BC_WeaponError,
        Kanturu_NextBattle,
        Kanturu_CoreGateOpens,
        Kanturu_NightmareNotify,
        Kanturu_Successfull,
        Kanturu_Fail,
        Server_EventStateChange,
        IV_IndexAlreadyUsed,
        IVEX_AlreadyEquiped,
        IVEX_NeedMoreAgility,
        IVEX_NeedMoreEnergy,
        IVEX_NeedMoreCommand,
        IVEX_CharNotLogged,
        IVEX_NeedMoreVitality,
        IVEX_UnequipNoEquiped,
        IV_MoveItem,
        IVEX_NeedMoreStrength,
        IV_CantMove,
        IVEX_PentagramTradeLimit,
        IV_DBSaveDeletingItem,
        RCache_Loading_ItemBags,
        CS_RegisteNotify,
        CS_RegisteMarkNotify,
        CS_Idle3,
        CS_Notify,
        CS_LastNotify,
        Guild_RelationShipCantChange,
        GE_AddEvent,
        GE_GetItem,
        IA_CreateGroup,
        IA_DeleteGroup,
        Server_CSServer_Lost,
    }
    public enum MonsterSpell : ushort
    {
        ThunderBreak = 1,
        BloodyWind,
        FireRay,
        Very,
        VampiresRickTouch,
        //DarkElf
        GroupAddress,
        GroupTherapy,
        Geom,
        //Balram
        TheDirection,
        //Death Spirit
        ReduceManaAG,
        //Soram
        Push,
        //Balgass
        DirectLandHit,
        Balgass,
        //Kentauros
        MultiShot,
        //Persona
        Demon,
        //Twin Tail
        HairAttack,
        //Dread
        Twotimesapeer,
        //Nightmare
        DogAttack,
        Potlike,
        Summon,
        FireJeans,
        Warp,
        //Maya hand
        Pressure,
        PowerWave,
        IceStorm,
        BrokenShower,
        //Ghost
        Stern,
        dog,
        //
        Roar,
        Breakperiod,
        AngerStrike,
        //Cooler Tin
        DogBall,
        //
        Blow,
        // Selupan
        PoisonBall,
        FrostStorm,
        FrostShock,
        Fall,
        Recall,
        Healing,
        Icing,
        Teleportation,
        Invincible,
        Berserk,
        //Shieldbottle
        Defense,
        Shield,
        //HealingDisease
        HDHealing,
        //Quartermaster
        Skill01,
        Skill02,
        //Combat Instructor
        Skill03,
        //Knight Commander
        Skill04,
        //Archmage
        PillarofFire,
        WideMeteorite,
        //Assassinated leader
        Skill06,
        //Riders GM
        EarthShakes,
        Bite,
        //Riders Director
        HeadofCEE,
        //Dessler
        BladeDoor,
        Skill07,
        //Vermont
        Skill08 = 60,
        Skill09,
        //El kaneu
        Skill14,
        Skill15,
        //Ion
        BloodAttack,
        GigantikStorm,
        Flame,
        General,
        //Bloody Golem
        BGStern,
        //Location Queen
        Ice,
        //Berserker
        SternBall,
        //Zeno Outsider
        ZOStern,
        //Safi Queen
        SternRoom,
        //Ice Nail Pin
        INPIce,
        //Shadow Master
        SMStern,
        //The Dark memeodeu
        Solitary,
        //The Dark Giant
        Dokgong,
        //Dark Iron Knight
        Poison,
        //Medusa
        CursePoison,
        Chaotic,
        Gigantik,
        Evil,
        //Salamander
        OneHitSkill,
        TwoHitsSkill,
        German,
        //Undine
        UOneHitSkill,
        SkillStrikes2,
        UIce,
        //Gnome
        GOneHitSkill,
        GSkillStrikes2,
        Stun,
        //Silpideu
        SOneHitSkill,
        SSkillStrikes2,
        SPush,
        //Hill Lhasa
        HLOneHitSkill,
        HLSkillStrikes2,
        HLHPLoss,
        //Lord Silvester
        GeneralStrike,
        Windwhirlwind,
        Curseofthewind,
        Windcalled,
    }
    public enum Spell : ushort
    {
        None,
        Poison,
        Meteorite,
        Lighting,
        FireBall,
        Flame,
        Teleport,
        Ice,
        Twister,
        EvilSpirit,
        Hellfire,
        PowerWave,
        AquaBeam,
        Cometfall,
        Inferno,
        TeleportAlly,
        SoulBarrier,
        EnergyBall,
        Defense,
        Falling_Slash,
        Lunge,
        Uppercut,
        Cyclone,
        Slash,
        Triple_Shot,
        Heal = 26,
        GreaterDefense,
        GreaterDamage,
        Summon_Goblin = 30,
        Summon_StoneGolem,
        Summon_Assassin,
        Summon_EliteYeti,
        Summon_DarkKnight,
        Summon_Bali,
        Summon_Soldier,
        Decay = 38,
        IceStorm,
        Nova,
        TwistingSlash,
        RagefulBlow,
        DeathStab,
        CrescentMoonSlash,
        ManaGlaive,
        Starfall,
        Impale,
        GreaterFortitude,
        FireBreath,
        FlameofEvilMonster,
        IceArrow,
        Penetration,
        FireSlash = 55,
        PowerSlash,
        SpiralSlash,
        Combo = 59,
        Force = 60,
        FireBurst,
        Earthshake,
        Summon,
        IncreaseCriticalDmg,
        ElectricSpike,
        ForceWave,
        Stern,
        CancelStern,
        SwellMana,
        Transparency,
        CancelTransparency,
        CancelMagic,
        ManaRays,
        FireBlast,
        PlasmaStorm = 76,
        InfinityArrow,
        FireScream,
        DrainLife = 214,
        ChainLighting,
        ElectricSurge,
        Reflex,
        Berseker,
        Sleep = 219,
        Night,
        MagicSpeedUp,
        MagicDefenseUp,
        Sahamutt,
        Neil,
        GhostPhantom,

        RedStorm = 230,
        MagicCircle = 233,
        Recovery = 234,
        MultiShot = 235,
        LightingStorm = 237,

        SelupanPoison = 250,
        SelupanIceStorm,
        SelupanIceStrike,
        SelupanFirstSkill,

        //RF Skills
        KillingBlow = 260,
        BeastUppercut,
        ChainDrive,
        DarkSide,
        DragonRoar,
        DragonSlasher,
        IgnoreDefense,
        IncreaseHealth,
        IncreaseBlock,
        Charge,
        PhoenixShot,

        // Master Level
        SoulBarrier1 = 435,
        SoulBarrier2,
        SoulBarrier3,
        SoulBarrier4,
        SoulBarrier5,
        Hellfire1 = 440,
        Hellfire2,
        Hellfire3,
        Hellfire4,
        Hellfire5,
        EvilSpirit1 = 445,
        EvilSpirit2,
        EvilSpirit3,
        EvilSpirit4,
        EvilSpirit5,
        IceStorm1 = 450,
        IceStorm2,
        IceStorm3,
        IceStorm4,
        IceStorm5,
        TwistingSlash1 = 455,
        TwistingSlash2,
        TwistingSlash3,
        TwistingSlash4,
        TwistingSlash5,
        DeathStab1 = 460,
        DeathStab2,
        DeathStab3,
        DeathStab4,
        DeathStab5,
        RagefulBlow1 = 465,
        RagefulBlow2,
        RagefulBlow3,
        RagefulBlow4,
        RagefulBlow5,
        GreatFortitude1 = 470,
        GreatFortitude2,
        GreatFortitude3,
        GreatFortitude4,
        GreatFortitude5,
        Heal1 = 475,
        Heal2,
        Heal3,
        Heal4,
        Heal5,
        GreaterDefense1 = 480,
        GreaterDefense2,
        GreaterDefense3,
        GreaterDefense4,
        GreaterDefense5,
        GreaterDamage1 = 485,
        GreaterDamage2,
        GreaterDamage3,
        GreaterDamage4,
        GreaterDamage5,
    }
    public enum MiniMapTag : byte
    {
        Shield = 1,
        Conversation,
        Hammer,
        Elixir,
        Storage,
    }

    [Flags]
    public enum MapAttributes : byte
    {
        Safe = 1,
        Stand = 2,
        NoWalk = 4,
        Hide = 8,
        Unknow = 16,
    }
    public enum RewardType : uint
    {
        None = 0x00,
        Exp = 0x01,
        Zen = 0x02,
        Item = 0x04,
        Point = 0x10
    }
    public enum AskType : uint
    {
        None,
        Monster,
        Skill,
        Item = 4,
        LevelUp = 8,
        Tutorial = 16,
        Buff = 32,
        ChaosCastleUserKill = 0x40,
        ChaosCastleMonsterKill,
        BloodCastleDoorKill,
        BloodCastleClear = 0x100,
        ChaosCastleClear,
        DevilSquareClear,
        IllusionTempleClear,
    }
    [Flags]
    public enum EnableClassCreation : byte
    {
        Summoner = 1,
        DarkLord = 2,
        MagicGladiator = 4,
        RageFighter = 8,
        GrowLancer = 16,
    }
    public enum BannerType : int
    {
        MuRummy,
        EvenInven,
        Evomon,
        UnityBattleField,
        UnityBattleField2,
        MerryXMas,
        NewYear = 6,
        MuRummySpecial = 7,
        MineSweeper = 8,
        JeweldryBingo = 9,
        BallsAndCows = 11,
        Unk = 12,
        MULite = 13,
    }

    public enum TradeResult : byte
    {
        Error = 0,
        Ok = 1,
        InventoryFull = 2,
        CantTradeHarmonized = 4,
    }
    //S9Eng
    public enum StorageID : int
    {
        Equipament,
        Inventory = 12,// Size 64
        ExpandedInventory1 = 76, // Size 32
        ExpandedInventory2 = 108, // Size 32
        UnkInventory = 140, // Size 64??????
        PersonalShop = 204, // Size 32
        ChaosBox=300,
        TradeBox,
        Pentagram,
        MuunInventory,
        EventInventory,
        Warehouse=400,
    }

    public enum LoginStatus
    {
        NotLogged,
        Logged,
        Playing
    }

    public enum LoginResult : byte
    {
        PasswordError,
        Ok = 1,
        AccountError,
        IsConnected,
        ServerFull,
        IsBanned,
        OldVersion,
        ConnectionError,
        ConnectionClosed3Fail,
        OnlyVIP,
        VipEnding,
        VipEnded,
        VipEnded2,

        OkWithItemBlock = 15,
    }

    public enum ControlCode : byte
    {
        Normal,
        CharacterBlock,
        ItemBlock,
        GameMaster = 0x20,
    }

    public enum Maps : ushort
    {
        Lorencia,
        Dugeon,
        Davias,
        Noria,
        LostTower,
        Exile,
        Stadium,
        Atlans,
        Tarkan,
        DevilSquare,
        Icarus,
        BloodCastle1,
        BloodCastle2,
        BloodCastle3,
        BloodCastle4,
        BloodCastle5,
        BloodCastle6,
        BloodCastle7,
        ChaosCastle1,
        ChaosCastle2,
        ChaosCastle3,
        ChaosCastle4,
        ChaosCastle5,
        ChaosCastle6,
        Kalima1,
        Kalima2,
        Kalima3,
        Kalima4,
        Kalima5,
        Kalima6,
        ValleyofLoren,
        LandofTrial,
        DevilSquare2,
        Aida,
        Crywolf,
        // null
        Kalima7 = 36,
        Kantru1,
        Kantru2,
        Kantru3,
        SilentSwamp,
        BarracksofBalgass,
        BalgassRefuge,
        T43,
        T44,
        IllusionTemple1,
        IllusionTemple2,
        IllusionTemple3,
        IllusionTemple4,
        IllusionTemple5,
        IllusionTemple6,
        Elbeland,
        BloodCastle8,
        ChaosCastle7,
        // null
        // null
        SwampOfCalmness = 56,
        Raklion,
        Selupan,
        // null
        // null
        Buhwajang = 61,
        SantaTown,
        Vulcan,
        DuelArena,
        DoppelgangerSnow,
        DoppelgangerVulcan,
        DoppelgangerSea,
        DoppelgangerCrystals,
        ImperialGuardian1,
        ImperialGuardian2,
        ImperialGuardian3,
        ImperialGuardian4,
        LorenMarket = 79,
        Karutan1,
        Karutan2,
        DoppelgangerRenewal,
        Acheron = 91,
        ArkaWar,
        Debenter = 95,
        ArcaBattle,
        ChaosCastleSurvival,
        IllussionTempleLeague1,
        IllussionTempleLeague2,
        UrkMontain1,
        UrkMontain2,
        TormentedSquareoftheFittest,
        TormentedSquare1,
        TormentedSquare2,
        TormentedSquare3,
        TormentedSquare4,
        Nars = 110,
        Ferea = 112,
        NixieLake,
        LabyrinthEntrance,
        Labyrinth,
        DeepDungeon1,
        DeepDungeon2,
        DeepDungeon3,
        DeepDungeon4,
        DeepDungeon5,
        NewQuest,
        SwampOfDarkness,
        KuberaMineArea1,
        KuberaMineArea2,
        KuberaMineArea3,
        KuberaMineArea4,
        KuberaMineArea5,
        AbyssOfAtlas1,
        AbyssOfAtlas2,
        AbyssOfAtlas3,
        ScorchedCanyon,
        InvalidMap = 255,
    }

    public enum MapEvents : byte
    {
        GoldenInvasion = 3
    }

    public enum HackCheck : ushort
    {
        InvalidPacket = 0x0006,
        StrangePacket = 0xF300,
    }

    public enum HeroClass : byte
    {
        DarkWizard,
        SoulMaster,
        GranMaster,
        SoulWizard = 7, //4TH Class
        DarkKnight = 0x10,
        BladeKnight,
        BladeMaster,
        DragonKnight = 0x17, //4TH Class
        FaryElf = 0x20,
        MuseElf,
        HighElf,
        NobleElf = 0x27, //4TH
        MagicGladiator = 0x30,
        DuelMaster,
        MagicKnight = 0x37, //4TH
        DarkLord = 0x40,
        LordEmperator,
        EmpireLord = 0x47,
        Summoner = 0x50,
        BlodySummoner,
        DimensionMaster,
        DimensionSummoner = 0x57, //4TH
        RageFighter = 0x60,
        FistMaster,
        FistBlazer = 0x67,//4TH
        GrowLancer = 0x70,
        MirageLancer,
        ShinningLancer = 0x77, //4TH
        RuneWizard = 0x80,
        RuneSpellMaster,
        GrandRuneMaster,
        MajesticRuneWizard = 0x87, //4TH
        Slayer = 0x90,
        RoyalSlayer,
        MasterSlayer,
        Slaughterer = 0x97,
        GunCrusher = 0xA0,
        GunBreaker,
        MasterGunBreaker,
        HeistGunCrasher = 0xA7, //4TH
        End = 0xff,
    }

    public enum Equipament
    {
        RightHand,
        LeftHand,
        Helm,
        Armor,
        Pants,
        Gloves,
        Boots,
        Wings,
        Pet,
        Pendant,
        RightRing,
        LeftRing,
        //End,
        Pentagrama = 236,
        Earring1,
        Earring2,
    }


    [Flags]
    public enum ExcellentOptionArmor
    {
        None = 0,
        IncreaseZen = 1,//Increase Zen +40%
        DefenseSuccessRate = 2,//Defense Success rate +10%
        ReflectDamage = 4,//Reflect Damage +5%
        DamageDecrease = 8, //Damage Decrease +4%
        IncreaseMana = 16,//Increase Mana +4%
        IncreaseHP = 32,//Increase HP +4%
        FullItem = IncreaseZen | DefenseSuccessRate | ReflectDamage | DamageDecrease | IncreaseMana | IncreaseHP,
    }


    [Flags]
    public enum ExcellentOptionWeapons
    {
        None = 0,
        IncreaseManaRate = 1,//Increase Adquisition rate of Mana after hunting monsters Mana/8
        IncreaseLifeRate = 2,//Increase Adquisition rate of Mana after hunting monsters life/8
        IncreaseAttacking = 4,//Increase Attacking (Wizardry) speed + 7
        IncreaseWizardryRate = 8, //Increase Wizardry Dmg 2%
        IncreaseWizardry = 16,//Increase Wizardry Level/20
        ExcellentDmgRate = 32,//Excellent Dmg Rate 10%
        FullItem = IncreaseManaRate | IncreaseLifeRate | IncreaseAttacking | IncreaseWizardryRate | IncreaseWizardry | ExcellentDmgRate,
    }

    // Level*50+Type
    public enum SocketOption : byte
    {
        SocketFire = 0, //Attack/Wizardy Increase +57
        SocketFire_2,//Attack Speed Increase +11
        SocketFire_3,//Maximum attack/Wizardy Increase +50
        SocketFire_4,//Minimum attack/Wizardy Increase +35
        SocketFire_5,//Attack/Wizardy Increase +35
        SocketFire1 = 50, 
        SocketFire2 = 100, 
        SocketFire3 = 150, 
        SocketFire4 = 200, 
        SocketWater = 10, //Block rating increase +14%
        SocketWater1 = 51, //Defense Increase +42
        SocketWater2 = 101, //Shield protection increase +30%
        SocketWater3 = 151, //Damage reduction +8%
        SocketWater4 = 201, //Damage reflection +9%
        SocketIce = 20, //Monster destruction for the Life increase +16250
        SocketIce1 = 52, //Monster destruction for the Mana increase +16250
        SocketIce2 = 102, //Skill attack increase +50
        SocketIce3 = 152, //Attack rating increase +40
        SocketIce4 = 202, //Item durability increase +38%
        SocketWind = 30, //Automatic Life recovery increase +20
        SocketWind1 = 53, //Maximum Life increase +8%
        SocketWind2 = 103, //Maximim Mana increase +8%
        SocketWind3 = 153, //Automatic Mana recovery increase +35
        SocketWind4 = 203, //Maximum AG increase +50
        SocketLightning = 40, //Exelen damage increase +40
        SocketLightning1 = 54, //Exelen damage rate increase +14%
        SocketLightning2 = 104, //Critical damage increase +50
        SocketLightning3 = 154, //Critical damage rate increase +12%
        SocketLightning4 = 204,
        //SocketGround = 50,
        //SocketGround1 = 55,
        //SocketGround2 = 105, //Hearth increase +38
        //SocketGround3 = 155,
        //SocketGround4 = 205,

        EmptySocket = 0xfe,
        None = 0xff
    }

    public enum GuildStatus : byte
    {
        Member,
        BattleMaster = 0x20,
        Assistant = 0x40,
        GuildMaster = 0x80,
        NoMember = 0xff
    }

    public enum GuildResult : byte
    {
        Fail = 0x00,
        Success = 0x01,
        CannotAcceptMoreMembers = 0x02,
        PlayerOffline = 0x03,
        NotGuildMaster = 0x04,
        HaveGuild = 0x05,
        InTransaction = 0x06,
        InsuficientLevel = 0x07,
        NotExist = 0x10,
        //UnionFail,
        NotExistPermission,
        NotExistExtraStatus,
        NotExistExtraType,
        ExistRelationshipUnion = 0x15,
        ExistRealtionshipRival,
        ExistUnion,
        ExistRival,
        NotExistUnion,
        NotExistRival,
        NotUnionMaster,
        NotRival,
        CannotBeUnionMaster,
        ExceedMaxUnionMembers,
        CancelRequest = 0x20,
        AllyMasterNoGems = 0xA1,
        DifferentGens = 0xA3,
    }

    public enum GuildRelation : byte
    {
        None,
        Union,
        Rival,
        UnionMaster = 4,
        RivalMaster = 8,
    }

    public enum LetterStatus : byte
    {
        Readed,
        UnReaded,
        New,
    }

    public enum RefillInfo : byte
    {
        MaxChanged = 0xFE,
        Update = 0xFD,
        Drink = 0xFF,
    }

    public enum PointAdd : byte
    {
        Strength,
        Agility,
        Vitality,
        Energy,
        Command,
    }

    public enum ClientCloseType : byte
    {
        CloseGame,
        SelectChar,
        ServerList,
    }

    public enum MoveItemFlags : byte
    {
        Inventory,
        Trade,
        Warehouse,
        ChaosBox,
        PersonalShop,
        DarkTrainer = 5,
        ElpisBox,
        OsboumeBox,
        JerridonBox,
        UnsocketSeedBox = 11,
        SeedMasterBox = 12,
        SeedAplication,
        PentagramBox = 17,
        Event = 21,
        Muun = 22,
    }

    public enum NoticeType : byte
    {
        Gold,
        Blue,
        Guild
    }

    public enum EventEnterType : byte
    {
        DevilSquare = 1,
        BloodCastle,
        ChaosCastle = 4,
        IllusionTemple,
    }

    public enum ObjectType
    {
        NPC,
        Monster,
        Gate,
    }

    public enum ObjectState
    {
        Regen,
        Live,
        Dying,
        Dying2,
        Die,
        WaitRegen,
        Invulnerable,
    }

    public enum NPCAttributeType
    {
        Warehouse,
        Shop,
        Quest,
        Buff,
        Window,
        EventChips,
        MessengerAngel,
        KingAngel,
        GuildMaster,
        Kanturu,
        DevilSquare,
        ServerDivision,
        Talk,
        Gens,
        CastleSiege,
        CastleSiegeCrown,
        CastleSiegeCrownSwitch,
        MossMerchant,
        ShopRuud,
    }

    public enum NPCWindow : byte
    {
        Shop = 0,
        Warehouse = 2,
        ChaosMachine = 3,
        DevilSquared = 4,
        MessengerAngel = 6,
        JewelMixer = 9,
        ChaosCard = 21,
        BlossomGovernor = 22,
        SokcetMaster = 23,
        SokcetResearcher = 24,
        LuckyCoins = 32,
        GateKeeper = 33,
        Sartigan = 35,
        LeoTheHelper = 38,
        RuudShop = 53,
    }

    public enum AttributeType
    {
        Ice,
        Poison,
        Light,
        Fire,
        Earth,
        Wind,
        Water,
    }

    public enum TaxType : byte
    {
        Warehouse = 1,
        Shop,
    }

    public enum ServerCommandType : byte
    {
        Fireworks,
        EventMsg,
        DefaultMsg = 4,
        ServerDivision = 6,
        ShadowPhantom = 0x0D,
        DevilSquarePK = 0x37,
        BloodCastlePK,
        ChaosCastlePK,
    }

    public enum EventMsg : byte
    {
        YouNeedInvitationDS = 2,
        DevilStarted, //???
        DevilDisabled = 6, //???
        RunningBC = 0x14,
        YouNeedInvitationBC = 0x15,
        SucceedBC = 0x17,
        InvalidBC = 0x18,
        GoAheadBC = 0x2D,
        CompletedBC = 0x2E,
    }

    public enum DefaultMsg
    {
        Guard,
        DeviasMadam,
        Lala,
    }

    public enum TalkResult : byte
    {
        Shop,
        WareHouse = 2,
        DevilSquare = 4,
    }

    public enum DamageType : ushort
    {
        Regular,
        Excellent = 2,
        Critical,
        Beat,
        Poison,
        Reflect,
        White,
        Miss = 9,
        Double = 0x40,
        Combo = 0x80,
    }

    public enum SkillStates : ushort
    {
        Attack = 1,
        Defense,
        ShadowPhantom,
        SoulBarrier,
        CriticalDamage,
        InfinityArrow,
        RecoverySpeed,
        SwellLife,
        SwellMana,
        PotionBless,
        PotionSoul,
        MagicCancel,
        CastleSiegeDoorState,
        CastelSiegeDefenseMark,
        CastleSiegeAttackOne,
        CastleSiegeAttackTwo,
        CastleSiegeAttackTree,
        Transparency,
        CastleSiegeDarkLord,
        CastleSiegeCrownState,
        AltarCanContract,
        AltarCantContract,
        AltarValidContract,
        AltarOfWolfCA,
        Admin,
        AltarOfWolfHCS,
        Invisible,
        GameMaster,
        SealAscencion,
        SealWealth,
        SealSustance,
        IllusionQuickness,
        IllusionSublimation,
        IllusionProtection,
        HAttackSpeed,
        HAttackPower,
        HDefensePower,
        HMaxLife,
        HMaxMana,
        SealAscencion2,
        SealWealth2,
        SealSustance2,
        SealMovement,
        ScrollQuick,
        ScrollDefense,
        ScrollDamage,
        ScrollPower,
        ScrollStamina,
        ScrollMana,
        ElixirPower,
        ElixirDefense,
        ElixirStamina,
        ElixirEnergy,
        ElixirCommand,
        Poison,
        Ice,
        IceArrow,
        DefenseDown,
        PhysicalDamageInmunity,
        MagicalDamageInmunity,
        Stun,
        MagicDefense,
        MonsterPhysicalDamageInmunity,
        MonsterMagicalDamageInmunity,
        IllusionOorderOfBondage,
        CrywolfStatueLevel1,
        CrywolfStatueLevel2,
        CrywolfStatueLevel3,
        CrywolfStatueLevel4,
        CrywolfStatueLevel5,
        SkillDamageDeflection,
        SkillSleep,
        SkillBlindness,
        SkillNeil,
        SkillSahamut,
        SkillNiceweek,
        SkillINNERBEIYSEYON,
        CherryManabuff,
        CherryLifebuff,
        CherryDamagebuff,
        SkillSwordPower,
        SkillMagicCircle,
        SkillSwordSlashEffect,
        SkillLightningStorm,
        SkillRedStorm,
        SkillCold,
        SealRed,
        SealYellow,
        USword,
        UTriangle,
        ImproveDefenseOfense,
        improveMaxLife,
        ImproveMana,
        ImproveDamage,
        ImrpoveDefense,
        improveAttackSpeed,
        ImproveBPRecovery,
        DuelInterface,
        TalismanOfGuardian,
        TalismanOfProtection,
        MasterSealOfAscension,
        MasterSealOfWealt,
        DuelMedal,
        SealOfStrength,
        DoubleGoerDelete,
        PKPenalty,
        MuBlueTired,
        MuBlueExhaust,
        PartyExperienceBonus = 112,
        MaxAGBoostAura,
        MaxSDBoostAura,
        MuBlueMinimunVitality,
        MuBlueLowVitality,
        MuBlueMediumVitality,
        MuBlueHighVitality,
        PCSMark7,
        HackToolPenalty,
        ScrollOfHealing,
        HawkFigurine,
        GoatFigurine,
        OakCharm,
        MapleCharm,
        GoldenOakCharm,
        GoldenMapleCharm,
        WornHorseshoe,
        GreaterIgnoreDefenseRate,
        Fitness,
        GreaterDefenseSuccessRate,
        MonkDecreaseDefenseRate,
        IronDefense,
        GreaterLifeEnhanced,
        GreaterLifeMastered,
        DeathStabEnhanced,
        MagicCircleImproved,
        MagicCircleEnhanced,
        ManaShieldMastered,
        FrozenStabMastered,


        UseMountUniria = 205,
        UseMountDinorant,
        UseMountDarkHorse,
        UseMountFenrir,

        Berseker=266,
    }

    public enum GateType : byte
    {
        Warp,
        Entrance,
        Exit,
    }

    public enum QuestState : byte
    {
        Clear,
        Reg,
        Complete,
        Unreg,
    }

    public enum QuestCompensation : byte
    {
        Statup = 200,
        Changeup,
        Plusstat,
        Comboskill,
        Master,
        AllStatsUp,
        Majestic,
    }

    public enum DevilSquareState : byte
    {
        Close = 0,
        Open = 1,
        Playing = 2,
        None = 3,
        BeforeStart = 4,
        BeforeEnd = 5,
        Quit = 6,
        CCBeforeEnter = 10,
        CCBeforePlay = 11,
        CCBeforeEnd = 12
    }

    public enum ChaosBoxMixResult : byte
    {
        Fail,
        Success,
        InsufficientMoney,
        TooManyItems,
        LowLevelUser,
        LackingItems = 6,
        IncorrectItems,
        InvalidItemLevel,
        UserClassLow,
        NoBcCorrectItems,
        BcInsufficientMoney,

        PentagramaUpgradeFail = 0xE1,
        PentagramaRefineFail,
        PentagramaFailWithTalisman,
        PentagramaSuccessNotFound = 0xF8,
        PentagramaInsufficientMoney,
        PentagramaLackingItems,
        PentagramaAttributeMissMatch,
        PentagramaRefineNotFound,
    }

    public enum ChaosMixType : byte
    {
        Default = 0x1,
        DevilSquared = 0x2,
        Plus10 = 0x3,
        Plus11 = 0x4,
        Dinorant = 0x5,
        Fruit = 0x6,
        WingLv2 = 0x7,
        BloodCastle = 0x8,
        WingLv1 = 0xb,
        SetItem = 0xc,
        DrakHorse = 0xd,
        DarkSpirit = 0xe,
        BlessPotion = 0xf,
        SoulPotion = 0x10,
        LifeStone = 0x11,
        HTBox = 0x14,
        Plus12 = 0x16,
        Plus13 = 0x17,
        Cloak = 0x18,
        Fenrir1 = 0x19,
        Fenrir2 = 0x1a,
        Fenrir3 = 0x1b,
        Fenrir4 = 0x1c,
        CounpundPotionL1 = 0x1e,
        CounpundPotionL2 = 0x1f,
        CounpundPotionL3 = 0x20,
        JOHPurity = 0x21,
        JOHSmeltingItem = 0x22,
        JOHRestore = 0x23,
        Item380 = 0x24,
        LotteryMix = 0x25,
        OldPaper = 0x25,
        CondorFeather = 0x26,
        WingLv3 = 0x27,
        SeedExtract = 0x2a,
        SeedSphere = 0x2b,
        SeedCalc = 0x2c,
        Mix2 = 0x2d,
        Secromicom = 0x2e,
        Plus14 = 49,
        Plus15 = 50,
    };

    public enum ClientEffect : byte
    {
        RecoverShield = 3,
        LevelUp = 16,
        ShieldDamage = 17,
    }

    public enum PartyResults : byte
    {
        Fail,
        Success,
        PlayerOffline = 0x03,
        InAnotherParty = 0x04,
        RestrictedLevel = 0x05
    }

    public enum KanturuState : byte
    {
        None,
        BattleStandBy,
        BattleOfMaya,
        BattleOfNightmare,
        TowerOfRefinery,
    }

    public enum DuelResults : byte
    {
        NoError,
        Failed,
        InvalidUser,
        NonPKServer,
        NonDuelCSServer,
        ConnectionClosing,
        NotDuelMurderer,
        AlreadyDuelled,
        InvalidMap,
        LimitPacketTime,
        InvitedMyself,
        InvalidIndex,
        Disconnected,
        SelfDefense,
        GuildWar,
        RefuseInvitated,
        DuelMax,
        InvalidStatus,
        AlreadyDuelRequested,
        AlreadyDuelReserved,
        AlreadyDuelling,
        AlreadyDuelRequested1,
        AlreadyDuelReserved1,
        AlreadyDuelling1,
        InvalidChannelId,
        FailedEnter,
        NotExistUser,
        ObserverMax,
        LimitLevel,
        NotFoundMoveReqData,
        NotEnoughMoney
    }

    public enum PShopResult : byte
    {
        Disabled,
        Success,
        InvalidPosition,
        InvalidItem,
        InvalidPrice,
        LevelTooLow,
        ItemBlocked,
        LackOfZen,
        ExceedingZen,
        LackOfBless = 11,
        LackOfSoul = 12,
        LackOfChaos = 13,
        SellerInventoryFull = 17,
    }
}

namespace MU.Resources
{
    public enum PIGrade
    {
        None,
        Common,
        Unique,
        Rare,
    }
}

--file CharacterInfo.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu.Resources.Game
{
    public class StatsInfo
    {
        public int Str { get; set; }
        public int Agi { get; set; }
        public int Vit { get; set; }
        public int Ene { get; set; }
        public int Cmd { get; set; }
    }

    public class AttriInfo
    {
        public float Life { get; set; }
        public float Mana { get; set; }
        public float LevelLife { get; set; }
        public float LevelMana { get; set; }
        public float VitalityToLife { get; set; }
        public float EnergyToMana { get; set; }

        public float StrToBP { get; set; }
        public float AgiToBP { get; set; }
        public float VitToBP { get; set; }
        public float EneToBP { get; set; }
        public float CmdToBP { get; set; }
    }
}


--file DSItemBagDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MU.Resources.Game
{
    [XmlRoot("root")]
    [XmlType(AnonymousType = true)]
    public class DSItemBagDto
    {
        [XmlElement] public DSIBDropInfoDto[] Section0 { get; set; }
        [XmlElement] public DSIBEventInfoDto[] Section1 { get; set; }
        [XmlElement] public DSIBBagInfoDto[] Section2 { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class DSIBDropInfoDto
    {
        [XmlAttribute] public byte MapIndex { get; set; }
        [XmlAttribute] public byte DropFlag { get; set; }
        [XmlAttribute] public ushort MinMonsterLevel { get; set; }
        [XmlAttribute] public ushort MaxMonsterLevel { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class DSIBEventInfoDto
    {
        [XmlAttribute] public string EventName { get; set; }
        [XmlAttribute] public int DropZen { get; set; }
        [XmlAttribute] public byte BoxType { get; set; }
        [XmlAttribute] public ushort BoxIndex { get; set; }
        [XmlAttribute] public byte BoxLevel { get; set; }
        [XmlAttribute] public short BoxDropRate { get; set; }
        [XmlAttribute] public short ItemDropRate { get; set; }
        [XmlAttribute] public short ExRate { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class DSIBBagInfoDto
    {
        //minLvl	maxLvl	Skill	Luck	maxZ28	maxExOpt
        [XmlAttribute] public byte Type { get; set; }
        [XmlAttribute] public ushort Index { get; set; }
        [XmlAttribute] public byte minLvl { get; set; }
        [XmlAttribute] public byte maxLvl { get; set; }
        [XmlAttribute] public byte Skill { get; set; }
        [XmlAttribute] public byte Luck { get; set; }
        [XmlAttribute] public byte maxZ28 { get; set; }
        [XmlAttribute] public byte maxExOpt { get; set; }
    }
}


--file Gate.cs
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;

namespace MU.Resources.Game
{
    public class Gate
    {
        public int Number { get; set; }

        public GateType GateType { get; set; }

        public Maps Map { get; set; }


        public Rectangle Door { get; set; }
        //public byte X1 { get; set; }

        //public byte Y1 { get; set; }

        //public byte X2 { get; set; }

        //public byte Y2 { get; set; }

        public int Target { get; set; }

        public int Move { get; set; }

        public string Name { get; set; }

        public byte Dir { get; set; }

        public ushort ReqLevel { get; set; }

        public ushort ReqZen { get; set; }
    }
}


--file JewelOfHarmonyOption.cs
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu.Resources.Game
{
    public class JewelOfHarmonyOption
    {
        public byte Type { get; set; }
        public byte Index { get; set; }
        public string Name { get; set; }
        public int[] Value { get; set; }
        public int[] Zen { get; set; }
    }
}


--file JOHDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MU.Resources.Game
{
    [XmlRoot("JewelOfHarmony")]
    public class JOHDto
    {
        [XmlElement] public JOHSectionDto[] Section0 { get; set; }
        [XmlElement] public JOHSectionDto[] Weapon { get; set; }
        [XmlElement] public JOHSectionDto[] Staff { get; set; }
        [XmlElement] public JOHSectionDto[] Defense { get; set; }
    }

    public class JOHSectionDto
    {
        [XmlAttribute] public int Index { get; set; }
        [XmlAttribute] public string Name { get; set; }
        [XmlAttribute] public int Weighted { get; set; }
        [XmlAttribute] public int Level { get; set; }
        [XmlAttribute] public int Level0 { get; set; }
        [XmlAttribute] public int Zen0 { get; set; }
        [XmlAttribute] public int Level1 { get; set; }
        [XmlAttribute] public int Zen1 { get; set; }
        [XmlAttribute] public int Level2 { get; set; }
        [XmlAttribute] public int Zen2 { get; set; }
        [XmlAttribute] public int Level3 { get; set; }
        [XmlAttribute] public int Zen3 { get; set; }
        [XmlAttribute] public int Level4 { get; set; }
        [XmlAttribute] public int Zen4 { get; set; }
        [XmlAttribute] public int Level5 { get; set; }
        [XmlAttribute] public int Zen5 { get; set; }
        [XmlAttribute] public int Level6 { get; set; }
        [XmlAttribute] public int Zen6 { get; set; }
        [XmlAttribute] public int Level7 { get; set; }
        [XmlAttribute] public int Zen7 { get; set; }
        [XmlAttribute] public int Level8 { get; set; }
        [XmlAttribute] public int Zen8 { get; set; }
        [XmlAttribute] public int Level9 { get; set; }
        [XmlAttribute] public int Zen9 { get; set; }
        [XmlAttribute] public int Level10 { get; set; }
        [XmlAttribute] public int Zen10 { get; set; }
        [XmlAttribute] public int Level11 { get; set; }
        [XmlAttribute] public int Zen11 { get; set; }
        [XmlAttribute] public int Level12 { get; set; }
        [XmlAttribute] public int Zen12 { get; set; }
        [XmlAttribute] public int Level13 { get; set; }
        [XmlAttribute] public int Zen13 { get; set; }
    }
}


--file ShopDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MU.Resources.Game
{
    [XmlRoot("Shop")]
    [XmlType(AnonymousType = true)]
    public class ShopInfoDto
    {
        [XmlAttribute] public string Description { get; set; }
        [XmlElement("Item")] public ShopRowDto[] Item { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class ShopRowDto
    {
        [XmlAttribute] public byte Type { get; set; }
        [XmlAttribute] public ushort Index { get; set; }
        [XmlAttribute] public byte Plus { get; set; }
        [XmlAttribute] public byte Durability { get; set; }
        [XmlAttribute] public bool Skill { get; set; }
        [XmlAttribute] public bool Luck { get; set; }
        [XmlAttribute] public byte Option { get; set; }
        [XmlAttribute] public byte Excellent { get; set; }
    }
}


--file WZItemBagDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MU.Resources.Game
{
    [XmlRoot("root")]
    [XmlType(AnonymousType = true)]
    public class WZItemBagDto
    {
        [XmlElement] public WZIBBagDto[] BagDtos { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class WZIBBagDto
    {
        [XmlAttribute] public byte Type { get; set; }
        [XmlAttribute] public ushort Index { get; set; }
        [XmlAttribute] public byte Lvl { get; set; }
        [XmlAttribute] public byte Skill { get; set; }
        [XmlAttribute] public byte Luck { get; set; }
        [XmlAttribute] public byte Option { get; set; }
    }
}


--file .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


--file MU.Resources.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("MU.Resources")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("MU.Resources")]
[assembly: System.Reflection.AssemblyTitleAttribute("MU.Resources")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file .NETCoreApp,Version=v3.1.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v3.1", FrameworkDisplayName = ".NET Core 3.1")]


--file MU.Resources.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("MU.Resources")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("MU.Resources")]
[assembly: System.Reflection.AssemblyTitleAttribute("MU.Resources")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


--file MU.Resources.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("MU.Resources")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("MU.Resources")]
[assembly: System.Reflection.AssemblyTitleAttribute("MU.Resources")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file ChaosMixDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("ChaosBox")]
    public class ChaosMixDto
    {
        [XmlElement("Jewel")]
        public JewelInfoDto[] Jewels { get; set; }

        [XmlElement("Mix")]
        public MixInfoDto[] Mixes { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class JewelInfoDto
    {
        [XmlAttribute("type")]
        public int Type { get; set; }

        [XmlAttribute("index")]
        public int Index { get; set; }

        [XmlAttribute("success")]
        public int Success { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class MixInfoDto
    {
        [XmlAttribute("name")]
        public string Name { get; set; }

        [XmlAttribute("success")]
        public int Success { get; set; }

        [XmlAttribute("value")]
        public int Value { get; set; }

        [XmlElement("Ingredient")]
        public IngredientInfoDto[] Ingredients { get; set; }

        [XmlElement("RewardSuccess")]
        public IngredientInfoDto[] RewardSuccess { get; set; }

        public IngredientInfoDto RewardFail { get; set; }

        [XmlAttribute("NPC")]
        public int NPC { get; set; } = 238;// Chaos Goblins by Default
    }

    [XmlType(AnonymousType = true)]
    public class IngredientInfoDto
    {
        [XmlAttribute("iid")]
        public int IID { get; set; }

        [XmlAttribute("type")]
        public int Type { get; set; } = -1;

        [XmlAttribute("index")]
        public int Index { get; set; } = -1;

        [XmlAttribute("level")]
        public string Level { get; set; } = "255";

        [XmlAttribute("luck")]
        public int Luck { get; set; } = -1;

        [XmlAttribute("skill")]
        public int Skill { get; set; } = -1;

        [XmlAttribute("option")]
        public int Option { get; set; } = -1;

        [XmlAttribute("excellent")]
        public int Excellent { get; set; } = -1;

        [XmlAttribute("count")]
        public int Count { get; set; } = 1;

        [XmlAttribute("success")]
        public int Success { get; set; } = 100;

        [XmlAttribute("harmony")]
        public int Harmony { get; set; } = -1;

        [XmlAttribute("setOption")]
        public int SetOption { get; set; } = -1;
        [XmlAttribute("socket")]
        public int Socket { get; set; } = -1;
    }
}


--file CharacterInfoDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("Characters")]
    public class CharactersInfoDto
    {
        [XmlElement()] public CharacterInfoDto[] Character { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class CharacterInfoDto
    {
        [XmlAttribute] public string BaseClass { get; set; }
        [XmlAttribute] public string Map { get; set; }
        [XmlAttribute] public int Level { get; set; }
        [XmlElement] public StatsInfoDto Stats { get; set; }
        [XmlElement] public AttriInfoDto Attributes { get; set; }
        [XmlElement] public EquipamentInfoDto[] Equipament { get; set; } = Array.Empty<EquipamentInfoDto>();
        [XmlElement] public int[] Skill { get; set; } = Array.Empty<int>();
    }

    [XmlType(AnonymousType = true)]
    public class StatsInfoDto
    {
        [XmlAttribute] public int Str { get; set; }
        [XmlAttribute] public int Agi { get; set; }
        [XmlAttribute] public int Vit { get; set; }
        [XmlAttribute] public int Ene { get; set; }
        [XmlAttribute] public int Cmd { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class AttriInfoDto
    {
        [XmlAttribute] public float Life { get; set; }
        [XmlAttribute] public float Mana { get; set; }
        [XmlAttribute] public float LevelLife { get; set; }
        [XmlAttribute] public float LevelMana { get; set; }
        [XmlAttribute] public float VitalityToLife { get; set; }
        [XmlAttribute] public float EnergyToMana { get; set; }

        [XmlAttribute] public float StrToBP { get; set; } = 0.2f;
        [XmlAttribute] public float AgiToBP { get; set; } = 0.4f;
        [XmlAttribute] public float VitToBP { get; set; } = 0.3f;
        [XmlAttribute] public float EneToBP { get; set; } = 0.2f;
        [XmlAttribute] public float CmdToBP { get; set; } = 0.0f;
    }

    [XmlType(AnonymousType = true)]
    public class EquipamentInfoDto
    {
        [XmlAttribute] public int Slot { get; set; }
        [XmlAttribute] public int Type { get; set; }
        [XmlAttribute] public int Index { get; set; }
        [XmlAttribute] public int Level { get; set; }
    }
}


--file ItemBagsDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("ItemBags")]
    public class ItemBagsDto
    {
        [XmlElement("ItemBag")]
        public ItemBagDto[] ItemBags { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class ItemBagDto
    {
        [XmlAttribute]
        public ushort Item { get; set; }
        [XmlAttribute]
        public ushort Monster { get; set; } = 0xffff;
        [XmlAttribute]
        public ushort Plus { get; set; } = 0xffff;
        [XmlAttribute]
        public ushort LevelMin { get; set; } = 0;
        [XmlAttribute]
        public string Bag { get; set; }
    }

    [XmlRoot("ItemList")]
    [XmlType(AnonymousType = true)]
    public class BagDto
    {
        [XmlAttribute] public ushort Number { get; set; }
        [XmlAttribute] public ushort Monster { get; set; } = 0xffff;
        [XmlAttribute] public ushort Plus { get; set; } = 0xffff;
        [XmlAttribute] public ushort LevelMin { get; set; } = 0;
        [XmlAttribute] public ushort DropItemCount { get; set; }
        [XmlAttribute] public ushort DropItemRate { get; set; }
        [XmlAttribute] public ushort DropZenRate { get; set; }
        [XmlAttribute] public int MinZen { get; set; }
        [XmlAttribute] public int MaxZen { get; set; }

        [XmlElement("Item")] public ItemInBagDto[] Item { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class ItemInBagDto
    {
        [XmlAttribute] public ushort Number { get; set; }
        [XmlAttribute] public byte MinLevel { get; set; }
        [XmlAttribute] public byte MaxLevel { get; set; }
        [XmlAttribute] public bool Luck { get; set; }
        [XmlAttribute] public bool Skill { get; set; }
        [XmlAttribute] public byte MinOption { get; set; }
        [XmlAttribute] public byte MaxOption { get; set; }
        [XmlAttribute] public byte MinExcellent { get; set; }
        [XmlAttribute] public byte MaxExcellent { get; set; }
    }
}


--file ItemDbDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("Items")]
    public class ItemDbDto
    {
        [XmlElement("Item")]
        public ItemDto[] items { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class ItemDto
    {
        [XmlAttribute] public ushort Number { get; set; }

        [XmlAttribute] public string Name { get; set; }

        [XmlAttribute] public string Slot { get; set; }

        [XmlAttribute] public string Skill { get; set; }

        [XmlAttribute] public string Size { get; set; }

        [XmlAttribute] public string Option { get; set; }

        [XmlAttribute] public string Drop { get; set; }

        [XmlAttribute] public ushort Level { get; set; }

        [XmlAttribute] public ushort Defense { get; set; }

        [XmlAttribute] public ushort DefenseRate { get; set; }

        [XmlAttribute] public string Dmg { get; set; } = "0-0";

        [XmlAttribute] public int Speed { get; set; }

        [XmlAttribute] public byte Durability { get; set; }

        [XmlAttribute] public byte MagicDur { get; set; }

        [XmlAttribute] public byte MagicPower { get; set; }

        [XmlAttribute] public ushort NeededLevel { get; set; }

        [XmlAttribute] public ushort NeededStr { get; set; }

        [XmlAttribute] public ushort NeededAgi { get; set; }

        [XmlAttribute] public ushort NeededVit { get; set; }

        [XmlAttribute] public ushort NeededEne { get; set; }

        [XmlAttribute] public ushort NeededCmd { get; set; }

        [XmlAttribute] public string ReqClass { get; set; }
        [XmlAttribute] public int Ruud { get; set; }
        [XmlAttribute] public int Zen { get; set; }

        [XmlAttribute] public string Attributes { get; set; } = "";
        [XmlAttribute] public byte MaxStack { get; set; } = 0;
        [XmlAttribute] public ushort OnMaxStack { get; set; } = 0xffff;
        [XmlAttribute] public string IsMount { get; set; } = "False";
        [XmlAttribute] public ushort Skin { get; set; } = 0xffff;
        [XmlAttribute] public string Inventory { get; set; } = "Inventory";
    }
}


--file ItemXmlDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    public class ItemXmlDto
    {
        [XmlAttribute] public int Number { get; set; }
        [XmlAttribute] public byte Plus { get; set; }
        [XmlAttribute] public bool Luck { get; set; }
        [XmlAttribute] public bool Skill { get; set; }
        [XmlAttribute] public byte Option28 { get; set; }
        [XmlAttribute] public byte Durability { get; set; }
        [XmlAttribute] public byte OptionExe { get; set; }
        [XmlAttribute] public byte FreeSockets { get; set; }
        [XmlAttribute] public uint BuyPrice { get; set; }
    }
}


--file KanturuMonstersDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("Stages")]
    public class KanturuStagesDto
    {
        [XmlElement("Stage")] public KanturuStageDto[] Stages { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class KanturuStageDto
    {
        [XmlAttribute] public int Number { get; set; }
        [XmlElement("Monster")] public KanturuMonsterDto[] Monsters { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class KanturuMonsterDto
    {
        [XmlAttribute] public ushort Type { get; set; }
        [XmlAttribute] public int Map { get; set; }
        [XmlAttribute] public byte Radio { get; set; }
        [XmlAttribute] public byte PosX { get; set; }
        [XmlAttribute] public byte PosY { get; set; }
        [XmlAttribute] public sbyte Dir { get; set; }
    }
}


--file MapsDbDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("Maps")]
    public class MapsDbDto
    {
        [XmlElement("Map")]
        public MapDto[] maps { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class MapDto
    {
        [XmlAttribute] public ushort Map { get; set; }
        [XmlAttribute] public string AttributteFile { get; set; }
    }
}


--file MapServerDto.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("MapServer")]
    public class MapServerDto
    {
        [XmlElement("Group")] public MSGroupDto[] Groups { get; set; } = Array.Empty<MSGroupDto>();
    }

    [XmlType(AnonymousType = true)]
    public class MSGroupDto
    {
        [XmlElement("GameServer")] public MSGameServerDto[] GameServers { get; set; } = Array.Empty<MSGameServerDto>();
    }

    [XmlType(AnonymousType = true)]
    public class MSGameServerDto
    {
        [XmlAttribute] public ushort Code { get; set; }
        [XmlAttribute] public string IP { get; set; }
        [XmlAttribute] public ushort Port { get; set; }
        [XmlAttribute] public int Default { get; set; }

        [XmlElement("Map")] public MSMapDto[] Maps { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class MSMapDto
    {
        [XmlAttribute] public Maps ID { get; set; }
        [XmlAttribute] public bool MoveAbleOption { get; set; }
        [XmlAttribute] public int Dest { get; set; }
    }
}


--file MasterSkillTreeDto.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Data;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("MasterSkillTree")]
    public class MasterSkillTreeDto
    {
        [XmlElement("Class")]
        public TreeDto[] Trees { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class TreeDto
    {
        [XmlAttribute] public HeroClass ID { get; set; }
        [XmlElement] public SkillTreeDto[] Skill { get; set; }

    }

    [XmlType(AnonymousType = true)]
    public class SubTreeDto
    {
        [XmlAttribute] public int Type { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class SkillTreeDto
    {
        [XmlAttribute] public int Index { get; set; }
        [XmlAttribute] public int ReqMinPoint { get; set; }
        [XmlAttribute] public int MaxPoint { get; set; }
        [XmlAttribute] public int ParentSkill1 { get; set; }
        [XmlAttribute] public int MagicNumber { get; set; }
        [XmlAttribute] public string Name { get; set; }
        [XmlAttribute] public string Ecuation { get; set; } = "";
        [XmlAttribute] public string Property { get; set; }

        public float GetValue(short Level)
        {
            if (string.IsNullOrWhiteSpace(Ecuation))
                return 0.0f;

            return (float)Evaluate(Ecuation.Replace("{0}", Level.ToString()));
        }

        private static double Evaluate(string expression)
        {
            DataTable table = new DataTable();
            table.Columns.Add("myExpression", string.Empty.GetType(), expression);
            DataRow row = table.NewRow();
            table.Rows.Add(row);
            var result = double.Parse((string)row["myExpression"]);
            return result;
        }
    }
}


--file MiniGameDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MU.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("MiniGame")]
    public class MiniGameDto
    {
        [XmlElement] public bool Active { get; set; }
        [XmlElement] public int NoneTime { get; set; }
        [XmlElement] public int OpenTime { get; set; }
        [XmlElement] public int ClosedTime { get; set; }
        [XmlElement] public ushort ItemDrop { get; set; }
        [XmlElement] public float DropRate { get; set; }
    }
}


--file NPCAttributesDto.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("NPCs")]
    public class NPCAttributesDto
    {
        [XmlElement("NPC")]
        public NPCAttributeDto[] NPCs { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class NPCAttributeDto
    {
        [XmlAttribute] public ushort NPC { get; set; }
        [XmlAttribute] public string Type { get; set; }
        [XmlAttribute] public string Data { get; set; }
        [XmlAttribute] public MiniMapTag Icon { get; set; } = MiniMapTag.Shield;
    }
}


--file PattersDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MU.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("Patterns")]
    public class PatternsDto
    {
        [XmlAttribute] public int Monster { get; set; }
        [XmlElement] public PatternDto[] Pattern { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class PatternDto
    {
        [XmlAttribute] public int Number { get; set; }
        [XmlElement] public MonsterSpell[] Skill { get; set; }
    }
}


--file PCPointShopDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("PCPointShop")]
    public class PCPointShopDto
    {
        [XmlElement("Item")] public ItemXmlDto[] Items { get; set; }
    }
}


--file PentagramaDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MU.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("Pentagrama")]
    public class PentagramaDto
    {
        [XmlElement("Monster")]
        public PentagramaMonsterDto[] Monsters { get; set; }

        [XmlElement("Socket")]
        public PentagramaSocketDto[] Sockets { get; set; }

        [XmlElement("Item")]
        public PentagramaItemDto[] Items { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class PentagramaItemDto
    {
        [XmlAttribute] public int Number { get; set; }
        [XmlAttribute] public PIGrade Grade { get; set; }
        [XmlAttribute] public string Option { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class PentagramaOptionDto
    {
        [XmlAttribute] public int Number { get; set; }
        [XmlAttribute] public string Name { get; set; }
        [XmlElement] public PentagramaErrtelDto[] Errtel { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class PentagramaErrtelDto
    {
        [XmlAttribute] public int Type { get; set; }
        [XmlAttribute] public int Rank { get; set; }
        [XmlAttribute] public int Level { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class PentagramaSocketDto
    {
        [XmlAttribute] public int Count { get; set; }
        [XmlAttribute] public int OpenRate { get; set; } = 0;
        [XmlElement("Rate")]
        public PentagramaSocketRatesDto[] Rates { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class PentagramaSocketRatesDto
    {
        [XmlAttribute] public int Set { get; set; } = 0;
        [XmlAttribute] public int Slot1 { get; set; } = 0;
        [XmlAttribute] public int Slot2 { get; set; } = 0;
        [XmlAttribute] public int Slot3 { get; set; } = 0;
        [XmlAttribute] public int Slot4 { get; set; } = 0;
        [XmlAttribute] public int Slot5 { get; set; } = 0;
    }

    [XmlType(AnonymousType = true)]
    public class PentagramaMonsterDto
    {
        [XmlAttribute]
        public ushort Number { get; set; }

        [XmlElement("Item")]
        public PentagramaMonsterItemDto[] Items { get; set; }

        [XmlAttribute]
        public int Rate { get; set; }
    }

    public class PentagramaMonsterItemDto
    {
        [XmlAttribute]
        public ushort Number { get; set; }

        [XmlAttribute]
        public ushort Rate { get; set; }
    }
}


--file QuestEXPDto.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("Quests")]
    public class QuestEXPDto
    {
        [XmlElement] public QuestNPCDto[] QuestList { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class QuestNPCDto
    {
        [XmlAttribute] public ushort Index { get; set; }

        [XmlElement] public QuestNPCInfoDto[] QuestInfo { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class QuestNPCInfoDto
    {
        [XmlAttribute] public uint Episode { get; set; }
        [XmlAttribute] public uint ReqEpisode { get; set; }
        [XmlAttribute] public ushort MinLevel { get; set; }
        [XmlAttribute] public ushort MaxLevel { get; set; }
        [XmlElement] public QuestNPCStateDto[] QuestState { get; set; }
        [XmlAttribute] public string Name { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class QuestNPCStateDto
    {
        [XmlAttribute] public uint State { get; set; }
        [XmlAttribute] public AskType Type { get; set; } = AskType.None;
        [XmlAttribute] public uint RewardEXP { get; set; } = 0;
        [XmlAttribute] public uint RewardZEN { get; set; } = 0;
        [XmlAttribute] public uint RewardGENS { get; set; } = 0;
        [XmlAttribute] public HeroClass Class { get; set; } = HeroClass.End;
        [XmlAttribute] public ushort Select1 { get; set; } = ushort.MaxValue;
        [XmlAttribute] public ushort Select2 { get; set; } = ushort.MaxValue;
        [XmlAttribute] public ushort Select3 { get; set; } = ushort.MaxValue;
        [XmlElement] public QuestItemDto[] Item { get; set; }
        [XmlElement] public QuestItemDto[] RewardItem { get; set; }
        [XmlElement] public QuestItemDto[] Monster { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class QuestItemDto
    {
        [XmlAttribute] public byte Type { get; set; }
        [XmlAttribute] public ushort Index { get; set; }
        [XmlAttribute] public byte Level { get; set; }
        [XmlAttribute] public bool Skill { get; set; }
        [XmlAttribute] public byte Option { get; set; }
        [XmlAttribute] public byte Excellent { get; set; }
        [XmlAttribute] public byte Count { get; set; }
    }
}


--file QuestsDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("Quests")]
    public class QuestsDto
    {
        [XmlElement] public QuestDto[] Quest { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class QuestDto
    {
        [XmlAttribute] public int Type { get; set; }
        [XmlAttribute] public int Index { get; set; }
        [XmlAttribute] public int SubType { get; set; }
        [XmlAttribute] public ushort NPC { get; set; }
        [XmlAttribute] public string Name { get; set; }

        [XmlElement("Detail")] public DetailDto[] Details { get; set; }
        [XmlElement("Condition")] public ConditionDto[] Conditions { get; set; }
    }

    [XmlType(AnonymousType =true)]
    public class DetailDto
    {
        [XmlAttribute] public int Index { get; set; }
        [XmlAttribute] public string Classes { get; set; }
        [XmlElement] public NeededItemDto[] NeededItem { get; set; }
        [XmlElement] public NeededMonsterDto NeededMonster { get; set; }
        [XmlElement] public RewardDto Reward { get; set; }
        [XmlElement] public MessageDto Message { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class NeededItemDto
    {
        [XmlAttribute] public int Type { get; set; }
        [XmlAttribute] public int Index { get; set; }
        [XmlAttribute] public int Level { get; set; }
        [XmlAttribute] public int Count { get; set; }
        [XmlAttribute] public string Monster { get; set; }
        [XmlAttribute] public int Drop { get; set; }
    }

    public class NeededMonsterDto
    {
        [XmlAttribute] public ushort Type { get; set; }
        [XmlAttribute] public int Count { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class RewardDto
    {
        [XmlAttribute] public string Type { get; set; }
        [XmlAttribute] public byte SubType { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class MessageDto
    {
        [XmlAttribute] public int LinkConditionIndex { get; set; }
        [XmlAttribute] public ushort BeforeReg { get; set; }
        [XmlAttribute] public ushort AfterReg { get; set; }
        [XmlAttribute] public ushort CompleteQuest { get; set; }
        [XmlAttribute] public ushort ClearQuest { get; set; }
    }

    [XmlType(AnonymousType =true)]
    public class ConditionDto
    {
        [XmlAttribute] public int Index { get; set; }
        [XmlAttribute] public int NeededQuest { get; set; }
        [XmlAttribute] public ushort MinLevel { get; set; }
        [XmlAttribute] public ushort MaxLevel { get; set; }
        [XmlAttribute] public int NeedStr { get; set; }
        [XmlAttribute] public int Cost { get; set; }
        [XmlAttribute] public int Message { get; set; }
    }
}


--file ServerInfoDto.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("Server")]
    public class ServerInfoDto
    {
        [XmlElement] public string Name { get; set; } = "GameServer";
        [XmlElement] public int Code { get; set; } = 0;
        [XmlElement] public int Show { get; set; } = 1;
        [XmlElement] public string Lang { get; set; } = "es";
        [XmlElement] public bool AutoRegister { get; set; } = true;
        [XmlElement] public ServerSeason Season { get; set; } = ServerSeason.Season9Eng;

        [XmlElement("Connection")] public ConnectionInfoDto Connection { get; set; } = new ConnectionInfoDto();
        [XmlElement("Database")] public DatabaseInfoDto Database { get; set; } = new DatabaseInfoDto();
        [XmlElement("Client")] public ClientInfoDto Client { get; set; } = new ClientInfoDto();
        [XmlElement("GamePlay")] public GamePlayInfoDto GamePlay { get; set; } = new GamePlayInfoDto();
        [XmlElement("Files")] public FilesInfoDto Files { get; set; } = new FilesInfoDto();
        [XmlElement("Event")] public EventDto[] Events { get; set; } = Array.Empty<EventDto>();
    }

    [XmlType(AnonymousType = true)]
    public class ConnectionInfoDto
    {
        [XmlElement] public string IP { get; set; } = "127.0.0.1";
        [XmlElement] public string IPPublic { get; set; } = "127.0.0.1";
        [XmlElement] public int Port { get; set; } = 55901;
        [XmlElement] public string ConnectServerIP { get; set; } = "127.0.0.1";
        [XmlElement] public string APIKey { get; set; } = "2020110116";
    }

    [XmlType(AnonymousType = true)]
    public class DatabaseInfoDto
    {
        [XmlElement] public string DBIp { get; set; } = "127.0.0.1";
        [XmlElement] public string DataBase { get; set; } = "MuOnline";
        [XmlElement] public string BDUser { get; set; } = "root";
        [XmlElement] public string DBPassword { get; set; } = "1234";
    }

    [XmlType(AnonymousType = true)]
    public class ClientInfoDto
    {
        [XmlElement] public string Version { get; set; } = "10635";
        [XmlElement] public string Serial { get; set; } = "fughy683dfu7teqg";
        [XmlElement] public string CashShopVersion { get; set; } = "512.2014.124";
    }

    [XmlType(AnonymousType = true)]
    public class GamePlayInfoDto
    {
        [XmlElement] public float Experience { get; set; } = 10.0f;
        [XmlElement] public float GoldExperience { get; set; } = 10.0f;
        [XmlElement] public float Zen { get; set; } = 10.0f;
        [XmlElement] public int DropRate { get; set; } = 60;
        [XmlElement] public ushort MaxPartyLevelDifference { get; set; } = 400;
        [XmlElement] public bool PVP { get; set; } = false;
    }

    [XmlType(AnonymousType = true)]
    public class FilesInfoDto
    {
        [XmlElement] public string DataRoot { get; set; } = "./Data/";
        [XmlElement] public string Monsters { get; set; } = "./Data/Monsters/Monster";
        [XmlElement] public string MonsterSetBase { get; set; } = "./Data/Monsters/MonsterSetBase";
        [XmlElement] public string SelupanPatterns { get; set; } = "./Data/Monsters/PatternSelupan.xml";
        [XmlElement] public string MapServer { get; set; } = "./Data/MapServer.xml";
        [XmlElement] public string MayaLeftHandPatterns { get; set; } = "./Data/Monsters/PatternMayaLeftHand.xml";
        [XmlElement] public string MayaRightHandPatterns { get; set; } = "./Data/Monsters/PatternMayaRightHand.xml";
        [XmlElement] public string NightmarePatterns { get; set; } = "./Data/Monsters/PatternNightmare.xml";
        [XmlElement] public string QuestWorld { get; set; } = "./Data/QuestWorld/";
        [XmlElement] public string MGMuRummy { get; set; } = "./Data/MiniGames/MuRummy.xml";
        [XmlElement] public string MGFindBombs { get; set; } = "./Data/MiniGames/FindBombs.xml";
        [XmlElement] public string MGJewelBingo { get; set; } = "./Data/MiniGames/JewelBingo.xml";
        [XmlElement] public string MGBallsAndCows { get; set; } = "./Data/MiniGames/BallsAndCows.xml";
    }

    [XmlType(AnonymousType = true)]
    public class EventDto
    {
        [XmlAttribute] public string name { get; set; }
        [XmlAttribute] public byte rate { get; set; }
        [XmlAttribute] public bool active { get; set; }
        [XmlElement("Condition")] public EConditionDto[] Conditions { get; set; }
        [XmlAttribute] public double duration { get; set; } = 315360000;
        [XmlAttribute] public string start { get; set; } = "00:00:00";
        [XmlAttribute] public GERepeatType repeat { get; set; } = GERepeatType.None;
        [XmlAttribute] public double experienceAdd { get; set; } = 0;
    }

    [XmlType(AnonymousType = true)]
    public class EConditionDto
    {
        [XmlAttribute] public int item { get; set; }
        [XmlAttribute] public byte itemLevel { get; set; }
        [XmlAttribute] public ushort mobMinLevel { get; set; }
        [XmlAttribute] public ushort mobMaxLevel { get; set; }
        [XmlAttribute] public Maps map { get; set; }
    }
}


--file ServerMessageDto.cs
﻿using MuEmu.Resources.Game;
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("ServerMessage")]
    public class ServerMessagesDto
    {

        [XmlElement("Message")]
        public ServerMessageDto[] Messages { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class ServerMessageDto
    {
        [XmlAttribute] public string ID { get; set; }
        [XmlAttribute] public string Message { get; set; }
    }
}


--file ShopListDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("Shops")]
    public class ShopListDto
    {
        [XmlElement("Shop")] public ShopDto[] Shops { get; set; }
    }

    public class ShopDto
    {
        [XmlAttribute] public ushort Shop { get; set; }
        [XmlAttribute] public string ItemList { get; set; }
    }
}


--file SpellDbDto.cs
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("Skills")]
    public class SpellDbDto
    {
        [XmlElement("Skill")]
        public SkillDto[] skills { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class SkillDto
    {
        [XmlAttribute] public ushort Number { get; set; }
        [XmlAttribute] public string Name { get; set; }
        [XmlAttribute] public ushort ReqLevel { get; set; }
        [XmlAttribute] public string Dmg { get; set; }
        [XmlAttribute] public ushort Mana { get; set; }
        [XmlAttribute] public ushort BP { get; set; }
        [XmlAttribute] public byte Distance { get; set; }
        [XmlAttribute] public uint Delay { get; set; }
        [XmlAttribute] public ushort Energy { get; set; }
        [XmlAttribute] public ushort Command { get; set; }
        [XmlAttribute] public sbyte Attribute { get; set; }
        [XmlAttribute] public short Type { get; set; }
        [XmlAttribute] public byte UseType { get; set; }
        [XmlAttribute] public int Brand { get; set; }
        [XmlAttribute] public int KillCount { get; set; }
        [XmlAttribute] public string Status { get; set; }
        [XmlAttribute] public string Classes { get; set; }
        [XmlAttribute] public int Rank { get; set; }
        [XmlAttribute] public int Group { get; set; }
        [XmlAttribute] public int MasterP { get; set; }
        [XmlAttribute] public int AG { get; set; }
        [XmlAttribute] public int SD { get; set; }
        [XmlAttribute] public int Duration { get; set; }
        [XmlAttribute] public ushort Str { get; set; }
        [XmlAttribute] public ushort Agility { get; set; }
        [XmlAttribute] public ushort Icon { get; set; }
        [XmlAttribute] public byte UseType2 { get; set; }
        [XmlAttribute] public ushort Item { get; set; }
        [XmlAttribute] public byte IsDamage { get; set; }
    }
}


--file WarpDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("Warp")]
    public class WarpDto
    {
        [XmlElement("Gate")]
        public GateDto[] Gates { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class GateDto
    {
        [XmlAttribute]
        public int Number { get; set; }

        [XmlAttribute]
        public string GateType { get; set; }

        [XmlAttribute]
        public string Map { get; set; }

        [XmlAttribute]
        public byte X1 { get; set; }

        [XmlAttribute]
        public byte Y1 { get; set; }

        [XmlAttribute]
        public byte X2 { get; set; }

        [XmlAttribute]
        public byte Y2 { get; set; }

        [XmlAttribute]
        public int Target { get; set; }

        [XmlAttribute]
        public int Move { get; set; } = -1;

        [XmlAttribute]
        public string Name { get; set; } = "";

        [XmlAttribute]
        public byte Dir { get; set; }

        [XmlAttribute]
        public ushort ReqLevel { get; set; }

        [XmlAttribute]
        public ushort ReqZen { get; set; } = 0;
    }
}


--file WZItem.cs
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;
using System.Xml.Serialization;

namespace MU.Resources.XML
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("Item")]
    public class WZItem
    {
        [XmlElement] public WZItemGroupWeapons[] Sword { get; set; }
        [XmlElement] public WZItemGroupWeapons[] Axe { get; set; }
        [XmlElement] public WZItemGroupWeapons[] Scepter { get; set; }
        [XmlElement] public WZItemGroupWeapons[] Spear { get; set; }
        [XmlElement] public WZItemGroupWeapons[] BowOrCrossbow { get; set; }
        [XmlElement] public WZItemGroupWeapons[] Staff { get; set; }
        [XmlElement] public WZItemGroupSet[] Shield { get; set; }
        [XmlElement] public WZItemGroupSet[] Helm { get; set; }
        [XmlElement] public WZItemGroupSet[] Armor { get; set; }
        [XmlElement] public WZItemGroupSet[] Pant { get; set; }
        [XmlElement] public WZItemGroupSet[] Gloves { get; set; }
        [XmlElement] public WZItemGroupSet[] Boots { get; set; }
        [XmlElement] public WZItemGroupWingsOrbsSeeds[] WingsOrbsSeeds { get; set; }
        [XmlElement] public WZItemGroupMisc[] Miscs  { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class WZItemGroupBasic
    {
        [XmlAttribute] public ushort Index { get; set; }
        [XmlAttribute] public byte Slot { get; set; }
        [XmlAttribute] public ushort Skill { get; set; }
        [XmlAttribute] public byte X { get; set; }
        [XmlAttribute] public byte Y { get; set; }
        [XmlAttribute] public byte Serial { get; set; }
        [XmlAttribute] public byte Option { get; set; }
        [XmlAttribute] public byte Drop { get; set; }
        [XmlAttribute] public string Name { get; set; }
        [XmlAttribute] public ushort Level { get; set; }

        [XmlIgnore] public Size Size => new Size(X, Y);
    }

    [XmlType(AnonymousType = true)]
    public class WZItemGroupWeapons : WZItemGroupBasic
    {
        [XmlAttribute] public ushort DmgMin { get; set; }
        [XmlAttribute] public ushort DmgMax { get; set; }
        [XmlAttribute] public ushort Speed { get; set; }
        [XmlAttribute] public ushort Durability { get; set; }
        [XmlAttribute] public ushort MagicDur { get; set; }
        [XmlAttribute] public ushort MagicPower { get; set; }
        [XmlAttribute] public ushort RequiredLvl { get; set; }
        [XmlAttribute] public ushort Str { get; set; }
        [XmlAttribute] public ushort Agi { get; set; }
        [XmlAttribute] public ushort Ene { get; set; }
        [XmlAttribute] public ushort Vit { get; set; }
        [XmlAttribute] public ushort Cmd { get; set; }
        [XmlAttribute] public ushort Type { get; set; }
        [XmlAttribute] public byte DW { get; set; }
        [XmlAttribute] public byte DK { get; set; }
        [XmlAttribute] public byte Elf { get; set; }
        [XmlAttribute] public byte MG { get; set; }
        [XmlAttribute] public byte DL { get; set; }
        [XmlAttribute] public byte SM { get; set; }

        [XmlIgnore] public Point Damage => new Point(DmgMin, DmgMax);
        [XmlIgnore] public List<HeroClass> Classes => GetClasses();
        private List<HeroClass> GetClasses()
        {
            var result = new List<HeroClass>();
            var list = new byte[] { DW, DK, Elf, MG, DL, SM };
            for(var i = 0; i < list.Length; i++)
            {
                if (list[i] <= 0)
                    continue;

                var @class = (HeroClass)((i << 8) + (list[i] - 1));
                result.Add(@class);
            }

            return result;
        }
    }

    [XmlType(AnonymousType = true)]
    public class WZItemGroupSet : WZItemGroupBasic
    {
        [XmlAttribute] public ushort Def { get; set; }
        [XmlAttribute] public ushort DefRate { get; set; }
        [XmlAttribute] public ushort Durability { get; set; }
        [XmlAttribute] public ushort ReqLevel { get; set; }
        [XmlAttribute] public ushort Str { get; set; }
        [XmlAttribute] public ushort Agi { get; set; }
        [XmlAttribute] public ushort Ene { get; set; }
        [XmlAttribute] public ushort Vit { get; set; }
        [XmlAttribute] public ushort Command { get; set; }
        [XmlAttribute] public ushort Type { get; set; }
        [XmlAttribute] public byte DW { get; set; }
        [XmlAttribute] public byte DK { get; set; }
        [XmlAttribute] public byte Elf { get; set; }
        [XmlAttribute] public byte MG { get; set; }
        [XmlAttribute] public byte DL { get; set; }
        [XmlAttribute] public byte SM { get; set; }

        [XmlIgnore] public List<HeroClass> Classes => GetClasses();
        private List<HeroClass> GetClasses()
        {
            var result = new List<HeroClass>();
            var list = new byte[] { DW, DK, Elf, MG, DL, SM };
            for (var i = 0; i < list.Length; i++)
            {
                if (list[i] <= 0)
                    continue;

                var @class = (HeroClass)((i << 8) + (list[i] - 1));
                result.Add(@class);
            }

            return result;
        }
    }

    [XmlType(AnonymousType = true)]
    public class WZItemGroupWingsOrbsSeeds : WZItemGroupBasic
    {
        [XmlAttribute] public ushort Defense { get; set; }
        [XmlAttribute] public ushort Durability { get; set; }
        [XmlAttribute] public ushort RequiredLvl { get; set; }
        [XmlAttribute] public ushort Ene { get; set; }
        [XmlAttribute] public ushort Strength { get; set; }
        [XmlAttribute] public ushort Agi { get; set; }
        [XmlAttribute] public ushort Command { get; set; }
        [XmlAttribute] public ushort Type { get; set; }
        [XmlAttribute] public byte DW { get; set; }
        [XmlAttribute] public byte DK { get; set; }
        [XmlAttribute] public byte Elf { get; set; }
        [XmlAttribute] public byte MG { get; set; }
        [XmlAttribute] public byte DL { get; set; }
        [XmlAttribute] public byte SM { get; set; }
        [XmlIgnore] public List<HeroClass> Classes => GetClasses();
        private List<HeroClass> GetClasses()
        {
            var result = new List<HeroClass>();
            var list = new byte[] { DW, DK, Elf, MG, DL, SM };
            for (var i = 0; i < list.Length; i++)
            {
                if (list[i] <= 0)
                    continue;

                var @class = (HeroClass)((i << 8) + (list[i] - 1));
                result.Add(@class);
            }

            return result;
        }
    }

    [XmlType(AnonymousType = true)]
    public class WZItemGroupMisc : WZItemGroupBasic
    {
        [XmlAttribute] public ushort Durability { get; set; }
        [XmlAttribute] public ushort Ice { get; set; }
        [XmlAttribute] public ushort Poison { get; set; }
        [XmlAttribute] public ushort Light { get; set; }
        [XmlAttribute] public ushort Fire { get; set; }
        [XmlAttribute] public ushort Earth { get; set; }
        [XmlAttribute] public ushort Wind { get; set; }
        [XmlAttribute] public ushort Water { get; set; }
        [XmlAttribute] public ushort Type { get; set; }
        [XmlAttribute] public byte DW { get; set; }
        [XmlAttribute] public byte DK { get; set; }
        [XmlAttribute] public byte Elf { get; set; }
        [XmlAttribute] public byte MG { get; set; }
        [XmlAttribute] public byte DL { get; set; }
        [XmlAttribute] public byte SM { get; set; }
        [XmlIgnore] public List<HeroClass> Classes => GetClasses();
        private List<HeroClass> GetClasses()
        {
            var result = new List<HeroClass>();
            var list = new byte[] { DW, DK, Elf, MG, DL, SM };
            for (var i = 0; i < list.Length; i++)
            {
                if (list[i] <= 0)
                    continue;

                var @class = (HeroClass)((i << 8) + (list[i] - 1));
                result.Add(@class);
            }

            return result;
        }
    }

    [XmlType(AnonymousType = true)]
    [XmlRoot("Item")]
    public class ItemBMDS16
    {
        [XmlElement] public ItemBMDS16GroupBasic[] Items { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class ItemBMDS16GroupBasic
    {
        [XmlAttribute] public ushort Number { get; set; }
        [XmlAttribute] public ushort Group { get; set; }
        [XmlAttribute] public ushort Index { get; set; }
        [XmlAttribute] public string ModelFolder { get; set; }//[260];
        [XmlAttribute] public string ModelName { get; set; }//[260];
        [XmlAttribute] public string Name { get; set; }//[64];
        [XmlAttribute] public byte KindA { get; set; }
        [XmlAttribute] public byte KindB { get; set; }
        [XmlAttribute] public byte Type { get; set; }
        [XmlAttribute] public byte TwoHands { get; set; }
        [XmlAttribute] public ushort Level { get; set; }
        [XmlAttribute] public byte Slot { get; set; }
        //[XmlAttribute] public byte GAP_564 { get; set; }
        [XmlAttribute] public Spell Skill { get; set; }
        [XmlAttribute] public byte Width { get; set; }
        [XmlAttribute] public byte Height { get; set; }
        [XmlIgnore] public Size Size => new Size(Width, Height);
        [XmlAttribute] public ushort DamageMin { get; set; }
        [XmlAttribute] public ushort DamageMax { get; set; }
        [XmlIgnore] public Point Damage => new Point(DamageMin, DamageMax);
        [XmlAttribute] public byte DefenseRate { get; set; }
        //[XmlAttribute] public byte GAP_575 { get; set; }
        [XmlAttribute] public ushort DefRate { get; set; }
        [XmlAttribute] public ushort MagicResistance { get; set; }
        [XmlAttribute] public byte Speed { get; set; }
        [XmlAttribute] public byte WalkSpeed { get; set; }
        [XmlAttribute] public byte Durability { get; set; }
        [XmlAttribute] public byte MagicDur { get; set; }
        [XmlAttribute] public ushort MagicPower { get; set; }
        [XmlAttribute] public ushort Str { get; set; }
        [XmlAttribute] public ushort Agi { get; set; }
        [XmlAttribute] public ushort Ene { get; set; }
        [XmlAttribute] public ushort Vit { get; set; }
        [XmlAttribute] public ushort Cmd { get; set; }
        [XmlAttribute] public ushort Lvl { get; set; }
        [XmlAttribute] public byte ItemValue { get; set; }
        //[XmlAttribute] public byte GAP3_601 { get; set; }
        [XmlAttribute] public int Zen { get; set; }
        [XmlAttribute] public byte SetAttr { get; set; }
        [XmlAttribute] public byte DW { get; set; }
        [XmlAttribute] public byte DK { get; set; }
        [XmlAttribute] public byte FE { get; set; }
        [XmlAttribute] public byte MG { get; set; }
        [XmlAttribute] public byte DL { get; set; }
        [XmlAttribute] public byte SU { get; set; }
        [XmlAttribute] public byte RF { get; set; }
        [XmlAttribute] public byte GL { get; set; }
        [XmlAttribute] public byte RW { get; set; }
        [XmlAttribute] public byte SL { get; set; }
        [XmlAttribute] public byte GC { get; set; }
        [XmlIgnore] public List<HeroClass> Classes => GetClasses();
        private List<HeroClass> GetClasses()
        {
            var result = new List<HeroClass>();
            var list = new byte[] { DW, DK, FE, MG, DL, SU, RF, GL, RW, SL, GC };
            for (var i = 0; i < list.Length; i++)
            {
                if (list[i] <= 0)
                    continue;

                var @class = (HeroClass)((i * 0x10) + (list[i] - 1));
                result.Add(@class);
            }

            return result;
        }
        [XmlAttribute] public byte Resist0 { get; set; } //[7]
        [XmlAttribute] public byte Resist1 { get; set; } //[7]
        [XmlAttribute] public byte Resist2 { get; set; } //[7]
        [XmlAttribute] public byte Resist3 { get; set; } //[7]
        [XmlAttribute] public byte Resist4 { get; set; } //[7]
        [XmlAttribute] public byte Resist5 { get; set; } //[7]
        [XmlAttribute] public byte Resist6 { get; set; } //[7]
        public List<AttributeType> Attributes => GetAttributes();
        private List<AttributeType> GetAttributes()
        {
            var result = new List<AttributeType>();
            var list = new byte[] { Resist0, Resist1, Resist2, Resist3, Resist4, Resist5, Resist6 };

            for(var i = 0; i < list.Length; i++)
            {
                if (list[i] != 0)
                    result.Add((AttributeType)i);
            }

            return result;
        }
        [XmlAttribute] public byte Dump { get; set; }
        [XmlAttribute] public byte Transaction { get; set; }
        [XmlAttribute] public byte PersonalStore { get; set; }
        [XmlAttribute] public byte Warehouse { get; set; }
        [XmlAttribute] public byte SellNpc { get; set; }
        [XmlAttribute] public byte Expensive { get; set; }
        [XmlAttribute] public byte Repair { get; set; }
        [XmlAttribute] public byte MaxStack { get; set; }
        [XmlAttribute] public byte PcFlag { get; set; }
        [XmlAttribute] public byte MuunFlag { get; set; }
        [XmlAttribute] public byte UnkFlag0 { get; set; }
        [XmlAttribute] public byte UnkFlag1 { get; set; }
        [XmlAttribute] public byte UnkFlag2 { get; set; }
        //[XmlAttribute] public byte GAP_673 { get; set; }
        //[XmlAttribute] public ushort Unk_End[3] { get; set; }
    }
}


--file XmlNewsDto.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MU.Resources.XML
{
    [XmlRoot("News")]
    [XmlType(AnonymousType =true)]
    public class XmlNewsDto
    {
        [XmlAttribute] public int Interval { get; set; }
        [XmlElement] public string[] New { get; set; }
    }
}


--file DataFormat.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;

namespace MU.Tool
{
    [WZContract]
    public class ServerList
    {
        [WZMember(0)] public ushort group { get; set; }
        [WZMember(1, typeof(BinaryStringSerializer), 13)] public string Name { get; set; }
        [WZMember(2, typeof(BinarySerializer), 20)] public byte[] Data { get; set; }
        [WZMember(3)] public byte d35 { get; set; }
        [WZMember(4)] public byte d36 { get; set; }
        [WZMember(5)] public byte descriptionLength { get; set; }
        [WZMember(6)] public byte d38 { get; set; }
        //[WZMember(5, typeof(ArrayWithScalarSerializer<byte>))] public byte[] desc { get; set; }
    }
}


--file Form1.cs
﻿using BlubLib.Serialization;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using WebZen.Util;

namespace MU.Tool
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private async Task ServerList(string path)
        {
            var content = await File.ReadAllBytesAsync(path);

            byte[] block, block2;
            string additionalInfo;
            for(var i = 0; i < content.Length; )
            {
                block = content.Skip(i).ToArray();
                block2 = block.Take(39).ToArray();
                BuxDecode.Decode(block2);
                using (var br = new MemoryStream(block))
                {
                    br.Seek(0, SeekOrigin.Begin);
                    br.Write(block2);
                    br.Seek(0, SeekOrigin.Begin);

                    var result = Serializer.Deserialize<ServerList>(br);
                    if(result.descriptionLength > 0)
                    {
                        block = new byte[result.descriptionLength];
                        br.Read(block);
                        BuxDecode.Decode(block);
                        additionalInfo = block.MakeString();
                    }
                    i += (int)br.Position;
                }                
            }
        }

        private async void button1_Click(object sender, EventArgs e)
        {
            var dialog = new OpenFileDialog();
            var result = dialog.ShowDialog();

            if (result != DialogResult.OK)
                return;

            switch(dialog.SafeFileName.ToLower())
            {
                case "serverlist.bmd":
                    await ServerList(dialog.FileName);
                    break;
            }
        }
    }
}


--file Form1.Designer.cs
﻿
namespace MU.Tool
{
    partial class Form1
    {
        /// <summary>
        ///  Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        ///  Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        ///  Required method for Designer support - do not modify
        ///  the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.button1 = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // button1
            // 
            this.button1.Location = new System.Drawing.Point(13, 13);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(75, 23);
            this.button1.TabIndex = 0;
            this.button1.Text = "Abrir";
            this.button1.UseVisualStyleBackColor = true;
            this.button1.Click += new System.EventHandler(this.button1_Click);
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(7F, 15F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(800, 450);
            this.Controls.Add(this.button1);
            this.Name = "Form1";
            this.Text = "Form1";
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.Button button1;
    }
}



--file .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


--file MU.Tool.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("MU.Tool")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("MU.Tool")]
[assembly: System.Reflection.AssemblyTitleAttribute("MU.Tool")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file .NETCoreApp,Version=v3.1.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v3.1", FrameworkDisplayName = ".NET Core 3.1")]


--file MU.Tool.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("MU.Tool")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("MU.Tool")]
[assembly: System.Reflection.AssemblyTitleAttribute("MU.Tool")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file Program.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace MU.Tool
{
    static class Program
    {
        /// <summary>
        ///  The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.SetHighDpiMode(HighDpiMode.SystemAware);
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}


--file Account.cs
﻿using MU.DataBase;
using MU.Resources;
using MuEmu.Entity;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MuEmu
{
    public class Account
    {
        private Dictionary<byte, Storage> _vaults { get; set; }
        private int _vaultMoney;

        public bool NeedSave { get; set; }
        public int ID { get; set; }
        public string Nickname { get; set; }
        public Player Player { get; set; }
        public Dictionary<byte, CharacterDto> Characters { get; set; }
        public byte ActiveVault { get; set; }
        public Storage Vault => _vaults[ActiveVault];
        public int VaultMoney { get => _vaultMoney; set { _vaultMoney = value; NeedSave = true; } }

        public Account(Player player, AccountDto accountDto)
        {
            Player = player;
            ActiveVault = 0;

            _vaults = new Dictionary<byte, Storage>();
            ID = accountDto.AccountId;
            Nickname = accountDto.Account;
            VaultMoney = accountDto.VaultMoney;

            using (var db = new GameContext())
                for (var i = (byte)0; i < accountDto.VaultCount; i++)
                {
                    var vault = new Storage(Storage.WarehouseSize);
                    vault.StorageID = StorageID.Warehouse+i;
                    _vaults.Add(i, vault);

                    var items = db.Items
                        .Where(x => x.VaultId == (int)vault.StorageID && x.AccountId == ID);

                    foreach (var it in items)
                    {
                        var item = new Item(it, this);
                        _vaults[i].Add((byte)it.SlotId, item);
                    }
                }
        }

        public async Task Save(GameContext db)
        {
            //foreach (var vault in _vaults.Values)
            //{
            //    foreach (var it in vault.Items.Values)
            //        await it.Save(db);
            //}
            _vaults.Values.ToList().ForEach(x => x.Items.Values.ToList().ForEach(x => x.Save(db)));

            if (!NeedSave)
                return;

            var accDto = db.Accounts.First(x => x.AccountId == ID);
            accDto.VaultMoney = VaultMoney;
            db.Accounts.Update(accDto);
            NeedSave = false;
        }
    }
}


--file Buff.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu
{
    public class Buff
    {
        public DateTimeOffset EndAt { get; set; }

        public int DefenseAdd { get; set; }
        public float DefenseAddRate { get; set; }

        public int DefenseRed { get; set; }
        public float DefenseRedRate { get; set; }

        public int AttackAdd { get; set; }
        public float AttackAddRate { get; set; }

        public int LifeAdd { get; set; }
        public float LifeAddRate { get; set; }

        public int ManaAdd { get; set; }
        public float ManaAddRate { get; set; }

        public float IgnoreDefenseRate { get; set; }

        public Character Source { get; set; }

        public int CoolDamage { get; set; }
        public int PoisonDamage { get; set; }

        public float DamageDeflection { get; set; }

        public SkillStates State { get; set; }
    }
}


--file CashShop.cs
﻿using MU.DataBase;
using MuEmu.Network;
using MU.Network.CashShop;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Linq;
using MU.Resources;
using MU.Network;

namespace MuEmu
{
    class IBSCategory
    {
        public int CategoryId;            //10
        public string Name;                    //W Coin (C)
        public int Const1;                //200
        public int Const2;                //201
        public int GroupId;                //10
        public int Position;            //1
        public bool IsRoot;                //1

        public IBSCategory(string[] vs)
        {
            CategoryId = int.Parse(vs[0]);
            Name = vs[1];
            Const1 = int.Parse(vs[2]);
            Const2 = int.Parse(vs[3]);
            GroupId = int.Parse(vs[4]);
            Position = int.Parse(vs[5]);
            IsRoot = int.Parse(vs[6])==1;
        }
    }
    class IBSPackage
    {
        public int CategoryId;              //13
        public int Position;                //1
        public int GameId;                  //263
        public string Name;                 //Rage Fighter Character Card
        public int Const1;                  //170
        public int Price;                   //500
        public string Description;              //A unlimited number of Rage Fighter can be created in one server. Only 1 Rage Fighter card is needed per server.
        public int Const2;                  //182
        public int Unknow;                  //185
        public DateTime DataTimeStart;              //20110608211000
        public DateTime DataTimeExpir;              //20150609141000
        public int Const3;                  //177
        public int Const4;                 //1
        public string CoinDesc;             //W Coin(C)
        public string CoinDesc2;                //W Coin(C) //Front type
        public int Const5;              //181
        public int Const6;              //200
        public int Const7;                  //0
        public int[] ProductRootId;         //284|
        public int ItemGroupAndIndex;       //7337
        public int coinType;            //2
        public int ProductCount;            //1
        public int[] ProductNodeId;     //353|
        public int CoinType1;               //0
        public int CoinType2;               //508
        public int Const8;	                //669


        public IBSPackage(string[] vs)
        {
            CategoryId = int.Parse(vs[0]);
            Position = int.Parse(vs[1]);
            GameId = int.Parse(vs[2]);
            Name = vs[3];
            Const1 = int.Parse(vs[4]);
            Price = int.Parse(vs[5]);
            Description = vs[6];
            int.TryParse(vs[8], out Const2);
            Unknow = int.Parse(vs[9]);

            int year, month, day, h, m, s;
            if (vs[10].Length >= 14)
            {
                year = int.Parse(vs[10].Substring(0, 4));
                month = int.Parse(vs[10].Substring(4, 2));
                day = int.Parse(vs[10].Substring(6, 2));
                h = int.Parse(vs[10].Substring(8, 2));
                m = int.Parse(vs[10].Substring(10, 2));
                s = int.Parse(vs[10].Substring(12, 2));
                DataTimeStart = new DateTime(year, month, day, h, m, s);
            }else
            {
                DataTimeStart = DateTime.Now;
            }
            if (vs[11].Length >= 14)
            {
                year = int.Parse(vs[11].Substring(0, 4));
                month = int.Parse(vs[11].Substring(4, 2));
                day = int.Parse(vs[11].Substring(6, 2));
                h = int.Parse(vs[10].Substring(8, 2));
                m = int.Parse(vs[10].Substring(10, 2));
                s = int.Parse(vs[10].Substring(12, 2));
                DataTimeExpir = new DateTime(year, month, day, h, m, s);
            }
            else
            {
                DataTimeExpir = DateTime.Now.AddYears(100);
            }

            Const3 = int.Parse(vs[12]);
            Const4 = int.Parse(vs[13]);
            CoinDesc = vs[14];
            CoinDesc2 = vs[15];
            Const5 = int.Parse(vs[16]);
            Const6 = int.Parse(vs[17]);
            Const7 = int.Parse(vs[18]);
            ProductRootId = vs[19].Split("|").Where(x => !string.IsNullOrWhiteSpace(x)).Select(x => int.Parse(x)).ToArray();
            ItemGroupAndIndex = int.Parse(vs[20]);
            coinType = int.Parse(vs[21]);
            ProductCount = int.Parse(vs[22]);
            ProductNodeId = vs[23].Split("|").Where(x => !string.IsNullOrWhiteSpace(x)).Select(x => int.Parse(x)).ToArray();
            CoinType1 = int.Parse(vs[24]);
            CoinType2 = int.Parse(vs[25]);
            Const8 = int.Parse(vs[26]);
        }
    }
    enum SellType
    {
        Duration,
        Quantity,
    }
    class IBSProduct
    {
        //3@Seal of Wealth(3day)@Duration@259200@Sec.@0@3@142@145@1@144@673@518@6700@10@140@386
        //12@ Devil Square Ticket @Quantity@1@EA@900@21@142@145@1@144@673@518@6702@7@138@680
        //60@ Pet Panda@Duration@1440@[1 Day(s)]@150@99@142@145@1@144@673@518@6736@10@138@680
        public int RootId;
        public string Name;
        public SellType sellType;
        public int Amount;
        public string sellTypeDesc;
        public int Coins;
        public int NodeId;
        public int Const1;
        public int Const2;
        public int Const3;
        public int Const4;
        public int Const5;
        public int Const6;
        public int ItemId;
        public int Const7;
        public int Const8;
        public int Const9;

        public IBSProduct(string[] vs)
        {
            RootId = int.Parse(vs[0]);
            Name = vs[1];
            Enum.TryParse(vs[2], out sellType);
            Amount = int.Parse(vs[3]);
            sellTypeDesc = vs[4];
            Coins = int.Parse(vs[5]);
            NodeId = int.Parse(vs[6]);
            Const1 = int.Parse(vs[7]);
            Const2 = int.Parse(vs[8]);
            Const3 = int.Parse(vs[9]);
            Const4 = int.Parse(vs[10]);
            Const5 = int.Parse(vs[11]);
            Const6 = int.Parse(vs[12]);
            ItemId = int.Parse(vs[13]);
            Const7 = int.Parse(vs[14]);
            Const8 = int.Parse(vs[15]);
            Const9 = int.Parse(vs[16]);
        }
    }
    class CashShopItem
    {

    }

    public class CashShop
    {
        private static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(CashShop));
        private ILogger log;
        private static ushort[] version;
        private static int[] banner;
        private Player _player;
        private int _wCoinP;
        private int _wCoinC;
        private int _goblinPoints;
        private List<Item> _gifItems = new List<Item>();
        private List<Item> _storage = new List<Item>();

        private static Dictionary<int, IBSCategory> cat;
        private static Dictionary<int, IBSPackage> pack;
        private static Dictionary<int, IBSProduct> prod;

        public static void Initialize(ushort[] ver)
        {
            version = new ushort[] { ver[0], ver[1], ver[2] };
            var root = $"./Data/CashShop/{ver[0]}.{ver[1]}.{ver[2]}/";

            cat = new Dictionary<int, IBSCategory>();
            pack = new Dictionary<int, IBSPackage>();
            prod = new Dictionary<int, IBSProduct>();

            using (var fs = File.OpenText(root+ "IBSCategory.txt"))
            {
                while (!fs.EndOfStream)
                {
                    var line = fs.ReadLine();
                    var subs = line.Split("@");

                    var a = new IBSCategory(subs);
                    cat.Add(a.CategoryId, a);
                }
            }

            using (var fs = File.OpenText(root + "IBSPackage.txt"))
            {
                while (!fs.EndOfStream)
                {
                    var line = fs.ReadLine();
                    var subs = line.Split("@");
                    try
                    {
                        var a = new IBSPackage(subs);
                    pack.Add(a.CategoryId*1000 + a.Position, a);
                    }
                    catch (Exception ex) {
                        Logger.Error("",ex);
                    }
                }
            }

            using (var fs = File.OpenText(root + "IBSProduct.txt"))
            {
                while (!fs.EndOfStream)
                {
                    var line = fs.ReadLine();
                    var subs = line.Split("@");

                    try
                    {
                        var a = new IBSProduct(subs);
                        prod.Add(a.NodeId, a);
                    }
                    catch (Exception) { }
                }
            }
        }

        public bool IsOpen { get; set; }

        public CashShop(GSSession session, CharacterDto db)
        {
            session.SendAsync(new SCashInit()).Wait();
            session.SendAsync(new SCashVersion { Ver1 = version[0], Ver2 = version[1], Ver3 = version[2] }).Wait();
            session.SendAsync(new SCashBanner { Ver1 = 583, Ver2 = 2014, Ver3 = 001 }).Wait();
            session.SendAsync(VersionSelector.CreateMessage<SCashPoints>(_wCoinC, _wCoinP, _goblinPoints)).Wait();

            _player = session.Player;
            log = Logger.ForAccount(session);
        }

        public void SendPoints()
        {
            _player.Session.SendAsync(VersionSelector.CreateMessage<SCashPoints>(_wCoinC, _wCoinP, _goblinPoints)).Wait();
        }

        public async void SendInventory(CCashInventoryItem message)
        {
            var _items = message.InventoryType == CSInventory.Storage ? _storage : _gifItems;

            var tPage = (ushort)Math.Ceiling(_items.Count / 8.0);
            var id = (message.Page - 1) * 8;
            var cicount = (ushort)Math.Max(_items.Count - id, 8);

            await _player.Session.SendAsync(new SCashInventoryItem
            {
                PageIndex = (ushort)message.Page,
                TotalPage = tPage,
                CurrentItemCount = cicount,
                TotalItemCount = (ushort)_items.Count,
            });

            var items = _items.Select(x => new SCashItemDto
            {
                InventoryType = message.InventoryType,
                AuthCode = 1,
                GiftName = "",
                Message = "",
                UniqueCode = 2,
                UniqueID1 = 3,
                UniqueID2 = 4,
                UniqueID3 = 5,
            }).ToArray();

            var msg = new SCashItemList
            {
                aIndex = _player.ID,
                AccountID = _player.Account.Nickname,
                InvType = message.InventoryType,
                InvNum = (byte)id,
                Result = 1,
                Items = items
            };
            Logger.Debug("Sending list from {0}", message.InventoryType);
            await _player.Session.SendAsync(msg);
        }

        public async void BuyItem(CCashItemBuy message)
        {
            var category = (from c in cat
                            where c.Value.CategoryId == message.Category
                            select c.Value).First();

            var package = (from p in pack
                           where p.Value.GameId == message.ItemIndex
                           select p.Value).First();

            var products = (from p in prod
                           where package.ProductNodeId.Contains(p.Value.NodeId) || package.ProductRootId.Contains(p.Value.RootId)
                           select p.Value);

            var product = (from p in products
                          where message.ItemOpt == 0 || p.NodeId == message.ItemOpt
                          select p)
                          .Skip(Program.RandomProvider(package.ProductRootId.Length))
                          .First();

            var neededCoins = product.Coins != 0 ? product.Coins : package.Price;

            log.Debug("Buy CashItem Cat:{0}->{1} ID:{2}, {3}{4}", category.Name, product.Name, message.ItemID, neededCoins, message.Coin);

            CSResult result = CSResult.Ok;

            switch(message.Coin)
            {
                case CoinType.GPoints:
                    if(_goblinPoints < neededCoins)
                    {
                        //result = CSResult.InsuficientWCoint;
                        break;
                    }
                    break;
                case CoinType.WCoin:
                    if (_wCoinC < neededCoins)
                    {
                        //result = CSResult.InsuficientWCoint;
                        break;
                    }
                    break;
            }

            if(package.DataTimeStart > DateTime.Now)
            {
                result = CSResult.ItemIsNotCurrentAvailable;
            }

            if(package.DataTimeExpir < DateTime.Now)
            {
                //result = CSResult.ItemIsNotLongerAvailable;
            }

            if(CSResult.Ok == result)
            {
                _storage.Add(new Item((ushort)product.ItemId));
            }

            await _player.Session.SendAsync(new SCashItemBuy { Result = result });
            SendInventory(new CCashInventoryItem { Page = 0, InventoryType = 0 });
        }
    }
}


--file Character.cs
﻿using MU.DataBase;
using MuEmu.Data;
using MuEmu.Entity;
using MuEmu.Monsters;
using MuEmu.Network;
using MU.Network.Auth;
using MU.Network.Game;
using MU.Network.PCPShop;
using MuEmu.Resources;
using MuEmu.Resources.Game;
using MuEmu.Resources.Map;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WebZen.Util;
using MU.Resources;
using MU.Network;
using MuEmu.Network.GameServices;
using MuEmu.Util;

namespace MuEmu
{
    public class PShop
    {
        public Character Chararacter { get; set; }
        public bool Open { get; set; }
        public string Name { get; set; }

        public PShopItemS9Eng[] Items => Chararacter.Inventory.PersonalShop.Items
            .Select(x => new PShopItemS9Eng() { 
                Pos = (byte)x.Value.SlotId, 
                Item = x.Value.GetBytes(), 
                Price = x.Value.PShopValueZ,
                BlessValue = x.Value.PShopValueB,
                SoulValue = x.Value.PShopValueS,
                ChaosValue = x.Value.PShopValueC,
            })
            .ToArray();

        public PShop(Character @char)
        {
            Chararacter = @char;
            Name = @char.Name + " Personal Store";
        }
    }

    public class SelfDefense
    {
        public Player Player { get; set; }
        public DateTime Ends { get; set; }
    }
    public class Character : IDisposable
    {
        #region Private
        private readonly List<List<float>> pklevelEXP = new List<List<float>>
        {
            new List<float> { 0.00f, 0.00f, 0.00f, 0.00f },//hero
            new List<float> { 0.00f, 0.00f, 0.00f, 0.00f },//hero
            new List<float> { 0.00f, 0.00f, 0.00f, 0.00f },//hero
            new List<float> { 0.03f, 0.02f, 0.01f, 0.00f },//commoner
            new List<float> { 0.05f, 0.05f, 0.05f, 0.00f },//pk1
            new List<float> { 0.10f, 0.10f, 0.10f, 0.10f },//pk2
            new List<float> { 0.20f, 0.20f, 0.20f, 0.20f } //murderer
        };
        private readonly List<float> pkLevelDropPVM = new List<float>
        {
            0.00f,
            0.00f,
            0.00f,
            0.06f, // Commoner
            0.25f, // warning
            0.50f,
            0.90f, // murderer
        };
        private readonly List<float> pkLevelDropPVP = new List<float>
        {
            0.00f,
            0.00f,
            0.00f,
            0.00f, // Commoner
            0.25f, // warning
            0.50f,
            0.90f, // murderer
        };

        private float _hp;
        private float _hpMax;
        private float _hpAdd;
        private float _sd;
        private float _sdMax;
        private float _sdAdd;
        private float _mp;
        private float _mpMax;
        private float _mpAdd;
        private float _bp;
        private float _bpMax;
        private float _bpAdd;
        private Point _position;
        private long _exp;
        private ushort _str;
        private ushort _strAdd;
        private ushort _agi;
        private ushort _agiAdd;
        private ushort _vit;
        private ushort _vitAdd;
        private ushort _ene;
        private ushort _eneAdd;
        private ushort _cmd;
        private ushort _cmdAdd;
        private uint _zen;
        private uint _ruud;
        private Maps _map = Maps.InvalidMap;
        private bool _needSave;
        private HeroClass _class;
        private ushort _level;
        private PKLevel _pkLevel;
        private ushort _levelUpPoints;
        private readonly Random _rand = new Random();
        private float _attackRatePvM = 0.0f;
        private float _attackRatePvP = 0.0f;
        private float _leftAttackMin = 0.0f;
        private float _leftAttackMax = 0.0f;
        private float _rightAttackMin = 0.0f;
        private float _rightAttackMax = 0.0f;
        private float _magicAttackMin = 0.0f;
        private float _magicAttackMax = 0.0f;
        private float _defense = 0.0f;
        private float _defenseRatePvM = 0.0f;
        private float _defenseRatePvP = 0.0f;
        private float _attackSpeed = 0.0f;
        private ushort _killerId;
        private int _deadlyDmg;
        private DateTime _autoRecuperationTime;
        #endregion

        /// <summary>
        /// Character ID in Database
        /// </summary>
        public int Id { get; }
        public Player Player { get; private set; }
        public Account Account => Player.Account;
        /// <summary>
        /// Network Index for client
        /// </summary>
        public ushort Index => (ushort)Player.Session.ID;

        public ControlCode CtlCode;
        private ushort _pcPoints;

        public Quests Quests { get; private set; }
        public Guild Guild { get; set; }
        public Inventory Inventory { get; private set; }
        public Spells Spells { get; private set; }
        public bool Change { get; set; }
        public Party Party { get; set; }
        public MasterLevel MasterLevel { get; private set; }
        public Friends Friends { get; private set; }
        public Gens Gens { get; private set; }
        public MuBot MuHelper { get; private set; }

        public PShop Shop { get; private set; }
        public CashShop CashShop { get; private set; }
        public Duel Duel { get; set; }
        public Monster KalimaGate { get; set; }
        public List<ushort> MonstersVP { get; set; }
        public List<Player> PlayersVP { get; set; }
        public List<ushort> ItemsVP { get; set; }

        #region Basic Info
        // Basic Info
        public HeroClass Class { get => _class; set { _class = value; _needSave = true; BaseInfo = ResourceCache.Instance.GetDefChar()[BaseClass]; } }
        public HeroClass BaseClass => (HeroClass)(((int)Class) & 0xF0);
        public bool Changeup {
            get => (((byte)Class) & 0x01) == 1;
            set
            {
                Class &= (HeroClass)(0xF0);
                Class |= (HeroClass)(value ? 1 : 0);
                _needSave = true;
            }
        }
        public bool MasterClass
        {
            get => (((byte)Class) & 0x02) == 2;
            set
            {
                Class &= (HeroClass)(0xF0);
                Class |= (HeroClass)(value ? 2 : 0);
                _needSave = true;
            }
        }
        public bool MajesticClass
        {
            get => (((byte)Class) & 0x04) == 4;
            set
            {
                Class &= (HeroClass)(0xF0);
                Class |= (HeroClass)(value ? 7 : 0);
                _needSave = true;
            }
        }
        public CharacterInfo BaseInfo { get; private set; }
        public ushort Resets { get; set; }
        public GremoryCase GremoryCase { get; private set; }
        internal HuntingRecord HuntingRecord { get; }
        public string Name { get; set; }
        public ushort Level { get => _level; set { _level = value; _needSave = true; } }
        public ushort GlobalLevel => (ushort)(_level + (MasterClass ? MasterLevel.Level : 0));
        public float Health {
            get => _hp;
            set {
                if (value > MaxHealth)
                {
                    value = MaxHealth;
                }

                if (_hp == value)
                    return;
                var arg = _hp > value ? RefillInfo.Update : RefillInfo.Drink;
                if (value <= 0)
                {
                    _hp = 0;
                    CharacterDie?.Invoke(this, new EventArgs());
                }else
                {
                    _hp = value;
                }


                HPorSDChanged(RefillInfo.Drink);
            }
        }
        public float MaxHealth
        {
            get => _hpMax + _hpAdd + Spells.IncreaseMaxHP;
            set
            {
                if (value == _hpMax + _hpAdd)
                    return;

                _hpAdd = value - _hpMax;

                HPorSDMaxChanged();
            }
        }
        public float Shield
        {
            get => _sd;
            set
            {
                if (value > MaxShield)
                {
                    value = MaxShield;
                }

                if (_sd == value)
                    return;

                var arg = _sd > value ? RefillInfo.Update : RefillInfo.Drink;
                if(value < 0)
                {
                    _sd = 0;
                }
                else
                {
                    _sd = value;
                }

                HPorSDChanged(RefillInfo.Drink);
            }
        }
        public float MaxShield
        {
            get => _sdMax + _sdAdd + Spells.IncreaseMaxSD;
            set
            {
                if (value == _sdMax + _sdAdd)
                    return;

                _sdAdd = value - _hpMax;

                HPorSDMaxChanged();
            }
        }
        public float Mana
        {
            get => _mp;
            set
            {
                if (value > MaxMana)
                {
                    value = MaxMana;
                }

                if (_mp == value)
                    return;

                var arg = _mp > value ? RefillInfo.Update : RefillInfo.Drink;

                if(value < 0)
                {
                    _mp = 0;
                }
                else
                {
                    _mp = value;
                }

                MPorBPChanged(arg);
            }
        }
        public float MaxMana
        {
            get => _mpMax + _mpAdd + Spells.IncreaseMaxMP;
            set
            {
                if (value == _mpMax + _mpAdd)
                    return;

                _mpAdd = value - _mpMax;

                MPorBPMaxChanged();
            }
        }
        public float Stamina
        {
            get => _bp;
            set
            {
                if (value > MaxStamina)
                {
                    value = MaxStamina;
                }

                if (_bp == value)
                    return;
                var arg = _bp > value ? RefillInfo.Update : RefillInfo.Drink;
                if (value < 0)
                {
                    _bp = 0;
                }
                else
                {
                    _bp = value;
                }

                MPorBPChanged(arg);
            }
        }
        public float MaxStamina
        {
            get => _bpMax + _bpAdd + Spells.IncreaseMaxAG;
            set
            {
                if (value == _bpMax + _bpAdd)
                    return;

                _bpAdd = value - _bpMax;

                MPorBPMaxChanged();
            }
        }
        public uint Money
        {
            get => _zen;
            set
            {
                if (value == _zen)
                    return;

                if (value > int.MaxValue)
                {
                    _zen = int.MaxValue;
                }
                else
                {
                    _zen = value;
                }
                _needSave = true;
                OnMoneyChange();
            }
        }
        public uint Ruud
        {
            get => _ruud;
            set
            {
                if (value == _ruud)
                    return;

                if (value > int.MaxValue)
                {
                    _ruud = int.MaxValue;
                }
                else
                {
                    _ruud = value;
                }
                _needSave = true;
                OnRuudChange();
            }
        }
        public PKLevel PKLevel { get => _pkLevel; 
            set
            {
                if (_pkLevel == value)
                    return;

                _pkLevel = value;
                _needSave = true;
                var pklev = new SPKLevel { Index = Player.ID, PKLevel = PKLevel };
                Player.SendV2Message(pklev);
                _ = Player.Session.SendAsync(pklev);
            } }
        public DateTime PKTimeEnds { get; set; }
        #endregion

        #region MapInfo
        // Map
        public Maps MapID {
            get => _map;
            set {
                if (_map == value)
                    return;
                _map = value;
                _needSave = true;
            }
        }
        public Point Position {
            get => _position;
            set
            {
                if (_position == value)
                    return;

                Map.PositionChanged(_position, value);
                _position = value;
                _needSave = true;
            }
        }
        public Point TPosition { get; set; }
        public byte Direction { get; set; }
        public byte Action { get; set; }

        public MapInfo Map { get; private set; }
        #endregion

        /// <summary>
        /// On Map Change trigger this event with sender as Character
        /// </summary>
        public event EventHandler MapChanged;

        /// <summary>
        /// On player die trigger this event with sender as Character
        /// </summary>
        public event EventHandler CharacterDie;

        /// <summary>
        /// On player regen trigger this event with sender as Character
        /// </summary>
        public event EventHandler CharacterRegen;

        // Experience
        public long Experience { get => _exp;
            set
            {
                if (value == _exp)
                    return;

                var gain = ((long)value - (long)_exp);
                MasterLevel.GetExperience(gain);

                _exp = value;

                if (_exp < 0)
                    _exp = 0;

                if (_exp >= NextExperience)
                    OnLevelUp();

                if (_exp < BaseExperience)
                    _exp = BaseExperience;

                HuntingRecord.GainExperience(gain);

                if (BaseClass == HeroClass.DarkLord)
                {

                    var pets = Inventory.FindAllItems(6661);
                    pets.AddRange(Inventory.FindAllItems(6660));
                    pets = pets.Where(x => x.SlotId <= (int)Equipament.LeftRing).ToList();
                    pets.AddRange(_mounts.Where(x => (int)x.Number == 6661 || (int)x.Number == 6660));

                    gain /= 5;
                    if (pets.Count > 1)
                        gain /= 2;

                    pets.ForEach(x => x.AddExperience((int)gain));
                }

                _needSave = true;
            }
        }
        public long BaseExperience => GetExperienceFromLevel((ushort)(Level - 1));
        public long NextExperience => GetExperienceFromLevel(Level);

        #region Stats
        // Points
        public ushort LevelUpPoints { get => _levelUpPoints;
            set
            {
                if (_levelUpPoints == value)
                    return;

                _levelUpPoints = value;
                _needSave = true;
            }
        }

        public ushort PCPoints
        {
            get => _pcPoints;
            set
            {
                _pcPoints = value;
                Player.Session.SendAsync(new SPCPShopPoints(value, 25000)).Wait();
            }
        }

        public ushort Strength
        {
            get => _str;
            set
            {
                if (value == _str)
                    return;

                _str = value;
                _needSave = true;
                CalcStats();
            }
        }
        public ushort StrengthAdd
        {
            get => _strAdd;
            set
            {
                if (value == _strAdd)
                    return;

                _strAdd = value;
                CalcStats();
            }
        }
        public ushort StrengthTotal => (ushort)(_str + _strAdd + Spells.IncreaseStrength);

        public ushort Agility
        {
            get => _agi;
            set
            {
                if (value == _agi)
                    return;

                _agi = value;
                _needSave = true;
                CalcStats();
            }
        }
        public ushort AgilityAdd
        {
            get => (_agiAdd);
            set
            {
                if (value == _agiAdd)
                    return;

                _agiAdd = value;
                CalcStats();
            }
        }
        public ushort AgilityTotal => (ushort)(_agi + _agiAdd + Spells.IncreaseAgility);

        public ushort Vitality
        {
            get => _vit;
            set
            {
                if (value == _vit)
                    return;

                _vit = value;
                _needSave = true;
                CalcStats();
            }
        }
        public ushort VitalityAdd
        {
            get => _vitAdd;
            set
            {
                if (value == _vitAdd)
                    return;

                _vitAdd = value;
                CalcStats();
            }
        }
        public ushort VitalityTotal => (ushort)(_vit + _vitAdd);

        public ushort Energy
        {
            get => _ene;
            set
            {
                if (value == _ene)
                    return;

                _ene = value;
                _needSave = true;
                CalcStats();
            }
        }
        public ushort EnergyAdd
        {
            get => _eneAdd;
            set
            {
                if (value == _eneAdd)
                    return;

                _eneAdd = value;
                CalcStats();
            }
        }
        public ushort EnergyTotal => (ushort)(_ene + _eneAdd);

        public ushort Command
        {
            get => _cmd;
            set
            {
                if (value == _cmd)
                    return;

                _cmd = value;
                _needSave = true;
                CalcStats();
            }
        }
        public ushort CommandAdd
        {
            get => _cmdAdd;
            set
            {
                if (value == _cmdAdd)
                    return;

                _cmdAdd = value;
                CalcStats();
            }
        }
        public ushort CommandTotal => (ushort)(_cmd + _cmdAdd);

        internal static void Reset(object session, CommandEventArgs e)
        {
            var Session = session as GSSession;
            var @char = Session.Player.Character;

            if (@char.Level < 400)
            {
                Session.SendAsync(new SNotice(NoticeType.Blue, "Necesitas nivel 400")).Wait();
                return;
            }

            if (@char.Money < 1000000)
            {
                Session.SendAsync(new SNotice(NoticeType.Blue, "Necesitas 1000000zen")).Wait();
                return;
            }


            var cinfo = @char.BaseInfo.Stats;

            @char.Level = 1;
            @char.Experience = 0;
            @char.Money -= 1000000u;
            //@char.Strength = (ushort)cinfo.Str;
            //@char.Agility = (ushort)cinfo.Agi;
            //@char.Vitality = (ushort)cinfo.Vit;
            //@char.Energy = (ushort)cinfo.Ene;
            //@char.Command = (ushort)cinfo.Cmd;
            @char.MapID = @char.BaseInfo.Map;
            @char.Resets++;
            //@char.LevelUpPoints = (ushort)Math.Min(@char.Resets*250, 65535);
            GameServices.CClientClose(Session, new CClientClose { Type = ClientCloseType.ServerList }).Wait();
        }

        public int TotalPoints => _str + _agi + _vit + _ene + _cmd + LevelUpPoints;

        public short AddPoints => (short)(TotalPoints - (BaseInfo.Stats.Str + BaseInfo.Stats.Agi + BaseInfo.Stats.Vit + BaseInfo.Stats.Ene + BaseInfo.Stats.Cmd + (Level - 1) * 5));
        public short MaxAddPoints => 100;
        public short MinusPoints => 0;
        public short MaxMinusPoints => 100;
        #endregion

        public ushort AttackRatePvM => (ushort)(_attackRatePvM + Spells.PvMAttackSuccessRate);
        public ushort AttackRatePvP => (ushort)_attackRatePvP;

        public ushort Defense => (ushort)(_defense + Spells.BuffList.Sum(x => x.DefenseAdd));
        public ushort DefenseRatePvM => (ushort)(_defenseRatePvM + Spells.BuffList.Sum(x => x.DefenseAddRate)*100.0f);
        public ushort DefenseRatePvP => (ushort)(_defenseRatePvP + Spells.PvPDefenceSuccessRate + Spells.BuffList.Sum(x => x.DefenseAddRate)*100.0f);

        public ushort CriticalDamage => (ushort)(_rightAttackMax + _leftAttackMax);
        public ushort ExcellentDamage => (ushort)(CriticalDamage * 2);

        public ObjectState State { get; set; }
        public DateTimeOffset RegenTime { get; private set; }
        public byte ClientClass => GetClientClass(Class);

        public PetMode PetMode { get; set; }
        public ushort PetTarget { get; set; }
        public DateTime PetLastAttack { get; set; }

        private List<Item> _mounts = new List<Item>();
        public UseItemFlag ApplyMount(Item it, UseItemFlag flag)
        {
            switch(flag)
            {
                case UseItemFlag.Apply:
                    if (!_mounts.Contains(it))
                    {
                        _mounts.Add(it);
                        it.Harmony.Option = 1;
                    }
                    else
                        break;
                    return flag;
                case UseItemFlag.Remove:
                    _mounts.Remove(it);
                    it.Harmony.Option = 0;
                    return flag;
            }
            return UseItemFlag.Remove;
        }
        public bool DataLoaded { get; internal set; }

        public List<SelfDefense> SelfDefense { get; set; } = new List<SelfDefense>();
        public bool HaveMount => _mounts.Any();

        public bool Transformation { get; internal set; }
        public ushort Skin { get; internal set; } = 0xffff;

        private Item getDarkRaven()
        {
            var item = _mounts.FirstOrDefault(x => (int)x.Number == 6661);
            if(item == null)
                item = Inventory.Get(Equipament.LeftHand);

            if (item?.Number.Number != 6661)
                return null;

            return item;
        }
        internal void AttackPet(ushort targetNumber)
        {
            var pet = getDarkRaven();
            //var rh = Inventory.Get(Equipament.RightHand);
            var attack = Program.RandomProvider(pet.AttackMax, pet.AttackMin);

            if (MonstersMng.MonsterStartIndex < targetNumber)
            {
                var mob = MonstersMng.Instance.GetMonster(targetNumber);
                if (MissCheck(mob.Info.Success))
                {
                    return;
                }

                //attack -= mob.Defense;
                mob.GetAttackedDelayed(Player, attack, DamageType.Regular, TimeSpan.FromMilliseconds(600));
                mob.Life -= attack;
            }
            else
            {

            }

            var msg = new SPetAttack
            {
                Number = Player.ID,
                TargetNumber = targetNumber,
                PetType = 0,
                SkillType = 1,
            };

            _=Player.Session.SendAsync(msg);
            SendV2Message(msg);
        }
        public void UpdatePetIA()
        {
            if (BaseClass != HeroClass.DarkLord)
                return;

            if (Map.GetAttributes(Position).Contains(MapAttributes.Safe))
                return;

            var pet = getDarkRaven();

            if (pet == null || PetLastAttack > DateTime.Now)
                return;

            int sleep = 1500 - pet.AttackSpeed * 10;
            PetLastAttack = DateTime.Now.AddMilliseconds(sleep);

            switch (PetMode)
            {
                case PetMode.AttackRandom:
                    if(PetTarget == 0xffff)
                    {
                        var mob = (from m in Map.Monsters
                                   where m.Position.Substract(Position).LengthSquared() < 6 && m.State == ObjectState.Live && m.Type == ObjectType.Monster
                                   orderby m.Position.Substract(Position).LengthSquared()
                                   select m).FirstOrDefault();

                        if (mob != null)
                        {
                            PetTarget = mob.Index;
                        }
                    }
                    if(PetTarget != 0xffff)
                    {
                        var mob = MonstersMng.Instance.GetMonster(PetTarget);
                        if(mob.State != ObjectState.Live)
                        {
                            PetTarget = 0xffff;
                            return;
                        }

                        AttackPet(PetTarget);
                    }
                    break;
                case PetMode.AttackWithMaster:
                case PetMode.AttackTarget:
                    if (PetTarget != 0xffff)
                    {
                        var mob = MonstersMng.Instance.GetMonster(PetTarget);
                        if (mob.State != ObjectState.Live)
                        {
                            PetTarget = 0xffff;
                            return;
                        }
                        else
                        {
                            AttackPet(PetTarget);
                        }
                    }
                    break;
            }
        }

        public static byte GetClientClass(HeroClass dbClass)
        {
            var @class = (int)dbClass;

            var result = @class & 0xF8;
            if(Program.Season >= ServerSeason.Season16Kor)
            {
                result |= (@class & 1) << 3;
                result |= (@class & 2) << 1;
                result |= (@class & 4) >> 1;
                result &= 0xFF;
                return (byte)result;
            }

            var changeUp = @class & 0x03;
            result |= (changeUp == 1) ? 0x08 : 0x00;
            result |= (changeUp == 2) ? 0x0C : 0x00;
            result <<= Program.Season == ServerSeason.Season12Eng ? 0 : 1;
            result &= 0xFF;
            return (byte)result;
        }

        public Character(Player plr, CharacterDto characterDto)
        {
            Player = plr;
            Player.Character = this;
            _autoRecuperationTime = DateTime.Now;
            CharacterDie += OnDead;
            Id = characterDto.CharacterId;
            Name = characterDto.Name;
            Class = (HeroClass)characterDto.Class;
            Level = characterDto.Level;
            Quests = new Quests(this, characterDto);
            Spells = new Spells(this, characterDto);
            Inventory = new Inventory(this, characterDto);
            MasterLevel = new MasterLevel(this, characterDto);
            Friends = new Friends(this, characterDto);
            Shop = new PShop(this);
            MonstersVP = new List<ushort>();
            ItemsVP = new List<ushort>();
            PlayersVP = new List<Player>();
            MuHelper = new MuBot(plr);
            Gens = new Gens(this, characterDto);
            State = ObjectState.Regen;
            CtlCode = (ControlCode)characterDto.CtlCode;
            Resets = characterDto.Resets;
            GremoryCase = new GremoryCase(this, characterDto);
            HuntingRecord = new HuntingRecord(this, characterDto);

            _position = new Point(characterDto.X, characterDto.Y);
            TPosition = _position;
            _map = (Maps)characterDto.Map;
            Map = ResourceCache.Instance.GetMaps()[_map];
            Map.AddPlayer(this);
            Map.SetAttribute(_position.X, _position.Y, MapAttributes.Stand);

            _exp = characterDto.Experience;
            _str = characterDto.Str;
            _agi = characterDto.Agility;
            _vit = characterDto.Vitality;
            _ene = characterDto.Energy;
            _cmd = characterDto.Command;
            _levelUpPoints = characterDto.LevelUpPoints;
            _pkLevel = (PKLevel)characterDto.PKLevel;
            PKTimeEnds = DateTime.Now.AddSeconds(characterDto.PKTime);

            CalcStats();

            Shield = _sdMax;
            Health = Math.Max(characterDto.Life, MaxHealth * 0.1f);
            Stamina = _bpMax / 2;
            Mana = characterDto.Mana;
            _zen = characterDto.Money;
            _ruud = characterDto.Ruud;

            PCPoints = 0;
            //byte ctlCode
            var StatsInfo = VersionSelector.CreateMessage<SCharacterMapJoin2>(
                MapID, 
                (byte)Position.X, 
                (byte)Position.Y, 
                Direction, 
                StrengthTotal, 
                AgilityTotal,
                VitalityTotal,
                EnergyTotal,
                CommandTotal,
                Experience,
                NextExperience,
                (ushort)Health,
                (ushort)_hpMax,
                (ushort)Mana,
                (ushort)_mpMax,
                (ushort)Shield,
                (ushort)MaxShield,
                (ushort)Stamina,
                (ushort)_bpMax,
                (byte)PKLevel,
                AddPoints,
                MaxAddPoints,
                MinusPoints,
                MaxMinusPoints,
                LevelUpPoints,
                characterDto.ExpandedInventory,
                Money,
                Ruud,
                (byte)CtlCode
               );

            CashShop = new CashShop(plr.Session, characterDto);
            plr.Session.SendAsync(StatsInfo).Wait();

            Inventory.SendInventory();
            Inventory.SendMuunInventory();
            Inventory.SendEventInventory();

            Quests.SendList();

            if (Class >= HeroClass.MuseElf && BaseClass == HeroClass.FaryElf)
                Spells.TryAdd(Spell.InfinityArrow).Wait();

            Spells.SendList();
            MasterLevel.SendInfo();
            Gens.SendMemberInfo();
            Program.Experience.SendExpInfo(plr.Session);
            try
            {
                plr.Session.SendAsync(new SResets { Resets = Resets }).Wait();
            }
            catch (Exception) { }

            plr.Session.SendAsync(new SEventEnterCount { Type = EventEnterType.BloodCastle, Left = 4 });
        }

        public void SendV2Message(object message, Player exclude = null)
        {
            lock (PlayersVP)
            {
                foreach (var plr in PlayersVP.Where(x => x != exclude))
                    plr.Session.SendAsync(message).Wait();
            }
        }

        #region EventHandlers
        public async void HPorSDChanged(RefillInfo info)
        {
            Party?.LifeUpdate();

            await Player.Session.SendAsync(VersionSelector.CreateMessage<SHeatlUpdate>(info, (ushort)_hp, (ushort)_sd, false));
        }
        private async void HPorSDMaxChanged()
        {
            Party?.LifeUpdate();

            await Player.Session.SendAsync(VersionSelector.CreateMessage<SHeatlUpdate>(RefillInfo.MaxChanged, (ushort)MaxHealth, (ushort)MaxShield, false));
        }
        private async void MPorBPChanged(RefillInfo info)
        {
            Party?.LifeUpdate();
            await Player.Session.SendAsync(new SManaUpdate(info, (ushort)_mp, (ushort)_bp));
        }
        private async void MPorBPMaxChanged()
        {
            Party?.LifeUpdate();
            await Player.Session.SendAsync(new SManaUpdate(RefillInfo.MaxChanged, (ushort)MaxMana, (ushort)MaxStamina));
        }
        private async void OnLevelUp()
        {
            if (Level >= 400)
                return;

            var curLevel = Level;

            do
            {
                Level++;
            } while (_exp >= NextExperience);

            CalcStats();

            var levelPoint = BaseClass == HeroClass.MagicGladiator || BaseClass == HeroClass.DarkLord ? 7 : 5;
            levelPoint += MasterClass ? 1 : 0;
            LevelUpPoints += (ushort)(levelPoint * (Level - curLevel));
            _hp = MaxHealth;
            _mp = MaxMana;
            _bp = MaxStamina;
            _sd = MaxShield;

            await Player.Session.SendAsync(new SLevelUp
            {
                Level = Level,
                LevelUpPoints = LevelUpPoints,
                MaxLife = (ushort)MaxHealth,
                MaxMana = (ushort)MaxMana,
                MaxShield = (ushort)MaxShield,
                MaxBP = (ushort)MaxStamina,
                AddPoint = (ushort)AddPoints,
                MaxAddPoint = (ushort)MaxAddPoints,
                MinusPoint = (ushort)MinusPoints,
                MaxMinusPoint = (ushort)MaxMinusPoints,
            });

            await Player.Session.SendAsync(new SEffect((ushort)Player.Session.ID, ClientEffect.LevelUp));
        }
        private async void OnMoneyChange()
        {
            var msg = VersionSelector.CreateMessage<SItemGet>(Money, (ushort)0xffff);
            await Player.Session.SendAsync(msg);
        }
        private async void OnRuudChange()
        {
            var msg = new SRuudSend { Ruud = Ruud };
            await Player.Session.SendAsync(msg);
        }
        internal void DisposeKalimaGate()
        {
            if (KalimaGate != null)
            {
                KalimaGate.Killer = Player;
                KalimaGate.Life = 0;
                KalimaGate.Caller = null;
                KalimaGate.ViewPort.ForEach(x => x.Character.MonstersVP.Remove(KalimaGate.Index));
                KalimaGate.ViewPort.Clear();
                KalimaGate.Map.DelMonster(KalimaGate);
                MonstersMng.Instance.Monsters.Remove(KalimaGate);
                KalimaGate = null;
            }
        }
        private void OnDead(object obj, EventArgs args)
        {
            State = ObjectState.Dying;
            RegenTime = DateTimeOffset.Now.AddSeconds(4);
            var die = new SDiePlayer((ushort)Player.Session.ID, 1, _killerId);
            DisposeKalimaGate();
            _=Player.Session.SendAsync(die);
            SendV2Message(die);

            int range = 0;
            if (Level > 220)
                range = 3;
            else if (Level > 150)
                range = 2;
            else if (Level > 10)
                range = 1;

            var drop = 0.0f;

            if (_killerId >= MonstersMng.MonsterStartIndex)
            {
                Experience -= (long)(Experience * pklevelEXP[(byte)PKLevel][range]);
                Money -= (uint)(Money * 0.04f);
                Player.Account.VaultMoney -= (int)(Player.Account.VaultMoney * 0.04f);

                drop = pkLevelDropPVM[(byte)PKLevel];
            }
            else
            {
                drop = pkLevelDropPVP[(byte)PKLevel];

                var killer = Program.server.Clients.FirstOrDefault(x => x.ID == _killerId);
                if(killer != null)
                {
                    var plr = killer.Player;
                    var duel = killer.Player.Character.Duel == Duel;
                    if(!plr.Character.SelfDefense.Any(x => x.Player.Character == this) && !duel)
                    {
                        if(PKLevel <= PKLevel.Commoner)
                        {
                            switch(plr.Character.PKLevel)
                            {
                                case PKLevel.Hero:
                                case PKLevel.Hero1:
                                case PKLevel.Hero2:
                                case PKLevel.Commoner:
                                    plr.Character.PKLevel = PKLevel.Warning;
                                    plr.Character.PKTimeEnds = DateTime.Now.AddHours(3);
                                    break;
                                case PKLevel.Warning:
                                    plr.Character.PKLevel = PKLevel.Warning;
                                    plr.Character.PKTimeEnds = plr.Character.PKTimeEnds.AddHours(3);
                                    break;
                                case PKLevel.Warning2:
                                    plr.Character.PKLevel = PKLevel.Murderer;
                                    plr.Character.PKTimeEnds = plr.Character.PKTimeEnds.AddHours(3);
                                    break;
                                case PKLevel.Murderer:
                                    plr.Character.PKTimeEnds = plr.Character.PKTimeEnds.AddHours(3);
                                    break;
                            }
                        }
                        else
                        {
                            
                        }
                    }
                }
            }

            // Drop on Die
            if(drop*100 > Program.RandomProvider(100))
            {
                var allItems = Inventory.MainInventory();
                if(allItems.Any())
                {
                    var rand = Program.RandomProvider(allItems.Count);
                    allItems[rand].Drop((byte)Position.X, (byte)Position.Y);
                }
            }
        }
        #endregion
        public void CalcStats()
        {
            if (Inventory == null)
                return;

            var att = BaseInfo.Attributes;
            _hpMax = (att.Life + att.LevelLife * (Level - 1 + (MasterLevel.Level - 1)) + att.VitalityToLife * Vitality)* (1.0f + Inventory.IncreaseHP + Spells.IncreaseMaxHP);
            _mpMax = (att.Mana + att.LevelMana * (Level - 1 + (MasterLevel.Level - 1)) + att.EnergyToMana * Energy)* (1.0f + Inventory.IncreaseMP);
            _bpMax = ((att.StrToBP * StrengthTotal) + (att.AgiToBP * AgilityTotal) + (att.VitToBP * VitalityTotal) + (att.EneToBP * EnergyTotal)) * (1.0f + Spells.IncreaseMaxAG);
            _sdMax = TotalPoints * 3 + (Level * Level) / 30/* + Defense*/ + Inventory.IncreaseSD;

            _ = Player.Session.SendAsync(new SXUpPront
            {
                AddDex = AgilityAdd,
                AddEne = EnergyAdd,
                AddLeadership = CommandAdd,
                AddStr = StrengthAdd,
                AddVit = VitalityAdd,
                Dex = Agility,
                Ene = Energy,
                Leadership = Command,
                Str = Strength,
                Vit = Vitality,
                mPrec = MaxMana / 27.5f,
            });

            Inventory.CalcStats();
            ObjCalc();
            HPorSDMaxChanged();
            MPorBPMaxChanged();
        }
        public void ObjCalc()
        {
            var right = Inventory?.Get(Equipament.RightHand)??null;
            var left = Inventory?.Get(Equipament.LeftHand)??null;

            switch(BaseClass)
            {
                case HeroClass.RuneWizard:
                case HeroClass.DarkWizard:
                    _leftAttackMin = (StrengthTotal / 8);
                    _leftAttackMax = (StrengthTotal / 4);
                    _rightAttackMin = (StrengthTotal / 8);
                    _rightAttackMax = (StrengthTotal / 4);
                    break;
                case HeroClass.DarkKnight:
                    _leftAttackMin = (StrengthTotal / 6);
                    _leftAttackMax = (StrengthTotal / 4);
                    _rightAttackMin = (StrengthTotal / 6);
                    _rightAttackMax = (StrengthTotal / 4);
                    break;
                case HeroClass.FaryElf:
                    if ((right?.Number.Type ?? ItemType.Invalid) == ItemType.BowOrCrossbow || (left?.Number.Type ?? ItemType.Invalid) == ItemType.BowOrCrossbow)
                    {
                        _leftAttackMin = AgilityTotal / 8;
                        _leftAttackMax = AgilityTotal / 4;
                        _rightAttackMin = AgilityTotal / 8;
                        _rightAttackMax = AgilityTotal / 4;
                    }
                    else
                    {
                        _leftAttackMin = (StrengthTotal + AgilityTotal) / 7;
                        _leftAttackMax = (StrengthTotal + AgilityTotal) / 4;
                        _rightAttackMin = (StrengthTotal + AgilityTotal) / 7;
                        _rightAttackMax = (StrengthTotal + AgilityTotal) / 4;
                    }
                    break;
                case HeroClass.MagicGladiator:
                    _leftAttackMin = (StrengthTotal / 6) + (EnergyTotal / 12);
                    _leftAttackMax = (StrengthTotal / 4) + (EnergyTotal / 8);
                    _rightAttackMin = (StrengthTotal / 6) + (EnergyTotal / 12);
                    _rightAttackMax = (StrengthTotal / 4) + (EnergyTotal / 8);
                    break;
                case HeroClass.DarkLord:
                    _leftAttackMin = (StrengthTotal / 7) + (EnergyTotal / 14);
                    _leftAttackMax = (StrengthTotal / 5) + (EnergyTotal / 10);
                    _rightAttackMin = (StrengthTotal / 7) + (EnergyTotal / 14);
                    _rightAttackMax = (StrengthTotal / 5) + (EnergyTotal / 10);
                    break;
                case HeroClass.Summoner:
                    _leftAttackMin = (StrengthTotal / 8);
                    _leftAttackMax = (StrengthTotal / 4);
                    _rightAttackMin = (StrengthTotal / 8);
                    _rightAttackMax = (StrengthTotal / 4);
                    break;
                //case HeroClass.RageFighter:
                //    break;
                case HeroClass.GrowLancer:
                    _leftAttackMin = (StrengthTotal / 8) + (AgilityTotal / 10);
                    _leftAttackMax = (StrengthTotal / 4) + (AgilityTotal / 6);
                    _rightAttackMin = (StrengthTotal / 8) + (AgilityTotal / 10);
                    _rightAttackMax = (StrengthTotal / 4) + (AgilityTotal / 6);
                    break;
                case HeroClass.Slayer:
                    _leftAttackMin = (StrengthTotal / 9);
                    _leftAttackMax = (StrengthTotal / 4);
                    _rightAttackMin = (StrengthTotal / 9);
                    _rightAttackMax = (StrengthTotal / 4);
                    break;
                default:
                    _leftAttackMin = (StrengthTotal / 8);
                    _leftAttackMax = (StrengthTotal / 4);
                    _rightAttackMin = (StrengthTotal / 8);
                    _rightAttackMax = (StrengthTotal / 4);
                    break;
            }

            

            if (right?.Attack ?? false)
            {
                _rightAttackMin += right.AttackMin;
                _rightAttackMax += right.AttackMax;
            }

            if (left?.Attack ?? false)
            {
                _leftAttackMin += left.AttackMin;
                _leftAttackMax += left.AttackMax;
            }

            if (BaseClass == HeroClass.DarkKnight || BaseClass == HeroClass.MagicGladiator)
            {
                if ((right?.Number ?? ItemNumber.Invalid) == (left?.Number ?? ItemNumber.Invalid) && (right?.Number ?? ItemNumber.Invalid) != ItemNumber.Invalid)
                {
                    _rightAttackMin *= 0.55f;
                    _rightAttackMax *= 0.55f;
                    _leftAttackMin *= 0.55f;
                    _leftAttackMax *= 0.55f;
                }
            }

            switch(BaseClass)
            {
                case HeroClass.DarkKnight:
                    _defense = AgilityTotal / 3.0f;
                    _defenseRatePvM = AgilityTotal / 3.0f;
                    _defenseRatePvP = Level * 2 + AgilityTotal / 0.5f;
                    _attackRatePvM = Level * 5 + AgilityTotal * 1.5f + StrengthTotal / 4;
                    _attackRatePvP = Level * 5 + AgilityTotal * 4.5f;
                    _attackSpeed = AgilityTotal / 15.0f;
                    break;
                case HeroClass.GunCrusher:
                    _defense = AgilityTotal / 3.0f;
                    _defenseRatePvM = AgilityTotal / 4.0f;
                    _defenseRatePvP = Level * 2 + AgilityTotal * 2.0f;
                    _attackRatePvM = Level * 5 + AgilityTotal * 1.5f + StrengthTotal / 4;
                    _attackRatePvP = Level * 3 + AgilityTotal * 3.5f;
                    _attackSpeed = AgilityTotal / 20.0f;
                    _magicAttackMin = EnergyTotal / 9.0f;
                    _magicAttackMax = EnergyTotal / 4.0f;
                    break;
                case HeroClass.RuneWizard:
                case HeroClass.DarkWizard:
                    _defense = AgilityTotal / 5.0f;
                    _defenseRatePvM = AgilityTotal / 3.0f;
                    _defenseRatePvP = Level * 2 + AgilityTotal / 0.25f;
                    _attackRatePvM = Level * 5 + AgilityTotal * 1.5f + StrengthTotal / 4;
                    _attackRatePvP = Level * 3 + AgilityTotal * 4.0f;
                    _attackSpeed = AgilityTotal / 10.0f;
                    _magicAttackMin = EnergyTotal / 9.0f;
                    _magicAttackMax = EnergyTotal / 4.0f;
                    break;
                case HeroClass.Slayer:
                    _defense = AgilityTotal / 5.0f;
                    _defenseRatePvM = AgilityTotal / 3.0f;
                    _defenseRatePvP = Level * 2 + AgilityTotal / 0.25f;
                    _attackRatePvM = Level * 5 + AgilityTotal * 1.5f + StrengthTotal / 4;
                    _attackRatePvP = Level * 3 + AgilityTotal * 4.0f;
                    _attackSpeed = AgilityTotal / 12.0f;
                    _magicAttackMin = EnergyTotal / 9.0f;
                    _magicAttackMax = EnergyTotal / 4.0f;
                    break;
                case HeroClass.FaryElf:
                    _defense = AgilityTotal / 10.0f;
                    _defenseRatePvM = AgilityTotal / 4.0f;
                    _defenseRatePvP = Level * 2 + AgilityTotal / 0.1f;
                    _attackRatePvM = Level * 5 + AgilityTotal * 1.5f + StrengthTotal / 4;
                    _attackRatePvP = Level * 5 + AgilityTotal * 0.6f;
                    _attackSpeed = AgilityTotal / 50.0f;
                    _magicAttackMax = _leftAttackMax;
                    _magicAttackMin = _leftAttackMin;
                    break;
                case HeroClass.MagicGladiator:
                    _defense = AgilityTotal / 5.0f;
                    _defenseRatePvM = AgilityTotal / 3.0f;
                    _defenseRatePvP = Level * 2 + AgilityTotal / 0.25f;
                    _attackRatePvM = Level * 5 + AgilityTotal * 1.5f + StrengthTotal / 4;
                    _attackRatePvP = Level * 5 + AgilityTotal * 3.5f;
                    _attackSpeed = AgilityTotal / 15.0f;
                    break;
                case HeroClass.DarkLord:
                    _defense = AgilityTotal / 7.0f;
                    _defenseRatePvM = AgilityTotal / 7.0f;
                    _defenseRatePvP = Level * 2 + AgilityTotal / 0.5f;
                    _attackRatePvM = Level * 5 + AgilityTotal * 2.5f + StrengthTotal / 4 + CommandTotal / 10;
                    _attackRatePvP = Level * 5 + AgilityTotal * 4.0f;
                    _attackSpeed = AgilityTotal / 10.0f;
                    break;
                case HeroClass.Summoner:
                    _defense = AgilityTotal / 3.0f;
                    _defenseRatePvM = AgilityTotal / 4.0f;
                    _defenseRatePvP = Level * 2 + AgilityTotal / 0.5f;
                    _attackRatePvM = Level * 5 + AgilityTotal * 1.5f + StrengthTotal / 4;
                    _attackRatePvP = Level * 5 + AgilityTotal * 3.5f;
                    _attackSpeed = AgilityTotal / 20.0f;
                    _magicAttackMin = EnergyTotal / 9.0f;
                    _magicAttackMax = EnergyTotal / 4.0f;
                    break;
                case HeroClass.RageFighter:
                    _defense = AgilityTotal / 3.0f;
                    _defenseRatePvM = AgilityTotal / 3.0f;
                    _defenseRatePvP = Level * 2 + AgilityTotal / 0.5f;
                    _attackRatePvM = Level * 5 + AgilityTotal * 1.5f + StrengthTotal * 4;
                    _attackRatePvP = Level * 5 + AgilityTotal * 4.5f;
                    _attackSpeed = AgilityTotal / 15.0f;
                    if (_attackSpeed > 288) _attackSpeed = 288.0f;
                    break;
                case HeroClass.GrowLancer:
                    _defense = AgilityTotal / 7.0f;
                    _defenseRatePvM = AgilityTotal / 3.0f;
                    _defenseRatePvP = Level * 2 + AgilityTotal / 0.5f;
                    _attackRatePvM = Level * 5 + AgilityTotal * 1.25f + StrengthTotal * 4;
                    _attackRatePvP = Level * 3 + AgilityTotal * 2.0f;
                    _attackSpeed = AgilityTotal / 20.0f;
                    if (_attackSpeed > 288) _attackSpeed = 288.0f;
                    break;
            }

            if (_attackSpeed > 288) _attackSpeed = 288.0f;

            _defense += Inventory.Defense;
            _defenseRatePvP += Inventory.DefenseRate;
            _defenseRatePvM += Inventory.DefenseRate;

            Player.Session.SendAsync(new SAttackSpeed {
                AttackSpeed = (uint)_attackSpeed,
                MagicSpeed = (uint)_attackSpeed / 2,
            }).Wait();
        }
        private long GetExperienceFromLevel(ushort level)
        {
            return (((level + 9L) * level) * level) * 10L + ((level > 255) ? ((((long)(level - 255) + 9L) * (level - 255L)) * (level - 255L)) * 1000L : 0L);
        }

        public void TryRegen()
        {
            if (RegenTime <= DateTimeOffset.Now)
            {
                Health = MaxHealth;
                Mana = MaxMana;
                Shield = MaxShield;
                Stamina = MaxStamina;
                State = ObjectState.Regen;
                _position = Map.GetRespawn();
                CharacterRegen?.Invoke(this, new EventArgs());
                var regen = VersionSelector.CreateMessage<SCharRegen>(MapID, (byte)_position.X, (byte)_position.Y, (byte)1, (ushort)Health, (ushort)Mana, (ushort)Shield, (ushort)Stamina, (uint)Experience, (ulong)Money);
                Player.Session.SendAsync(regen).Wait();
            }
        }

        public async Task WarpTo(Maps map, Point position, byte dir)
        {
            if(MapID != map)
            {
                _map = map;
                Map?.ClearAttribute(_position.X, _position.Y, MapAttributes.Stand);
                Map?.DelPlayer(this);
                MapChanged?.Invoke(this, new EventArgs());
                Map = ResourceCache.Instance.GetMaps()[_map];
                Map.AddPlayer(this);
                _position = position;
                Map.SetAttribute(_position.X, _position.Y, MapAttributes.Stand);
                DataLoaded = false;
            }else
            {
                Map.PositionChanged(Position, position);
                Map.SendWeather(this);
                _position = position;
            }
            Direction = dir;
            TPosition = _position;

            if (!MapServerManager.CheckMapServerMove(Player.Session, map))
                return;

            if (State == ObjectState.Live)
            {
                var msg = VersionSelector.CreateMessage<STeleport>((ushort)256, MapID, _position, Direction);
                await Player.Session.SendAsync(msg);
            }
        }

        public async Task WarpTo(int gate)
        {
            var g = ResourceCache.Instance.GetGates()[gate];

            if (g.Door.Left<g.Door.Right && g.Door.Top<g.Door.Bottom)
            {
                var rand = new Random();
                var randX = rand.Next(g.Door.Left, g.Door.Right);
                var randY = rand.Next(g.Door.Top, g.Door.Bottom);

                await WarpTo(g.Map, new Point(randX, randY), g.Dir);
            }else
            {
                await WarpTo(g.Map, new Point(g.Door.Left, g.Door.Top), g.Dir);
            }
        }

        public void TeleportTo(Point position)
        {
            _position = position;
            SubSystem.Instance.AddDelayedMessage(Player, TimeSpan.FromMilliseconds(500), new STeleport(0, MapID, _position, Direction));
        }

        public async Task Save(GameContext db)
        {
            if (_needSave)
            {
                _needSave = false;
                var charDto = db.Characters.First(x => x.CharacterId == Id);
                charDto.Class = (byte)_class;
                charDto.Level = _level;
                charDto.LevelUpPoints = _levelUpPoints;
                charDto.Map = (byte)_map;
                charDto.X = (byte)_position.X;
                charDto.Y = (byte)_position.Y;
                charDto.Experience = (long)_exp;
                charDto.Life = (ushort)_hp;
                charDto.MaxLife = (ushort)_hpMax;
                charDto.Mana = (ushort)_mp;
                charDto.MaxMana = (ushort)_mpMax;
                charDto.Str = _str;
                charDto.Agility = _agi;
                charDto.Vitality = _vit;
                charDto.Energy = _ene;
                charDto.Command = _cmd;
                charDto.Money = _zen;
                charDto.Ruud = _ruud;
                charDto.CtlCode = (int)CtlCode;
                charDto.Resets = Resets;
                charDto.PKLevel = (byte)_pkLevel;
                charDto.PKTime = (int)(PKTimeEnds - DateTime.Now).TotalSeconds;
                if(charDto.Gens == null)
                {
                    charDto.Gens = new GensDto
                    {
                        CharacterId = charDto.CharacterId,
                        Character = charDto,
                        Class = 14,
                        Contribution = 0,
                        Influence = 0,
                        Ranking = 9999,
                    };
                }
                charDto.Gens.Influence = (int)Gens.Influence;
                charDto.Gens.Ranking = Gens.Ranking;
                charDto.Gens.Class = Gens.Class;
                charDto.Gens.Contribution = Gens.Contribution;
                db.Characters.Update(charDto);
                await db.SaveChangesAsync();
            }
            await Inventory.Save(db);
            await Spells.Save(db);
            await Quests.Save(db);
            await MasterLevel.Save(db);
            await db.SaveChangesAsync();
        }

        #region Battle
        public int GetDefense()
        {
            var _base = Inventory.Defense+Spells.IncreaseDefense;
            var dmgAbsorb = 1.0f + Inventory.WingDmgAbsorb;
            var guardian = Inventory.Get(Equipament.Pet)?.Number ?? ItemNumber.Invalid;

            // Guardian Angel
            if(guardian == (ItemNumber)6656)
            {
                dmgAbsorb += 0.12f;
            }

            return (int)(_base * dmgAbsorb);
        }
        public int Attack(Character target, out DamageType type)
        {
            var leftHand = Inventory.Get(Equipament.LeftHand);
            var rightHand = Inventory.Get(Equipament.RightHand);
            var pet = Inventory.Get(Equipament.Pet);
            var wing = Inventory.Get(Equipament.Wings);
            var twing = target.Inventory.Get(Equipament.Wings);
            var criticalRate = Inventory.CriticalRate;
            var excellentRate = Inventory.ExcellentRate*100;
            var tReflect = target.Inventory.Reflect;

            type = DamageType.Regular;
            var attack = 0.0f;

            if (MissCheck(target.DefenseRatePvP))
            {
                type = DamageType.Miss;
                return (int)attack;
            }

            if (excellentRate > _rand.Next(100))
                type = DamageType.Excellent;
            else if (criticalRate > _rand.Next(100))
                type = DamageType.Critical;

            attack = BaseAttack(type != DamageType.Regular);
            attack *= (type == DamageType.Excellent) ? 2.2f : 1.0f;
            attack += Spells.BuffList.Sum(x => x.AttackAdd);
            attack += rightHand?.AditionalDamage ?? 0;
            attack += leftHand?.AditionalDamage ?? 0;
            attack += Inventory.IncreaseAttack;

            if (wing != null) // Wings increase Dmg 12%+(Level*2)%
            {
                Health -= 3;
                if(Health > 0)
                {
                    attack *= wing.WingDmgAdd + Spells.WingsAttackPowUp/100.0f + 1.0f;
                }
            }

            if ((pet?.Number ?? ItemNumber.Zen) == ItemNumber.FromTypeIndex(13, 1)) // Satan 30% Attack Fisic & Magic
            {
                Health -= 3;
                if (Health > 0)
                {
                    attack *= 1.3f;
                }
            }

            if (twing != null) // Wings decrease Dmg 12%+(Level*2)%
                attack *= 0.88f - twing.Plus * 0.02f;

            attack -= target.GetDefense();
            WeaponDurDown(target.Inventory.Defense);
            return (int)attack;
        }

        public int Attack(Monster target, out DamageType type)
        {
            type = DamageType.Regular;
            var wing = Inventory.Get(Equipament.Wings);
            var pet = Inventory.Get(Equipament.Pet);
            var criticalRate = Inventory.CriticalRate;
            var excellentRate = Inventory.ExcellentRate*100;
            var leftHand = Inventory.Get(Equipament.LeftHand);
            var rightHand = Inventory.Get(Equipament.RightHand);
            if(PetMode == PetMode.AttackWithMaster)
            {
                PetTarget = target.Index;
            }

            var attack = 0.0f;

            if(MissCheck(target.Info.Success))
            {
                type = DamageType.Miss;
                return 0;
            }

            if (excellentRate > _rand.Next(100))
                type = DamageType.Excellent;
            else if (criticalRate > _rand.Next(100))
                type = DamageType.Critical;

            attack = BaseAttack(type != DamageType.Regular);
            attack *= (type == DamageType.Excellent) ? 2.2f : 1.0f;
            attack += rightHand?.AditionalDamage ?? 0;
            attack += leftHand?.AditionalDamage ?? 0;
            attack += Spells.BuffList.Sum(x => x.AttackAdd);

            if (wing != null) // Wings increase Dmg 12%+(Level*2)%
            {
                Health -= 3;
                if (Health > 0)
                {
                    attack *= wing.WingDmgAdd + Spells.WingsAttackPowUp + 1.0f;
                }
            }

            if((pet?.Number??ItemNumber.Zen) == ItemNumber.FromTypeIndex(13,1)) // Satan 30% Attack Fisic & Magic
            {
                Health -= 3;
                if (Health > 0)
                {
                    attack *= 1.3f;
                }
            }

            if (attack < 0)
                attack = 0;

            if(_rand.Next(3)!=0)
                attack -= target.Defense;
            
            WeaponDurDown(target.Defense);
            return (int)attack;
        }

        /// <summary>
        /// Check if can attack a target
        /// </summary>
        /// <param name="defenseRate">Defense Rate</param>
        /// <returns>false if can attack</returns>
        private bool MissCheck(int defenseRate)
        {
            if (_rand.Next(AttackRatePvM) < defenseRate)
            {
                if (_rand.Next(100) >= 5)
                {
                    return true;
                }
            }
            return false;
        }

        public async Task GetAttacked(ushort source, byte dirdis, byte aa, int dmg, DamageType type, Spell isMagic, int eDmg)
        {
            if (State != ObjectState.Live)
                return;

            if (dmg < 0)
                dmg = 0;

            GSSession sourceSession = source >= MonstersMng.MonsterStartIndex ? null : Program.server.Clients.FirstOrDefault(x => x.ID == source);

            _killerId = source;

            if(_killerId < MonstersMng.MonsterStartIndex)
            {
                var plr = Program.server.Clients.First(x => x.ID == source).Player;
                if (!plr.Character.SelfDefense.Any(x => x.Player.Character == this))
                {
                    if(PKLevel.Warning2 > PKLevel)
                    {
                        var selfDefense = SelfDefense.FirstOrDefault(x => x.Player == plr);
                        if (selfDefense != null)
                        {
                            selfDefense.Ends = DateTime.Now.AddMinutes(5);
                        }
                        else
                        {
                            SelfDefense.Add(new SelfDefense { Player = plr, Ends = DateTime.Now.AddMinutes(5) });
                            _ = Player.Session.SendAsync(new SNotice(NoticeType.Blue, "Selfdefense active for " + plr.Character.Name));
                        }
                    }                    
                }
            }

            switch (_rand.Next(6))
            {
                case 0:
                    Inventory.Get(Equipament.Helm)?.ArmorDurabilityDown(dmg);
                    break;
                case 1:
                    Inventory.Get(Equipament.Armor)?.ArmorDurabilityDown(dmg);
                    break;
                case 2:
                    Inventory.Get(Equipament.Pants)?.ArmorDurabilityDown(dmg);
                    break;
                case 3:
                    Inventory.Get(Equipament.Gloves)?.ArmorDurabilityDown(dmg);
                    break;
                case 4:
                    Inventory.Get(Equipament.Boots)?.ArmorDurabilityDown(dmg);
                    break;
                case 5:
                    Inventory.Get(Equipament.Wings)?.ArmorDurabilityDown(dmg);
                    break;
            }
            object message;
            var sdDamage = 0.0f;
            var healthDamage = 0.0f;

            if (sourceSession != null)
            {
                sdDamage = ((dmg+eDmg) * 0.8f);
                healthDamage = ((dmg+eDmg) * 0.2f);
                if(sdDamage > Shield)
                {
                    healthDamage += (sdDamage - Shield);
                }

                if(healthDamage > Health)
                {
                    healthDamage = Health;
                }
            }
            else
            {
                healthDamage = dmg+eDmg;
            }

            Shield -= sdDamage;
            Health -= healthDamage;
            _deadlyDmg = (int)healthDamage;

            message = VersionSelector.CreateMessage<SAttackResult>((ushort)Player.Session.ID, (ushort)healthDamage, type, (ushort)sdDamage);

            var reflex = Inventory.Reflect + Spells.BuffList.Sum(x => x.DamageDeflection);
            var dmgReflect = reflex * dmg;
            if (dmgReflect>0)
            {
                if (sourceSession != null)
                {
                    await sourceSession.Player.Character.GetAttacked(Player.ID, 0, 0, (int)dmgReflect, DamageType.Reflect, Spell.None, 0);
                } else
                {
                    Monster mob = MonstersMng.Instance.GetMonster(source);
                    await mob.GetAttacked(Player, (int)dmgReflect, DamageType.Reflect, 0);
                }
            }

            if (State != ObjectState.Dying)
            {
                if (isMagic == Spell.None)
                {
                    var msg = new SAction(source, dirdis, aa, (ushort)Player.Session.ID);
                    await Player.Session.SendAsync(message);
                    if(sourceSession != null)
                        await sourceSession.SendAsync(message);
                    await Player.Session.SendAsync(msg);
                    Player.SendV2Message(msg, sourceSession?.Player);
                }
                else
                {
                    SubSystem.Instance.AddDelayedMessage(Player, TimeSpan.FromMilliseconds(100), message);
                    SubSystem.Instance.AddDelayedMessage(sourceSession?.Player, TimeSpan.FromMilliseconds(100), message);

                    message = VersionSelector.CreateMessage<SMagicAttack>(isMagic, source, (ushort)Player.Session.ID);

                    await Player.Session.SendAsync(message);
                    Player.SendV2Message(message);
                }
            }
        }

        public int SkillAttack(SpellInfo spell, int targetDefense, out DamageType type)
        {
            var criticalRate = Inventory.CriticalRate;
            var excellentRate = Inventory.ExcellentRate;
            var wing = Inventory.Get(Equipament.Wings);
            var leftHand = Inventory.Get(Equipament.LeftHand);
            var rightHand = Inventory.Get(Equipament.RightHand);
            var pet = Inventory.Get(Equipament.Pet);

            var attack = 0.0f;
            type = DamageType.Regular;

            if (excellentRate > _rand.Next(100))
                type = DamageType.Excellent;
            else if (criticalRate > _rand.Next(100))
                type = DamageType.Critical;

            WeaponDurDown(targetDefense);

            attack = BaseAttack(type != DamageType.Regular);
            attack *= (type == DamageType.Excellent) ? 2.2f : 1.0f;
            attack += _rand.Next(spell.Damage.X, spell.Damage.Y);
            attack += rightHand?.AditionalDamage ?? 0;
            attack += leftHand?.AditionalDamage ?? 0;
            attack += Inventory.IncreaseAttack;

            if (wing != null) // Wings increase Dmg 12%+(Level*2)%
            {
                Health -= 3;
                if (Health > 0)
                {
                    attack *= 1.12f + wing.Plus * 0.02f;
                }
            }

            if ((pet?.Number ?? ItemNumber.Zen) == ItemNumber.FromTypeIndex(13, 1)) // Satan 30% Attack Fisic & Magic
            {
                Health -= 3;
                if (Health > 0)
                {
                    attack *= 1.3f;
                }
            }

            attack *= (200.0f + EnergyTotal / 10.0f) / 100.0f;

            attack -= targetDefense;
            return (int)attack;
        }
        
        public int MagicAttack(SpellInfo spell, int targetDefense, out DamageType type)
        {
            var criticalRate = Inventory.CriticalRate;
            var excellentRate = Inventory.ExcellentRate;
            var wing = Inventory.Get(Equipament.Wings);
            var leftHand = Inventory.Get(Equipament.LeftHand);
            var rightHand = Inventory.Get(Equipament.RightHand);
            var pet = Inventory.Get(Equipament.Pet);

            WeaponDurDown(targetDefense);
            var magicAdd = 0;

            if (rightHand != null)
                magicAdd = rightHand.BasicInfo.MagicPower / 2 + rightHand.Plus * 2;

            var attack = 0.0f;
            type = DamageType.Regular;
            if (excellentRate > _rand.Next(100))
                type = DamageType.Excellent;
            else if (criticalRate > _rand.Next(100))
                type = DamageType.Critical;

            attack += (type != DamageType.Regular) ? spell.Damage.Y + _magicAttackMax : _rand.Next((int)(spell.Damage.X + _magicAttackMin), (int)(spell.Damage.Y + _magicAttackMax));
            attack += Spells.BuffList.Sum(x => x.AttackAdd);
            attack *= 1.0f + magicAdd / 100.0f;
            attack += rightHand?.AditionalMagic??0;
            attack += Inventory.IncreaseWizardry;
            attack *= 1.0f + Inventory.IncreaseWizardryRate;
            attack *= (type == DamageType.Excellent) ? 2.2f : 1.0f;
            attack += Inventory.IncreaseAttack;

            if (wing != null) // Wings increase Dmg 12%+(Level*2)%
            {
                Health -= 3;
                if (Health > 0)
                {
                    attack *= 1.12f + wing.Plus * 0.02f;
                }
            }

            if ((pet?.Number ?? ItemNumber.Zen) == ItemNumber.FromTypeIndex(13, 1)) // Satan 30% Attack Fisic & Magic
            {
                Health -= 3;
                if (Health > 0)
                {
                    attack *= 1.3f;
                }
            }

            if (attack < 0)
                attack = 0.0f;

            attack -= targetDefense;
            return (int)attack;
        }

        public float BaseAttack(bool critical)
        {
            _autoRecuperationTime = DateTime.Now;
            var leftHand = Inventory.Get(Equipament.LeftHand);
            var attack = 0.0f;

            attack = critical ? _rightAttackMax : _rand.Next((int)_rightAttackMin, (int)_rightAttackMax);

            if (leftHand?.Attack ?? false)
                attack += critical ? _leftAttackMax : _rand.Next((int)_leftAttackMin, (int)_leftAttackMax);

            return attack;
        }

        public async Task<int> PentagramAttack(Character target)
        {
            var pItem = Inventory.Get(Equipament.Pentagrama);
            if (pItem == null)
                return 0;

            var tpItem = target.Inventory.Get(Equipament.Pentagrama);

            var def = tpItem?.Defense ?? 0;
            var tElement = tpItem?.PentagramaMainAttribute ?? Element.None;

            var max = Math.Max(pItem.AttackMax, pItem.AttackMin);
            var min = Math.Min(pItem.AttackMax, pItem.AttackMin);

            var dmg = Program.RandomProvider(max, min) * Pentagrama.GetElementalFactor(pItem.PentagramaMainAttribute, tElement);
            dmg -= def;

            var eMessage = new SElementalDamage
            {
                Damage = (uint)dmg,
                Element = pItem.PentagramaMainAttribute,
                Number = Player.ID,
                Target = target.Player.ID,
            };

            await Player.Session.SendAsync(eMessage);
            await target.Player.Session.SendAsync(eMessage);

            return (int)dmg;
        }

        public async Task<int> PentagramAttack(Monster target)
        {
            var pItem = Inventory.Get(Equipament.Pentagrama);
            if (pItem == null || target.Type == ObjectType.NPC)
                return 0;

            //var tpItem = target.Info.MainAttribute;

            var def = target.Info.PentagramDefense;
            var tElement = target.Element;

            var max = Math.Max(pItem.AttackMax, pItem.AttackMin);
            var min = Math.Min(pItem.AttackMax, pItem.AttackMin);

            var dmg = Program.RandomProvider(max, min) * Pentagrama.GetElementalFactor(pItem.PentagramaMainAttribute, tElement);
            dmg -= def;

            var eMessage = new SElementalDamage
            {
                Damage = (uint)dmg,
                Element = pItem.PentagramaMainAttribute,
                Number = target.Index,
                Target = Player.ID,
            };

            await Player.Session.SendAsync(eMessage);

            return (int)dmg;
        }
        #endregion

        public void Autorecovery()
        {
            HuntingRecord.Update();

            var elapsed = DateTime.Now - _autoRecuperationTime;

            var add = (elapsed.TotalSeconds > 25)? 10 : (elapsed.TotalSeconds > 15)? 5 : (elapsed.TotalSeconds > 10)? 1 : 0;

            var update1 = add > 0 && (_hp < MaxHealth || _sd < MaxShield);
            var update2 = _mp < MaxMana || _bp < MaxStamina;

            if (_hp < MaxHealth) _hp += Math.Min(add+Spells.IncreaseAutoHPRegeneration, MaxHealth - _hp);
            if (_sd < MaxShield) _sd += Math.Min(add+Spells.IncreaseAutoSDRegeneration+Inventory.IncreaseSDRecovery, MaxShield - _sd);

            float addMp = 0;
            float addBp = 0;

            SelfDefense = SelfDefense.Where(x => x.Ends > DateTime.Now).ToList();
            PKLevel = (PKLevel)Math.Ceiling(Math.Min(Math.Max((PKTimeEnds - DateTime.Now).TotalHours,0) / 3.0f + 3.0f, 6.0f));

            switch (BaseClass)
            {
                case HeroClass.DarkKnight:
                    addMp = MaxMana / 27.5f;
                    addBp = 2 + (float)MaxStamina / 20;
                    break;
                case HeroClass.RuneWizard:
                case HeroClass.DarkWizard:
                case HeroClass.FaryElf:
                case HeroClass.Summoner:
                    addMp = (float)MaxMana / 27.5f;
                    addBp = 2 + (float)MaxStamina / 33.333f;
                    break;
                case HeroClass.MagicGladiator:
                case HeroClass.DarkLord:
                    addMp = (float)MaxMana / 27.5f;
                    addBp = 1.9f + (float)MaxStamina / 33;
                    break;
                case HeroClass.GrowLancer:
                case HeroClass.RageFighter:
                    addMp = (float)MaxMana / 27.5f;
                    addBp = 1.9f + (float)MaxStamina / 33;
                    break;
            }

            if (_mp < MaxMana) _mp += Math.Min(addMp+Spells.IncreaseAutoMPRegeneration, MaxMana - _mp);
            if (_bp < MaxStamina) _bp += Math.Min(addBp+Spells.IncreaseAutoBPRegeneration, MaxStamina - _bp);

            if (update1)
                HPorSDChanged(RefillInfo.Drink);

            if (update2)
                MPorBPChanged(RefillInfo.Drink);
        }

        public void WeaponDurDown(int Defense)
        {
            var left = Inventory.Get(Equipament.LeftHand);
            var right = Inventory.Get(Equipament.RightHand);

            var bl = left?.Number.Type == ItemType.BowOrCrossbow && left != Inventory.Arrows;
            var br = right?.Number.Type == ItemType.BowOrCrossbow && right != Inventory.Arrows;

            var bow = bl ? left : (br ? right : null);

            if(bow != null && Inventory.Arrows != null)
            {
                if (Inventory.Arrows.Durability <= 0)
                {
                    Inventory.Delete(Inventory.Arrows).Wait();
                    return;
                }

                if (!Spells.BufActive(SkillStates.InfinityArrow))
                {
                    Inventory.Arrows.Durability -= 1;
                    if (Inventory.Arrows.Durability <= 0)
                    {
                        Inventory.Delete(Inventory.Arrows).Wait();
                    }
                }

                bow.BowWeaponDurabilityDown(Defense);
            }
            else
            {
                if (right != null && left != null && right.Number.Type >= ItemType.Sword && right.Number.Type < ItemType.BowOrCrossbow &&
                left.Number.Type >= ItemType.Sword && left.Number.Type < ItemType.BowOrCrossbow)
                {
                    var item = Program.RandomProvider(2) == 0 ? right : left;
                    item.NormalWeaponDurabilityDown(Defense);
                }
                else if (right != null && right.Number.Type >= ItemType.Sword && right.Number.Type < ItemType.BowOrCrossbow)
                {
                    right.NormalWeaponDurabilityDown(Defense);
                }
            }
        }

        public override string ToString()
        {
            return Name+" Level:"+Level+" Class:"+Class;
        }

        #region Commands
        public static async void AddStr(object session, CommandEventArgs eventArgs)
        {
            var Session = session as GSSession;
            var @char = Session.Player.Character;

            if(int.TryParse(eventArgs.Argument, out int res))
            {
                if(res <= @char.LevelUpPoints)
                {
                    if (res + @char.StrengthTotal >= ushort.MaxValue)
                        res = ushort.MaxValue - @char.StrengthTotal;

                    @char.LevelUpPoints -= (ushort)res;
                    @char.Strength += (ushort)res;


                    await Session.SendAsync(new SNotice(NoticeType.Blue, "You need relogin"));
                    return;
                }
                await Session.SendAsync(new SNotice(NoticeType.Blue, "Insufficient Points"));
                return;
            }

            await Session.SendAsync(new SNotice(NoticeType.Blue, "Syntax error. command is: /add*** <Number>"));
        }

        public static async void AddAgi(object session, CommandEventArgs eventArgs)
        {
            var Session = session as GSSession;
            var @char = Session.Player.Character;

            if (int.TryParse(eventArgs.Argument, out int res))
            {
                if (res <= @char.LevelUpPoints)
                {
                    if (res + @char.AgilityTotal >= ushort.MaxValue)
                        res = ushort.MaxValue - @char.AgilityTotal;

                    @char.LevelUpPoints -= (ushort)res;
                    @char.Agility += (ushort)res;
                    
                    await Session.SendAsync(new SNotice(NoticeType.Blue, "You need relogin"));
                    return;
                }
                await Session.SendAsync(new SNotice(NoticeType.Blue, "Insufficient Points"));
                return;
            }

            await Session.SendAsync(new SNotice(NoticeType.Blue, "Syntax error. command is: /add*** <Number>"));
        }

        public static async void AddVit(object session, CommandEventArgs eventArgs)
        {
            var Session = session as GSSession;
            var @char = Session.Player.Character;

            if (int.TryParse(eventArgs.Argument, out int res))
            {
                if (res <= @char.LevelUpPoints)
                {
                    if (res + @char.VitalityTotal >= ushort.MaxValue)
                        res = ushort.MaxValue - @char.VitalityTotal;

                    @char.LevelUpPoints -= (ushort)res;
                    @char.Vitality += (ushort)res;


                    await Session.SendAsync(new SNotice(NoticeType.Blue, "You need relogin"));
                    return;
                }
                await Session.SendAsync(new SNotice(NoticeType.Blue, "Insufficient Points"));
                return;
            }

            await Session.SendAsync(new SNotice(NoticeType.Blue, "Syntax error. command is: /add*** <Number>"));
        }

        public static async void AddEne(object session, CommandEventArgs eventArgs)
        {
            var Session = session as GSSession;
            var @char = Session.Player.Character;

            if (int.TryParse(eventArgs.Argument, out int res))
            {
                if (res <= @char.LevelUpPoints)
                {
                    if (res + @char.EnergyTotal >= ushort.MaxValue)
                        res = ushort.MaxValue - @char.EnergyTotal;

                    @char.LevelUpPoints -= (ushort)res;
                    @char.Energy += (ushort)res;


                    await Session.SendAsync(new SNotice(NoticeType.Blue, "You need relogin"));
                    return;
                }
                await Session.SendAsync(new SNotice(NoticeType.Blue, "Insufficient Points"));
                return;
            }

            await Session.SendAsync(new SNotice(NoticeType.Blue, "Syntax error. command is: /add*** <Number>"));
        }

        public static async void AddCmd(object session, CommandEventArgs eventArgs)
        {
            var Session = session as GSSession;
            var @char = Session.Player.Character;

            if (int.TryParse(eventArgs.Argument, out int res))
            {
                if (res <= @char.LevelUpPoints)
                {
                    if (res + @char.CommandTotal >= ushort.MaxValue)
                        res = ushort.MaxValue - @char.CommandTotal;

                    @char.LevelUpPoints -= (ushort)res;
                    @char.Command += (ushort)res;

                    await Session.SendAsync(new SNotice(NoticeType.Blue, "You need relogin"));
                    return;
                }
                await Session.SendAsync(new SNotice(NoticeType.Blue, "Insufficient Points"));
                return;
            }

            await Session.SendAsync(new SNotice(NoticeType.Blue, "Syntax error. command is: /add*** <Number>"));
        }

        public void Dispose()
        {
            Map?.DelPlayer(this);
            Map = null;

            PartyManager.Remove(Player);
            Duel?.Leave(Player);
            Duel = null;
            DisposeKalimaGate();

            var mobVp = MonstersVP.Select(x => MonstersMng.Instance.GetMonster(x)).ToList();
            foreach (var m in mobVp.Where(x => x.Target == Player))
            {
                m.Target = null;
            }
        }
        #endregion
    }
}


--file ChaosMixInfo.cs
﻿using MU.Network.Game;
using MU.Resources;
using MuEmu.Monsters;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu.Data
{
    public class JewelInfo
    {
        public ItemNumber ItemNumber { get; set; }
        public int Success { get; set; }
    }
    public class IngredientInfo
    {
        public int IID { get; set; }
        public ItemNumber ItemNumber { get; set; }
        public int[] Level { get; set; }
        public int Luck { get; set; }
        public int Skill { get; set; }
        public int Option { get; set; }
        public int Excellent { get; set; }
        public int Count { get; set; }
        public int Harmony { get; set; }
        public int SetOption { get; set; }
        public int Success { get; set; }
        public int Socket { get; set; }

        public bool Match(Item item)
        {
            if(ItemNumber == ItemNumber.Invalid) // AnyItem
            {

            }else if(ItemNumber.Type == ItemType.Invalid && ItemNumber.Index == item.Number.Index) // AnyType
            {

            }else if(ItemNumber.Index == 0x1FF && ItemNumber.Type == item.Number.Type) // AnyIndex
            {

            }else if(ItemNumber == item.Number) // ExactMatch
            {

            }else
            {
                return false;
            }

            if (Level.Length == 1 && Level[0] != 255 && Level[0] != item.Plus)
                return false;
            else if (Level.Length == 2 && Level[0] >= item.Plus && Level[1] <= item.Plus)
                return false;

            if (Luck != -1 && (item.Luck ? 1 : 0) != Luck) // No match LUCK
                return false;

            if (Skill != -1 && (item.Skill ? 1 : 0) != Skill) // No match Skill
                return false;

            if (Option > (item.Option28*4)) // No match Option
                return false;

            if (Excellent > item.ExcellentCount || (Excellent == 0 && item.ExcellentCount != 0))
                return false;

            if(Harmony > item.Harmony.Option)
                return false;

            if (SetOption > item.SetOption)
                return false;

            if(Socket == 254 && !item.Slots.Any(x => x == SocketOption.EmptySocket))
                return false;

            return true;
        }
    }
    public class MixInfo
    {
        public string Name { get; set; }
        public int GeneralSuccess { get; set; }
        public int BaseCost { get; set; }
        public int NPC { get; set; }
        public List<IngredientInfo> Ingredients { get; set; }
        public List<IngredientInfo> ResultSuccess { get; set; }
        public IngredientInfo ResultFail { get; set; }

        public ChaosBoxMixResult Execute(Character @char, CChaosBoxItemMixButtonClick mixAditionalInfo = null)
        {
            var cbItems = @char.Inventory.ChaosBox.Items;
            var items = cbItems.Select(x => x.Value);

            if(BaseCost > @char.Money)
                return ChaosBoxMixResult.InsufficientMoney;

            @char.Money -= (uint)BaseCost;

            var ingOk = new Dictionary<IngredientInfo, int>();

            foreach(var ing in Ingredients)
            {
                var count = items.Where(x => ing.Match(x)).Count();
                if (ing.Count > count && !ingOk.Any(x => x.Key.IID==ing.IID))
                    return ChaosBoxMixResult.IncorrectItems;

                ingOk.Add(ing, count);
            }

            var pairIng = (from ing in Ingredients
                          from it in cbItems
                          where ing.Match(it.Value)
                          select new { Address = it.Key, Item = it.Value, Ingredient = ing }).ToList();

            var leftItems = (from it in cbItems
                            where !pairIng.Any(x => x.Item == it.Value)
                            select it).ToList();

            var successRate = GeneralSuccess;
            foreach(var ing in ingOk)
            {
                var scalar = (ing.Value - ing.Key.Count);
                successRate += scalar * 10;
            }

            if (successRate > 100)
                successRate = 100;
            var rand = new Random();
            ChaosBoxMixResult result = ChaosBoxMixResult.Success;

            if (rand.Next(0, 100) > successRate - 1)
            {
                result = ChaosBoxMixResult.Fail;
            }

            @char.Inventory.DeleteChaosBox();

            var prob = rand.Next(0, 100);
            IngredientInfo res = null;
            if (result == ChaosBoxMixResult.Success)
            {
                foreach (var r in ResultSuccess)
                {
                    if (prob < r.Success)
                    {
                        res = r;
                        break;
                    }
                    prob -= r.Success;
                }
            }
            else
            {
                res = ResultFail;
            }

            if (res == null)
                res = ResultSuccess.First();

            var res2 = pairIng.FirstOrDefault(x => x.Ingredient.IID == res.IID);

            // find any Seed Spear
            var seed = pairIng.FirstOrDefault(x => x.Item.Number >= 6244 && x.Item.Number <= 6273);

            if (res.ItemNumber != ItemNumber.Invalid || res2 != null)
            {
                var mix = new Item(res.ItemNumber != ItemNumber.Invalid ? res.ItemNumber : res2.Item.Number);

                if (res.Level.Length == 1)
                {
                    mix.Plus = res.Level[0] == 255 ? res2.Item.Plus : (byte)res.Level[0];
                }
                else if (res.Level.Length == 2)
                {
                    mix.Plus = (byte)rand.Next(res.Level[0], res.Level[1]);
                }
                else
                {
                    mix.Plus = res2?.Item.Plus ?? 0;
                }

                if (res.Harmony != -1)
                {
                    mix.Harmony.Option = (byte)res.Harmony;
                    mix.Harmony.Level = 0;
                }
                else
                {
                    mix.Harmony.Option = res2?.Item.Harmony.Option ?? 0;
                    mix.Harmony.Level = res2?.Item.Harmony.Level ?? 0;
                }

                mix.Luck = res.Luck == -1 ? res2?.Item.Luck ?? false : (res.Luck > 0 ? true : false);
                mix.Skill = res.Skill == -1 ? res2?.Item.Skill ?? false : (res.Skill > 0 ? true : false);
                mix.Option28 = (byte)(res.Option == -1 ? res2?.Item.Option28 ?? 0x00 : res.Option);
                mix.OptionExe = (byte)(res.Excellent == -1 ? res2?.Item.OptionExe ?? 0x00 : res.Excellent);
                mix.SetOption = (byte)(res.SetOption == -1 ? res2?.Item.SetOption ?? 0x00 : res.SetOption);
                if(res.Socket != -1 && seed != null)
                {
                    var code = seed.Item.Number.Index - 100;
                    var level = code / 6;
                    var type = (SocketOption)(seed.Item.Plus + (code % 6) * 10 + level * 50);

                    mix.Slots = res2?.Item.Slots ?? new SocketOption[5];
                    mix.Slots[mixAditionalInfo.Info] = type;
                }
                mix.Character = @char;
                mix.Account = @char.Account;
                mix.Character = @char;
                @char.Inventory.ChaosBox.Add(mix);
            }

            return result;
        }

        public override string ToString()
        {
            return Name;
        }
    }
    public class ChaosMixInfo
    {
        public List<JewelInfo> AdditionalJewels { get; set; }
        public List<MixInfo> Mixes { get; set; }

        public MixInfo FindMix(Character @char)
        {
            var cbItems = @char.Inventory.ChaosBox.Items;
            var items = from obj in cbItems select obj.Value;
            var MixMatching = new Dictionary<MixInfo, int>();
            var npc = @char.Player.Window as Monster;

            foreach (var m in Mixes.Where(x => x.NPC == npc.Info.Monster))
            {
                var ingCount = 0;
                var iteCount = 0;
                var itemsUsed = new List<Item>();
                foreach(var ing in m.Ingredients)
                {
                    ingCount += ing.Count;
                    var a = items.Where(x => ing.Match(x));
                    itemsUsed.AddRange(a);
                    iteCount += a.Count();
                }
                var res = (float)iteCount;

                res /= ingCount;
                res *= 100.0f;
                var leftItems = items.Except(itemsUsed);
                var leftItemsWithOutJewels = leftItems.Where(x => x.Number != ItemNumber.FromTypeIndex(14, 13) && x.Number != ItemNumber.FromTypeIndex(14, 14));

                if (leftItemsWithOutJewels.Count() > 0)
                {
                    res = 0;
                }

                MixMatching.Add(m, (int)res);
            }

            return MixMatching
                //.OrderByDescending(x => x.Value)
                .Where(x => x.Value == 100)
                .Select(x => x.Key)
                .FirstOrDefault();
        }
    }
}


--file ItemInfo.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;

namespace MuEmu.Data
{
    public class ItemInfo
    {
        public ushort Number { get; set; }
        public Spell Skill { get; set; }
        public Size Size { get; set; }
        public byte Durability { get; set; }
        public bool Option { get; set; }
        public bool Drop { get; set; }
        public string Name { get; set; }
        public ushort Level { get; set; }
        public Point Damage { get; set; }
        public byte MagicDur { get; set; }
        public byte MagicPower { get; set; }
        public ushort Def { get; set; }
        public ushort DefRate { get; set; }
        public int Speed { get; set; }
        public ushort ReqLevel { get; set; }
        public ushort Str { get; set; }
        public ushort Agi { get; set; }
        public ushort Vit { get; set; }
        public ushort Ene { get; set; }
        public ushort Cmd { get; set; }
        public List<HeroClass> Classes { get; set; }
        public int Zen { get; set; }
        public List<AttributeType> Attributes { get; set; }
        public byte MaxStack { get; set; }
        public ItemNumber OnMaxStack { get; internal set; } = ItemNumber.Invalid;
        public bool IsMount { get; set; }
        public ushort Skin { get; set; }
        public StorageID Inventory { get; internal set; } = StorageID.Inventory;
        public int Ruud { get; internal set; }
    }
}


--file ItemThrowInfo.cs
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu.Data
{
    public class ItemThrowInfo
    {
        public ItemNumber Number { get; set; }
        public ushort Plus { get; set; }
        public ushort LevelMin { get; set; }
        public List<Item> Storage { get; set; }
    }
}


--file NPCInfo.cs
﻿using MU.Resources;
using MuEmu.Resources.Map;
using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu.Data
{
    public class NPCInfo
    {
        public ushort NPC { get; set; }
        public NPCAttributeType Class { get; set; }
        public ushort Data { get; set; }
        public MiniMapTag Icon { get; set; }
        public ShopInfo Shop => Data != 0xffff ? Resources.ResourceCache.Instance.GetShops()[Data] : null;
    }
}


--file PCPointShopInfo.cs
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu.Data
{
    public class PCPointShopInfo
    {
    }
}


--file QuestInfo.cs
﻿using MU.Resources;
using MuEmu.Resources;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu.Data
{
    public class QuestInfo
    {
        public int Type { get; set; }
        public int Index { get; set; }
        public string Name { get; set; }
        public ushort NPC { get; set; }
        public List<SubQuest> Sub { get; set; }
        public List<RunConditions> Conditions { get; set; }

        public bool CanRun(Character @char)
        {
            var sub = Sub.Find(x => x.Allowed.Any(y => y == @char.Class));

            if (sub == null)
                return false;

            var conditions = Conditions.FindAll(x => x.Index == sub.Index || x.Index == -1);
            return conditions.TrueForAll(x => x.CanRun(@char));
        }
    }

    public class SubQuest
    {
        public int Index { get; set; }
        public HeroClass[] Allowed { get; set; }
        public List<Item> Requeriment { get; set; }
        public ushort Monster { get; set; }
        public ushort MonsterMin { get; set; }
        public ushort MonsterMax { get; set; }
        public int Count { get; set; }
        public Dictionary<QuestState, ushort> Messages { get; set; }
        public QuestCompensation CompensationType { get; set; }
        public byte Amount { get; set; }
        public ushort Drop { get; set; }
    }

    public class RunConditions
    {
        public int Index { get; set; }
        public int NeededQuestIndex { get; set; }
        public ushort MinLevel { get; set; }
        public ushort MaxLevel { get; set; }
        public int NeedStr { get; set; }
        public int Cost { get; set; }
        public int Message { get; set; }

        public bool CanRun(Character @char)
        {
            if ((MinLevel > @char.GlobalLevel && MinLevel != 0) || (@char.GlobalLevel > MaxLevel && MaxLevel != 0))
                return false;

            if (!@char.Quests.IsClear(NeededQuestIndex))
                return false;

            return true;
        }
    }
}


--file ShopInfo.cs
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu.Data
{
    public class ShopInfo
    {
        public ushort Shop { get; set; }
        public Storage Storage { get; set; }
    }
}


--file SpellInfo.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;

namespace MuEmu.Data
{
    public class SpellInfo
    {
        public Spell Number { get; set; }
        public string Name { get; set; }
        public ushort ReqLevel { get; set; }
        public Point Damage { get; set; }
        public ushort Mana { get; set; }
        public ushort BP { get; set; }
        public byte Distance { get; set; }
        public uint Delay { get; set; }
        public ushort Energy { get; set; }
        public ushort Command { get; set; }
        public sbyte Attribute { get; set; }
        public short Type { get; set; }
        public byte UseType { get; set; }
        public int Brand { get; set; }
        public int KillCount { get; set; }
        public List<int> Status { get; set; }
        public List<HeroClass> Classes { get; set; }
        public int Rank { get; set; }
        public int Group { get; set; }
        public int MasterP { get; set; }
        public int AG { get; set; }
        public int SD { get; set; }
        public int Duration { get; set; }
        public ushort Str { get; set; }
        public ushort Agility { get; set; }
        public ushort Icon { get; set; }
        public byte UseType2 { get; set; }
        public ushort Item { get; set; }
        public byte IsDamage { get; set; }
    }
}


--file DuelSystem.cs
﻿using MU.Network;
using MU.Network.Game;
using MU.Resources;
using MuEmu.Util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MuEmu
{
    public class Duel
    {
        public bool Free { get; set; }
        public bool Started { get; set; }
        public List<Player> Observers { get; }
        public Player Challenger { get; set; }
        public Player Challenged { get; set; }
        public int ChallengerPoints { get; set; }
        public int ChallengedPoints { get; set; }
        public int ChallengerGate { get; }
        public int ChallengedGate { get; }
        public int ObserversGate { get; }

        public Duel(int challengerGate, int challengedGate, int observersGate)
        {
            Free = true;
            ChallengerGate = challengerGate;
            ChallengedGate = challengedGate;
            ObserversGate = observersGate;
            Observers = new List<Player>();
        }

        private void BroadcastMessage(object msg)
        {
            Challenger.Session.SendAsync(msg).Wait();
            Challenged.Session.SendAsync(msg).Wait();

            Observers.Select(x => x.Session).SendAsync(msg).Wait();
        }

        public void Clear(Player winner, Player loser)
        {
            Free = true;
            Started = false;

            BroadcastMessage(new SDuelBroadcastRound() { Flag = 1 });
            BroadcastMessage(new SDuelBroadcastResult(winner.Character.Name, loser.Character.Name));
            Challenger.Session.SendAsync(new SDuelAnsExit(DuelResults.NoError, (ushort)Challenged.Session.ID, Challenged.Character.Name)).Wait();
            Challenged.Session.SendAsync(new SDuelAnsExit(DuelResults.NoError, (ushort)Challenger.Session.ID, Challenger.Character.Name)).Wait();

            Observers.ForEach(x => x.Character.Spells.ClearBuffByEffect(SkillStates.DuelInterface).Wait());
            Observers.Clear();
            ChallengerPoints = 0;
            ChallengedPoints = 0;
            Challenger.Character.Duel = null;
            Challenged.Character.Duel = null;
            Challenger.Character.CharacterRegen -= Character_CharacterRegen;
            Challenged.Character.CharacterRegen -= Character_CharacterRegen;
            Challenger.Character.CharacterDie -= ChallengerDie;
            Challenged.Character.CharacterDie -= ChallengedDie;
            Challenger.Character.WarpTo(17).Wait();
            Challenged.Character.WarpTo(17).Wait();
            Challenger = null;
            Challenged = null;
        }

        public void Join()
        {
            Started = true;
            Challenger.Character.CharacterDie += ChallengerDie;
            Challenged.Character.CharacterDie += ChallengedDie;
            Challenger.Character.CharacterRegen += Character_CharacterRegen;
            Challenged.Character.CharacterRegen += Character_CharacterRegen;
            Challenger.Character.WarpTo(ChallengerGate).Wait();
            Challenged.Character.WarpTo(ChallengedGate).Wait();
            Challenger.Session.SendAsync(new SDuelAnsDuelInvite(DuelResults.NoError, (ushort)Challenged.Session.ID, Challenged.Character.Name)).Wait();
            Challenged.Session.SendAsync(new SDuelAnsDuelInvite(DuelResults.NoError, (ushort)Challenger.Session.ID, Challenger.Character.Name)).Wait();
            BroadcastScore();
            BroadcastMessage(new SDuelBroadcastRound() { Flag = 0 });
        }

        public void Leave(Player plr)
        {
            if(Challenger == plr)
            {
                Challenged.Character.Spells.SetBuff(SkillStates.DuelMedal, TimeSpan.FromHours(1));
                Clear(Challenged, plr);
            }else if(Challenged == plr)
            {
                Challenger.Character.Spells.SetBuff(SkillStates.DuelMedal, TimeSpan.FromHours(1));
                Clear(Challenger, plr);
            }
        }

        private void Character_CharacterRegen(object sender, EventArgs e)
        {
            Challenger.Character.WarpTo(ChallengerGate).Wait();
            Challenged.Character.WarpTo(ChallengedGate).Wait();
        }

        private void ChallengerDie(object sender, EventArgs e)
        {
            ChallengedPoints++;
            BroadcastScore();
            if (ChallengedPoints == 10)
            {
                Challenged.Character.Spells.SetBuff(SkillStates.DuelMedal, TimeSpan.FromHours(1));
                Clear(Challenged, Challenger);
            }
        }

        private void ChallengedDie(object sender, EventArgs e)
        {
            ChallengerPoints++;
            BroadcastScore();
            if (ChallengerPoints == 10)
            {
                Challenger.Character.Spells.SetBuff(SkillStates.DuelMedal, TimeSpan.FromHours(1));
                Clear(Challenger, Challenged);
            }
        }

        public void BroadcastScore()
        {
            BroadcastMessage(new SDuelBroadcastScore((ushort)Challenger.Session.ID, (ushort)Challenged.Session.ID, (byte)ChallengerPoints, (byte)ChallengedPoints));
        }

        public void BroadcastRound()
        {
            Observers.Select(x => x.Session).SendAsync(new SDuelBroadcastRound() { Flag = 0 }).Wait();
        }

        internal DuelResults AddObserver(Player plr)
        {
            if (Observers.Count == 10)
                return DuelResults.ObserverMax;

            Observers.Select(x => x.Session).SendAsync(new SDuelRoomBroadcastJoin(plr.Character.Name)).Wait();
            Observers.Add(plr);
            plr.Session.SendAsync(new SDuelRoomBroadcastObservers(Observers.Select(x => x.Character.Name).ToArray())).Wait();
            plr.Character.WarpTo(ObserversGate).Wait();
            plr.Character.Spells.SetBuff(SkillStates.DuelInterface, TimeSpan.FromDays(1));
            BroadcastScore();

            return DuelResults.NoError;
        }

        internal DuelResults DelObserver(Player player)
        {
            player.Character.Spells.ClearBuffByEffect(SkillStates.DuelInterface).Wait();
            Observers.Remove(player);
            Observers.Select(x => x.Session).SendAsync(new SDuelRoomBroadcastLeave(player.Character.Name)).Wait();
            player.Character.WarpTo(17).Wait();
            return DuelResults.NoError;
        }
    }
    public class DuelSystem
    {
        private static DuelSystem _instance;
        private Duel[] _duelChannels;

        public DuelSystem()
        {
            _duelChannels = new Duel[4];

            _duelChannels[0] = new Duel(295, 296, 303);
            _duelChannels[1] = new Duel(297, 298, 304);
            _duelChannels[2] = new Duel(299, 300, 305);
            _duelChannels[3] = new Duel(301, 302, 306);
        }

        public static void Initialize()
        {
            if (_instance != null)
                return;

            _instance = new DuelSystem();
        }

        public static bool CreateDuel(Player challenger, Player challenged)
        {
            lock(_instance._duelChannels)
            {
                var res = _instance._duelChannels.FirstOrDefault(x => x.Free);
                if (res == null)
                    return false;

                res.Free = false;
                res.Challenger = challenger;
                res.Challenged = challenged;
                challenger.Character.Duel = res;
                challenged.Character.Duel = res;
                return true;
            }
        }

        public static void NPCTalk(Player plr)
        {

            var msg = new SDuelChannelList(
                    _instance._duelChannels
                    .Select(x => 
                        new DuelChannel(x.Challenger?.Character.Name??"", x.Challenged?.Character.Name??"", x.Started, x.Observers.Count < 4))
                    .ToArray()
                );
        }

        public static DuelResults TryJoinRoom(Player plr, byte room)
        {
            if (room >= 4)
            {
                return DuelResults.InvalidChannelId;
            }

            var duelChannel = _instance._duelChannels[room];
            return duelChannel.AddObserver(plr);
        }

        public static DuelResults LeaveRoom(Player player, byte room)
        {
            if (room >= 4)
            {
                return DuelResults.InvalidChannelId;
            }

            var duelChannel = _instance._duelChannels[room];
            return duelChannel.DelObserver(player);
        }
    }
}


--file AcheronGuardian.cs
﻿using MU.Network.Event;
using MU.Resources;
using MuEmu.Monsters;
using MuEmu.Resources;
using MuEmu.Resources.Map;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;

namespace MuEmu.Events.AcheronGuardian
{
    internal class AcheronGuardian : Event
    {
        private List<Point> _obeliskPositions = new List<Point>
        {
            new Point(89,41),
            new Point(188,101),
            new Point(162,54),
        };
        private List<Maps> _obeliskMaps = new List<Maps>
        { 
            Maps.ArkaWar,
            Maps.ArkaWar,
            Maps.ArcaBattle,
        };
        private Monster _obelisk;
        private List<Monster> _cursedMonsters = new List<Monster>();
        private Dictionary<Element, List<ushort>> _cursedMonstersByElement = new Dictionary<Element, List<ushort>>
        {
            /*1*/{ Element.Fire,  new List<ushort>{ 633, 637, } },
            /*2*/{ Element.Water, new List<ushort>{ 632, 638, } },
            /*3*/{ Element.Earth, new List<ushort>{ 635, 640, } },
            /*4*/{ Element.Wind,  new List<ushort>{ 634, 639, } },
            /*5*/{ Element.Dark,  new List<ushort>{ 636, 641, } },
        };
        private DateTime _nextSpawn;
        public MapInfo Map { get; set; }
        public MapInfo Map2 { get; set; }
        public AcheronGuardian()
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(AcheronGuardian));
            Map = ResourceCache.Instance.GetMaps()[Maps.ArkaWar];
            Map2 = ResourceCache.Instance.GetMaps()[Maps.ArcaBattle];
            Map.PlayerLeaves += OnPlayerLeave;
            Map2.PlayerLeaves += OnPlayerLeave;
        }
        public override void Initialize()
        {
            base.Initialize();
            ChangeState(EventState.Open);
        }
        public override void NPCTalk(Player plr)
        {
            throw new NotImplementedException();
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            GetPlayerEventInfo(sender as Player).Eventer = false;
        }

        public override void OnTransition(EventState NextState)
        {
            switch(NextState)
            {
                case EventState.Open:
                    Trigger(EventState.Playing, TimeSpan.FromMinutes(1));
                    _ = Program.NoEventMapAnoucement("Acheron Guardian Will Start in 1min.");
                    break;
                case EventState.Playing:
                    Trigger(EventState.Playing, TimeSpan.FromMinutes(30));
                    _ = Program.NoEventMapAnoucement("Acheron Guardian is Started!.");

                    var obeliskCode = (ushort)(627 + Program.RandomProvider(5));
                    var randObeliskPos = Program.RandomProvider(_obeliskPositions.Count);
                    _obelisk = MonstersMng.Instance.CreateMonster(
                        obeliskCode,
                        ObjectType.Gate,
                        _obeliskMaps[randObeliskPos],
                        _obeliskPositions[randObeliskPos],
                        1,
                        (Element)MonstersMng.Instance.MonsterInfo[obeliskCode].MainAttribute);
                    _obelisk.Die += _obelisk_Die;
                    _logger.Debug("Obelisk Spawned in {0},{1}", _obelisk.Position.X, _obelisk.Position.Y);
                    break;
                case EventState.Closed:
                    if(_obelisk != null)
                    {
                        MonstersMng.Instance.DeleteMonster(_obelisk);
                        foreach(var m in _cursedMonsters)
                        {
                            MonstersMng.Instance.DeleteMonster(m);
                        }
                        _cursedMonsters.Clear();
                    }

                    var now = DateTime.Now;

                    if(now.Hour <= 12)
                        now = now.AddDays(-1);

                    var next = new DateTime(now.Year,now.Month,now.Day).AddDays(1).AddHours(12);

                    if (next.DayOfWeek == DayOfWeek.Wednesday)
                        next.AddDays(1);

                    Trigger(EventState.Open, next-now);
                    _players
                        .Where(x => x.Eventer)
                        .ToList()
                        .ForEach(x => x.Player.Character.WarpTo(27).Wait());

                    _logger.Information("Next Acheron Guardian will start {0}", next);
                    break;
                case EventState.None:
                    break;
            }
        }

        private void _obelisk_Die(object sender, EventArgs e)
        {
            _nextSpawn = DateTime.Now.Add(TimeLeft);
            _obelisk.Active = false;
            _cursedMonsters.ForEach(x => x.State = ObjectState.Dying);
            Trigger(EventState.Closed, TimeSpan.FromMinutes(1));
            var txt = _obelisk.Killer.Character.Name + " killed the " + _obelisk.Info.Name;
            _ = Program.MapAnoucement(Maps.ArkaWar, txt);
            _ = Program.MapAnoucement(Maps.ArcaBattle, txt);
        }

        public override void Update()
        {
            base.Update();

            if (CurrentState != EventState.Playing)
                return;

            if (_nextSpawn > DateTime.Now)
                return;

            _nextSpawn = DateTime.Now.AddMinutes(5);
            var codes = _cursedMonstersByElement[_obelisk.Element];
            for(var i = 0; i < 5; i++)
            {
                var mtype = codes[Program.RandomProvider(codes.Count)];
                var m = MonstersMng.Instance.CreateMonster(
                    mtype,
                    ObjectType.Monster,
                    _obelisk.MapID,
                    new Point(
                        _obelisk.Position.X + Program.RandomProvider(3, -6),
                        _obelisk.Position.Y + Program.RandomProvider(3, -6)
                        ),
                    1,
                    (Element)MonstersMng.Instance.MonsterInfo[mtype].MainAttribute);
                m.Die += Monster_Die;
            }
        }

        private void Monster_Die(object sender, EventArgs e)
        {
            var m = sender as Monster;
            m.Active = _obelisk.Active;
        }

        public override bool TryAdd(Player plr)
        {
            if (CurrentState == EventState.Playing)
            {
                _ = plr.Character.WarpTo(426);

                GetPlayerEventInfo(plr).Eventer = true;
            }
            else
            {
                _ = plr.Session.SendAsync(new SAcheronEventEnter { Result = 1 });
                return false;
            }
            return true;
        }
    }
}


--file BloodCastle.cs
﻿using MuEmu.Monsters;
using MU.Network.Event;
using MU.Network.Game;
using MuEmu.Resources;
using MuEmu.Resources.Map;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Threading.Tasks;
using MU.Resources;
using MuEmu.Network;
using MuEmu.Resources.Game;
using MuEmu.Entity;
using MuEmu.Network.GameServices;

namespace MuEmu.Events.BloodCastle
{
    public class BloodCastle : Event
    {
        private static List<int> s_BCRewardZenIn = new List<int>
        {
            20000,
            50000,
            100000,
            150000,
            200000,
            250000,
            250000,
            250000,
        };
        private Item _reward = new Item(new ItemNumber(13, 19));

        private MapInfo _map;
        private BloodCastles _manager;
        private List<Player> _playerForReward = new List<Player>();
        private Player _winner;
        private bool _ended;

        public Maps MapID { get; set; }

        public const int MaxPlayers = 10;
        public int Bridge { get; }
        public Player DoorWinner { get; set; }
        public Player StatueWinner { get; set; }
        public Player Winner { get => _winner; 
            set
            {
                _winner = value;
            }
        }

        public Player WeaponOwner { get; set; }
        public List<Player> Players { get; set; }
        public List<Monster> Monsters { get; set; }
        public Monster Gate { get; set; }
        public Monster Statue { get; set; }
        public Monster Archangel { get; set; }
        public ushort MonsterCount { get; set; }
        public ushort MonsterKill { get; set; }
        public ushort BossCount { get; set; }
        public ushort BossKill { get; set; }
        
        public BloodCastle(BloodCastles mng, int bridge, TimeSpan closed, TimeSpan open, TimeSpan playing)
            :base(closed, open, playing)
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(BloodCastle) + " " + (bridge+1));

            _manager = mng;
            Bridge = bridge;
            Players = new List<Player>();
            Monsters = new List<Monster>();
            MapID = (bridge < 7 ? (Maps)((int)Maps.BloodCastle1 + bridge) : Maps.BloodCastle8);
            _map = ResourceCache.Instance.GetMaps()[MapID];
            _map.PlayerJoins += PlayerAdded;
            _map.PlayerLeaves += OnPlayerLeave;
            _map.MonsterAdd += AddMonster;
        }

        public override bool TryAdd(Player plr)
        {
            if (CurrentState != EventState.Open)
                return false;

            if (Players.Count >= MaxPlayers)
                return false;

            Players.Add(plr);
            if(Bridge < 6)
            {
                plr.Character.WarpTo(66 + Bridge).Wait();
            }else if(Bridge == 6)
            {
                plr.Character.WarpTo(80).Wait();
            }
            else if (Bridge == 7)
            {
                plr.Character.WarpTo(271).Wait();
            }else
            {
                Players.Remove(plr);
                return false;
            }

            plr.Character.CharacterDie += OnPlayerDead;
            //plr.Character.MapChanged += OnPlayerLeave;

            return true;
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            var plr = (sender as Player);
            Players.Remove(plr);
            if (WeaponOwner == plr)
            {
                try
                {
                    var a = plr.Character.Inventory.FindAll(_reward.Number).First();
                    GameServices.CItemThrow(plr.Session, new CItemThrow
                    {
                        MapX = (byte)plr.Character.Position.X,
                        MapY = (byte)plr.Character.Position.Y,
                        Source = a,
                    }).Wait();
                }catch(Exception)
                { }
                WeaponOwner = null;
                //_map.AddItem(, , _reward);
            }

            if (Players.Count == 0 && CurrentState == EventState.Playing)
                Trigger(EventState.Closed);
        }

        private void PlayerAdded(object sender, EventArgs e)
        {
            var plr = sender as Player;

            // Prevent login into BC
            if (!Players.Contains(plr))
                plr.Character.WarpTo(22).Wait();
        }

        private void AddMonster(object sender, EventArgs e)
        {
            var mons = sender as Monster;
            mons.Active = false;

            switch (mons.Info.Monster)
            {
                // Spirit Sorcerer
                case 89:
                case 95:
                case 112:
                case 118:
                case 124:
                case 130:
                case 143:
                case 433:
                    mons.Die += SorcererDead;
                    Monsters.Add(mons);
                    break;
                // Castle Gate
                case 131:
                    mons.Die += GateDead;
                    Gate = mons;
                    mons.Active = true;
                    break;
                // Statue of Saint
                case 132:
                case 133:
                case 134:
                    mons.Die += StatueDead;
                    Statue = mons;
                    break;
                case 232:
                    mons.Active = true;
                    Archangel = mons;
                    break;
                default:
                    mons.Die += MonsterDead;
                    Monsters.Add(mons);
                    break;
            }
        }

        private void MonsterDead(object sender, EventArgs e)
        {
            if (MonsterKill < MonsterCount)
            {
                MonsterKill++;
                if (MonsterKill == MonsterCount)
                {
                    CastleBridge(true);
                    Program.MapAnoucement(MapID, ServerMessages.GetMessage(Messages.BC_MonstersKilled));
                }
            }
        }

        private void SorcererDead(object sender, EventArgs e)
        {
            if (BossKill < BossCount)
            {
                BossKill++;
                if (BossKill == BossCount)
                {
                    Statue.Active = true;
                    Program.MapAnoucement(MapID, ServerMessages.GetMessage(Messages.BC_BossKilled)).Wait();
                }
            }
        }

        private void GateDead(object sender, EventArgs e)
        {
            var mons = sender as Monster;
            DoorWinner = mons.Killer;
            mons.Active = false;
            Program
                .MapAnoucement(MapID, ServerMessages.GetMessage(Messages.BC_DoorKiller, DoorWinner.Character.Name))
                .Wait();
            CastleDoor(true);
        }

        private void StatueDead(object sender, EventArgs e)
        {
            var mons = sender as Monster;
            StatueWinner = mons.Killer;
            mons.Active = false;
            _reward.Plus = (byte)(mons.Info.Monster - 132);
            _map.AddItem(mons.Position.X, mons.Position.Y, _reward.Clone() as Item, mons.Killer.Character);
            Program
                .MapAnoucement(MapID, ServerMessages.GetMessage(Messages.BC_StatueKiller, StatueWinner.Character.Name))
                .Wait();
        }

        private void Clear()
        {
            foreach(var mons in Monsters)
            {
                mons.Active = false;
            }

            if(Gate!=null)
                Gate.Active = true;

            if (Statue != null)
                Statue.Active = false;

            if (Archangel != null)
                Archangel.Active = true;

            if (WeaponOwner != null)
            {
                var a = WeaponOwner.Character.Inventory.FindAll(_reward.Number).First();
                WeaponOwner.Character.Inventory.Delete(a);
                WeaponOwner = null;
            }

            _playerForReward.Clear();
            _winner = null;
            DoorWinner = null;
            StatueWinner = null;
        }

        public override void Update()
        {
            switch(CurrentState)
            {
                case EventState.Open:
                    if (TimeLeft.Seconds != 0)
                        break;
                    Program.MapAnoucement(MapID, ServerMessages.GetMessage(Messages.BC_Open2, TimeLeft.Minutes));
                    break;
                case EventState.Playing:
                    if ((int)Time.TotalSeconds == 30)
                        SendAsync(new SDevilSquareSet(DevilSquareState.BeforeStart)).Wait();

                    if ((int)Time.TotalSeconds < 60)
                        return;

                    if ((int)Time.TotalSeconds == 60)
                    {
                        SendAsync(new SBloodCastleState(0, (ushort)(TimeLeft.TotalSeconds - 60), 0, 0, 0xffff, 1)).Wait();
                        foreach (var mons in Monsters)
                        {
                            mons.State = ObjectState.Regen;
                            mons.Active = true;
                        }
                        // Bridge Start
                        CastleEntrace(true);
                    }

                    if (TimeLeft.TotalSeconds > 60 && !_ended)
                    {
                        var timeleft = (ushort)(TimeLeft.TotalSeconds - 60);

                        var msg = new SBloodCastleState(4, timeleft, MonsterCount, MonsterKill, (ushort)(WeaponOwner?.Session.ID ?? 0xffff), _reward.Plus);

                        if (MonsterKill < MonsterCount)
                        {
                            msg.State = 1;
                        }
                        else if(DoorWinner == null)
                        {
                            msg.State = 2;
                        }
                        else if (BossKill < BossCount || StatueWinner == null)
                        {
                            msg.State = 4;
                            msg.MaxKillMonster = BossCount;
                            msg.CurKillMonster = BossKill;
                        }
                        else
                        {
                            msg.State = 4;
                            msg.MaxKillMonster = BossCount;
                            msg.CurKillMonster = BossKill;
                            if (WeaponOwner == null)
                            {
                                WeaponOwner = Players
                                    .FirstOrDefault(x => x.Character.Inventory.FindAllItems(_reward.Number).Any());

                                if (WeaponOwner != null)
                                    Program.MapAnoucement(MapID, ServerMessages.GetMessage(Messages.BC_WeaponOwner, WeaponOwner.Character.Name));
                            }
                        }

                        SendAsync(msg).Wait();

                        if(timeleft == 30)
                            SendAsync(new SDevilSquareSet(DevilSquareState.BeforeEnd)).Wait();
                    }

                    if((int)TimeLeft.TotalSeconds == 60 || Winner != null)
                    {
                        GiveReward();
                        _ended = true;
                        SendAsync(new SBloodCastleState(2, 59, 0, 0, 0xffff, 1)).Wait();

                        if(Winner != null)
                            Program.MapAnoucement(MapID, ServerMessages.GetMessage(Messages.BC_Winner, Winner.Character.Name)).Wait();
                        Winner = null;
                        Trigger(EventState.Closed, TimeSpan.FromSeconds(59));
                        Clear();
                    }

                    if (TimeLeft == TimeSpan.FromSeconds(30))
                        SendAsync(new SDevilSquareSet(DevilSquareState.Quit)).Wait();
                    break;
            }
            base.Update();
        }

        public override void OnTransition(EventState NextState)
        {
            switch (NextState)
            {
                case EventState.Closed:
                    CastleEntrace(false);
                    CastleDoor(false);
                    CastleBridge(false);

                    foreach (var plr in Players.ToArray())
                        plr.Character.WarpTo(22).Wait();

                    Players.Clear();
                    if(_manager.CurrentState != EventState.Closed)
                        Trigger(EventState.Open, _manager.TimeLeft + _closedTime);
                    break;
                case EventState.Open:
                    Trigger(EventState.Playing, _openTime);
                    break;
                case EventState.Playing:
                    SendAsync(new SCommand(ServerCommandType.EventMsg, (byte)EventMsg.GoAheadBC)).Wait();
                    _playerForReward = Players.ToList();
                    MonsterCount = (ushort)(Players.Count * 40);
                    BossCount = (ushort)(10 * Players.Count);
                    Trigger(EventState.Closed, _playingTime);
                    break;
            }
        }

        private async Task SendAsync(object message)
        {
            foreach(var plr in Players)
            {
                await plr.Session.SendAsync(message);
            }
        }

        private async void CastleEntrace(bool free)
        {
            if (free) await _map.RemoveAttribute(MapAttributes.NoWalk, new Rectangle(13, 15, 2, 8));
            else await _map.AddAttribute(MapAttributes.NoWalk, new Rectangle(13, 15, 2, 8));
        }

        private async void CastleBridge(bool free)
        {
            if (free) await _map.RemoveAttribute(MapAttributes.Hide, new Rectangle(13, 70, 2, 5));
            else await _map.AddAttribute(MapAttributes.Hide, new Rectangle(13, 70, 2, 5));
        }

        private async void CastleDoor(bool free)
        {
            if (free)
            {
                await _map.RemoveAttribute(MapAttributes.NoWalk, new Rectangle(13, 75, 2, 5));// Door Itself
                await _map.RemoveAttribute(MapAttributes.NoWalk, new Rectangle(11, 80, 14, 9));// Zone Beginh Door
                await _map.RemoveAttribute(MapAttributes.NoWalk, new Rectangle(8, 80, 2, 3));// Altar 

            }
            else
            {
                await _map.AddAttribute(MapAttributes.NoWalk, new Rectangle(13, 75, 2, 5));
                await _map.RemoveAttribute(MapAttributes.NoWalk, new Rectangle(11, 80, 14, 9));// Zone Beginh Door
                await _map.RemoveAttribute(MapAttributes.NoWalk, new Rectangle(8, 80, 2, 3));// Altar 
            }
        }

        private async void GiveReward()
        {
            List<BCScore> bc = new List<BCScore>();
            using (var db = new GameContext())
            {
            if (Winner != null)
                {
                    var party = Winner.Character.Party;
                    foreach (var plr in _playerForReward)
                    {
                        int points;
                        if (plr == Winner)
                        {
                            points = 1000 + Bridge * 5;
                            // Jewel of Chaos
                            _map.AddItem(plr.Character.Position.X, plr.Character.Position.Y, new Item(new ItemNumber(6159)), plr.Character);
                        }
                        else if (plr.Character.Party == party)
                        {
                            points = 800;
                            // Jewel of Chaos
                            _map.AddItem(plr.Character.Position.X, plr.Character.Position.Y, new Item(new ItemNumber(6159)), plr.Character);
                        }
                        else if (Players.Any(x => x == plr))
                        {
                            points = 600;
                        }
                        else
                        {
                            points = 300;
                        }

                        float experience = 0;
                        if (plr == Winner || Winner.Character.Party == plr.Character.Party)
                        {
                            var mult = plr == Winner ? 1.0f : 0.5f;
                            experience += (5000 + Bridge * 5000) * mult;
                            experience += (float)(TimeLeft.TotalSeconds * (160 + 20 * Bridge)) * mult;
                        }

                        if (plr == DoorWinner || DoorWinner.Character.Party == plr.Character.Party)
                        {
                            var mult = plr == DoorWinner ? 1.0f : 0.5f;
                            experience += (20000 + 30000 * Bridge) * mult;
                        }

                        if (plr == StatueWinner || StatueWinner.Character.Party == plr.Character.Party)
                        {
                            var mult = plr == StatueWinner ? 1.0f : 0.5f;
                            experience += (20000 + 30000 * Bridge) * mult;
                        }

                        var zMult = Players.Any(x => x == plr) ? 1.0f : 0.5f;

                        plr.Character.Experience += (uint)experience;
                        plr.Character.Money += (uint)(s_BCRewardZenIn[Bridge] * zMult);

                        if (plr.Status != LoginStatus.NotLogged)
                            await plr.Session.SendAsync(new SBloodCastleReward(true, 255, new BCScore[] { new BCScore {
                            Name = plr.Character.Name,
                            Experience = (int)experience,
                            Score = points,
                            Zen = (int)(s_BCRewardZenIn[Bridge] * zMult),
                        } }));
                        var _dto = (from c in db.BloodCastles
                                where c.CharacterId == plr.Character.Id
                                select c).SingleOrDefault();

                        if (_dto == null)
                        {
                            _dto = new MU.DataBase.BloodCastleDto
                            {
                                CharacterId = plr.Character.Id,
                                Points = points
                            };
                            db.BloodCastles.Add(_dto);
                        }
                        else
                        {
                            _dto.Points += points;
                            db.BloodCastles.Update(_dto);
                        }
                    }
                }
                else
                {
                    foreach (var plr in _playerForReward)
                    {
                        float experience = 0;

                        if (DoorWinner != null)
                            if (plr == DoorWinner || DoorWinner.Character.Party == plr.Character.Party)
                            {
                                var mult = plr == DoorWinner ? 1.0f : 0.5f;
                                experience += (20000 + 30000 * Bridge) * mult;
                            }

                        if (StatueWinner != null)
                            if (plr == StatueWinner || StatueWinner.Character.Party == plr.Character.Party)
                            {
                                var mult = plr == StatueWinner ? 1.0f : 0.5f;
                                experience += (20000 + 30000 * Bridge) * mult;
                            }

                        if (plr.Status != LoginStatus.NotLogged)
                            await plr.Session.SendAsync(new SBloodCastleReward(false, 255, new BCScore[] { new BCScore {
                        Name = plr.Character.Name,
                            Experience = (int)experience,
                            Score = -300,
                            Zen = 0,
                        } }));
                        var _dto = (from c in db.BloodCastles
                                    where c.CharacterId == plr.Character.Id
                                    select c).SingleOrDefault();

                        if (_dto == null)
                        {
                            _dto = new MU.DataBase.BloodCastleDto
                            {
                                CharacterId = plr.Character.Id,
                                Points = -300
                            };
                            db.BloodCastles.Add(_dto);
                        }
                        else
                        {
                            _dto.Points += -300;
                            db.BloodCastles.Update(_dto);
                        }
                    }
                }
            }

            _playerForReward.Clear();
        }

        public override void NPCTalk(Player plr)
        {
            var session = plr.Session;
            if (CurrentState != EventState.Playing || (CurrentState == EventState.Playing && TimeLeft > TimeSpan.FromMinutes(4)))
            {
                session.SendAsync(new SNotice(NoticeType.Blue, ServerMessages.GetMessage(Messages.BC_Time))).Wait();
                return;
            }

            if ((int)TimeLeft.TotalSeconds == 60 || Winner != null)
            {
                session.SendAsync(new SCommand(ServerCommandType.EventMsg, (byte)EventMsg.CompletedBC)).Wait();
                return;
            }

            var item = plr.Character.Inventory.FindAllItems(_reward.Number).FirstOrDefault();

            if (item == null)
            {
                session.SendAsync(new SCommand(ServerCommandType.EventMsg, (byte)EventMsg.InvalidBC)).Wait();
                return;
            }

            plr.Character.Inventory.Delete(item).Wait();

            if (DoorWinner == null || StatueWinner == null)
            {
                _logger.Error(ServerMessages.GetMessage(Messages.BC_WeaponError));
                return;
            }
            session.SendAsync(new SCommand(ServerCommandType.EventMsg, (byte)EventMsg.SucceedBC)).Wait();
            Winner = plr;
            WeaponOwner = null;
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            var @char = sender as Character;
            var item = @char.Inventory.FindAll(_reward.Number);
            if(item.Length > 0)
            {
                GameServices.CItemThrow(@char.Player.Session, new CItemThrow
                {
                    MapX = (byte)@char.Position.X,
                    MapY = (byte)@char.Position.Y,
                    Source = item.First()
                }).Wait();
            }
            @char.WarpTo(22).Wait();
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }
    }
}


--file BloodCastles.cs
﻿using MU.Network.Game;
using MU.Resources;
using MU.Resources.Game;
using MuEmu.Resources;
using MuEmu.Resources.Game;
using MuEmu.Resources.Map;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu.Events.BloodCastle
{    internal struct BloodCastleInfo
    {
        public byte Bridge { get; set; }
        public ushort MinLevel { get; set; }
        public ushort MaxLevel { get; set; }
    }
    public class BloodCastles : Event
    {
        private static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(BloodCastles));

        private BloodCastle[] _bridges;

        public BloodCastles()
            :base(TimeSpan.FromHours(0.25), TimeSpan.FromMinutes(5), TimeSpan.FromMinutes(17))
        {
            _eventLevelReqs = new List<EventLevelReq>
            {
                new EventLevelReq{ Min = 15, Max = 80 },
                new EventLevelReq{ Min = 81, Max = 130 },
                new EventLevelReq{ Min = 131, Max = 180 },
                new EventLevelReq{ Min = 181, Max = 230 },
                new EventLevelReq{ Min = 231, Max = 280 },
                new EventLevelReq{ Min = 281, Max = 330 },
                new EventLevelReq{ Min = 331, Max = 400 },
                new EventLevelReq{ Min = 0, Max = 0 },
            };

            _bridges = new BloodCastle[8];
            for (var i = 0; i < _bridges.Length; i++)
            {
                _bridges[i] = new BloodCastle(this, i, _closedTime, _openTime, _playingTime);
            }
        }

        public override void Initialize()
        {
            base.Initialize();
            foreach (var bridge in _bridges)
                bridge.Initialize();
        }

        private static IEnumerable<Player> PlayersOut()
        {
            return Program.server.Clients
                                .Where(x => x.Player != null)
                                .Where(x => x.Player.Character != null)
                                .Select(x => x.Player)
                                .Where(x => (x.Character.MapID < Maps.BloodCastle1 || x.Character.MapID > Maps.BloodCastle7) && x.Character.MapID != Maps.BloodCastle8);
        }

        public override void Update()
        {
            switch(CurrentState)
            {
                case EventState.Closed:
                    break;
                case EventState.Open:
                    if (((int)TimeLeft.TotalSeconds) % 60 == 0 && TimeLeft.TotalSeconds >= 60)
                    {
                        Program.NoEventMapAnoucement(ServerMessages.GetMessage(Messages.BC_Open, (int)Math.Ceiling(TimeLeft.TotalMinutes))).Wait();
                        Program.NoEventMapSendAsync(new SEventNotificationS16Kor
                        {
                            Active = 1,
                            EventID = EventIcon.BloodCastle
                        });
                    }
                    break;
                case EventState.Playing:
                    break;
            }

            foreach(var bridge in _bridges)
            {
                bridge.Update();
            }

            base.Update();
        }
        
        public void MessengerAngelTalk(Player plr)
        {
            if (CurrentState != EventState.Open)
            {
                plr.Session.SendAsync(new SCommand(ServerCommandType.EventMsg, (byte)EventMsg.RunningBC)).Wait();
                return;
            }

            plr.Session.SendAsync(new STalk { Result = NPCWindow.MessengerAngel }).Wait();
        }

        public void AngelKingTalk(Player plr)
        {
            var bridge = _bridges.FirstOrDefault(x => x.Players.Any(y => y == plr));
            if (bridge == null)
            {
                plr.Session.SendAsync(new SCommand(ServerCommandType.EventMsg, (byte)EventMsg.InvalidBC)).Wait();
                return;
            }

            bridge.NPCTalk(plr);
        }

        public override bool TryAdd(Player plr)
        {
            var bridge = GetEventNumber(plr);

            return _bridges[bridge - 1].TryAdd(plr);
        }

        public override void NPCTalk(Player plr)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnTransition(EventState NextState)
        {
            switch(NextState)
            {
                case EventState.Closed:
                    Trigger(EventState.Open, _closedTime);
                    break;
                case EventState.Open:
                    Trigger(EventState.Playing, _openTime);
                    break;

                case EventState.Playing:
                    Program.NoEventMapAnoucement(ServerMessages.GetMessage(Messages.BC_Closed)).Wait();
                    Trigger(EventState.Closed, _playingTime);
                    break;
            }
            Program.NoEventMapSendAsync(new SEventNotificationS16Kor
            {
                Active = (byte)(NextState == EventState.Open ? 1 : 0),
                EventID = EventIcon.BloodCastle
            });
        }
    }
}


--file CastleSiege.cs
﻿using MU.Network.CastleSiege;
using MU.Resources;
using MuEmu.Monsters;
using MuEmu.Resources;
using MuEmu.Resources.Map;
using MuEmu.Util;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu.Events.CastleSiege
{
    internal enum SiegeStates
    {
        None = -1,
        Idle1,
        RegisteSiege,
        Idle2,
        RegisteMark,
        Idle3,
        Notify,
        ReadySiege,
        StartSiege,
        EndSiege,
        EndCycle,
    }

    internal class CastleSiegeState : StateMachine<SiegeStates>
    {
        private CastleSiege main;
        private MapInfo map;
        internal List<Monster> gates = new List<Monster>();
        internal List<Monster> guardianStatues = new List<Monster>();
        internal Monster sw1;
        internal Monster sw2;
        internal Monster crown;
        private Dictionary<SiegeStates, TimeSpan> _periods = new Dictionary<SiegeStates, TimeSpan>
        {
            {SiegeStates.Idle1,         TimeSpan.Zero },
            {SiegeStates.RegisteSiege,  TimeSpan.FromMinutes(2879) },
            {SiegeStates.Idle2,         TimeSpan.FromMinutes(1) },
            {SiegeStates.RegisteMark,   TimeSpan.FromHours(24) },
            {SiegeStates.Idle3,         TimeSpan.FromHours(36) },
            {SiegeStates.Notify,        TimeSpan.FromHours(7) },
            {SiegeStates.ReadySiege,    TimeSpan.FromMinutes(2) },//FromHours
            {SiegeStates.StartSiege,    TimeSpan.FromHours(2) },
            {SiegeStates.EndSiege,      TimeSpan.FromHours(1) },
            {SiegeStates.EndCycle,      TimeSpan.Zero },
        };
        private Dictionary<SiegeStates, int> _totals = new Dictionary<SiegeStates, int>();

        public CastleSiegeState(CastleSiege mng)
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(CastleSiegeState));
            map = ResourceCache.Instance.GetMaps()[Maps.ValleyofLoren];
            map.MonsterAdd += Map_MonsterAdd;
            main = mng;
            ChangeState(SiegeStates.None);

            var total = 0;
            foreach(var p in _periods)
            {
                _totals.Add(p.Key, total);
                total += (int)p.Value.TotalSeconds;
            }
        }

        private void Map_MonsterAdd(object sender, EventArgs e)
        {
            var mob = sender as Monster;
            switch(mob.Info.Monster)
            {
                case 277:
                    gates.Add(mob);
                    mob.Type = ObjectType.Gate;
                    mob.Active = false;
                    mob.Die += Mob_Die;
                    break;
                case 283:
                    guardianStatues.Add(mob);
                    mob.Type = ObjectType.Gate;
                    mob.Active = false;
                    mob.Die += Mob_Die;
                    break;
                case 216:
                    crown = mob;
                    break;
                case 217:
                    sw1 = mob;
                    break;
                case 218:
                    sw2 = mob;
                    break;
            }
        }

        private void Mob_Die(object sender, EventArgs e)
        {
            var mob = sender as Monster;
            mob.Active = false;
        }

        public DateTime NextSiegePeriod { get; set; }

        public override void Initialize()
        {
            GetNextSiegePeriod();
        }

        public DateTime GetNextSiegePeriod()
        {
            var now = DateTime.Now;
            DateTime firstSunday;
            do
            {
                var firstDay = new DateTime(now.Year, now.Month, 1);
                var addDays = (7 - (int)firstDay.DayOfWeek) % 7;
                firstSunday = firstDay.AddDays(addDays);
                now = now.AddMonths(1);
            } while (firstSunday < DateTime.Now && DateTime.Now - firstSunday > TimeSpan.FromDays(7));

            NextSiegePeriod = firstSunday.AddSeconds(_totals[SiegeStates.StartSiege]);

            if (DateTime.Now > firstSunday)
            {
                var sub = DateTime.Now - firstSunday;

                var currentPeriod = _totals.Last(x => sub.TotalSeconds > x.Value);

                var lastState = currentPeriod.Key;
                var duration = _periods[lastState];
                var trans = DateTime.Now - firstSunday.AddSeconds(currentPeriod.Value);
                var left = duration - trans;

                ChangeState(lastState);
                if (lastState + 1 < SiegeStates.EndCycle)
                    Trigger(lastState + 1, left);
                else
                    Trigger(SiegeStates.Idle1, left);
            }
            else
            {
                Trigger(SiegeStates.RegisteSiege, firstSunday - DateTime.Now);
            }

            return NextSiegePeriod;
        }

        public override void OnTransition(SiegeStates NextState)
        {
            if (NextState == SiegeStates.None)
                return;

            var nextState = NextState + 1;
            if (nextState > SiegeStates.EndCycle)
                nextState = SiegeStates.Idle1;

            Trigger(nextState, _periods[NextState]);
            _logger.Information("Sync State: {0}, NextState {2} at {1}", NextState, DateTime.Now.Add(_periods[NextState]), nextState);

            switch(NextState)
            {
                case SiegeStates.None:
                    break;
                case SiegeStates.Idle1:
                    break;
                case SiegeStates.RegisteSiege:
                    break;
                case SiegeStates.Idle2:
                    break;
                case SiegeStates.RegisteMark:
                    break;
                case SiegeStates.Idle3:
                    break;
                case SiegeStates.Notify:
                    break;
                case SiegeStates.ReadySiege:
                    break;
                case SiegeStates.StartSiege:
                    {
                        var curSkill = SkillStates.CastleSiegeAttackOne;
                        byte side = 0;
                        foreach (var g in main.AttackGuild.Take(3))
                        {
                            var membersOnline = g.Guild.Members.Where(x => x.Player != null).ToList();
                            membersOnline.ForEach(x => x.Player.Character.Spells.SetBuff(curSkill, TimeLeft));
                            _ = membersOnline.Select(x => x.Player.Session).SendAsync(new SCastleSiegeNotifyStart { State = 1 });
                            _ = membersOnline.Select(x => x.Player.Session).SendAsync(new SJoinSideNotify { Side = side++ });
                            curSkill++;
                        }
                        gates.ForEach(x => x.Active = true);
                        guardianStatues.ForEach(x => x.Active = true);
                        TimeLeftSend();
                    }
                    break;
                case SiegeStates.EndSiege:
                    break;
                case SiegeStates.EndCycle:
                    break;
            }
        }

        internal void NotifyAllUserSide()
        {
            var list = main.AttackGuild
                .Select(x => x.Guild).ToList();

            list.ForEach(x => x.Union.SelectMany(x => x.Members).Select(x => x.Player.Session).SendAsync(new SJoinSideNotify { Side = 1 }));
        }

        public override void Update()
        {
            switch(CurrentState)
            {
                case SiegeStates.RegisteSiege:
                    RegisteSiege();
                    break;
                case SiegeStates.RegisteMark:
                    RegisteMark();
                    break;
                case SiegeStates.Idle3:
                    Idle3();
                    break;
                case SiegeStates.Notify:
                    Notify();
                    break;
                case SiegeStates.ReadySiege:
                    ReadySiege();
                    break;
                case SiegeStates.StartSiege:
                    StartSiege();
                    break;
            }
            base.Update();
        }

        private void RegisteSiege()
        {
            var seconds = (int)Time.TotalSeconds;
            var notify = (seconds % 1800) == 0;
            if (!notify)
                return;

            _=Program.GlobalAnoucement(ServerMessages.GetMessage(MU.Resources.Messages.CS_RegisteNotify));
        }

        private void RegisteMark()
        {
            var seconds = (int)Time.TotalSeconds;
            var notify = (seconds % 1800) == 0;
            if (!notify)
                return;

            _ = Program.GlobalAnoucement(ServerMessages.GetMessage(MU.Resources.Messages.CS_RegisteMarkNotify));
        }

        private void Idle3()
        {
            var seconds = (int)Time.TotalSeconds;
            var notify = (seconds % 7200) == 0;
            if (!notify)
                return;

            _ = Program.GlobalAnoucement(ServerMessages.GetMessage(MU.Resources.Messages.CS_Idle3));
        }

        private void Notify()
        {
            var seconds = (int)Time.TotalSeconds;
            var notify = (seconds % 1800) == 0;
            if (!notify)
                return;

            _ = Program.GlobalAnoucement(ServerMessages.GetMessage(MU.Resources.Messages.CS_Notify));
        }

        private void ReadySiege()
        {
            var seconds = (int)Time.TotalSeconds;
            var notify = (seconds % 1800) == 0;
            seconds = (int)TimeLeft.TotalSeconds;
            var lastNotify = seconds <= 300 && (seconds % 60) == 0;
            if (notify)
            {
                _ = Program.GlobalAnoucement(ServerMessages.GetMessage(Messages.CS_Notify));
            }
            if(lastNotify)
            {
                _ = Program.GlobalAnoucement(ServerMessages.GetMessage(Messages.CS_LastNotify, seconds/60));
            }
        }

        private void NotifySwitch(Player plr, Monster sw, Player owner, byte state)
        {
            _ = plr.Session.SendAsync(new SCastleSiegeNotifySwitch
            {
                Index = sw.Index,
                UserIndex = (owner?.ID ?? 0xffff),
                State = state
            });
        }

        private void NotifySwitchInfo(Monster sw, Player plr)
        {
            var msg = new SCastleSiegeNotifySwitchInfo
            {
                GuildName = plr?.Character.Guild.Name??"",
                UserName = plr?.Character.Name??"",
                Index = sw.Index,
                Side = 0,
                State = (byte)(plr != null ? 1 : 0),
            };
            if (plr != null)
            {
                _ = plr.Session.SendAsync(msg);
            }
            _ = sw.ViewPort.Select(x => x.Session).SendAsync(msg);
        }

        private void NotifyCrownState(byte state)
        {
            var msg = new SCastleSiegeNotifyCrownState
            {
                State = state
            };

            if (state == 0)
                crown.Spells.SetBuff(SkillStates.CastleSiegeCrownState, TimeLeft);
            else
                crown.Spells.ClearBuffByEffect(SkillStates.CastleSiegeCrownState).Wait();

            _ = crown.ViewPort.SendAsync(msg);
        }

        private void StartSiege()
        {
            var seconds = (int)Time.TotalSeconds;
            var notify = (seconds % 180) == 0;
            seconds = (int)TimeLeft.TotalSeconds;
            if (notify)
            {
                TimeLeftSend();
            }
            if(seconds % 1800 == 0)
            {
                _ = Program.GlobalAnoucement(ServerMessages.GetMessage(Messages.CS_Notify));
            }
            if(seconds < 180 && (seconds % 60) == 0)
            {
                TimeLeftSend();
            }
            if((seconds % 3) == 0)
            {
                MinimapUpdate();
            }

            if (main.Switch1 != null)
            {
                var sw = main.Switch1.Window as Monster;
                if(sw.Position.Substract(main.Switch1.Character.Position).LengthSquared() > 3)
                {
                    main.Switch1 = null;
                    NotifyCrownState(1);
                }
            }

            if (main.Switch2 != null)
            {
                var sw = main.Switch2.Window as Monster;
                if (sw.Position.Substract(main.Switch2.Character.Position).LengthSquared() > 3)
                {
                    main.Switch2 = null;
                    NotifyCrownState(1);
                }
            }

            NotifySwitchInfo(sw1, main.Switch1);
            NotifySwitchInfo(sw2, main.Switch2);

            if(main.Switch1 != null && main.Switch2 != null)
            {
                if(main.Switch1.Character.Guild.Union[0] == main.Switch2.Character.Guild.Union[0])
                {
                    NotifyCrownState(0);
                }
                else
                {
                    NotifyCrownState(1);
                }
            }
        }

        private void MinimapUpdate()
        {
            var list = new List<Guild>();
            list.Add(main.Owner);
            list.AddRange(main.AttackGuild.Select(x => x.Guild));
            list.RemoveAll(x => x == null);

            foreach(var g in list)
            {
                var master = g.Union.FirstOrDefault()?.Master??g.Master;
                var members = g.Union.SelectMany(x => x.Members).Where(x => x.Player != null);

                if (master == null)
                    continue;

                _ = master.Player.Session.SendAsync(new SCastleSiegeMinimapData
                {
                    List = members.Select(x => new CastleSiegeMinimapDta
                    {
                        X = (byte)x.Player.Character.Position.X,
                        Y = (byte)x.Player.Character.Position.Y
                    }).ToArray()
                });
            }

            if(main.Owner != null)
            {
                var listMob = new List<CastleSiegeMinimapNPCDta>();
                listMob.AddRange(gates.Select(x => new CastleSiegeMinimapNPCDta { Type = 0, X = (byte)x.Position.X, Y = (byte)x.Position.Y }));
                listMob.AddRange(guardianStatues.Select(x => new CastleSiegeMinimapNPCDta { Type = 0, X = (byte)x.Position.X, Y = (byte)x.Position.Y }));

                _ = main.Owner.Master.Player.Session.SendAsync(new SCastleSiegeMinimapNPCData
                {
                    List = listMob.ToArray()
                });
            }
        }

        private void TimeLeftSend()
        {
            _ = Program.NoEventMapSendAsync(new SLeftTimeAlarm
            {
                Hour = (byte)TimeLeft.Hours,
                Minute = (byte)TimeLeft.Minutes
            });
        }
    }

    public class AttackGuildInfo
    {
        public int Marks { get; set; }
        public Guild Guild { get; set; }
        public bool GiveUp { get; set; }
    }
    public class CastleSiege : Event
    {
        private CastleSiegeState subStates;
        internal SiegeStates State => subStates.CurrentState;

        public int StageTimeLeft => (int)subStates.TimeLeft.TotalSeconds;
        public DateTimeOffset StateStart => subStates.Start;
        public DateTimeOffset StateEnd => subStates.End;
        public DateTime SiegeExpectedPeriod => subStates.NextSiegePeriod;

        public Guild Owner { get; internal set; }
        public List<AttackGuildInfo> AttackGuild { get; set; } = new List<AttackGuildInfo>();
        public Player Switch1 { get; set; }
        public Player Switch2 { get; set; }

        public CastleSiege()
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(CastleSiegeState));
            subStates = new CastleSiegeState(this);
        }

        public override void Initialize()
        {
            base.Initialize();
            subStates.Initialize();

            Trigger(EventState.Open);
        }

        public override void NPCTalk(Player plr)
        {
            throw new NotImplementedException();
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnTransition(EventState NextState)
        {
            switch(NextState)
            {
                case EventState.Open:
                    subStates.Trigger(SiegeStates.Idle1);
                    break;
            }
        }

        public override void Update()
        {
            subStates.Update();
            base.Update();
        }

        public override bool TryAdd(Player plr)
        {
            throw new NotImplementedException();
        }

        internal void CrownTalk(Player player)
        {
            throw new NotImplementedException();
        }

        internal void CrownSwitchTalk(Monster mob, Player player)
        {
            if (Switch1?.Session.Closed??false)
                Switch1 = null;
            if (Switch2?.Session.Closed??false)
                Switch2 = null;

            if (State != SiegeStates.StartSiege)
                return;

            if (subStates.guardianStatues.Any(x => x.Active))
                return;

            switch (mob.Info.Monster)
            {
                case 217:
                    _ = player.Session.SendAsync(new SCastleSiegeNotifySwitch
                    {
                        Index = mob.Index,
                        UserIndex = (Switch1?.ID??0xffff),
                        State = (byte)(Switch1 != null ? 2 : 1)
                    });
                    if (Switch1 == null)
                    {
                        Switch1 = player;
                        player.Window = mob;
                        player.Character.CharacterDie += Character_CharacterDie;
                    }
                    break;
                case 218:
                    _ = player.Session.SendAsync(new SCastleSiegeNotifySwitch
                    {
                        Index = mob.Index,
                        UserIndex = (Switch2?.ID ?? 0xffff),
                        State = (byte)(Switch2 != null ? 2 : 1)
                    });
                    if (Switch2 == null)
                    {
                        Switch2 = player;
                        player.Window = mob;
                        player.Character.CharacterDie += Character_CharacterDie;
                    }
                    break;
            }
        }

        private void Character_CharacterDie(object sender, EventArgs e)
        {
            var @char = sender as Character;
            @char.CharacterDie -= Character_CharacterDie;
            if (Switch1 == @char.Player)
                Switch1 = null;
            if (Switch2 == @char.Player)
                Switch2 = null;
        }

        internal void RegisteAttackGuild(Player player)
        {
            var g = player.Character.Guild.Union[0];
            AttackGuild.Add(new AttackGuildInfo { GiveUp = false, Guild = g, Marks = 0 });
            _ = player.Session.SendAsync(new SGuildRegiste { Result = 1, GuildName = g.Name });
        }

        internal int RegisteMark(Guild guild, byte durability)
        {
            var info = AttackGuild.FirstOrDefault(x => x.Guild == guild);
            if (info == null)
                return 0;

            info.Marks += durability;
            return info.Marks;
        }
    }
}


--file ChaosCastle.cs
﻿using MuEmu.Monsters;
using MU.Network.Event;
using MU.Network.Game;
using MuEmu.Resources.Map;
using MuEmu.Util;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using WebZen.Util;
using MU.Resources;
using MU.Network;

namespace MuEmu.Events.ChaosCastle
{
    public class ChaosCastle : Event
    {
        private ushort _monsterA = 162;
        private ushort _monsterB = 163;
        private List<Monster> _ccMonsters;
        private Maps _map;
        private MapInfo _mapInfo;
        private Rectangle _floorState;
        private int _recaudation;
        private byte _trapStatus;

        public int Index { get; private set; }
        public ChaosCastle(int index, TimeSpan close, TimeSpan open, TimeSpan playing) : base(close, open, playing)
        {
            Index = index + 1;
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(ChaosCastle) + " " + Index);
            _monsterA += (ushort)index;
            _monsterB += (ushort)index;
            _map = (Maps)((int)Maps.ChaosCastle1 + index);
            if (Index == 7)
            {
                _monsterA = 426;
                _monsterB = 427;
                _map = Maps.ChaosCastle7;
            }
            _mapInfo = Resources.ResourceCache.Instance.GetMaps()[_map];
            _ccMonsters = _mapInfo.Monsters;
            _floorState = ChaosCastles.Ground;
            _mapInfo.MonsterAdd += OnMonsterAdd;
        }

        public void OnMonsterAdd(object sender, EventArgs eventArgs)
        {
            var mob = sender as Monster;
            mob.Die += OnMonsterDead;
            mob.Active = false;
            mob.CanDrop = false;
        }

        public override void NPCTalk(Player plr)
        {
            throw new NotImplementedException();
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            var mob = sender as Monster;
            mob.Active = false;
            
            var plrInfo = _players.Find(x => x.Player == mob.Killer);
            if (plrInfo == null)
                return;

            plrInfo.Score += 100;

            var playersInBlowArea = _mapInfo.Players.Where(x => x.Position.Substract(mob.Position).Length() <= 2);
            foreach (var plr in playersInBlowArea)
            {
                var distance = mob.Position.Substract(plr.Position);
                var ls = Math.Max(distance.LengthSquared(), 0);
                var norma = distance.Normalize();
                var direction = new Point((int)(norma.X * 3 / ls), (int)(norma.Y * 3 / ls));
                plr.Position = new Point(plr.Position.X + direction.X, plr.Position.Y + direction.Y);
                var msg = new SPositionSet((ushort)plr.Player.Session.ID, plr.Position);
                var dmg = 15 / ls;
                plr.Health -= (float)dmg;
                plr.Player.Session.SendAsync(msg).Wait();

                var attack = VersionSelector.CreateMessage<SAttackResult>((ushort)plr.Player.Session.ID, (ushort)dmg, DamageType.Regular, 0);
                plr.Player.Session.SendAsync(attack).Wait();
                plr.Player.SendV2Message(msg);
            }

            UpdateFloor();

            if (EventCount() == 1)
                GiveRewards();
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            var plr = (sender as Character)?.Player ?? null;
            plr.Character
                .WarpTo(22)
                .Wait();

            //var plrInfo = _players.Find(x => x.Player == plr);

            //if (plrInfo != null)
            //{
            //    plrInfo.Eventer = false;
            //    if(plr.Killer.GetType() == typeof(Player))
            //    {
            //        var killer = plr.Killer as Player;
            //        plrInfo = _players.Find(x => x.Player == killer);
            //        if(plrInfo != null)
            //        {
            //            plrInfo.Score += 1;
            //        }
            //    }
            //}

            //UpdateFloor();

            //if (EventCount() == 1)
            //    GiveRewards();
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            var plr = (sender as Character)?.Player??null;

            var plrInfo = _players.Find(x => x.Player == plr);

            if (plrInfo == null)
            {
                _logger.Error("Player isn't in the event");
                plr.Character.CharacterDie -= OnPlayerDead;
                plr.Character.MapChanged -= OnPlayerLeave;
            }
            else
            {
                plr.Character.CharacterDie -= OnPlayerDead;
                plr.Character.MapChanged -= OnPlayerLeave;
                plrInfo.Eventer = false;
            }

            UpdateFloor();

            if (EventCount() == 1)
                GiveRewards();
        }

        public override void OnTransition(EventState NextState)
        {
            switch (NextState)
            {
                case EventState.Open:
                    _recaudation = 0;
                    _players.Clear();
                    Trigger(EventState.Playing, _openTime);
                    _floorState = ChaosCastles.Ground;
                    break;
                case EventState.Playing:
                    Program
                        .MapAnoucement(_map, $"Chaos Castle {Index} Starts!.")
                        .Wait();

                    _mapInfo.Push();
                    SendSatus(5);

                    var fill = Math.Min(50 - _players.Count(x => x.Eventer), _ccMonsters.Count);
                    for(var i = 0; i < fill; i++)
                        _ccMonsters[i].Active = true;

                    Trigger(EventState.Closed, _playingTime);

                    _mapInfo.RemoveAttribute(MapAttributes.Safe, ChaosCastles.Ground)
                        .Wait();
                    break;
                case EventState.Closed:
                    _mapInfo.Push();
                    SendSatus(7);
                    for (var i = 0; i < _ccMonsters.Count; i++)
                        _ccMonsters[i].Active = false;
                    break;
            }
        }

        public override void Update()
        {
            switch (CurrentState)
            {
                case EventState.Closed:
                    if((int)TimeLeft.TotalSeconds == 30)
                    {
                        Program.NoEventMapSendAsync(new SDevilSquareSet(DevilSquareState.CCBeforeEnter)).Wait();
                    }
                    break;
                case EventState.Open:
                    if (((int)TimeLeft.TotalSeconds) % 60 == 0 && (int)TimeLeft.TotalSeconds > 0)
                    {
                        Program
                            .MapAnoucement(_map, $"Chaos Castle {Index} Will start in {(int)TimeLeft.TotalMinutes} minute(s).")
                            .Wait();
                    }
                    if ((int)TimeLeft.TotalSeconds == 30)
                    {
                        _mapInfo.SendAsync(new SDevilSquareSet(DevilSquareState.CCBeforePlay)).Wait();
                    }
                    _trapStatus = 6;
                    break;
                case EventState.Playing:
                    if (!CanRun())
                    {
                        GiveRewards();
                        Trigger(EventState.Closed);
                        break;
                    }

                    if ((int)TimeLeft.TotalSeconds == 60)
                    {
                        GiveRewards();
                        break;
                    }

                    if ((int)TimeLeft.TotalSeconds == 30)
                    {
                        _mapInfo.SendAsync(new SDevilSquareSet(DevilSquareState.CCBeforeEnd)).Wait();
                    }

                    if (TimeLeft > TimeSpan.FromMinutes(1))
                        SendSatus(6);
                    break;
            }

            base.Update();
        }

        public bool CanRun()
        {
            return _players.Any(x => x.Eventer);
        }

        public override bool TryAdd(Player plr)
        {
            if (_players.Count >= 70)
                return false;

            if (plr.Character.Money < ChaosCastles.EntryFee[Index - 1])
                return false;

            plr.Character.Money -= (uint)ChaosCastles.EntryFee[Index - 1];
            _recaudation += ChaosCastles.EntryFee[Index - 1];

            _players.Add(new PlayerEventInfo
            {
                Eventer = true,
                Player = plr,
                Score = 0,
            });

            plr.Character
                .WarpTo(Index==7?272:81+Index)
                .Wait();
            plr.Character.CharacterDie += OnPlayerDead;
            plr.Character.MapChanged += OnPlayerLeave;

            return true;
        }

        private int EventCount()
        {
            return _ccMonsters.Count(x => x.Active) + _players.Count(x => x.Eventer);
        }

        private void SendSatus(byte status)
        {
            _players.Where(x => x.Eventer)
                .Select(x => x.Player.Session)
                .SendAsync(new SBloodCastleState(status, (ushort)(TimeLeft.TotalSeconds-60), 100, (ushort)EventCount(), 255, 255))
                .Wait();
        }

        private void UpdateFloor()
        {
            bool changeFloor = false;
            switch (EventCount())
            {
                case 40:
                    _floorState = ChaosCastles.Ground;
                    break;
                case 30:
                    _floorState.Inflate(new Size(4, 4));
                    changeFloor = true;
                    _trapStatus = 8;
                    break;
                case 20:
                    _floorState.Inflate(new Size(4, 4));
                    changeFloor = true;
                    _trapStatus = 9;
                    break;
                case 10:
                    _floorState.Inflate(new Size(4, 4));
                    changeFloor = true;
                    _trapStatus = 10;
                    break;
            }

            if (changeFloor)
            {
                var ground = ChaosCastles.Ground;
                var up = new Rectangle(ground.X, ground.Y, ground.Width, _floorState.Y - ground.Y);
                var down = new Rectangle(ground.X, ground.Y+up.Height+_floorState.Height, ground.Width, _floorState.Y - ground.Y);
                var left = new Rectangle(ground.X, ground.Y, _floorState.X - ground.X, ground.Height);
                var right = new Rectangle(ground.X+left.Width+_floorState.Width, ground.Y, _floorState.X - ground.X, ground.Height);

                _mapInfo.AddAttribute(MapAttributes.Hide, up).Wait();
                _mapInfo.AddAttribute(MapAttributes.Hide, down).Wait();
                _mapInfo.AddAttribute(MapAttributes.Hide, left).Wait();
                _mapInfo.AddAttribute(MapAttributes.Hide, right).Wait();
                SendSatus(_trapStatus);

                _players
                    .Where(x => x.Eventer)
                    .Where(x => !_floorState.Contains(x.Player.Character.Position))
                    .ToList()
                    .ForEach(x => x.Player.Character.Health = 0.0f);
            }
        }

        private void GiveRewards()
        {
            var playersIn = _players
                            .Where(x => x.Eventer);

            PlayerEventInfo winner = null;

            if (playersIn.Count() != 0)
            {
                winner = playersIn.OrderByDescending(x => x.Score/100*2+x.Score%100).First();
                var wXP = ChaosCastles.MonsterKillExp[Index - 1] * (winner.Score / 100);
                wXP += ChaosCastles.PlayerKillExp[Index - 1] * (winner.Score % 100);
                winner.Player.Session.SendAsync(new SBloodCastleReward()
                {
                    Winner = 1,
                    Type = 0xFE,
                    ScoreTable = new BCScore[] {
                                    new BCScore {
                                     Name = winner.Player.Character.Name,
                                     Score = winner.Score/100,
                                     Experience = wXP,
                                     Zen = winner.Score%100,
                                    }
                                }
                })
                    .Wait();

                winner.Player.Character.Experience += (long)wXP;
                winner.Player.Session.SendAsync(new SKillPlayer(0xffff, (ushort)wXP, 0)).Wait();
                winner.Player.Character.Money += (uint)(_recaudation * 0.8f);
            }

            var losers = _players.Where(x => x != winner);
            foreach (var l in losers)
            {
                if (l.Eventer)
                {
                    l.Player.Character
                        .WarpTo(22)
                        .Wait();
                }

                var XP = ChaosCastles.MonsterKillExp[Index - 1] * (winner.Score / 100);
                XP += ChaosCastles.PlayerKillExp[Index - 1] * (winner.Score % 100);

                l.Player.Session.SendAsync(new SBloodCastleReward()
                {
                    Winner = 0,
                    Type = 0xFE,
                    ScoreTable = new BCScore[] {
                                    new BCScore {
                                     Name = winner.Player.Character.Name,
                                     Score = winner.Score/100,
                                     Experience = XP,
                                     Zen = winner.Score%100,
                                    }
                                }
                })
                .Wait();

                l.Player.Character.Experience += (long)XP;
            }

            foreach (var mob in _ccMonsters)
                mob.Active = false;

            SendSatus(7);
            
            _recaudation = 0;
            Trigger(EventState.Closed, TimeSpan.FromMinutes(1));
        }
    }
}


--file ChaosCastles.cs
﻿using MU.Network.Game;
using MU.Resources;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;

namespace MuEmu.Events.ChaosCastle
{
    public class ChaosCastles : Event
    {
        private List<ChaosCastle> _castles = new List<ChaosCastle>();
        public const int MaxPlayers = 70;
        public static Rectangle Ground = new Rectangle(23, 75, 21, 33);
        public static int[] EntryFee = new int[]
        {
            25000, 80000, 150000, 250000, 400000, 650000, 1000000
        };
        public static int[] PlayerKillExp = new int[]
        {
            0x1F4, 0x3E8, 0x5DC, 0x7D0, 0x9C4, 0xBB8, 0xFA0
        };
        public static int[] MonsterKillExp = new int[]
        {
            0x3E8, 0x5DC, 0x7D0, 0x9C4, 0xBB8, 0xDAC, 0x1194
        };
        public static List<ItemNumber[]> Rewards = new List<ItemNumber[]>
        {
            new ItemNumber[] { new ItemNumber(14,13), new ItemNumber(14,14) }, //1
            new ItemNumber[] { new ItemNumber(14,22), new ItemNumber(14,16), new ItemNumber(ItemNumber.Invalid), }, //2
            new ItemNumber[] { new ItemNumber(14,22), new ItemNumber(14,16), new ItemNumber(ItemNumber.Invalid), }, //3
            new ItemNumber[] { new ItemNumber(14,22), new ItemNumber(14,16), new ItemNumber(ItemNumber.Invalid), }, //4
            new ItemNumber[] { new ItemNumber(14,22), new ItemNumber(14,16), new ItemNumber(ItemNumber.Invalid), }, //5
            new ItemNumber[] { new ItemNumber(14,22), new ItemNumber(14,16), new ItemNumber(ItemNumber.Invalid), }, //6
            new ItemNumber[] { new ItemNumber(14,22), new ItemNumber(14,16), new ItemNumber(ItemNumber.Invalid), }, //7
        };
        public ChaosCastles()
            : base(TimeSpan.FromHours(4), TimeSpan.FromMinutes(5), TimeSpan.FromMinutes(11))
        {
            _eventLevelReqs = new List<EventLevelReq>
            {
                new EventLevelReq{ Min = 15, Max = 49 },
                new EventLevelReq{ Min = 50, Max = 119 },
                new EventLevelReq{ Min = 120, Max = 179 },
                new EventLevelReq{ Min = 180, Max = 239 },
                new EventLevelReq{ Min = 240, Max = 299 },
                new EventLevelReq{ Min = 300, Max = 400 },
                new EventLevelReq{ Min = 0, Max = 0 },
            };

            for(var i = 0; i < 7; i++)
            {
                _castles.Add(new ChaosCastle(i, _closedTime, _openTime, _playingTime));
            }
        }
        public override void Initialize()
        {
            foreach (var c in _castles)
                c.Initialize();

            base.Initialize();
            Trigger(EventState.Open);
        }
        public override void NPCTalk(Player plr)
        {
            throw new NotImplementedException();
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnTransition(EventState NextState)
        {
            switch(NextState)
            {
                case EventState.Closed:
                    Trigger(EventState.Open, _closedTime);
                    break;
                case EventState.Open:
                    Program.NoEventMapAnoucement($"{nameof(ChaosCastle)} is open")
                        .Wait();
                    Trigger(EventState.Playing, _openTime);
                    foreach (var cc in _castles)
                        cc.Trigger(EventState.Open);
                    break;
                case EventState.Playing:
                    Trigger(EventState.Closed, _playingTime);
                    break;
            }
            Program.NoEventMapSendAsync(new SEventNotificationS16Kor
            {
                Active = (byte)(NextState == EventState.Open?1:0),
                EventID = EventIcon.ChaosCastle
            });
        }

        public override void Update()
        {
            switch (CurrentState)
            {
                case EventState.Open:
                    if (((int)TimeLeft.TotalSeconds) % 60 == 0 && (int)TimeLeft.TotalSeconds > 0)
                    {
                        Program
                            .NoEventMapAnoucement($"Chaos Castle Will start in {(int)TimeLeft.TotalMinutes} minute(s).")
                            .Wait();
                        Program.NoEventMapSendAsync(new SEventNotificationS16Kor
                        {
                            Active = 1,
                            EventID = EventIcon.ChaosCastle
                        });
                    }
                    break;
            }

            foreach (var cc in _castles)
            {
                cc.Update();
            }
            base.Update();
        }

        public override bool TryAdd(Player plr)
        {
            var CCnumber = GetEventNumber(plr);

            if (CCnumber == 0)
                return false;

            var item = plr.Character.Inventory.FindAllItems(new ItemNumber(13, 29)).FirstOrDefault();
            if (item == null)
                return false;

            plr.Character.Inventory
                .Delete(item)
                .Wait();

            return _castles[CCnumber - 1].TryAdd(plr);
        }
    }
}


--file Crywolf.cs
﻿using Microsoft.EntityFrameworkCore.Internal;
using MuEmu.Monsters;
using MuEmu.Network;
using MU.Network.Event;
using MU.Network.Game;
using MU.Resources;
using MuEmu.Resources;
using MuEmu.Resources.Map;
using MuEmu.Util;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.ComponentModel.Design;
using System.Drawing;
using System.Linq;
using System.Text;
using WebZen.Util;

namespace MuEmu.Events.Crywolf
{
    internal class CrywolfAltar
    {
        public enum CrywolfAltarStates
        {
            Free,
            Contracted = 1<<4,
            AttemptToContract = 2<<4,
            Broken = 3<<4,
        }

        public Monster Altar;
        public Player Elf;
        public int Left;
        public DateTime ValidContractTime;
        public Point Position;
        public bool ValidContract;
        public DateTime ActiveTime;
        public CrywolfAltarStates State => (ValidContract) ? CrywolfAltarStates.Contracted : (Elf != null) ? CrywolfAltarStates.AttemptToContract : (Left > 0) ? CrywolfAltarStates.Free : CrywolfAltarStates.Broken;
        public byte StateByte => (byte)(Left | (byte)State);
    }
    public class Crywolf : Event
    {
        public enum OccupationState
        {
            Success,
            Fail,
            Battel,
        };
        public enum CrywolfState
        {
            None,
            Notify1,
            Notify2,
            Ready,
            Start,
            End,
            EndCycle,
        };

        private DateTime _nextNotify;
        private Dictionary<int, CrywolfAltar> _altar;

        private DateTime _standBy;
        private DateTime _stage;
        private DateTime _contract;
        private DateTime _contractEnd;
        private DateTime _army;
        private DateTime _balgas;
        private DateTime _end;

        private MapInfo _mapInfo;
        private OccupationState _occupation;
        public OccupationState Occupation
        {
            get => _occupation;
            private set
            {
                if (_occupation == value)
                    return;

                _occupation = value;

                _mapInfo.SendAsync(new SCrywolfState
                {
                    Occupation = (byte)value,
                    State = (byte)_crywolfState
                }).Wait();
            }
        }
        private CrywolfState _crywolfState;
        public CrywolfState State
        {
            get => _crywolfState;
            private set
            {
                if (_crywolfState == value)
                    return;

                _logger.Information("SubState {0}->{1}", _crywolfState, value);
                _crywolfState = value;

                _mapInfo.SendAsync(new SCrywolfState
                {
                    Occupation = (byte)_occupation,
                    State = (byte)value
                }).Wait();
            }
        }

        private double _statueHPMax;
        private double _statueHP;
        private Monster _statue;
        private List<Monster> _armyList;
        private Monster _balgass;
        private List<SkillStates> _statueStates = new List<SkillStates>
        {
            0,
            SkillStates.Poison,
            SkillStates.Ice,
            SkillStates.Attack,
            SkillStates.Defense,
            SkillStates.SoulBarrier,
        };
        private Dictionary<byte, int> _scoreRank = new Dictionary<byte, int>
        {
            { 0, 1000 },
            { 1, 3000 },
            { 2, 5000 },
            { 3, 10000 },
            { 4, int.MaxValue },
        };
        private List<long> _bonusExp = new List<long>
        {
            0,
            100000,
            400000,
            600000,
            900000,
        };
        private List<int> _monsterGroups = new List<int> { 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13 };
        private List<int> _bossGroups = new List<int> { 5 };

        public Crywolf():base(TimeSpan.FromDays(6), TimeSpan.FromDays(1), TimeSpan.FromDays(1))
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(Crywolf));
            _mapInfo = ResourceCache.Instance.GetMaps()[Maps.Crywolf];
            _mapInfo.PlayerLeaves += OnPlayerLeave;
            _mapInfo.PlayerJoins += _mapInfo_PlayerJoins;
            _mapInfo.MonsterAdd += _mapInfo_MonsterAdd;
            _altar = new Dictionary<int, CrywolfAltar>
            {
                { 205, new CrywolfAltar{ Elf = null, Left = 2 } },
                { 206, new CrywolfAltar{ Elf = null, Left = 2 } },
                { 207, new CrywolfAltar{ Elf = null, Left = 2 } },
                { 208, new CrywolfAltar{ Elf = null, Left = 2 } },
                { 209, new CrywolfAltar{ Elf = null, Left = 2 } },
            };

            _armyList = new List<Monster>();
        }

        private void _mapInfo_MonsterAdd(object sender, EventArgs e)
        {
            var mob = sender as Monster;
            if(mob.Info.Monster == 204)
            {
                _statue = mob;
            }else
            if(mob.Info.Monster >= 205 && mob.Info.Monster <= 209)
            {
                _altar[mob.Info.Monster].Altar = mob;
            }else
            {
                switch (mob.Info.Monster)
                {
                    case 349://Balgass
                    case 340://Dark Elf
                    case 348://Ballista
                    case 341://Soram
                    case 344://Balram
                    case 345://Death Spirit
                        mob.Die += OnMonsterDead;
                        mob.Active = false;
                        _armyList.Add(mob);
                        if (mob.Info.Monster == 349)
                            _balgass = mob;
                        break;
                }
            }
        }

        internal async void SendBenefit(GSSession session)
        {
            await session.SendAsync(new SCrywolfBenefit(0));
        }

        internal async void SendState(GSSession session)
        {
            await session.SendAsync(new SCrywolfState {
                Occupation = (byte)_occupation,
                State = (byte)_crywolfState
            });
        }

        private void _mapInfo_PlayerJoins(object sender, EventArgs e)
        {
            if(CurrentState == EventState.Open)
                _players.Add(new PlayerEventInfo
                {
                    Eventer = false,
                    Player = (sender as Player),
                    Score = 0,
                });
        }

        public override void Initialize()
        {
            base.Initialize();
            Trigger(EventState.Closed);
        }

        public override void Update()
        {
            base.Update();
            if (State >= CrywolfState.Ready)
            {
                var hp = 0.0;
                var changed = false;
                foreach (var a in _altar.Values)
                {
                    if (a.Elf != null && !a.ValidContract && a.ValidContractTime <= DateTime.Now)
                    {
                        a.ValidContract = true;
                        a.Elf.Character.Spells.SetBuff(SkillStates.AltarValidContract, TimeSpan.FromDays(1));
                        var altar = a.Altar.Info.Monster - 204;
                        a.Elf.Session.SendAsync(new SNotice(NoticeType.Blue, $"You contracted {altar} Altar Successfuly")).Wait();
                        Program.GlobalAnoucement($"{a.Elf.Character.Name} contracted Altar Nr. {altar}").Wait();
                        a.Altar.Spells.ClearAll();
                        a.Altar.Spells.SetBuff(SkillStates.AltarValidContract, TimeSpan.FromDays(1));
                        changed = true;
                    }

                    if (a.ValidContract)
                    {
                        hp += a.Elf.Character.Health;
                    }

                    if (a.Elf != null && a.Position != a.Elf.Character.Position)
                    {
                        OnPlayerLeave(a.Elf, new EventArgs());
                    }
                }

                if (_statue != null && changed)
                {
                    _statue.Spells.ClearAll();
                    _statue.Spells.SetBuff(
                        _statueStates[_altar.Values.Count(x => x.ValidContract)],
                        TimeSpan.FromDays(1),
                        _altar.Values
                            .Select(x => x.Elf)
                            .FirstOrDefault(x => x != null)?.Character ?? null
                        );
                }
                _statueHP = hp;
            }

            switch (CurrentState)
            {
                case EventState.None:
                    break;
                case EventState.Closed:
                    {
                        State = CrywolfState.None;
                        if(_standBy <= DateTime.Now)
                        {
                            Trigger(EventState.Open);
                        }
                    }
                    break;
                case EventState.Open:
                    { 
                        switch (State)
                        {
                            case CrywolfState.Notify1:
                                if (_nextNotify <= DateTime.Now)
                                {
                                    Program.GlobalAnoucement("[Crywolf] La estatua perdio su proteccion").Wait();
                                    _nextNotify = DateTime.Now.AddSeconds(70);
                                }
                                if (_stage <= DateTime.Now)
                                    State = CrywolfState.Notify2;
                                break;
                            case CrywolfState.Notify2:
                            case CrywolfState.Ready:
                                if (_nextNotify <= DateTime.Now)
                                {
                                    var left = _army - DateTime.Now;
                                    if (Math.Floor(left.TotalMinutes) <= 1)
                                    {
                                        Program.GlobalAnoucement($"[Crywolf] El ejercito de balgass atacara en {(int)left.TotalSeconds}seg").Wait();
                                    }
                                    else
                                    {
                                        Program.GlobalAnoucement($"[Crywolf] El ejercito de balgass atacara en {(int)left.TotalMinutes}min").Wait();
                                    }
                                    _nextNotify = DateTime.Now.AddSeconds(70);
                                }
                                if (_contract <= DateTime.Now && State != CrywolfState.Ready)
                                {
                                    State = CrywolfState.Ready;
                                    _mapInfo.SendAsync(new SCrywolfStatueAndAltarInfo
                                    {
                                        AltarState = _altar.Values.Select(x => x.StateByte).ToArray(),
                                        StatueHP = (int)(_statueHPMax > 0 ? _statueHP / _statueHPMax : 0.0),
                                    }).Wait();
                                    _monsterGroups.ForEach(x => MonsterIA.InitGroup(x));
                                }

                                if(State == CrywolfState.Ready)
                                {
                                    _mapInfo.SendAsync(new SCrywolfStatueAndAltarInfo
                                    {
                                        AltarState = _altar.Values.Select(x => x.StateByte).ToArray(),
                                        StatueHP = (int)(_statueHPMax > 0 ? _statueHP / _statueHPMax : 0.0),
                                    }).Wait();
                                }

                                if(_army <= DateTime.Now)
                                    Trigger(EventState.Playing);
                                break;
                        }
                    }
                    break;
                case EventState.Playing:
                    {
                        if (_nextNotify <= DateTime.Now)
                        {
                            //20s
                            _mapInfo.SendAsync(new SCrywolfLeftTime { TimeLeft = _end - DateTime.Now }).Wait();
                            //2s
                            _mapInfo.SendAsync(new SCrywolfStatueAndAltarInfo
                            {
                                AltarState = _altar.Values.Select(x => x.StateByte).ToArray(),
                                StatueHP = (int)(_statueHPMax > 0 ? _statueHP / _statueHPMax : 0.0),
                            }).Wait();
                            //5s
                            _mapInfo.SendAsync(new SCrywolfBossMonsterInfo
                            {
                                Monster = (byte)_armyList.Count(x => x.Active && x.Info.Monster == 340),
                                MonsterHP = (int)((_balgass?.Active??false) ? _balgass.Life / (_balgass.MaxLife + 1) : -1.0),
                            }).Wait();

                            if (_balgass != null && !_balgass.Active && _balgas <= DateTime.Now)
                            {
                                _bossGroups.ForEach(x => MonsterIA.InitGroup(x));
                            }

                            _nextNotify = DateTime.Now.AddSeconds(2);
                        }

                        if (_altar.Values.Count(x => x.ValidContract) <= 0)
                            Close(OccupationState.Fail);

                        if (_end <= DateTime.Now)
                            Close(OccupationState.Success);
                    }
                    break;
            }
        }

        public override void NPCTalk(Player plr)
        {
            var mob = plr.Window as Monster;
            if(
                mob.Info.Monster >= 205 && mob.Info.Monster <= 209 &&
                _contract <= DateTime.Now && _contractEnd >= DateTime.Now
                )
            {
                var a = _altar[mob.Info.Monster];
                if (a.Elf == null && a.Left > 0 && a.ActiveTime <= DateTime.Now)
                {
                    a.ValidContractTime = DateTime.Now.AddSeconds(5);
                    a.Elf = plr;
                    a.Left--;
                    a.Altar.Spells.ClearAll();
                    a.Altar.Spells.SetBuff(SkillStates.AltarOfWolfCA, TimeSpan.FromDays(1));
                    a.Elf.Character.Spells.SetBuff(SkillStates.AltarOfWolfCA, TimeSpan.FromSeconds(5));
                    a.Position = a.Elf.Character.Position;

                    _statueHP += plr.Character.Health;
                    _statueHPMax += plr.Character.MaxHealth;

                    _logger.ForAccount(plr.Session).Information("[Altar Op.] Attempt to contract Altar[{0}]", mob.Info.Monster-204);
                }
            }
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            var mob = sender as Monster;
            mob.Active = false;
            var killer = _players.Find(x => x.Player == mob.Killer);
            if(killer == null)
            {
                killer = new PlayerEventInfo
                {
                    Player = mob.Killer
                };
                _players.Add(killer);
            }    
            switch(mob.Info.Monster)
            {
                case 349://Balgass
                    killer.Score += 7000;
                    Close(OccupationState.Success);
                    break;
                case 340://Dark Elf
                    killer.Score += 3000; 
                    break;
                case 348://Ballista
                    killer.Score += 1000;
                    break;
                case 341://Soram
                    killer.Score += 700;
                    break;
                case 344://Balram
                    killer.Score += 600;
                    break;
                case 345://Death Spirit
                    killer.Score += 600;
                    break;
            }
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            var @char = sender as Character;

            if (@char == null)
                return;

            var result = _altar.Values.FirstOrDefault(x => x.Elf == @char.Player);
            if (result == null)
                return;

            var sp = result.Altar.Spells;
            sp.ClearAll();
            if (result.Left > 0)
            {
                sp.SetBuff(SkillStates.AltarCanContract, TimeSpan.FromDays(1));
            }else
            {
                sp.SetBuff(SkillStates.AltarCantContract, TimeSpan.FromDays(1));
            }

            result.ActiveTime = DateTime.Now.AddSeconds(10);
            result.ValidContract = false;
            result.Elf.Character.Spells.ClearAll();
            result.Elf = null;

            double _StatueHP = 0;
            double _StatueHPMax = 0;
            foreach(var a in _altar.Values.Where(x => x.Elf != null))
            {
                _StatueHP += a.Elf.Character.Health;
                _StatueHPMax += a.Elf.Character.MaxHealth;
            }

            _statueHP = _StatueHP;
            _statueHPMax = _StatueHPMax;

            _logger.ForAccount(@char.Player.Session).Information("[Altar Op.] Remove contract Altar[{0}]", result.Altar.Info.Monster - 204);

            if (_statue != null)
            {
                _statue.Spells.ClearAll();
                _statue.Spells.SetBuff(_statueStates[_altar.Values.Count(x => x.ValidContract)], TimeSpan.FromDays(1));
            }
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            OnPlayerDead((sender as Player).Character, eventArgs);
        }

        public override void OnTransition(EventState NextState)
        {
            _mapInfo.SendAsync(new SCrywolfState
            {
                Occupation = (byte)_occupation,
                State = (byte)_crywolfState,
            }).Wait();

            switch (NextState)
            {
                case EventState.None:
                    State = CrywolfState.None;
                    break;
                case EventState.Closed:
                    {
                        _monsterGroups.ForEach(x => MonsterIA.DelGroup(x));
                        _bossGroups.ForEach(x => MonsterIA.DelGroup(x));
                        foreach (var a in _altar.Values)
                        {
                            a.Left = 2;
                            if (a.Altar != null)
                            {
                                a.Altar.Spells.ClearAll();
                            }
                            else
                            {
                                Trigger(EventState.None);
                            }
                        }

                        State = CrywolfState.None;
                        var eventDay = DateTime.Now.AddDays(-(int)DateTime.Today.DayOfWeek + (int)DayOfWeek.Wednesday);
                        if (eventDay < DateTime.Now)
                            eventDay = eventDay.AddDays(7);

                        _standBy = new DateTime(eventDay.Year, eventDay.Month, eventDay.Day, 09, 24, 00);
                        _stage = _standBy.AddMinutes(16);
                        _contract = _stage.AddMinutes(5);
                        _contractEnd = _contract.AddMinutes(2.5);
                        _army = _contract.AddMinutes(5);
                        _balgas = _army.AddMinutes(5);
                        _end = _balgas.AddMinutes(5);

                        _logger.Information("Start at {0}", _standBy);
                        _players.Clear();
                    }
                    break;
                case EventState.Open:
                    State = CrywolfState.Notify1;
                    foreach(var a in _altar.Values)
                    {
                        a.Altar.Spells.ClearAll();
                        a.Altar.Spells.SetBuff(SkillStates.AltarCanContract, TimeSpan.FromDays(1));
                    }
                    break;
                case EventState.Playing:
                    State = CrywolfState.Start;
                    foreach (var m in _armyList)
                    {
                        m.Active = true;
                    }
                    break;
            }
        }

        public override bool TryAdd(Player plr)
        {
            throw new NotImplementedException();
        }

        private void SendRank()
        {
            var orderList = _players
                .OrderByDescending(x => x.Score)
                .Where(x => x.Player.Status == LoginStatus.Playing && !_altar.Values.Any(y => y.Elf == x.Player))
                .ToList();

            var dto = new List<CrywolfHeroDto>();

            var count = 5;
            foreach(var plr in orderList)
            {
                var rank = _scoreRank.First(x => x.Value > plr.Score).Key;
                var exp = _bonusExp[rank];

                if (_occupation == OccupationState.Fail)
                    exp = (long)(exp * 0.1f);

                var @char = plr.Player.Character;
                @char.Experience += exp;
                plr.Player.Session
                    .SendAsync(new SKillPlayer(0xffff, (ushort)exp, 0))
                    .Wait();

                dto.Add(new CrywolfHeroDto
                {
                    Rank = rank,
                    Score = plr.Score,
                    Class = @char.Class,
                    btName = @char.Name.GetBytes()
                });

                if(count-- > 0 && Occupation == OccupationState.Success)
                {
                    _mapInfo.AddItem(
                        @char.Position.X,
                        @char.Position.Y,
                        new Item(ItemNumber.FromTypeIndex(14, 13)),// Jewel of Bless
                        @char
                        );
                }
            }

            orderList
                .Select(x => x.Player.Session)
                .SendAsync(new SCrywolfHeroList { Heros = dto.ToArray() })
                .Wait();

            _players.Clear();
            if(Occupation == OccupationState.Success)
            {
                foreach(var a in _altar.Values.Where(x => x.Elf!=null && x.ValidContract))
                {
                    var @char = a.Elf.Character;
                    _mapInfo.AddItem(
                        @char.Position.X,
                        @char.Position.Y,
                        new Item(ItemNumber.FromTypeIndex(14, 13)),// Jewel of Bless
                        @char
                        );                    
                }
            }
        }

        private void Close(OccupationState state)
        {
            Occupation = state;
            State = CrywolfState.End;
            SendRank();
            Trigger(EventState.Closed);
        }
    }
}


--file DevilSquare.cs
﻿using MuEmu.Monsters;
using MU.Network.Event;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using MU.Resources;

namespace MuEmu.Events.DevilSquare
{
    public class DevilSquare : Event
    {
        private ushort _gate;
        private List<List<Monster>> _ground = new List<List<Monster>>();
        private DevilSquares _manager;
        public int Index { get; private set; }

        public DevilSquare(DevilSquares dsManager, int DSindex, TimeSpan close, TimeSpan open, TimeSpan playing, ushort gate) : base(close, open, playing)
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(DevilSquare) +" "+ DSindex);
            Index = DSindex;
            _gate = gate;
            _manager = dsManager;
            var ground = dsManager._dsGround[DSindex - 1];
            var rand = new Random();

            for (var i = 0; i < 7; i++)
            {
                var type = dsManager._mobGround[Index - 1, i];
                var subList = new List<Monster>();
                for (var n = 0; n < 40; n++)
                {
                    var x = rand.Next(ground.Left, ground.Right);
                    var y = rand.Next(ground.Top, ground.Bottom);
                    var mob = MonstersMng.Instance.CreateMonster(type, ObjectType.Monster, Index <= 4 ? Maps.DevilSquare : Maps.DevilSquare2, new Point(x, y), (byte)rand.Next(7));
                    mob.Die += OnMonsterDead;
                    subList.Add(mob);
                    mob.Active = false;
                }
                _ground.Add(subList);
            }
        }
        public override void NPCTalk(Player plr)
        {
            throw new NotImplementedException();
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            var mob = sender as Monster;
            var score = mob.DamageSum[mob.Killer] / mob.MaxLife * mob.Level;
            score *= Index;
            var pInfo = _players.Find(x => x.Player == mob.Killer);
            pInfo.Score += (int)score;

            //_logger.Debug("Monster Dead: {0} {1} {2}", mob.Info.Name, mob.Info.Level, score);
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            var @char = sender as Character;
            var plr = @char.Player;

            var eventInfo = _players.Find(x => x.Player == plr);
            eventInfo.Eventer = false;

            @char.WarpTo(27).Wait();

            if (!_players.Any(x => x.Eventer))
                Trigger(EventState.Closed);
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            var @char = sender as Character;
            var plr = @char.Player;

            var eventInfo = _players.Find(x => x.Player == plr);
            eventInfo.Eventer = false;

            if (!_players.Any(x => x.Eventer))
                Trigger(EventState.Closed);
        }

        public override void OnTransition(EventState NextState)
        {
            switch (NextState)
            {
                case EventState.Closed:
                    foreach(var list in _ground)
                    {
                        foreach(var monster in list)
                        {
                            monster.Active = false;
                        }
                    }
                    var ranking = _players
                        .OrderByDescending(x => x.Score)
                        .Select((x,i) => new DevilSquareScoreInfo
                        {
                            rank = (byte)(i+1),
                            player = x.Player,
                            Name = x.Player.Character.Name,
                            TotalScore = x.Score,
                            BonusExp = 0,
                            BonusZen = 0,
                        }).ToList();

                    foreach(var r in ranking)
                    {
                        var a = r.rank * 100.0f / _players.Count;
                        if(r.BonusExp == 1)
                        {
                            r.BonusExp = _manager._rewards[Index - 1][0].EXP;
                            r.BonusZen = _manager._rewards[Index - 1][0].Zen;
                        }else if(a < 0.3f)
                        {
                            r.BonusExp = _manager._rewards[Index - 1][1].EXP;
                            r.BonusZen = _manager._rewards[Index - 1][1].Zen;
                        }
                        else if (a < 0.5f)
                        {
                            r.BonusExp = _manager._rewards[Index - 1][2].EXP;
                            r.BonusZen = _manager._rewards[Index - 1][2].Zen;
                        }
                        else if (a < 0.5f)
                        {
                            r.BonusExp = _manager._rewards[Index - 1][3].EXP;
                            r.BonusZen = _manager._rewards[Index - 1][3].Zen;
                        }
                    }

                    foreach(var p in ranking)
                    {
                        var score = new SDevilSquareResult
                        {
                            MyRank = p.rank,
                            Score = ranking.ToArray()
                        };
                        (p.player as Player).Session.SendAsync(score).Wait();
                    }

                    _players.Clear();
                    break;
                case EventState.Open:
                    Trigger(EventState.Playing, _openTime);
                    break;
                case EventState.Playing:
                    if (_players.Any(x => x.Eventer))
                    {
                        SpawList(0);
                        Trigger(EventState.Closed, _playingTime);
                    }else
                    {
                        Trigger(EventState.Closed);
                    }
                    break;
            }
        }

        public override void Update()
        {
            switch(CurrentState)
            {
                case EventState.Playing:
                    break;
            }
            base.Update();
        }

        internal void SpawList(int number)
        {
            foreach (var monster in _ground[number])
            {
                monster.State = ObjectState.WaitRegen;
                monster.Active = true;
            }
        }

        public override bool TryAdd(Player plr)
        {
            if (_players.Count < DevilSquares.MaxPlayers)
            {
                _players.Add(new PlayerEventInfo { Eventer = true, Player = plr, Score = 0 });
                plr.Character.WarpTo(_gate).Wait();
                plr.Character.CharacterDie += OnPlayerDead;
                plr.Character.MapChanged += OnPlayerLeave;

                return true;
            }

            return false;
        }
    }
}


--file DevilSquares.cs
﻿using MuEmu.Monsters;
using MU.Network.Event;
using MU.Network.Game;
using MU.Resources;
using MuEmu.Resources.Map;
using MuEmu.Util;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using MuEmu.Resources;

namespace MuEmu.Events.DevilSquare
{
    public class DevilSquares : Event
    {
        private struct DevilSquareLevels
        {
            public int Normal;
            public int Special;
        }

        internal struct DevilSquareRewards
        {
            public int EXP { get; set; }
            public int Zen { get; set; }
        }

        private readonly ItemNumber r_devilInvitation = new ItemNumber(14, 19);
        private readonly DevilSquareLevels[] r_levels = new DevilSquareLevels[]
        {
            new DevilSquareLevels{ Normal = 15, Special = 10 },
            new DevilSquareLevels{ Normal = 131, Special = 111 },
            new DevilSquareLevels{ Normal = 181, Special = 161 },
            new DevilSquareLevels{ Normal = 231, Special = 211 },
            new DevilSquareLevels{ Normal = 281, Special = 261 },
            new DevilSquareLevels{ Normal = 331, Special = 311 },
            new DevilSquareLevels{ Normal = 401, Special = 401 }
        };
        internal readonly Rectangle[] _dsGround = new Rectangle[]
        {
            new Rectangle(119, 80, 31, 35),
            new Rectangle(121, 152, 31, 35),
            new Rectangle(49, 138, 31, 35),
            new Rectangle(53, 74, 31, 35),
            new Rectangle(120, 80, 31, 35),
            new Rectangle(122, 152, 31, 35),
            new Rectangle(49, 138, 31, 35),
        };
        internal readonly ushort[,] _mobGround = new ushort[7,7]
        {
            { 17, 15, 5, 13, 8, 36, 18 },
            { 10, 39, 34, 41, 40, 35, 49 },
            { 41, 37, 35, 180, 64, 65, 67 },
            { 64, 65, 60, 294, 57, 70, 66 },
            { 60, 294, 71, 144, 61, 73, 291 },
            { 290, 57, 70, 293, 74, 292, 275 },
            { 356, 510, 409, 411, 358, 360, 340 },
        };
        internal readonly List<DevilSquareRewards[]> _rewards = new List<DevilSquareRewards[]>
        {
            new DevilSquareRewards[]{
                new DevilSquareRewards{ EXP = 6000, Zen =  30000 },
                new DevilSquareRewards{ EXP = 4000, Zen =  25000 },
                new DevilSquareRewards{ EXP = 2000, Zen =  20000 },
                new DevilSquareRewards{ EXP = 1000, Zen =  15000 }
            },
            new DevilSquareRewards[]{
                new DevilSquareRewards{ EXP = 8000, Zen =  40000 },
                new DevilSquareRewards{ EXP = 6000, Zen =  35000 },
                new DevilSquareRewards{ EXP = 4000, Zen =  30000 },
                new DevilSquareRewards{ EXP = 2000, Zen =  25000 }
            },
            new DevilSquareRewards[]{
                new DevilSquareRewards{ EXP =10000, Zen =  50000 },
                new DevilSquareRewards{ EXP = 8000, Zen =  45000 },
                new DevilSquareRewards{ EXP = 6000, Zen =  40000 },
                new DevilSquareRewards{ EXP = 4000, Zen =  35000 }
            },
            new DevilSquareRewards[]{
                new DevilSquareRewards{ EXP =20000, Zen =  60000 },
                new DevilSquareRewards{ EXP =10000, Zen =  55000 },
                new DevilSquareRewards{ EXP = 8000, Zen =  50000 },
                new DevilSquareRewards{ EXP = 6000, Zen =  45000 }
            },
            new DevilSquareRewards[]{
                new DevilSquareRewards{ EXP =22000, Zen =  70000 },
                new DevilSquareRewards{ EXP =20000, Zen =  65000 },
                new DevilSquareRewards{ EXP =10000, Zen =  60000 },
                new DevilSquareRewards{ EXP = 8000, Zen =  55000 }
            },
            new DevilSquareRewards[]{
                new DevilSquareRewards{ EXP =24000, Zen =  80000 },
                new DevilSquareRewards{ EXP =22000, Zen =  75000 },
                new DevilSquareRewards{ EXP =20000, Zen =  70000 },
                new DevilSquareRewards{ EXP =10000, Zen =  65000 }
            },
            new DevilSquareRewards[]{
                new DevilSquareRewards{ EXP =26000, Zen =  90000 },
                new DevilSquareRewards{ EXP =24000, Zen =  85000 },
                new DevilSquareRewards{ EXP =22000, Zen =  80000 },
                new DevilSquareRewards{ EXP =20000, Zen =  75000 }
            },
        };

        private DevilSquare[] _devilSquares;
        private DateTimeOffset _nextSpawn;
        private int _nextSpawnNumber;
        private DateTimeOffset _nextMessage = DateTimeOffset.Now;
        internal IEnumerable<MapInfo> _maps;

        public const int MaxPlayers = 10;
        private const int ClosedTime = 17;
        private const int OpenedTime = 2;
        private const int PlayingTime = 5;

        public DevilSquares() : 
            this(TimeSpan.FromMinutes(ClosedTime), TimeSpan.FromMinutes(OpenedTime), TimeSpan.FromMinutes(PlayingTime))
        {
        }
        public DevilSquares(TimeSpan close, TimeSpan open, TimeSpan playing) : base(close, open, playing)
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(DevilSquares));

            _devilSquares = new DevilSquare[7]
            {
                new DevilSquare(this, 1, close+playing, open, playing, 58),
                new DevilSquare(this, 2, close+playing, open, playing, 59),
                new DevilSquare(this, 3, close+playing, open, playing, 60),
                new DevilSquare(this, 4, close+playing, open, playing, 61),
                new DevilSquare(this, 5, close+playing, open, playing, 111),
                new DevilSquare(this, 6, close+playing, open, playing, 112),
                new DevilSquare(this, 7, close+playing, open, playing, 270),
            };

            _maps = Resources.ResourceCache.Instance.GetMaps()
                .Where(x => x.Key == Maps.DevilSquare || x.Key == Maps.DevilSquare2)
                .Select(x => x.Value);

            foreach(var map in _maps)
            {
                map.MonsterAdd += OnMonsterAdd;
            }
        }

        public override void Initialize()
        {
            Trigger(EventState.Open);
        }

        public override void NPCTalk(Player plr)
        {
            if(CurrentState != EventState.Open)
            {
                plr.Session.SendAsync(new SCommand(ServerCommandType.EventMsg, (byte)EventMsg.DevilStarted))
                    .Wait();
                return;
            }

            var res = plr.Character.Inventory.FindAllItems(r_devilInvitation);

            //var DSNumber = GetPlayerDS(plr);

            if (!res.Any(/*x => x.Plus == DSNumber*/))
            {
                plr.Session.SendAsync(new SCommand(ServerCommandType.EventMsg, (byte)EventMsg.YouNeedInvitationDS))
                    .Wait();
                return;
            }

            plr.Session.SendAsync(new STalk { Result = NPCWindow.DevilSquared })
                .Wait();
        }

        public override void OnTransition(EventState nextState)
        {
            var ns = nextState;
            switch(ns)
            {
                case EventState.Closed:
                    Trigger(EventState.Open, _closedTime);
                    break;
                case EventState.Open:
                    Trigger(EventState.Playing, _openTime);
                    foreach (var ds in _devilSquares)
                        ds.Trigger(EventState.Open);
                    break;
                case EventState.Playing:
                    _nextSpawnNumber = 0;
                    _nextSpawn = DateTimeOffset.Now.Add(_playingTime / 7);
                    Trigger(EventState.Closed, _playingTime);
                    break;
            }
        }

        public override void Update()
        {
            switch (CurrentState)
            {
                case EventState.Closed:
                    if (TimeLeft.TotalMinutes <= 16 && ((int)TimeLeft.TotalMinutes) % 5 == 0 && _nextMessage < DateTimeOffset.Now)
                    {
                        _nextMessage = DateTimeOffset.Now.AddMinutes(4);
                        Program.NoEventMapAnoucement(ServerMessages.GetMessage(Messages.DS_Closed, (int)TimeLeft.TotalMinutes))
                            .Wait();
                    }
                    if((int)TimeLeft.TotalSeconds == 30)
                    {
                        Program.server.Clients
                            .Where(x => x.Player.Status == LoginStatus.Playing)
                            .SendAsync(new SDevilSquareSet(DevilSquareState.Close))
                            .Wait();
                    }
                    break;
                case EventState.Open:
                    if((int)TimeLeft.TotalSeconds == 30)
                    {
                        Program.server.Clients
                            .Where(x => x.Player.Status == LoginStatus.Playing)
                            .SendAsync(new SDevilSquareSet(DevilSquareState.Open))
                            .Wait();
                    }
                    break;
                case EventState.Playing:
                    if(DateTimeOffset.Now >= _nextSpawn)
                    {
                        _nextSpawn = DateTimeOffset.Now.Add(_playingTime / 7);
                        _nextSpawnNumber++;
                        foreach (var ds in _devilSquares)
                        {
                            ds.SpawList(_nextSpawnNumber);
                        }
                    }

                    if ((int)TimeLeft.TotalSeconds == 30)
                    {
                        Resources.ResourceCache.Instance.GetMaps()
                            .Where(x => x.Key == Maps.DevilSquare || x.Key == Maps.DevilSquare2)
                            .SelectMany(y => y.Value.Players)
                            .Select(z => z.Player.Session)
                            .SendAsync(new SDevilSquareSet(DevilSquareState.Playing))
                            .Wait();
                    }
                    break;
            }
            foreach (var ds in _devilSquares)
            {
                ds.Update();
            }
            base.Update();
        }

        public int GetPlayerDS(Player plr)
        {
            int DSNumber = -1;
            if (plr.Character.MasterClass)
                DSNumber = 7;
            else
                for (var i = 0; i < 6; i++)
                {
                    if (plr.Character.BaseClass == HeroClass.MagicGladiator || plr.Character.BaseClass == HeroClass.DarkLord)
                    {
                        if (r_levels[i].Special <= plr.Character.Level && 
                            r_levels[i + 1].Special > plr.Character.Level)
                        {
                            DSNumber = i + 1;
                            break;
                        }
                    }
                    else
                    {
                        if (r_levels[i].Normal <= plr.Character.Level &&
                            r_levels[i + 1].Normal > plr.Character.Level)
                        {
                            DSNumber = i + 1;
                            break;
                        }
                    }
                }

            return DSNumber;
        }

        public override bool TryAdd(Player plr)
        {
            var DSNumber = GetPlayerDS(plr);
            var ds = _devilSquares[DSNumber - 1];
            return ds.TryAdd(plr);
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public void OnMonsterAdd(object sender, EventArgs eventArgs)
        {
            var mob = sender as Monster;
            mob.Active = false;
        }
    }
}


--file DoubleGoer.cs
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;

namespace MuEmu.Events.DoubleGoer
{
    public class DoubleGoer : Event
    {
        private List<Point> _player;
        private List<Point> _monster;

        public DoubleGoer()
            :base(TimeSpan.Zero, TimeSpan.FromDays(100), TimeSpan.FromMinutes(10))
        {
            _player = new List<Point>
            {
                new Point{ X = 197, Y = 30 },
                new Point{ X = 133, Y = 68 },
                new Point{ X = 110, Y = 60 },
                new Point{ X = 95, Y = 15 },
            };

            _monster = new List<Point>
            {
                new Point{ X = 224, Y = 100 },
                new Point{ X = 113, Y = 180 },
                new Point{ X = 110, Y = 150 },
                new Point{ X = 43, Y = 108 },
            };
        }

        public override void Initialize()
        {
            base.Initialize();
        }
        public override void NPCTalk(Player plr)
        {
            throw new NotImplementedException();
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnTransition(EventState NextState)
        {
            throw new NotImplementedException();
        }

        public override bool TryAdd(Player plr)
        {
            throw new NotImplementedException();
        }

        public override void Update()
        {
            base.Update();
            switch(CurrentState)
            {
                case EventState.Open:
                    if (_players.Count > 0)
                        Trigger(EventState.Playing);
                    break;
                case EventState.Playing:
                    if (_players.Count <= 0)
                        Trigger(EventState.Closed);


                    break;
            }
        }
    }
}


--file EventEgg.cs
﻿using MU.Network.Event;
using MU.Resources;
using MuEmu.Monsters;
using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Serilog;
using Serilog.Core;

namespace MuEmu.Events.Event_Egg
{
    public class EventEgg : Event
    {
        private IEnumerable<Monster> _monsters;
        private List<TimeSpan> _spans = new List<TimeSpan>
        {
            TimeSpan.FromMinutes(1),//00:01
            TimeSpan.FromMinutes(20),
            TimeSpan.FromMinutes(40),

            TimeSpan.FromMinutes(780),//13:00
            TimeSpan.FromMinutes(800),
            TimeSpan.FromMinutes(820),

            TimeSpan.FromMinutes(1260),//21:00
            TimeSpan.FromMinutes(1280),
            TimeSpan.FromMinutes(1300),

            TimeSpan.FromMinutes(1320),//22:00
            TimeSpan.FromMinutes(1340),
            TimeSpan.FromMinutes(1360),

            TimeSpan.FromMinutes(1380),//23:00
            TimeSpan.FromMinutes(1400),
            TimeSpan.FromMinutes(1420),
        };

        public EventEgg()
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(EventEgg));
        }

        public override void Initialize()
        {
            base.Initialize();
            Trigger(EventState.Open);
            Program.server.Connect += Server_Connect;
        }

        private void Server_Connect(object sender, Network.WZServerEventArgs e)
        {
            e.session.Player.OnStatusChange += Player_OnStatusChange;
        }

        private void Player_OnStatusChange(object sender, EventArgs e)
        {
            var plr = sender as Player;
            if(plr.Status == LoginStatus.Playing && CurrentState != EventState.None)
            {
                _ = plr.Session.SendAsync(new SSendBanner { Type = BannerType.EvenInven });
            }
            if(plr.Status == LoginStatus.NotLogged)
            {
                plr.OnStatusChange -= Player_OnStatusChange;
            }
        }

        public override void NPCTalk(Player plr)
        {
            throw new NotImplementedException();
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            var mob = sender as Monster;
            mob.Active = false;
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        private TimeSpan GetTimeToNextSpaw()
        {
            var currentTime = DateTime.Now - DateTime.Today;
            try
            {
                var nextTime = _spans.First(x => x > currentTime);
                return DateTime.Today.Add(nextTime) - DateTime.Now;
            }catch(Exception)
            {
                return DateTime.Today.Add(_spans.First()) - DateTime.Now;
            }
        }

        public override void OnTransition(EventState NextState)
        {
            switch(NextState)
            {
                case EventState.Open:
                    _monsters = from mob in MonstersMng.Instance.Monsters
                                where mob.Info.Monster == 674 || mob.Info.Monster == 675 || mob.Info.Monster == 676
                                select mob;
                    foreach(var mob in _monsters)
                    {
                        mob.Die += OnMonsterDead;
                    }
                    Trigger(EventState.Playing, GetTimeToNextSpaw());
                    break;
                case EventState.Playing:
                    {
                        foreach(var mob in _monsters)
                        {
                            mob.Active = true;
                        }
                        Trigger(EventState.Closed, TimeSpan.FromMinutes(19));
                    }
                    break;
                case EventState.Closed:
                    Trigger(EventState.Playing, GetTimeToNextSpaw());
                    break;
            }
        }

        public override bool TryAdd(Player plr)
        {
            throw new NotImplementedException();
        }
    }
}


--file Event.cs
﻿using MU.Resources;
using MuEmu.Util;
using Serilog;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu.Events
{
    public enum EventState
    {
        None,
        Closed,
        Open,
        Playing,
    }
    public class PlayerEventInfo
    {
        public Player Player { get; set; }
        public int Score { get; set; }
        public bool Eventer { get; set; }
    }
    public class EventLevelReq
    {
        public int Min { get; set; }
        public int Max { get; set; }
    }
    public abstract class Event : StateMachine<EventState>
    {
        //protected ILogger _logger;
        protected TimeSpan _closedTime = TimeSpan.FromMinutes(2 * 60);
        protected TimeSpan _openTime = TimeSpan.FromMinutes(5);
        protected TimeSpan _playingTime = TimeSpan.FromMinutes(15);
        protected List<PlayerEventInfo> _players = new List<PlayerEventInfo>();
        protected List<EventLevelReq> _eventLevelReqs;
        protected Random _random = new Random();

        public byte RemainTime { get
            {
                switch(CurrentState)
                {
                    case EventState.Closed:
                        return (byte)TimeLeft.TotalMinutes;
                    case EventState.Open:
                        return 0;
                    case EventState.Playing:
                        return (byte)Math.Min((TimeLeft.TotalMinutes + _closedTime.TotalMinutes),255);
                }

                return 0;
            }
        }

        public byte Count => (byte)_players.Count(x => x.Eventer);
        public Event()
        { }

        public Event(TimeSpan close, TimeSpan open, TimeSpan playing)
        {
            _closedTime = close;
            _openTime = open;
            _playingTime = playing;
        }

        public override void Initialize()
        {
            _closedTime -= _openTime + _playingTime;
            Trigger(EventState.Closed);
        }
        public abstract void NPCTalk(Player plr);
        public abstract bool TryAdd(Player plr);
        public abstract void OnPlayerDead(object sender, EventArgs eventArgs);
        public abstract void OnPlayerLeave(object sender, EventArgs eventArgs);
        public abstract void OnMonsterDead(object sender, EventArgs eventArgs);

        public int GetEventNumber(Player plr)
        {
            var lvl = plr.Character.Level;
            if (plr.Character.MasterClass)
                return _eventLevelReqs.Count;

            if (plr.Character.BaseClass == HeroClass.MagicGladiator || plr.Character.BaseClass == HeroClass.DarkLord)
            {
                lvl = (ushort)(lvl * 3.0f / 2.0f);
                lvl = Math.Min(lvl, (ushort)400);
            }

            return _eventLevelReqs.FindIndex(x => x.Min <= lvl && x.Max >= lvl)+1;
        }

        public virtual Item GetItem(ushort mobLevel, Maps map)
        {
            return null;
        }
        public virtual BannerType GetBanner()
        {
            return (BannerType)0xff;
        }

        public PlayerEventInfo GetPlayerEventInfo(Player plr)
        {
            if (plr == null)
                throw new ArgumentNullException(nameof(plr));

            var info = _players.FirstOrDefault(x => x.Player == plr);
            if (info == null)
            {
                info = new PlayerEventInfo { Player = plr };
                _players.Add(info);
            }

            return info;
        }
    }
}


--file EventChips.cs
﻿using MU.Network.Event;
using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu.Events.EventChips
{
    public class EventChips
    {
        public static EventChips Instance { get; set; }

        public static void Initialize()
        {
            if (Instance != null)
                throw new Exception(nameof(EventChips) + "Already Initialized");

            Instance = new EventChips();
        }

        public static void NPCTalk(Player plr)
        {
            if(plr.Character.MapID == Maps.Lorencia)
            {
                plr.Session.SendAsync(new SEventChipInfo(0, 0, new short[] { 0, 0, 0 }));
            }
            else if (plr.Character.MapID == Maps.Davias)
            {
                plr.Session.SendAsync(new SEventChipInfo(2, 0, new short[] { 0, 0, 0 }));
            }
        }
    }
}


--file EventManagement.cs
﻿using MuEmu.Events.Minigames;
using MuEmu.Util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu.Events
{
    public enum Events
    {
        DevilSquared,
        BloodCastle,
        Kanturu,
        ChaosCastle,
        Crywolf,
        ImperialGuardian,
        DoubleGoer,
        MoonRabbit,
        WhiteWizard,
        EventEgg,
        MuRummy,
        CastleSiege,
        Raklion,
        AcheronGuardian,
        JeweldryBingo,
        MineSweeper,
        BallsAndCows,
    }
    internal class EventInfo
    {
        public Event Obj { get; set; }

        public bool IsEnabled { get; set; }
    }
    public class EventManagement
    {
        Dictionary<Events, EventInfo> _events = new Dictionary<Events, EventInfo>();

        public EventManagement AddEvent(Events ev, Event obj)
        {
            _events.Add(ev, new EventInfo { IsEnabled = true, Obj = obj });
            obj.Initialize();
            return this;
        }

        public EventManagement SetEventEnable(Events ev, bool isEnabled)
        {
            _events[ev].IsEnabled = isEnabled;
            return this;
        }

        public T GetEvent<T>(/*Events ev*/)
        {
            return (T)(object)_events.Values.First(x => x.Obj.GetType() == typeof(T)).Obj;
            //_events[ev].Obj;
        }

        public IEnumerable<Event> GetEvents()
        {
            return _events.Values
                .Where(x => x.IsEnabled)
                .Select(x => x.Obj);
        }

        public void Update()
        {
            foreach(var ev in _events.Values.Where(x => x.IsEnabled))
            {
                ev.Obj.Update();
            }
        }
    }
}


--file GlobalEvent.cs
﻿using MU.Resources;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu.Events
{
    class DropRange
    {
        public ushort MinLevel;
        public ushort MaxLevel;
        public Maps Map;
        public Item Item;
    }
    public class GlobalEvent
    {
        private static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(GlobalEvent));
        private GlobalEvents manager;
        private List<DropRange> ranges = new List<DropRange>();
        public bool Active { get; set; }
        public byte Rate { get; set; }
        public GERepeatType RepeatType { get; set; }
        public DateTime Start { get; set; }
        public TimeSpan Duration { get; set; }
        public double ExpAdd { get; set; }
        public string Name { get; set; }

        public GlobalEvent(GlobalEvents mngr)
        {
            manager = mngr;
        }

        public GlobalEvent AddRange(Item it, ushort mobMinLevel, ushort mobMaxLevel, Maps map = (Maps)255)
        {
            ranges.Add(new DropRange { Item = it, MaxLevel = mobMaxLevel, MinLevel = mobMinLevel, Map = map });
            return this;
        }

        public Item GetItem(ushort mobLevel, Maps map)
        {
            if(!Active || Program.RandomProvider(100) > Rate)
            {
                return null;
            }

            var prev = ranges.Where(x => x.Map == (Maps)255 || x.Map == map);

            return prev.FirstOrDefault(x => x.MinLevel <= mobLevel && x.MaxLevel >= mobLevel)?.Item.Clone() as Item??null;
        }

        public void Update()
        {
            Active = Start < DateTime.Now && Start.Add(Duration) > DateTime.Now;
            if(RepeatType != GERepeatType.None && Start.Add(Duration) < DateTime.Now)
            {
updateCondition:
                switch(RepeatType)
                {
                    case GERepeatType.Annually:
                        Start = Start.AddYears(1);
                        break;
                    case GERepeatType.Monthly:
                        Start = Start.AddMonths(1);
                        break;
                    case GERepeatType.Weekly:
                        Start = Start.AddDays(7);
                        break;
                    case GERepeatType.Daily:
                        Start = Start.AddDays(1);
                        break;
                }
                if(Start.Add(Duration) < DateTime.Now)
                    goto updateCondition;

                Logger
                    .ForContext(Constants.SourceContextPropertyName, Name)
                    .Information("Updated active period, Start {0} - End {1}", Start, Start.Add(Duration));
            }
        }
    }
}


--file GlobalEvents.cs
﻿using MU.Resources;
using MuEmu.Resources;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;

namespace MuEmu.Events
{
    public class GlobalEvents
    {
        private static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(GlobalEvents));
        private Dictionary<string, GlobalEvent> _events = new Dictionary<string, GlobalEvent>();

        public GlobalEvents AddEvent(string name, GlobalEvent ev)
        {
            Logger.Information(ServerMessages.GetMessage(Messages.GE_AddEvent), name, ev.Active, ev.Rate);
            _events.Add(name, ev);
            ev.Name = name;
            return this;
        }

        public Item GetItem(ushort mobLevel, Maps map)
        {
            foreach(var ev in _events)
            {
                var ret = ev.Value.GetItem(mobLevel, map);
                if (ret == null)
                    continue;

                Logger.Information(ServerMessages.GetMessage(Messages.GE_GetItem), ev.Key, map, ret);

                return ret;
            }

            foreach(var ev in Program.EventManager.GetEvents())
            {
                var ret = ev.GetItem(mobLevel, map);
                if (ret == null)
                    continue;

                Logger.Information(ServerMessages.GetMessage(Messages.GE_GetItem), ev.GetType(), map, ret);

                return ret;
            }

            return null;
        }

        public void Update()
        {
            _events.Values.ToList().ForEach(x => x.Update());
            Program.Experience.ExperienceRate = (float)ExpAdd;
        }

        public double ExpAdd => _events.Values.Where(x => x.Active).Sum(x => x.ExpAdd);
        public bool AnyEvent => _events.Values.Any(x => x.Active);
    }
}


--file GoldenInvasion.cs
﻿using MuEmu.Monsters;
using MU.Network.Game;
using MuEmu.Resources;
using MuEmu.Resources.Map;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Text;
using MU.Resources;

namespace MuEmu.Events
{
    public class GoldenInvasion
    {
        private static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(GoldenInvasion));
        private List<Monster> _goldenMob = new List<Monster>();
        private DateTime _nextInvasion = DateTime.Now;
        private readonly Maps[] dekronMaps = new Maps[] { Maps.Lorencia, Maps.Noria, Maps.Davias };
        private Maps dekronMap;
        private MapInfo dekronMapInfo;
        private int dekronCount;

        public void AddMonster(Monster mob)
        {
            _goldenMob.Add(mob);
            mob.Die += Gold_Die;
        }

        public void Update()
        {
            if(dekronCount == 0 && DateTime.Now >= _nextInvasion)
            {
                _nextInvasion = DateTime.Now.AddHours(2);
                Start();
            }
        }

        public async void Start()
        {
            dekronCount = 0;
            dekronMap = dekronMaps[Program.RandomProvider(3)];
            foreach(var gold in _goldenMob)
            {
                if(gold.Info.Monster == 79) // golden Dekron
                {
                    var p = MonstersMng.Instance.GetSpawn(dekronMap, 0, 255, 0, 255);
                    gold.Warp(dekronMap, (byte)p.X, (byte)p.Y);
                    Logger.Information("Dragon spawn on {0},{1}", (byte)p.X, (byte)p.Y);
                    dekronCount++;
                }

                gold.Active = true;
            }

            dekronMapInfo = ResourceCache.Instance
                .GetMaps()[dekronMap];

            dekronMapInfo.DragonInvasion = true;

            await dekronMapInfo
                .SendAsync(new SEventState(MapEvents.GoldenInvasion, true));

            await Program.NoEventMapAnoucement($"[{dekronMap}] Golden Dragon Invasion");
        }

        private async void Gold_Die(object sender, EventArgs e)
        {
            var mob = sender as Monster;
            mob.Active = false;
            if (mob.Info.Monster == 79)
                dekronCount--;

            if(dekronCount <= 0)
            {
                foreach (var gold in _goldenMob)
                {
                    gold.Active = false;
                }
                dekronMapInfo.DragonInvasion = false;

                await dekronMapInfo
                    .SendAsync(new SEventState(MapEvents.GoldenInvasion, false));


                await Program.NoEventMapAnoucement("Golden Invasion ends");
            }
        }
    }
}


--file ImperialGuardian.cs
﻿using Serilog;
using Serilog.Core;
using MU.Network.Event;
using MySqlX.XDevAPI;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MuEmu.Monsters;
using MuEmu.Resources.Map;
using MuEmu.Resources;
using System.Drawing;
using System.Threading.Tasks;
using MuEmu.Util;
using MU.Resources;
using MU.Network.Game;

namespace MuEmu.Events.ImperialGuardian
{
    internal class FortressGate
    {
        public ushort Class;
        public int X;
        public int Y;
        public byte Dir;
        public Monster monster;
        public Maps map;
    }

    enum FortressZoneState
    {
        Ready,
        BeginTimeAttack,
        BeginWaitPlayer,
        BeginLootTime,
        AllWarpNextZone,
        MissionFail,
        AllKick,
        MissionClear,
        None,
    }

    internal class ImperialZone : StateMachine<FortressZoneState>
    {
        public ushort Zone { get; }
        public bool IsLastZone => (Zone == 3 && _manager._eventDay == DayOfWeek.Sunday) || (Zone == 2 && _manager._eventDay != DayOfWeek.Sunday);
        public bool AbleUsePortal { get; private set; }
        private ImperialGuardian _manager;
        private List<Player> _players;
        private int _lastNotify;

        public override void Initialize()
        {
            Trigger(FortressZoneState.Ready);
        }

        public ImperialZone(ImperialGuardian manager, ushort zone)
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(ImperialZone)+ zone.ToString());
            _manager = manager;
            Zone = zone;
            _players = new List<Player>();
        }

        void NotifyZoneClear(uint type)
        {
            var msg = new SImperialNotifyZoneClear
            {
                Type = type,
                RewardExp = 100,
            };

            switch(type)
            {
                case 0:
                    msg.RewardExp = 0;
                    break;
                case 2:
                    break;
            }

            _players.Select(x => x.Session).SendAsync(msg);
        }

        public override void OnTransition(FortressZoneState NextState)
        {
            switch(NextState)
            {
                case FortressZoneState.Ready:
                    AbleUsePortal = false;
                    if (_manager.CurrentState != EventState.Open)
                    {
                        Trigger(FortressZoneState.AllKick);
                    }
                    break;
                case FortressZoneState.BeginTimeAttack:
                    Trigger(FortressZoneState.MissionFail, TimeSpan.FromMinutes(10));
                    _manager.LoadMonsters(Zone);
                    _manager.Zone = Zone;
                    break;
                case FortressZoneState.BeginWaitPlayer:
                    Trigger(FortressZoneState.BeginTimeAttack, TimeSpan.FromMinutes(1));
                    _manager.UnloadMonsters((ushort)(Zone - 1));
                    break;
                case FortressZoneState.BeginLootTime:
                    AbleUsePortal = true;
                    _manager.NextZone?.Trigger(FortressZoneState.BeginWaitPlayer);
                    Trigger(IsLastZone?FortressZoneState.AllKick:FortressZoneState.MissionFail, TimeSpan.FromMinutes(1));

                    _ = _manager._map.SendAsync(new SNotice(NoticeType.Gold, "[IG] BeginLootTime1"));
                    _ = _manager._map.SendAsync(new SNotice(NoticeType.Gold, "[IG] BeginLootTime2"));
                    break;
                case FortressZoneState.AllWarpNextZone:
                    _players.ForEach(x => x.Character.WarpTo(22));
                    //Trigger(FortressZoneState.Ready);
                    break;
                case FortressZoneState.MissionFail:
                    NotifyZoneClear(0);
                    Trigger(FortressZoneState.AllKick);
                    break;
                case FortressZoneState.AllKick:
                    _manager.KickAll();
                    Trigger(FortressZoneState.Ready);
                    break;
                case FortressZoneState.MissionClear:
                    AbleUsePortal = true;
                    NotifyZoneClear(2);
                    Trigger(FortressZoneState.BeginLootTime);
                    break;
            }
        }

        public override void Update()
        {
            var notify = new SImperialNotifyZoneTime
            {
                ZoneIndex = Zone,
                DayOfWeek = (byte)_manager._eventDay,
            };
            notify.RemainTime = (uint)TimeLeft.TotalMilliseconds;
            switch (CurrentState)
            {
                case FortressZoneState.BeginTimeAttack:
                    if((int)TimeLeft.TotalSeconds == 60)
                    {
                        _ = _manager._map.SendAsync(new SNotice(NoticeType.Gold, "Portal will be closed"));
                    }else if(_lastNotify != (int)TimeLeft.TotalMinutes)
                    {
                        _lastNotify = (int)TimeLeft.TotalMinutes;
                        _ = _manager._map.SendAsync(new SNotice(NoticeType.Gold, $"Portal will be closed after {_lastNotify} minutes"));
                    }
                    if(_manager._activeMobs <= 0)
                    {
                        Trigger(IsLastZone? FortressZoneState.MissionClear:FortressZoneState.BeginLootTime);
                    }
                    notify.MsgType = 2;
                    notify.RemainMonster = (uint)_manager._activeMobs;
                    _manager.RunTraps();
                    break;
                case FortressZoneState.BeginLootTime:
                    notify.MsgType = 0;
                    if (Zone == 3)
                        break;
                    break;
                case FortressZoneState.BeginWaitPlayer:
                    notify.MsgType = 1;
                    if (_lastNotify != (int)TimeLeft.TotalMinutes)
                    {
                        _lastNotify = (int)TimeLeft.TotalMinutes;
                        _ = _manager._map.SendAsync(new SNotice(NoticeType.Gold, $"Waiting for players {_lastNotify} minutes"));
                    }                        
                    break;
                default:
                    notify.MsgType = 3;
                    break;
            }
            if(notify.MsgType != 3)
                _ = _players.Select(x => x.Session).SendAsync(notify);

            base.Update();
        }

        internal void AddPlayer(Player plr)
        {
            _players.Add(plr);
        }
        internal Player RemPlayer(Player plr)
        {
            _players.Remove(plr);
            if(_players.Count()==0)
            {
                Trigger(FortressZoneState.AllWarpNextZone);
            }
            return plr;
        }

        internal void Clear()
        {
            AbleUsePortal = false;
            _players.Clear();
            Trigger(FortressZoneState.Ready);
        }
    }

    public class ImperialGuardian : Event
    {
        enum FortressSubState
        {
            None,
            StandBy1,
            Phaze1,
            Standby2,
            Phaze2,
            StandBy3,
            Phaze3,
            StandBy4,
            Phaze4,
            End,
        }

        private List<int> _imperialGates = new List<int>
        {
            322,
            307,
            312,
            317,
            307,
            312,
            317,
        };
        private List<int> _imperialExpReward = new List<int>
        {
            5000000,
            500000,
            600000,
            700000,
            800000,
            900000,
            1000000,
        };
        private List<FortressGate> _DestlerGaliaGates = new List<FortressGate>
        {
            new FortressGate{ Class = 525, X = 234, Y = 29, Dir = 1, map = Maps.ImperialGuardian1},
            new FortressGate{ Class = 524, X = 233, Y = 55, Dir = 1, map = Maps.ImperialGuardian1},
            new FortressGate{ Class = 525, X = 216, Y = 80, Dir = 1, map = Maps.ImperialGuardian1},
            new FortressGate{ Class = 525, X = 194, Y = 25, Dir = 3, map = Maps.ImperialGuardian1},
            new FortressGate{ Class = 524, X = 166, Y = 25, Dir = 3, map = Maps.ImperialGuardian1},
            new FortressGate{ Class = 525, X = 154, Y = 53, Dir = 1, map = Maps.ImperialGuardian1},
            new FortressGate{ Class = 525, X = 180, Y = 79, Dir = 1, map = Maps.ImperialGuardian1}
        };
        private List<FortressGate> _VermontErkanneGates = new List<FortressGate>
        {
            new FortressGate{ Class = 525, X = 75, Y = 67, Dir = 3, map = Maps.ImperialGuardian2},
            new FortressGate{ Class = 524, X = 50, Y = 65, Dir = 3, map = Maps.ImperialGuardian2},
            new FortressGate{ Class = 527, X = 19, Y = 65, Dir = 3, map = Maps.ImperialGuardian2},
            new FortressGate{ Class = 525, X = 37, Y = 93, Dir = 1, map = Maps.ImperialGuardian2},
            new FortressGate{ Class = 524, X = 41, Y = 117, Dir = 1, map = Maps.ImperialGuardian2},
            new FortressGate{ Class = 527, X = 55, Y = 154, Dir = 1, map = Maps.ImperialGuardian2},
            new FortressGate{ Class = 525, X = 107, Y = 112, Dir = 3, map = Maps.ImperialGuardian2}
        };
        private List<FortressGate> _KatoRaymondGates = new List<FortressGate>
        {
            new FortressGate{ Class = 525, X = 146, Y = 191, Dir = 3, map = Maps.ImperialGuardian3},
            new FortressGate{ Class = 527, X = 119, Y = 192, Dir = 3, map = Maps.ImperialGuardian3},
            new FortressGate{ Class = 525, X = 89, Y = 195, Dir = 3, map = Maps.ImperialGuardian3},
            new FortressGate{ Class = 528, X = 222, Y = 134, Dir = 1, map = Maps.ImperialGuardian3},
            new FortressGate{ Class = 524, X = 222, Y = 160, Dir = 1, map = Maps.ImperialGuardian3},
            new FortressGate{ Class = 527, X = 223, Y = 193, Dir = 1, map = Maps.ImperialGuardian3},
            new FortressGate{ Class = 525, X = 167, Y = 217, Dir = 1, map = Maps.ImperialGuardian3}
        };
        private List<FortressGate> _JerintGaionGates = new List<FortressGate>
        {
            new FortressGate{ Class = 528, X = 81, Y = 68, Dir = 3, map = Maps.ImperialGuardian4},
            new FortressGate{ Class = 527, X = 50, Y = 69, Dir = 3, map = Maps.ImperialGuardian4},
            new FortressGate{ Class = 528, X = 32, Y = 90, Dir = 1, map = Maps.ImperialGuardian4},
            new FortressGate{ Class = 528, X = 34, Y = 176, Dir = 1, map = Maps.ImperialGuardian4},
            new FortressGate{ Class = 527, X = 52, Y = 191, Dir = 3, map = Maps.ImperialGuardian4},
            new FortressGate{ Class = 528, X = 69, Y = 166, Dir = 1, map = Maps.ImperialGuardian4},
            new FortressGate{ Class = 528, X = 156, Y = 132, Dir = 3, map = Maps.ImperialGuardian4},
            new FortressGate{ Class = 527, X = 197, Y = 132, Dir = 3, map = Maps.ImperialGuardian4},
            new FortressGate{ Class = 528, X = 225, Y = 159, Dir = 1, map = Maps.ImperialGuardian4},
            new FortressGate{ Class = 528, X = 214, Y = 21, Dir = 3, map = Maps.ImperialGuardian4}
        };
        private List<FortressGate> _fortressGates;

        private List<Rectangle> __JerintGaionAtt = new List<Rectangle>
        {
            new Rectangle(77, 67, 5, 2),
            new Rectangle(46, 68, 5, 2),
            new Rectangle(31, 89, 2, 5),
            new Rectangle(33, 175, 2, 5),
            new Rectangle(51, 190, 5, 2),
            new Rectangle(68, 162, 2, 5),
            new Rectangle(155, 131, 5, 2),
            new Rectangle(195, 131, 6, 2),
            new Rectangle(224, 158, 2, 5),
            new Rectangle(210, 23, 5, 2),
        };
        private List<Rectangle> _fortressAtt;

        private List<Monster> _traps;

        private List<ImperialZone> _zones;

        internal int Zone { get; set; }
        internal ImperialZone CurrentZone => _zones[Zone];
        internal ImperialZone NextZone => CurrentZone.IsLastZone == false ? _zones[Zone + 1] : null;

        internal DayOfWeek _eventDay;
        private int _baseGroup;
        private DateTime _subStateEnd;
        internal MapInfo _map;
        internal int _activeMobs;

        private SImperialEnterResult _eventState = new SImperialEnterResult();

        public Maps Map;

        public ImperialGuardian()
            : base(TimeSpan.Zero, TimeSpan.FromDays(100), TimeSpan.FromMinutes(10))
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(ImperialGuardian));
            _zones = new List<ImperialZone>();

            for(var i = 0; i < 4; i++)
            {
                _zones.Add(new ImperialZone(this, (ushort)i));
            }
        }
        public override void Initialize()
        {
            base.Initialize();
            Trigger(EventState.Open);

            _fortressGates = new List<FortressGate>();
            _fortressGates.AddRange(_DestlerGaliaGates);
            _fortressGates.AddRange(_VermontErkanneGates);
            _fortressGates.AddRange(_KatoRaymondGates);
            _fortressGates.AddRange(_JerintGaionGates);
            foreach (var g in _fortressGates)
            {
                g.monster = MonstersMng.Instance.CreateMonster(g.Class, ObjectType.NPC, g.map, new System.Drawing.Point(g.X, g.Y), g.Dir);
                g.monster.Die += OnMonsterDead;
                g.monster.Regen += Monster_Regen;
            }

            _zones.ForEach(x => x.Initialize());
        }

        private void Monster_Regen(object sender, EventArgs e)
        {
            var mob = sender as Monster;
            mob.Active = false;
        }

        public override void NPCTalk(Player plr)
        {
            throw new NotImplementedException();
        }

        private async void SetGateState(Monster mob, bool enable)
        {
            if (_map == null)
                return;

            Rectangle rect = new Rectangle(mob.Position.X - 3, mob.Position.Y - 2, 3, 4);
            switch(mob.Direction)
            {
                case 1:
                    rect = new Rectangle(mob.Position.X - 2, mob.Position.Y, 4, 3);
                    break;
                case 5:
                    rect = new Rectangle(mob.Position.X - 2, mob.Position.Y - 3, 4, 3);
                    break;
                case 3:
                    rect = new Rectangle(mob.Position.X - 3, mob.Position.Y - 2, 3, 4);
                    break;
                case 7:
                    rect = new Rectangle(mob.Position.X, mob.Position.Y - 2, 3, 4);
                    break;
            }
            if(enable)
                await _map.AddAttribute(MapAttributes.Unknow, rect);
            else
                await _map.RemoveAttribute(MapAttributes.Unknow, rect);
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            var mob = sender as Monster;

            _logger.Information("Monster {0} dead, left {1} mobs", mob.Info.Name, _activeMobs);
            mob.Active = false;

            var result = _fortressGates.FindIndex(x => x.monster == mob)+1;
            if(result > 0)
            {
                SetGateState(mob, false);

                _ = _map.RemoveAttribute(MapAttributes.Unknow, _fortressAtt[result-1]);

                if(result < _fortressGates.Count() && result < (Zone+1)*3)
                    _fortressGates[result].monster.Type = ObjectType.Gate;

                return;
            }

            _activeMobs--;
            if(_activeMobs == 0)
            {
                _fortressGates[1].monster.Type = ObjectType.Gate;
            }
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            var info = _players.First(x => x.Player == (sender as Character).Player);
            OnPlayerLeave(sender, eventArgs);
            _ = info.Player.Character.WarpTo(267);
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            var info = _players.First(x => x.Player == (sender as Character).Player);
            info.Eventer = false;
            info.Player.Character.CharacterDie -= OnPlayerDead;
            info.Player.Character.MapChanged -= OnPlayerLeave;
        }

        public override void OnTransition(EventState NextState)
        {
            switch(NextState)
            {
                case EventState.Open:
                    foreach (var g in _fortressGates)
                    {
                        g.monster.Active = false;
                        g.monster.Type = ObjectType.NPC;
                    }

                    _map?.Players.ForEach(x => _ = x.WarpTo(267));
                    _zones.ForEach(x => x.Clear());
                    Zone = 0;
                    break;
                case EventState.Playing:
                    _subStateEnd = DateTime.Now;
                    _eventDay = DateTime.Now.DayOfWeek;
                    _eventDay = _eventDay == DayOfWeek.Sunday ? (DayOfWeek)7 : _eventDay;
                    _baseGroup = (int)_eventDay * 3 + 21;
                    _eventState.Day = (byte)_eventDay;
                    _eventState.Unk = 3;
                    _eventState.State = 1;

                    switch (DateTime.Now.DayOfWeek)
                    {
                        case DayOfWeek.Monday://Destler
                        case DayOfWeek.Thursday://Galia
                            _fortressGates = _DestlerGaliaGates;
                            _fortressAtt = __JerintGaionAtt;
                            Map = Maps.ImperialGuardian1;
                            _baseGroup = 24;
                            break;
                        case DayOfWeek.Tuesday://Vermont
                        case DayOfWeek.Friday://Erkanne
                            _fortressGates = _VermontErkanneGates;
                            _fortressAtt = __JerintGaionAtt;
                            Map = Maps.ImperialGuardian2;
                            _baseGroup = 27;
                            break;
                        case DayOfWeek.Wednesday://Kato
                        case DayOfWeek.Saturday://Raymond
                            _fortressGates = _KatoRaymondGates;
                            _fortressAtt = __JerintGaionAtt;
                            Map = Maps.ImperialGuardian3;
                            _baseGroup = 30;
                            break;
                        case DayOfWeek.Sunday://Jerint y Gaion Kharein
                            _fortressGates = _JerintGaionGates;
                            _fortressAtt = __JerintGaionAtt;
                            Map = Maps.ImperialGuardian4;
                            _baseGroup = 36;
                            break;
                    }
                    _map = ResourceCache.Instance.GetMaps()[Map];
                    _traps = _map.Monsters.Where(x => x.Info.Monster == 523).ToList();
                    break;
            }
        }

        public override bool TryAdd(Player plr)
        {
            var result = new SImperialEnterResult
            {
                Day = (byte)DateTime.Now.DayOfWeek,
                Index = plr.ID,
                Result = 0,
                State = 1,
                Unk = 0,
                EntryTime = 0,
            };

            /*if(plr.Character.Party == null)
            {
                result.Result = 6;
                _ = plr.Session.SendAsync(result);
                return false;
            }*/

            var itNum = ItemNumber.FromTypeIndex(14, (ushort)(result.Day == (byte)DayOfWeek.Sunday ? 109 : 102));
            var invitation = plr.Character.Inventory.FindAll(itNum);
            if(invitation.Length <= 0)
            {
                result.Result = 2;
                _ = plr.Session.SendAsync(result);
                return false;
            }

            if (
                CurrentState != EventState.Open && 
                (_players.First().Player.Character.Party != plr.Character.Party ||
                CurrentZone.CurrentState != FortressZoneState.BeginWaitPlayer)
                )
            {
                result.Result = 1;
                _ = plr.Session.SendAsync(result);
                return false;
            }

            _ = plr.Character.Inventory.Delete(invitation.First());
            plr.Window = null;
            _ = plr.Character.WarpTo(_imperialGates[(int)result.Day]);

            _players.Add(new PlayerEventInfo { Eventer = true, Player = plr });
            plr.Character.MapChanged += OnPlayerLeave;
            plr.Character.CharacterDie += OnPlayerDead;

            if(CurrentState == EventState.Open)
            {
                _zones[0].Trigger(FortressZoneState.BeginWaitPlayer);
                _zones[0].AddPlayer(plr);
            }
            else
            {
                CurrentZone.AddPlayer(plr);
            }

            return true;
        }

        public void RunTraps()
        {
            foreach (var t in _traps)
                foreach (var p in _players.Where(x => x.Eventer))
                {
                    if (t.Position.Substract(p.Player.Character.Position).LengthSquared() <= 5)
                    {
                        DamageType dmg;
                        Spell spell;

                        var att = t.MonsterAttack(out dmg, out spell);
                        _ = p.Player.Character.GetAttacked(t.Index, t.Direction, 120, att, dmg, spell, 0);
                    }
                }
        }

        internal void StandBy(ushort Zone, bool enable)
        {
            var newType = enable ? ObjectType.NPC : ObjectType.Gate;
            _fortressGates[Zone * 3].monster.Type = newType;
            /*if (!_zones[Zone].IsLastZone)
            {
                _fortressGates[Zone * 3 + 1].monster.Type = newType;
                _fortressGates[Zone * 3 + 2].monster.Type = newType;
            }*/
        }

        internal void LoadMonsters(ushort Zone)
        {
            _activeMobs = MonsterIA.InitGroup(_baseGroup+ Zone, OnMonsterDead);
            StandBy(Zone, false);
        }

        internal void UnloadMonsters(ushort Zone)
        {
            if (Zone == 0xffff)
            {
                foreach (var g in _fortressGates)
                {
                    g.monster.Active = true;
                    SetGateState(g.monster, true);
                }
            }
            else
            {
                MonsterIA.DelGroup(_baseGroup + Zone);
            }
        }

        internal void UpdateState(Player plr)
        {
            _eventState.State = (byte)(CurrentZone.Zone + 1);
            _eventState.EntryTime = (ushort)CurrentZone.TimeLeft.TotalSeconds;
            _eventState.Index = plr.ID;
            _ = _map.SendAsync(_eventState);
        }

        public override void Update()
        {
            switch (CurrentState)
            {
                case EventState.Open:
                    if (_players.Where(x => x.Eventer).Count() <= 0)
                        break;
                    Trigger(EventState.Playing);                    
                    break;
                case EventState.Playing:
                    if (_players.Where(x => x.Eventer).Count() == 0)
                    {
                        Trigger(EventState.Open);
                        break;
                    }
                    break;
            }
            _zones.ForEach(x => x.Update());
            base.Update();
        }

        internal async Task UsePortal(Character @char, ushort moveNumber)
        {
            if(!CurrentZone.AbleUsePortal)
            {
                return;
            }

            CurrentZone.RemPlayer(@char.Player);
            NextZone?.AddPlayer(@char.Player);
            UpdateState(@char.Player);

            await @char.WarpTo(moveNumber);
        }

        internal void KickAll()
        {
            _players.ForEach(x => x.Player.Character.WarpTo(22).Wait());
            _players.Clear();
        }
    }
}


--file Kanturu.cs
﻿using MU.Network.Event;
using MU.Resources;
using MU.Network.Game;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MuEmu.Util;
using MuEmu.Resources;
using MuEmu.Resources.XML;
using MuEmu.Monsters;

namespace MuEmu.Events.Kanturu
{
    public enum KanturuStandByState
    {
        None,
        Start,
        Notify,
        End,
    };
    public enum KanturuBattleOfMayaState
    {
        None,

        StandBy1,
        Notify1,
        Start1,
        Maya1,
        End1,
        EndCycle1,

        StandBy2,
        //Notify2,
        Start2,
        Maya2,
        End2,
        EndCycle2,

        StandBy3,
        //Notify3,
        Start3,
        Maya3,
        End3,
        EndCycle3,

        End,
        EndCycle,
    };
    public enum KanturuBattleOfNightmareState
    {
        None,
        Idle,
        Notify,
        Start,
        End,
        EndCycle,
    }
    public enum KanturuTowerOfRefinementState
    {
        None,
        Revitalization,
        Notify1,
        Close,
        Notify2,
        End,
    }

    public class KanturuStandBy : StateMachine<KanturuStandByState>
    {
        private Kanturu _manager;
        public KanturuStandBy(Kanturu mng)
        {
            _manager = mng;
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(KanturuStandBy));
        }
        public override void Initialize()
        {
            _manager._state = KanturuState.BattleStandBy;
            Trigger(KanturuStandByState.Start, TimeSpan.FromSeconds(3));
        }

        public override void OnTransition(KanturuStandByState NextState)
        {
            switch(NextState)
            {
                case KanturuStandByState.Start:
                    Trigger(KanturuStandByState.Notify, TimeSpan.FromSeconds(60));//1140
                    break;
                case KanturuStandByState.Notify:
                    Trigger(KanturuStandByState.End, TimeSpan.FromSeconds(60));
                    /*"[Refinery Tower] Can enter in 1 minute"*/
                    Program.MapAnoucement(Maps.Kantru2, ServerMessages.GetMessage(Messages.Kanturu_CoreGateOpens, (int)TimeLeft.TotalMinutes)).Wait();
                    break;
                case KanturuStandByState.End:
                    _manager.Trigger(EventState.Playing);
                    Trigger(KanturuStandByState.None);
                    break;
            }
        }
    }

    public class KanturuBattleOfMaya : StateMachine<KanturuBattleOfMayaState>
    {
        private Kanturu _manager;
        private bool _LeftHand = false;
        private bool _RightHand = false;
        private PatternManager _hand1;
        private PatternManager _hand2;

        public KanturuBattleOfMaya(Kanturu mng)
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(KanturuBattleOfMaya));
            _manager = mng;
        }

        public override void Initialize()
        {
            _manager._state = KanturuState.BattleOfMaya;
            Trigger(KanturuBattleOfMayaState.StandBy1, TimeSpan.FromSeconds(3));
        }

        private void DieMonster(object sender, EventArgs args)
        {
            var mob = sender as Monster;
            if (mob.Info.Monster == 362 || mob.Info.Monster == 363)
            {
                _LeftHand |= mob.Info.Monster == 362;
                _RightHand |= mob.Info.Monster == 363;
                mob.Active = false;
            }

            mob.Map.SendAsync(new SNotice(NoticeType.Gold, mob.Info.Name + " killed by " + mob.Killer.Character.Name));

            if(CurrentState == KanturuBattleOfMayaState.Maya1 && _LeftHand)
            {
                Trigger(KanturuBattleOfMayaState.End1, TimeSpan.FromSeconds(5));
            }else if (CurrentState == KanturuBattleOfMayaState.Maya2 && _RightHand)
            {
                Trigger(KanturuBattleOfMayaState.End2, TimeSpan.FromSeconds(5));
            }else if (CurrentState == KanturuBattleOfMayaState.Maya3 && _LeftHand && _RightHand)
            {
                Trigger(KanturuBattleOfMayaState.End3, TimeSpan.FromSeconds(5));
            }
        }

        public override void OnTransition(KanturuBattleOfMayaState NextState)
        {
            _manager.SendAll(new SKanturuStateChange { 
                State = _manager._state, 
                btDetailState = (byte)NextState 
            });

            if(NextState == KanturuBattleOfMayaState.EndCycle1 ||
                NextState == KanturuBattleOfMayaState.EndCycle2 ||
                NextState == KanturuBattleOfMayaState.EndCycle3)
            {
                var str = ServerMessages.GetMessage(Messages.Kanturu_NextBattle);
                Program.MapAnoucement(Maps.Kantru1, str).Wait();
                Program.MapAnoucement(Maps.Kantru2, str).Wait();
                Program.MapAnoucement(Maps.Kantru3, str).Wait();
            }

            switch (NextState)
            {
                // Battle Stage 1
                case KanturuBattleOfMayaState.StandBy1:
                    Trigger(KanturuBattleOfMayaState.Notify1, TimeSpan.FromSeconds(120));
                    break;
                case KanturuBattleOfMayaState.Notify1:
                    if(!_manager.CanRun())
                    {
                        _manager.FailState = true;
                        Trigger(KanturuBattleOfMayaState.End);
                        return;
                    }
                    
                    Trigger(KanturuBattleOfMayaState.Start1, TimeSpan.FromSeconds(15));
                    break;
                case KanturuBattleOfMayaState.Start1:
                    _manager.LoadScene(0);
                    Trigger(KanturuBattleOfMayaState.End1, TimeSpan.FromSeconds(900));
                    _manager.SendAll(new SKanturuBattleTime { BattleTime = (int)TimeLeft.TotalMilliseconds });
                    break;
                case KanturuBattleOfMayaState.Maya1:
                    {
                        _LeftHand = false;
                        _RightHand = false;
                        _manager.LoadScene(3);
                        MonsterIA.InitGroup(20, DieMonster);
                        var h1 = MonstersMng.Instance.Monsters.FirstOrDefault(x => x.Info.Monster == 363 || x.Info.Monster == 362);
                        _hand1 = new PatternManager(h1, Program.XMLConfiguration.Files.MayaLeftHandPatterns);
                        _hand1.UseSkill += _hand_UseSkill;
                    }
                    break;
                case KanturuBattleOfMayaState.End1:
                    _hand1.UseSkill -= _hand_UseSkill;
                    _hand1 = null;
                    MonsterIA.DelGroup(20);
                    if (_manager.MonsterCount()>1 || !_LeftHand)
                    {
                        _manager.FailState = true;
                        Trigger(KanturuBattleOfMayaState.End);
                        return;
                    }
                    Trigger(KanturuBattleOfMayaState.EndCycle1, TimeSpan.FromSeconds(5));
                    break;
                case KanturuBattleOfMayaState.EndCycle1:
                    {
                        Trigger(KanturuBattleOfMayaState.StandBy2, TimeSpan.FromSeconds(3));
                    }
                    break;

                // Battle Stage 2
                case KanturuBattleOfMayaState.StandBy2:
                    Trigger(KanturuBattleOfMayaState.Start2, TimeSpan.FromSeconds(60));
                    break;
                case KanturuBattleOfMayaState.Start2:
                    _manager.LoadScene(0);
                    Trigger(KanturuBattleOfMayaState.End2, TimeSpan.FromSeconds(900));
                    _manager.SendAll(new SKanturuBattleTime { BattleTime = (int)TimeLeft.TotalMilliseconds });
                    break;
                case KanturuBattleOfMayaState.Maya2:
                    {
                        _LeftHand = false;
                        _RightHand = false;
                        MonsterIA.InitGroup(21, DieMonster);
                        _manager.LoadScene(4);
                        var h1 = MonstersMng.Instance.Monsters.FirstOrDefault(x => x.Info.Monster == 363 || x.Info.Monster == 362);
                        _hand2 = new PatternManager(h1, Program.XMLConfiguration.Files.MayaRightHandPatterns);
                        _hand2.UseSkill += _hand_UseSkill;
                    }
                    break;
                case KanturuBattleOfMayaState.End2:
                    _hand2.UseSkill -= _hand_UseSkill;
                    _hand2 = null;
                    MonsterIA.DelGroup(21);
                    if (_manager.MonsterCount() > 1 || !_RightHand)
                    {
                        _manager.FailState = true;
                        Trigger(KanturuBattleOfMayaState.End);
                        return;
                    }
                    Trigger(KanturuBattleOfMayaState.EndCycle2, TimeSpan.FromSeconds(5));
                    break;
                case KanturuBattleOfMayaState.EndCycle2:
                    Trigger(KanturuBattleOfMayaState.StandBy3, TimeSpan.FromSeconds(3));
                    break;

                // Battle Stage 3
                case KanturuBattleOfMayaState.StandBy3:
                    Trigger(KanturuBattleOfMayaState.Start3, TimeSpan.FromSeconds(60));
                    break;
                case KanturuBattleOfMayaState.Start3:
                    _manager.LoadScene(1);
                    Trigger(KanturuBattleOfMayaState.End3, TimeSpan.FromSeconds(900));
                    _manager.SendAll(new SKanturuBattleTime { BattleTime = (int)TimeLeft.TotalMilliseconds });
                    break;
                case KanturuBattleOfMayaState.Maya3:
                    {
                        _LeftHand = false;
                        _RightHand = false;
                        MonsterIA.InitGroup(22, DieMonster);
                        _manager.LoadScene(5);
                        var h1 = MonstersMng.Instance.Monsters.FirstOrDefault(x => x.Info.Monster == 362);
                        var h2 = MonstersMng.Instance.Monsters.FirstOrDefault(x => x.Info.Monster == 363);
                        _hand1 = new PatternManager(h1, Program.XMLConfiguration.Files.MayaLeftHandPatterns);
                        _hand2 = new PatternManager(h2, Program.XMLConfiguration.Files.MayaRightHandPatterns);
                        _hand1.UseSkill += _hand_UseSkill;
                        _hand2.UseSkill += _hand_UseSkill;
                    }
                    break;
                case KanturuBattleOfMayaState.End3:
                    _hand1.UseSkill -= _hand_UseSkill;
                    _hand2.UseSkill -= _hand_UseSkill;
                    _hand1 = null;
                    _hand2 = null;
                    MonsterIA.DelGroup(22);
                    if (_manager.MonsterCount() > 1 || !_LeftHand || !_RightHand)
                    {
                        _manager.FailState = true;
                        Trigger(KanturuBattleOfMayaState.End);
                        return;
                    }
                    Trigger(KanturuBattleOfMayaState.EndCycle3, TimeSpan.FromSeconds(5));
                    break;
                case KanturuBattleOfMayaState.EndCycle3:
                    Trigger(KanturuBattleOfMayaState.End, TimeSpan.FromSeconds(3));
                    break;

                case KanturuBattleOfMayaState.End:
                    Trigger(KanturuBattleOfMayaState.EndCycle, TimeSpan.FromSeconds(3));
                    if(_manager.FailState)
                    {
                        _manager.SendAll(new SNotice(NoticeType.Gold, ServerMessages.GetMessage(Messages.Kanturu_Fail)));
                    }
                    break;
                case KanturuBattleOfMayaState.EndCycle:
                    if (!_manager.FailState)
                    {
                        _manager._battleOfNightmare.Initialize();
                    }
                    else
                    {
                        _manager.Trigger(EventState.Open);
                    }
                    Trigger(KanturuBattleOfMayaState.None);
                    break;
            }
        }

        private void _maya_UseSkill(object sender, UseSkillEventArgs e)
        {
            var monster = sender as Monster;
            var msg0 = new SKanturuWideAttack
            {
                ObjClass = monster.Info.Monster,
                Type = 0,
            };
            _manager.SendAll(msg0);
        }

        private void _hand_UseSkill(object sender, UseSkillEventArgs e)
        {
            var monster = sender as Monster;
            var msg1 = new SKanturuWideAttack
            {
                ObjClass = monster.Info.Monster,
                Type = 1,
            };
            DamageType type;
            Spell spell;
            if (monster.Target != null)
            {
                var attack = monster.MonsterAttack(out type, out spell);
                monster.Target?.Character.GetAttacked(monster.Index, 1, 1, attack, type, spell, 0);
            }
            switch (e.Spell)
            {
                case MonsterSpell.Pressure:
                    //monster.Spells.AttackSend(Spell.pres, monster.Target.ID, true);
                    break;
                case MonsterSpell.PowerWave:
                    monster.Spells.AttackSend(Spell.PowerWave, monster.Target.ID, true);
                    break;
                case MonsterSpell.BrokenShower:
                    _manager.SendAll(msg1);
                    break;
                case MonsterSpell.IceStorm:
                    break;
            }

        }

        public override void Update()
        {
            _hand1?.Update();
            _hand2?.Update();
            switch(CurrentState)
            {
                case KanturuBattleOfMayaState.Maya1:
                case KanturuBattleOfMayaState.Maya2:
                case KanturuBattleOfMayaState.Maya3:
                case KanturuBattleOfMayaState.Notify1:
                case KanturuBattleOfMayaState.Start1:
                case KanturuBattleOfMayaState.Start2:
                case KanturuBattleOfMayaState.Start3:
                    _manager.SendAll(new SKanturuMonsterUserCount { MonsterCount = (byte)(_manager.MonsterCount() - 1), UserCount = _manager.Count });
                    if (!_manager.CanRun())
                    {
                        _manager.FailState = true;
                        Trigger(KanturuBattleOfMayaState.End);
                    }
                    if(
                        (CurrentState == KanturuBattleOfMayaState.Start1 ||
                        CurrentState == KanturuBattleOfMayaState.Start2 ||
                        CurrentState == KanturuBattleOfMayaState.Start3) &&
                        _manager.MonsterCount() <= 1)
                    {
                        Trigger(CurrentState+1);
                    }
                    break;
            }
            base.Update();
        }


    }

    public class KanturuBattleOfNightmare : StateMachine<KanturuBattleOfNightmareState>
    {
        private Kanturu _manager;
        private PatternManager _nightmare;
        public KanturuBattleOfNightmare(Kanturu mng)
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(KanturuBattleOfNightmare));
            _manager = mng;
        }

        public override void Initialize()
        {
            _manager._state = KanturuState.BattleOfNightmare;
            Trigger(KanturuBattleOfNightmareState.Idle, TimeSpan.FromSeconds(3));
        }

        public override void OnTransition(KanturuBattleOfNightmareState NextState)
        {
            _manager.SendAll(new SKanturuStateChange
            {
                State = _manager._state,
                btDetailState = (byte)NextState
            });

            switch (NextState)
            {
                case KanturuBattleOfNightmareState.None:
                    break;
                case KanturuBattleOfNightmareState.Idle:
                    _manager.WarpAllTo(134);
                    Trigger(KanturuBattleOfNightmareState.Notify, TimeSpan.FromSeconds(5));
                    break;
                case KanturuBattleOfNightmareState.Notify:
                    Trigger(KanturuBattleOfNightmareState.Start, TimeSpan.FromSeconds(10));
                    _manager.SendAll(new SNotice(NoticeType.Gold, ServerMessages.GetMessage(Messages.Kanturu_NightmareNotify)));
                    break;
                case KanturuBattleOfNightmareState.Start:
                    {
                        _manager.LoadScene(2);
                        MonsterIA.InitGroup(23, DieMonster);
                        var mob = MonstersMng.Instance.Monsters.FirstOrDefault(x => x.Info.Monster == 361);
                        _nightmare = new PatternManager(mob, Program.XMLConfiguration.Files.NightmarePatterns);
                        _nightmare.UseSkill += _nightmare_UseSkill;
                        _manager.FailState = true;
                        Trigger(KanturuBattleOfNightmareState.End, TimeSpan.FromSeconds(1200));
                        _manager.SendAll(new SKanturuBattleTime { BattleTime = (int)TimeLeft.TotalSeconds });
                    }
                    break;
                case KanturuBattleOfNightmareState.End:
                    _nightmare = null;
                    MonsterIA.DelGroup(23);
                    _logger.Information("Battle result:{0}", _manager.FailState?"Fail":"Win");
                    _manager.SendAll(new SKanturuBattleResult { Result = (byte)(_manager.FailState ? 0 : 1) });
                    Trigger(KanturuBattleOfNightmareState.EndCycle, TimeSpan.FromSeconds(5));
                    break;
                case KanturuBattleOfNightmareState.EndCycle:
                    if(_manager.FailState)
                    {
                        _manager.Clear();
                    }else
                    {
                        _manager._towerOfRefinement.Initialize();
                        _manager.Trigger(EventState.Closed);
                    }
                    Trigger(KanturuBattleOfNightmareState.None);
                    break;
            }
        }

        private void _nightmare_UseSkill(object sender, UseSkillEventArgs e)
        {
            var monster = (Monster)sender;
            switch(e.Spell)
            {
                case MonsterSpell.DogAttack:
                    break;
                case MonsterSpell.Potlike:
                    break;
                case MonsterSpell.Summon:
                    break;
                case MonsterSpell.FireJeans:
                    break;
                case MonsterSpell.Warp:
                        monster.Warp(Maps.Kantru3,
                        (byte)(monster.Position.X + Program.RandomProvider(6, -6)),
                        (byte)(monster.Position.Y + Program.RandomProvider(6, -6))
                        );
                    break;
            }
        }

        private void DieMonster(object sender, EventArgs e)
        {
            var mob = sender as Monster;
            mob.Active = false;
            if(mob.Info.Monster == 361)
            {
                _manager.SendAll(new SNotice(NoticeType.Gold, ServerMessages.GetMessage(Messages.Kanturu_Successfull, mob.Killer.Character.Name)));
                _manager.FailState = false;
                Trigger(KanturuBattleOfNightmareState.End);
            }
        }

        public override void Update()
        {
            switch(CurrentState)
            {
                case KanturuBattleOfNightmareState.Start:
                    break;
            }
            base.Update();
        }
    }

    public class KanturuTowerOfRefinement : StateMachine<KanturuTowerOfRefinementState>
    {
        private Kanturu _manager;

        public KanturuTowerOfRefinement(Kanturu mng)
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(KanturuTowerOfRefinement));
            _manager = mng;
        }

        public override void Initialize()
        {
            Trigger(KanturuTowerOfRefinementState.Revitalization, TimeSpan.FromSeconds(3));
        }

        public override void OnTransition(KanturuTowerOfRefinementState NextState)
        {
            _manager.SendAll(new SKanturuStateChange
            {
                State = _manager._state,
                btDetailState = (byte)NextState
            });

            switch (NextState)
            {
                case KanturuTowerOfRefinementState.None:
                    _manager.Trigger(EventState.Open);
                    break;
                case KanturuTowerOfRefinementState.Revitalization:
                    Trigger(KanturuTowerOfRefinementState.Notify1, TimeSpan.FromSeconds(82500));
                    break;
                case KanturuTowerOfRefinementState.Notify1:
                    Trigger(KanturuTowerOfRefinementState.Close, TimeSpan.FromSeconds(300));
                    break;
                case KanturuTowerOfRefinementState.Close:
                    Trigger(KanturuTowerOfRefinementState.Notify2, TimeSpan.FromSeconds(2220));
                    break;
                case KanturuTowerOfRefinementState.Notify2:
                    Trigger(KanturuTowerOfRefinementState.End, TimeSpan.FromSeconds(180));
                    break;
                case KanturuTowerOfRefinementState.End:
                    Trigger(KanturuTowerOfRefinementState.None, TimeSpan.FromSeconds(5));
                    break;
            }
        }
    }

    public class Kanturu : Event
    {
        private DateTimeOffset _lastAnouncement = DateTimeOffset.Now;
        private KanturuStagesDto _info;
        private List<Monster> _monsters = new List<Monster>();
        internal KanturuState _state;
        internal KanturuStandBy _standBy;
        internal KanturuBattleOfMaya _battleOfMaya;
        internal KanturuBattleOfNightmare _battleOfNightmare;
        internal KanturuTowerOfRefinement _towerOfRefinement;

        public bool FailState { get; set; }

        public const int MaxPlayers = 15;

        public Kanturu()
            : base(TimeSpan.FromDays(1), TimeSpan.FromMinutes(2), TimeSpan.FromHours(1))
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(Kanturu));
            _standBy = new KanturuStandBy(this);
            _battleOfMaya = new KanturuBattleOfMaya(this);
            _battleOfNightmare = new KanturuBattleOfNightmare(this);
            _towerOfRefinement = new KanturuTowerOfRefinement(this);

            _info = ResourceLoader.XmlLoader<KanturuStagesDto>("./Data/Monsters/KanturuMonsterSet.xml");
        }

        public override void Initialize()
        {
            base.Initialize();
            Trigger(EventState.Open);
        }

        public override void NPCTalk(Player plr)
        {
            var msg = new SKanturuStateInfo
            {
                State = _state,
                btEnter = 0,
                btDetailState = 0,
                btUserCount = (byte)_players.Count,
            };

            switch(_state)
            {
                case KanturuState.BattleStandBy:
                    msg.btDetailState = (byte)_standBy.CurrentState;
                    msg.iRemainTime = (int)_standBy.TimeLeft.TotalSeconds;
                    break;
                case KanturuState.BattleOfMaya:
                    msg.btDetailState = (byte)_battleOfMaya.CurrentState;
                    msg.iRemainTime = (int)_battleOfMaya.TimeLeft.TotalSeconds;
                    switch(_battleOfMaya.CurrentState)
                    {
                        case KanturuBattleOfMayaState.StandBy1:
                        case KanturuBattleOfMayaState.StandBy2:
                        case KanturuBattleOfMayaState.StandBy3:
                            if (_players.Count(x => x.Eventer == true) < MaxPlayers)
                                msg.btEnter = 1;
                            break;
                    }
                    break;
                case KanturuState.BattleOfNightmare:
                    msg.btDetailState = (byte)_battleOfNightmare.CurrentState;
                    msg.iRemainTime = (int)_battleOfNightmare.TimeLeft.TotalSeconds;
                    break;
                case KanturuState.TowerOfRefinery:
                    msg.btDetailState = (byte)_towerOfRefinement.CurrentState;
                    msg.iRemainTime = (int)_towerOfRefinement.TimeLeft.TotalSeconds;
                    switch (_towerOfRefinement.CurrentState)
                    {
                        case KanturuTowerOfRefinementState.Revitalization:
                        case KanturuTowerOfRefinementState.Notify1:
                            msg.btEnter = 1;
                            break;
                    }
                    break;
            }

            plr.Session.SendAsync(msg)
                .Wait();
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            var mob = sender as Monster;
            mob.Active = false;
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            OnPlayerLeave(sender, eventArgs);
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            var info = (from plr in _players
                        where plr.Player == (Player)sender
                        select plr).FirstOrDefault();

            info.Eventer = false;
        }

        public override void OnTransition(EventState NextState)
        {
            switch(NextState)
            {
                case EventState.None:
                    _state = KanturuState.None;
                    break;
                case EventState.Closed:
                    _state = KanturuState.TowerOfRefinery;
                    //Trigger(EventState.Open, TimeSpan.FromHours(23));
                    break;
                case EventState.Open:
                    Clear();
                    _standBy.Initialize();
                    _state = KanturuState.BattleStandBy;
                    break;
                case EventState.Playing:
                    _battleOfMaya.Initialize();
                    _state = KanturuState.BattleOfMaya;
                    break;
            }
        }

        internal bool CanRun()
        {
            return _players.Any(x => x.Eventer) || EventState.Closed == CurrentState;
        }

        internal void Clear()
        {
            WarpAllTo(137);
            _players.Clear();
            FailState = false;
        }

        internal void WarpAllTo(int gate)
        {
            _players.ForEach(x => x.Player?.Character?.WarpTo(gate).Wait());
        }

        internal async void SendAll(object message)
        {
            await _players
                .Where(x => x.Eventer == true)
                .Select(x => x.Player.Session)
                .SendAsync(message);
        }

        internal void LoadScene(int number)
        {
            foreach (var x in _monsters)
            {
                x.Die -= OnMonsterDead;
                MonstersMng.Instance.DeleteMonster(x);
            }
            _monsters.Clear();

            var mobs = _info.Stages.First(x => x.Number == number).Monsters;
            _monsters = mobs.Select(x => MonstersMng.Instance.CreateMonster(x.Type, ObjectType.Monster, (Maps)x.Map, new System.Drawing.Point(x.PosX, x.PosY), (byte)x.Dir)).ToList();
            foreach (var x in _monsters)
            {
                x.Die += OnMonsterDead;
            }
        }

        internal int MonsterCount()
        {
            return _monsters.Where(x => x.Active).Count();
        }

        public override void Update()
        {
            switch(CurrentState)
            {
                case EventState.Closed:
                    break;
                case EventState.Open:
                    break;
                case EventState.Playing:
                    break;
            }
            _standBy.Update();
            _battleOfMaya.Update();
            _battleOfNightmare.Update();
            _towerOfRefinement.Update();
            base.Update();
        }

        public override bool TryAdd(Player plr)
        {
            if(
                CurrentState == EventState.Playing && 
                _state == KanturuState.BattleOfMaya && 
                (_battleOfMaya.CurrentState == KanturuBattleOfMayaState.StandBy1 || _battleOfMaya.CurrentState == KanturuBattleOfMayaState.StandBy2 || _battleOfMaya.CurrentState == KanturuBattleOfMayaState.StandBy3)
                )
            {
                plr.Character.WarpTo(133).Wait();
                plr.Character.CharacterDie += Character_CharacterDie;
                plr.Character.MapChanged += Character_MapChanged;
                var exists = _players.FirstOrDefault(x => x.Player == plr);
                if (exists == null)
                {
                    _players.Add(new PlayerEventInfo
                    {
                        Eventer = true,
                        Player = plr,
                        Score = 0,
                    });
                }
                else
                {
                    exists.Eventer = true;
                }
                return true;
            }else if(CurrentState == EventState.Closed && 
                (_towerOfRefinement.CurrentState == KanturuTowerOfRefinementState.Revitalization || _towerOfRefinement.CurrentState == KanturuTowerOfRefinementState.Notify1))
            {
                plr.Character.WarpTo(135).Wait();

                plr.Session.SendAsync(new SKanturuStateChange
                {
                    State = _state,
                    btDetailState = (byte)_towerOfRefinement.CurrentState
                }).Wait();
                return true;
            }
            return false;
        }

        private void Character_MapChanged(object sender, EventArgs e)
        {
            var @char = sender as Character;
            OnPlayerLeave(@char.Player, e);
            @char.MapChanged -= Character_MapChanged;
        }

        private void Character_CharacterDie(object sender, EventArgs e)
        {
            var @char = sender as Character;
            OnPlayerDead(@char.Player, e);
            @char.CharacterDie -= Character_CharacterDie;
        }
    }
}


--file LuckyCoins.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;

namespace MuEmu.Events.LuckyCoins
{
    public class LuckyCoins
    {
        private Dictionary<Player, uint> _register;
        public static LuckyCoins Instance { get; set; }

        private LuckyCoins()
        {
            _register = new Dictionary<Player, uint>();
        }

        public static async Task<uint> Registered(Player plr)
        {
            if(Instance._register.ContainsKey(plr))
                return Instance._register[plr];

            return 0;
        }

        public static async Task<uint> Registre(Player plr)
        {
            var inv = plr.Character.Inventory;
            var luckyItemsPos = inv.FindAll(new ItemNumber(14, 100));
            var luckyItems = inv.Get(luckyItemsPos);
            var reg = Instance._register;

            if (!reg.ContainsKey(plr))
                reg.Add(plr, 0);

            foreach (var luckyCoin in luckyItems)
            {
                if(luckyCoin.Durability > 0)
                {
                    reg[plr] += luckyCoin.Durability;
                    await inv.Delete(luckyCoin);
                }
            }

            return reg[plr];
        }

        public static void Initialize()
        {
            if (Instance != null)
                throw new Exception("LuckyCoins Already Initialized!");

            Instance = new LuckyCoins();
        }
    }
}


--file BallsAndCows.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu.Events.Minigames
{
    internal class BallsAndCowsGame
    {
        private Player _player;
        readonly int[] hrValue = new int[] { 600, 500, 400, 320, 285 };
        public BallsAndCowsGame(Player plr)
        {
            _player = plr;
            Ball = new byte[5];
            Strikes = new byte[5];
            Numbers = new byte[15];
            Hidden = new byte[3];
        }

        public int State { get; internal set; }
        public byte[] Ball { get; internal set; }
        public byte[] Strikes { get; internal set; }
        public byte[] Numbers { get; internal set; }
        public byte[] Hidden { get; internal set; }
        public ushort Score { get; internal set; }

        internal void Start()
        {
            Array.Fill(Ball, (byte)0xff);
            Array.Fill(Strikes, (byte)0xff);
            Array.Fill(Numbers, (byte)0xff);
            FillRow();
            State = 1;
        }

        internal void FillRow()
        {
            var list = new List<byte> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
            for(var i = 0; i < 3; i++)
            {
                var index = Program.RandomProvider(list.Count);
                Hidden[i] = list[index];
                list.RemoveAt(index);
            }
        }

        internal void SetNumber(byte[] numbers)
        {
            var last = Numbers.Count(x => x != 0xff);
            if (last >= Numbers.Length)
                return;

            Numbers[last] = numbers[last];

            if ((last+1) % 3 == 0)
                Match();

            if (last + 1 >= Numbers.Length)
                State = 2;
        }

        internal void Match()
        {
            for(var i = 0; i < 5; i++)
            {
                var subGroup = Numbers.Skip(i * 3).Take(3);
                if (subGroup.Any(x => x == 0xff))
                    break;

                Strikes[i] = (byte)subGroup.Where((x, i) => Hidden[i] == x).Count();
                Ball[i] = (byte)subGroup.Where((x, i) => Hidden.Contains(x) && Hidden[i] != x).Count();
            }

            var sum = 0;
            sum = Strikes.Where(x => x != 0xff).Sum(x => x) * 40;
            sum = Ball.Where(x => x != 0xff).Sum(x => x) * 10;

            var homeRun = Strikes.ToList().FindIndex(x => x == 3);

            if (homeRun != -1)
            {
                sum += hrValue[homeRun];
                State = 2;
            }

            Score = (ushort)sum;
        }
    }

    internal class BallsAndCows : MiniGame<BallsAndCowsGame>
    {
        public override BannerType GetBanner() => BannerType.BallsAndCows;
        public BallsAndCows(string file) : base(file) { }
    }
}


--file JeweldryBingo.cs
﻿using MU.Network.Event;
using MU.Resources;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu.Events.Minigames
{
    internal class JeweldryBingoCell
    {
        public JBType Type { get; set; } = JBType.Empty;
        public bool Selected { get; set; }

        public JBType Value => Type | (JBType)(Selected ? 0xF0 : 0x00);
    }
    internal class JeweldryBingoGame
    {
        private List<JeweldryBingoCell> _board = new List<JeweldryBingoCell>();
        private Dictionary<JBType, byte> _abailableJewels = new Dictionary<JBType, byte>();
        private List<JBType> _pool = new List<JBType>();
        private byte[] _matching = new byte[12];
        public JBState State { get; set; }
        public byte Box { get; set; }
        public ushort LuckyScore { get; set; }
        public ushort NormalScore { get; set; }
        public ushort JewelryScore { get; set; }

        public JeweldryBingoGame(Player plr)
        {
            for (int i = 0; i < 25; i++)
            {
                _board.Add(new JeweldryBingoCell());
            }

            _board[12].Selected = true;

            for (var i = 0; i < 6; i++)
            {
                _abailableJewels.Add((JBType)i, 4);
            }

            State = JBState.Open;
        }

        public JBType[] GetGrid()
        {
            return _board.Select(x => x.Value).ToArray();
        }

        public byte[] AvailableJewels => _abailableJewels.Values.ToArray();

        public JBType CurrentJewel => _pool.First();
        public byte LeftJewels => (byte)_pool.Count;

        internal void Place(byte slot, JBType jewelType)
        {
            if (slot == 12 || slot >= _board.Count)
                return;

            if (_board[slot].Type != JBType.Empty)
                return;

            if (!_abailableJewels.ContainsKey(jewelType) || _abailableJewels[jewelType] == 0)
                return;

            _abailableJewels[jewelType]--;
            _board[slot].Type = jewelType;
        }

        internal void AutoPlace()
        {
            while (AvailableJewels.Sum(x => x) > 0)
            {
                var abilableTypes = _abailableJewels.Where(x => x.Value > 0).Select(x => x.Key);
                var placeType = abilableTypes.ElementAt(Program.RandomProvider(abilableTypes.Count()));

                Place((byte)Program.RandomProvider(25), placeType);
            }
        }

        internal void SelectBox(byte box)
        {
            Box = box;
            _abailableJewels.Clear();
            for (var i = 0; i < 14;)
            {
                var jewelType = (JBType)Program.RandomProvider(6);
                var contains = _abailableJewels.ContainsKey(jewelType);
                if (!contains)
                {
                    _abailableJewels.Add(jewelType, 1);
                    _pool.Add(jewelType);
                    i++;
                }
                else if (contains && _abailableJewels[jewelType] < 4)
                {
                    _abailableJewels[jewelType]++;
                    _pool.Add(jewelType);
                    i++;
                }
            }
        }

        internal byte[] GetMatching()
        {
            //horizontal
            for (var i = 0; i < 5; i++)
            {
                var bingo = true;
                for (var j = 0; j < 5; j++)
                    bingo &= _board[i + j * 5].Selected;

                if (bingo && _matching[i] != 1)
                {
                    _matching[i] = 1;

                    JewelryScore -= 180;
                    if (i == 2)
                    {
                        LuckyScore += 312;
                    }
                    else
                    {
                        NormalScore += 240;
                        JewelryScore -= 45;
                    }
                }
            }

            //Vertical
            for (var i = 0; i < 5; i++)
            {
                var bingo = true;
                for (var j = 0; j < 5; j++)
                    bingo &= _board[i * 5 + j].Selected;

                if (bingo && _matching[i + 5] != 1)
                {
                    _matching[i + 5] = 1;

                    JewelryScore -= 180;
                    if (i == 2)
                    {
                        LuckyScore += 312;
                    }
                    else
                    {
                        NormalScore += 240;
                        JewelryScore -= 45;
                    }
                }
            }

            // Diagonal 1
            {
                var bingo = true;
                for (var j = 0; j < 5; j++)
                    bingo &= _board[j * 5 + j].Selected;

                if (bingo && _matching[10] != 1)
                {
                    _matching[10] = 1;
                    LuckyScore += 312;
                    JewelryScore -= 180;
                }
            }

            // Diagonal 2
            {
                var bingo = true;
                for (var j = 0; j < 5; j++)
                    bingo &= _board[j * 5 + (4 - j)].Selected;

                if (bingo && _matching[11] != 1)
                {
                    _matching[11] = 1;
                    LuckyScore += 312;
                    JewelryScore -= 180;
                }
            }

            return _matching;
        }

        internal void SelectJewel(byte slot, JBType jewelType)
        {
            if (slot >= _board.Count || jewelType != CurrentJewel)
                return;

            _pool.RemoveAt(0);
            JewelryScore += 45;

            _board[slot].Selected = true;
        }

        internal Item GetReward()
        {
            var totalScore = LuckyScore + NormalScore + JewelryScore;
            if (totalScore < 700)
            {
                return new Item(7576);
            }
            else if (totalScore < 900)
            {
                return new Item(7577);
            }
            else if (totalScore < 1000)
            {
                return new Item(7578);
            }
            return new Item(7579);
        }
    }
    internal class JeweldryBingo : MiniGame<JeweldryBingoGame>
    {
        private Dictionary<Player, JeweldryBingoGame> _games = new Dictionary<Player, JeweldryBingoGame>();

        public JeweldryBingo(string file) : base(file)
        { }

        public override BannerType GetBanner() => BannerType.JeweldryBingo;
    }
}


--file MineSweeper.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using MU.Resources;
using MU.Network.Event;

namespace MuEmu.Events.Minigames
{
    internal class MineSweeperCell
    {
        private MineSweeperGame _game;
        private List<MineSweeperCell> EmptyCell = new List<MineSweeperCell>();
        private int _proximity = 0xff;
        public int X { get; private set; }
        public int Y { get; private set; }
        public int Proximity => Mark ? 0xFE : Mine ? 9 : GetProximity();
        public bool Mine { get; set; }
        public bool Hide { get; set; }
        public bool Mark { get; set; }
        public MineSweeperCell(MineSweeperGame game, int index)
        {
            _game = game;
            X = index % 8;
            Y = index / 8;
            Hide = true;
        }

        private int GetProximity()
        {
            if (Mine)
                return 0;

            if (_proximity != 0xff)
                return _proximity;

            _proximity = 0;
            for (var i = 0; i < 9; i++)
            {
                var x = X + i % 3 - 1;
                var y = Y + i / 3 - 1;
                if (x >= 0 && y >= 0 && x < 8 && y < 6)
                {
                    var index = x + y * 8;
                    if (_game._board[index].Mine)
                        _proximity++;
                    else
                        EmptyCell.Add(_game._board[index]);
                }
            }
            return _proximity;
        }
        public IEnumerable<MineSweeperCell> PropagateReveal()
        {
            List<MineSweeperCell> result = new List<MineSweeperCell>();

            if (!Hide)
                return result;

            Hide = false;
            result.Add(this);
            if (Proximity == 0)
            {
                result.AddRange(EmptyCell.Where(x => x.Proximity < 9).SelectMany(x => x.PropagateReveal()));
            }
            else if (Proximity < 9)
            {
                result.AddRange(EmptyCell.Where(x => x.Proximity == 0).SelectMany(x => x.PropagateReveal()));
            }

            return result;
        }

        public ushort Cell => (ushort)((Proximity << 8) + X + Y * 8);
        public ushort Score => (ushort)(Proximity * 10);
    }
    internal class MineSweeperGame
    {
        private Player _player;
        internal List<MineSweeperCell> _board = new List<MineSweeperCell>();
        private int _totalBombs = 0;

        public bool Finished { get; private set; }
        public bool Losed { get; private set; }
        public ushort Score { get; internal set; }
        public byte RemainMines => (byte)(_totalBombs - _board.Count(x => x.Mark));
        public ushort Correct => (ushort)_board.Where(x => x.Mark && x.Mine).Count();
        public ushort Incorrect => (ushort)_board.Where(x => x.Mark && !x.Mine).Count();
        public ushort TotalScore => (ushort)Math.Max(Score + Correct * 50 + Incorrect * -20 + (Losed ? -50 : 500), 0);

        public IEnumerable<MineSweeperCell> FailedBomb => _board.Where(x => x.Mark && !x.Mine);

        public MineSweeperGame(Player plr)
        {
            _player = plr;
            for (var i = 0; i < 6 * 8; i++)
            {
                _board.Add(new MineSweeperCell(this, i));
            }

            for (_totalBombs = 0; _totalBombs < 11;)
            {
                var pos = Program.RandomProvider(6 * 8);
                if (!_board[pos].Mine)
                {
                    _board[pos].Mine = true;
                    _totalBombs++;
                }
            }
        }

        public IEnumerable<ushort> GetBoard()
        {
            for (var i = 0; i < _board.Count; i++)
            {
                if (_board[i].Hide)
                    continue;

                yield return _board[i].Cell;
            }
        }

        internal IEnumerable<ushort> Reveal(byte cell)
        {
            if (_board[cell].Mine)
            {
                return Array.Empty<ushort>();
            }

            var reveal = _board[cell].PropagateReveal();
            Score += (ushort)reveal.Sum(x => x.Score);

            return reveal.Select(x => x.Cell);
        }

        internal byte Mark(byte cell)
        {
            _board[cell].Mark = !_board[cell].Mark;
            if (Correct == _totalBombs && Incorrect == 0)
            {
                Finish();
            }
            return (byte)(_board[cell].Mark ? 1 : 0);
        }

        internal ushort Finish(bool lose = false)
        {
            Finished = true;
            Losed = lose;
            _board.ForEach(x => x.Hide = false);
            return (ushort)(Score + Correct * 50 + Incorrect * -20 + (lose ? -50 : 500));
        }

        internal bool IsClear()
        {
            var hideCount = _board.Where(x => x.Hide).Count();
            if (hideCount == _totalBombs)
                Finish();

            if (Finished)
                return true;

            return false;
        }

        internal Item GetReward()
        {
            if (TotalScore <= 150)
            {
                return new Item(7542);
            }
            if (TotalScore <= 850)
            {
                return new Item(7543);
            }
            return new Item(7544);
        }
    }
    internal class MineSweeper : MiniGame<MineSweeperGame>
    {
        public override BannerType GetBanner() => BannerType.MineSweeper;
        public MineSweeper(string file) : base(file) { }
    }
}


--file MiniGame.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using MU.Resources.XML;
using MuEmu.Resources;

namespace MuEmu.Events.Minigames
{
    public class MiniGame<T> : Event
    {
        private Dictionary<Player, T> _games = new Dictionary<Player, T>();
        private MiniGameDto _config;

        public MiniGame(string file)
        {
            LoadConfig(file);
        }

        public void LoadConfig(string file)
        {
            _config = ResourceLoader.XmlLoader<MiniGameDto>(file);
            _openTime = TimeSpan.FromSeconds(_config.OpenTime);
            _closedTime = TimeSpan.FromSeconds(_config.ClosedTime);
        }
        public override Item GetItem(ushort mobLevel, Maps map)
        {
            if (Program.RandomProvider(10000) < _config.DropRate * 100)
                return new Item(_config.ItemDrop);

            return null;
        }

        public override void Initialize()
        {
            base.Initialize();

            Trigger(EventState.Open, TimeSpan.FromSeconds(_config.NoneTime));
        }

        public override void NPCTalk(Player plr)
        {
            throw new NotImplementedException();
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override bool TryAdd(Player plr)
        {
            throw new NotImplementedException();
        }

        public override void OnTransition(EventState NextState)
        {
            switch (NextState)
            {
                case EventState.Open:
                    Trigger(EventState.Closed, _openTime);
                    break;
                case EventState.Closed:
                    Trigger(EventState.Open, _closedTime);
                    break;
            }
        }
        public T GetGame(Player plr)
        {
            if (!_games.ContainsKey(plr))
            {
                var obj = (T)Activator.CreateInstance(typeof(T), plr);
                _games.Add(plr, obj);
                plr.OnStatusChange += Plr_OnStatusChange;
            }

            return _games[plr];
        }

        private void Plr_OnStatusChange(object sender, EventArgs e)
        {
            var plr = sender as Player;
            ClearGame(plr);
        }

        public void ClearGame(Player plr)
        {
            plr.OnStatusChange -= Plr_OnStatusChange;
            _games.Remove(plr);
        }
    }
}


--file MuRummy.cs
﻿using MU.Network.Event;
using MU.Resources;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WebZen.Util;

namespace MuEmu.Events.Minigames
{
    public class MuRummyGame
    {
        private Player _player;
        private List<MuRummyCardInfo> _specialCardDeck = new List<MuRummyCardInfo>();
        private List<MuRummyCardInfo> _cardDeck = new List<MuRummyCardInfo>();
        private List<MuRummyCardInfo> _playCard = new List<MuRummyCardInfo>();

        public byte State { get; internal set; }
        public byte CardCount => (byte)_cardDeck.Count;
        public ushort Score { get; internal set; }
        public byte SpecialCardCount => (byte)_specialCardDeck.Count;
        public byte Type { get; internal set; }
        public MuRummyCardInfo SpecialCard => _playCard[8];

        public MuRummyGame(Player player)
        {
            _player = player;
        }

        internal MuRummyCardInfo[] GetCardInfo()
        {
            return _playCard.Take(5).Append(SpecialCard).ToArray();
        }

        internal MuRummyCardInfo[] GetPlayedCard()
        {
            return _playCard.Skip(5).Take(3).Append(_playCard[9]).ToArray();
        }

        internal byte[] GetSlotStatus()
        {
            return new byte[] {
            0, 0, 0, 0, 0,
            0, 0, 0, (byte)(1-Type), (byte)(1-Type),
            };
        }

        internal void Start(byte type)
        {
            State = 1;
            Type = type;
            var list = new List<byte>();
            for(var i = 0; i < 24; i++)
            {
                list.Add((byte)i);
            }

            _cardDeck.Clear();
            while (list.Count > 0)
            {
                var position = Program.RandomProvider(list.Count);
                var element = list[position];
                list.RemoveAt(position);
                _cardDeck.Add(new MuRummyCardInfo
                {
                    Color = (byte)(element / 8 + 1),
                    Number = (byte)(element % 8 + 1),
                    Slot = 0
                });
            }

            if(Type == 1)
            {
                while (_specialCardDeck.Count < 3)
                {
                    _specialCardDeck.Add(new MuRummyCardInfo
                    {
                        Color = 4,
                        Number = (byte)(Program.RandomProvider(11) + 1),
                        Slot = 8,
                    });
                }
            }            
            
            for(var i = 0; i < 10; i++)
            {
                _playCard.Add(new MuRummyCardInfo { Slot = (byte)i });
            }
        }

        internal MuRummyCardInfo MovePlayCard(byte from, byte to)
        {
            var pcf = _playCard[from];
            var pct = _playCard[to];
            var empty = new MuRummyCardInfo { Slot = from, Color = 0xff, Number = 0xff};
            if(Type == 0 && from >= 7)
            {
                return empty;
            }
            if(Type == 1 && pcf.Color == 4 && (pcf.Number > 9 && to != 9))
            {
                return empty;
            }

            _playCard[to] = pcf;
            _playCard[from] = pct;
            return pcf;
        }

        internal MuRummyCardInfo ThrowPlayCard(byte from)
        {
            var pcf = _playCard[from];
            _playCard[from] = new MuRummyCardInfo { Slot = pcf.Slot };

            return _playCard[from];
        }

        internal void SetPlayCard(byte to, MuRummyCardInfo playCard)
        {
            _playCard[to] = playCard;
        }

        internal ushort Match()
        {
            var sort = _playCard
                .Skip(5)
                .Take(3)
                .Append(_playCard[9])
                .Where(x => x.Number != 0)
                .OrderBy(x => x.Number)
                .ToList();

            var lower = sort.First().Number;
            var color = sort.First().Color;
            var sameNumbers = sort.Count(x => x.Number == lower);
            var consecutive = sort.Select(x => x.Number).Distinct().Count(x => x == lower++);
            var sameColors = sort.Count(x => x.Color == color || x.Color == 4);
            var score = 0;

            for (var i = 5; i < 10; i++)
            {
                if (_playCard[i].Slot == i)
                    continue;

                var pcf = _playCard[i];
                var pct = _playCard[pcf.Slot];
                _playCard[pcf.Slot] = pcf;
                _playCard[i] = pct;
            }
            if (sameNumbers>2 || consecutive>2)
            {
                var x2Card = sort.Any(x => x.Number == 10);
                var changeColor = sort.Any(x => x.Number == 11);
                if (sameNumbers>2)
                {
                    var specialCard = sort.Take(sameNumbers).Any(x => x.Color == 4);
                    score = 10 + sort.First().Number * 10 + (specialCard?10:0) + (sameNumbers==4?10:0);
                } else
                {
                    var specialCard = sort.Take(consecutive).Any(x => x.Color == 4);
                    score = (sameColors>2 || changeColor) ? 40 : 0;
                    score += sort.First().Number * 10 + (specialCard ? 10 : 0);
                }
                foreach(var card in sort)
                {
                    ThrowPlayCard(card.Slot);
                }

                score *= x2Card?2:1;
            }

            Score += (ushort)score;

            return (ushort)score;
        }

        internal List<MuRummyCardInfo> Reveal()
        {
            var result = new List<MuRummyCardInfo>();
            for(var i = 0; i < 5 && _cardDeck.Count > 0; i++)
            {
                if(_playCard[i].Color == 0)
                {
                    _playCard[i] = _cardDeck[0];
                    _playCard[i].Slot = (byte)i;
                    result.Add(_playCard[i]);
                    _cardDeck.RemoveAt(0);
                }
            }

            if(Type == 1 && _specialCardDeck.Count > 0 && _playCard[8].Number == 0)
            {
                _playCard[8] = _specialCardDeck[0];
                result.Add(_playCard[8]);
                _specialCardDeck.RemoveAt(0);
            }

            while(result.Count < 6)
            {
                result.Add(new MuRummyCardInfo());
            }

            return result;
        }
    }
    public class MuRummy : MiniGame<MuRummyGame>
    {
        public MuRummy(string file) : base(file)
        { }
        public override BannerType GetBanner() => BannerType.MuRummy;
    }
}


--file MoonRabbit.cs
﻿using MU.Resources;
using MuEmu.Monsters;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu.Events.MoonRabbit
{
    public class MoonRabbit : Event
    {
        private Maps[] _eventMaps = new Maps[] { Maps.Noria, Maps.Davias, Maps.Lorencia, Maps.Elbeland };
        private Dictionary<Maps, List<Monsters.Monster>> _monsters = new Dictionary<Maps, List<Monsters.Monster>>();
        private Maps _currentEventMap;

        public MoonRabbit()
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(MoonRabbit));
        }

        public override void NPCTalk(Player plr)
        {
            throw new NotImplementedException();
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            var mob = sender as Monster;
            mob.Active = false;
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void Initialize()
        {
            base.Initialize();
            Trigger(EventState.Open);
        }

        public override void Update()
        {
            switch(CurrentState)
            {
                case EventState.Playing:
                    if (_monsters.ContainsKey(_currentEventMap))
                    {
                        if(!_monsters[_currentEventMap].Any(x => x.Active))
                        {
                            Trigger(EventState.Closed);
                        }
                    }
                    break;
            }
            base.Update();
        }

        public override void OnTransition(EventState NextState)
        {
            switch(NextState)
            {
                case EventState.Open:
                    // rabbits
                    _monsters = Monsters.MonstersMng.Instance.Monsters
                        .Where(x => x.Info.Monster == 413)
                        .GroupBy(x => x.MapID)
                        .ToDictionary(x => x.Key, x => x.ToList());

                    foreach(var mob in _monsters.Values.SelectMany(x => x))
                    {
                        mob.Die += OnMonsterDead;
                        mob.Active = false;
                    }
                    Trigger(EventState.Playing);
                    break;
                case EventState.Playing:
                    _currentEventMap = _eventMaps.ElementAt(Program.RandomProvider(_eventMaps.Length));
                    if(_monsters.ContainsKey(_currentEventMap))
                        _monsters[_currentEventMap].ForEach(x => x.Active = true);

                    Program.NoEventMapAnoucement($"[Moon Rabbit] Lunar Rabits invadieron {_currentEventMap}");
                    break;
                case EventState.Closed:
                    Trigger(EventState.Playing, TimeSpan.FromDays(1));

                    Program.NoEventMapAnoucement($"[Moon Rabbit] Invasion en {_currentEventMap} repelida");
                    break;
            }
        }

        public override bool TryAdd(Player plr)
        {
            throw new NotImplementedException();
        }
    }
}


--file BattleOfSelupan.cs
﻿using MU.Network.Game;
using MU.Resources;
using MU.Resources.XML;
using MuEmu.Monsters;
using MuEmu.Resources.Map;
using MuEmu.Util;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu.Events.Raklion
{
    public class BattleOfSelupan : Event
    {
        private bool firstSkill;
        private Monster _selupan;
        private List<Monster> _spiderEggs;
        private List<Monster> _summonMonster;
        private MapInfo _map;

        private DateTime _nextSkill;
        private List<List<MonsterSpell>> _selupanPatters = new List<List<MonsterSpell>>();

        public BattleOfSelupan()
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(BattleOfSelupan));

            _map = Resources.ResourceCache.Instance.GetMaps()[Maps.Selupan];
            _map.PlayerJoins += BattleOfSelupan_PlayerJoins;
            _map.PlayerLeaves += BattleOfSelupan_PlayerLeaves;

            var xml = Resources.ResourceLoader.XmlLoader<PatternsDto>(Program.XMLConfiguration.Files.DataRoot+ Program.XMLConfiguration.Files.SelupanPatterns);
            foreach(var x in xml.Pattern.OrderBy(x => x.Number))
            {
                _selupanPatters.Add(x.Skill.ToList());
            }
        }

        private void BattleOfSelupan_PlayerLeaves(object sender, EventArgs e)
        {
            var plr = sender as Player;
            var info = _players.Find(x => x.Player == plr);
            if (info != null)
            {
                info.Eventer = false;
            }
        }

        private void BattleOfSelupan_PlayerJoins(object sender, EventArgs e)
        {
            var plr = sender as Player;

            var info = _players.Find(x => x.Player == plr);
            if(info != null)
            {
                info.Eventer = true;
            }
            else
            {
                _players.Add(new PlayerEventInfo { Player = plr, Eventer = true, Score = 0 });
            }
            if(_players.Count(x => x.Eventer == true) == 1)
                Trigger(EventState.Playing, TimeSpan.FromSeconds(60));
        }

        public override void Initialize()
        {
            base.Initialize();
            Trigger(EventState.Closed);
        }

        private void LinkMonsters()
        {
            if (_selupan != null)
                return;

            _selupan = _map.Monsters.Find(x => x.Info.Monster == 459);
            _selupan.Die += _selupan_Die;
            _selupan.Active = false;
            _selupan.Type = ObjectType.NPC;

            _summonMonster = _map.Monsters.FindAll(x => (x.Info.Monster == 457 || x.Info.Monster == 458));
            _spiderEggs = _map.Monsters.FindAll(x => x.Info.Monster >= 460 && x.Info.Monster <= 462);
            foreach (var mon in _summonMonster)
            {
                mon.Active = false;
                mon.Die += OnMonsterDead;
            }
            foreach (var mon in _spiderEggs)
            {
                mon.Active = false;
                mon.Die += spiderEggs_Die;
            }
        }

        private void spiderEggs_Die(object sender, EventArgs e)
        {
            var mon = (Monster)sender;
            mon.Active = false;
            if (_spiderEggs.Count(x => x.Active) == 0)
            {
                _selupan.Type = ObjectType.Monster;
                _selupan.Active = true;
            }
        }

        private void _selupan_Die(object sender, EventArgs e)
        {
            _selupan.Active = false;
            Trigger(EventState.Closed);
        }

        public override void NPCTalk(Player plr)
        {
            throw new NotImplementedException();
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            var mon = sender as Monster;
            mon.Active = false;
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnTransition(EventState NextState)
        {
            switch(NextState)
            {
                case EventState.Closed:
                    LinkMonsters();
                    _summonMonster.ForEach(x => x.Active = false);
                    _spiderEggs.ForEach(x => x.Active = false);
                    _selupan.Active = false;
                    Trigger(EventState.Open, TimeSpan.FromSeconds(60));
                    break;
                case EventState.Open:
                    break;
                case EventState.Playing:
                    firstSkill = false;
                    _spiderEggs.ForEach(x => x.Active = true);
                    break;
            }
        }

        public override bool TryAdd(Player plr)
        {
            throw new NotImplementedException();
        }

        private void UpdateSelupan()
        {
            if (!_selupan.Active || _nextSkill > DateTime.Now)
                return;

            var currPatter = (int)((1.0f - _selupan.Life / _selupan.MaxLife) * _selupanPatters.Count);
            var patter = _selupanPatters[currPatter];
            var randomSkill = Program.RandomProvider(patter.Count);
            var skill = patter[randomSkill];

            if (!firstSkill)
            {
                skill = MonsterSpell.Fall;
                firstSkill = true;
            }

            _=_selupan.ViewPort.Select(x => x.Session).SendAsync(new SMonsterSkillS9Eng
                {
                MonsterSkillNumber = (ushort)skill,
                ObjIndex = _selupan.Index,
                TargetObjIndex = _selupan.Target?.ID??0xffff
            });

            switch(skill)
            {
                case MonsterSpell.Recall:
                    _summonMonster.ForEach(x => x.Active = true);
                    break;
                case MonsterSpell.Invincible:
                    _spiderEggs.ForEach(x => x.Active = true);
                    _selupan.Type = ObjectType.NPC;
                    break;
                case MonsterSpell.PoisonBall:
                    _selupan.Spells.AttackSend(Spell.SelupanPoison, _selupan.Target?.ID??0xffff, true);
                    _selupan.Target?.Character.Spells.SetBuff(SkillStates.Poison, TimeSpan.FromSeconds(10), _selupan);
                    break;
                case MonsterSpell.FrostStorm:
                    _selupan.Spells.AttackSend(Spell.SelupanIceStorm, _selupan.Target?.ID ?? 0xffff, true);
                    _selupan.Target?.Character.Spells.SetBuff(SkillStates.Ice, TimeSpan.FromSeconds(10), _selupan);
                    break;
                case MonsterSpell.FrostShock:
                    _selupan.Spells.AttackSend(Spell.SelupanIceStrike, _selupan.Target?.ID ?? 0xffff, true);
                    _selupan.Target?.Character.Spells.SetBuff(SkillStates.Ice, TimeSpan.FromSeconds(10), _selupan);
                    break;
                case MonsterSpell.Fall:
                    _selupan.Spells.AttackSend(Spell.SelupanFirstSkill, _selupan.Target?.ID ?? 0xffff, true);
                    break;
                case MonsterSpell.Healing:
                    _selupan.Life += (_selupan.MaxLife-_selupan.Life)*0.1f;
                    break;
                case MonsterSpell.Teleportation:

                    _selupan.Warp(Maps.Selupan,
                        (byte)(147 + Program.RandomProvider(6, -6)),
                        (byte)(29 + Program.RandomProvider(6, -6))
                        );
                    break;
            }

            var maxDelay = (int)MathF.Max(10000.0f * _selupan.Life / _selupan.MaxLife, 3000.0f);
            var delay = Program.RandomProvider(maxDelay, 300);
            _nextSkill = DateTime.Now.AddMilliseconds(delay);

            _logger.Debug("Selupan use {0},{2},{3}, next attack in {1}ms", skill, delay, _selupan.Position.X, _selupan.Position.Y);
        }

        public override void Update()
        {
            base.Update();
            switch(CurrentState)
            {
                case EventState.Open:
                    break;
                case EventState.Playing:
                    UpdateSelupan();
                    if (!_players.Any(x => x.Eventer))
                        Trigger(EventState.Closed);
                    break;
            }
        }
    }
}


--file UnityBattleField.cs
﻿using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu.Events.UnityBattleField
{
    public class UnityBattleField : Event
    {
        public UnityBattleField()
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(UnityBattleField));
        }

        public override void NPCTalk(Player plr)
        {
            throw new NotImplementedException();
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnTransition(EventState NextState)
        {
            throw new NotImplementedException();
        }

        public override bool TryAdd(Player plr)
        {
            throw new NotImplementedException();
        }
    }
}


--file WhiteWizard.cs
﻿using MU.Resources;
using MuEmu.Monsters;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;

namespace MuEmu.Events.WhiteWizard
{
    public class WhiteWizard : Event
    {
        private Maps _eventMap;
        private Dictionary<Maps, Rectangle> _eventSpot = new Dictionary<Maps, Rectangle>()
        {
            {Maps.Lorencia, new Rectangle(66,44,125,153)},
            {Maps.Davias, new Rectangle(111,14,121,111)},
            {Maps.Noria, new Rectangle(136,53,87,128)},
        };
        private Dictionary<Maps, Point[]> _eventDest = new Dictionary<Maps, Point[]>()
        {
            { Maps.Lorencia, new Point[]{ new Point(133, 79), new Point(87, 126), new Point(133, 178), new Point(180, 126) } },
            { Maps.Davias, new Point[]{ new Point(164, 42), new Point(221, 85), new Point(164, 42), new Point(221, 85) } },
            { Maps.Noria, new Point[]{ new Point(160, 45), new Point(160, 45), new Point(152, 117), new Point(209, 133) } }
        };
        private List<Monster> _monsters = new List<Monster>();
        private Monster _whiteWizard;

        public WhiteWizard()
        {
            _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(WhiteWizard));
        }

        public override void Initialize()
        {
            base.Initialize();
            Trigger(EventState.Open);
        }

        public override void NPCTalk(Player plr)
        {
            throw new NotImplementedException();
        }

        public override void OnMonsterDead(object sender, EventArgs eventArgs)
        {
            var mob = sender as Monster;
            mob.Active = false;
            if (mob.Info.Monster == 135)
            {
                _=Program.GlobalAnoucement($"{mob.Killer.Character.Name} as defeated the Lorencia White Wizard corps!");
            }
        }

        public override void OnPlayerDead(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnPlayerLeave(object sender, EventArgs eventArgs)
        {
            throw new NotImplementedException();
        }

        public override void OnTransition(EventState NextState)
        {
            switch(NextState)
            {
                case EventState.Open:
                    {
                        _whiteWizard = MonstersMng.Instance.Monsters.FirstOrDefault(x => x.Info.Monster == 135);
                        var Orcs = MonstersMng.Instance.Monsters.Where(x => x.Info.Monster == 136 || x.Info.Monster == 137);
                        if (_whiteWizard != null)
                            _monsters.Add(_whiteWizard);

                        _monsters.AddRange(Orcs);

                        foreach (var Mob in _monsters)
                        {
                            Mob.Active = false;
                            Mob.Die += OnMonsterDead;
                        }
                        if (_whiteWizard == null)
                        {
                            Trigger(EventState.None);
                            return;
                        }

                        _whiteWizard.Die += OnMonsterDead;
                        Trigger(EventState.Playing);
                    }
                    break;
                case EventState.Playing:
                    {
                        _eventMap = _eventSpot.Keys.ElementAt(Program.RandomProvider(_eventSpot.Keys.Count));
                        var rect = _eventSpot[_eventMap];
                        var randomSpawX = (byte)Program.RandomProvider(rect.Right, rect.Left);
                        var randomSpawY = (byte)Program.RandomProvider(rect.Bottom, rect.Top);
                        var map =Resources.ResourceCache.Instance.GetMaps()[_eventMap];
                        do
                        {
                            randomSpawX = (byte)Program.RandomProvider(rect.Right, rect.Left);
                            randomSpawY = (byte)Program.RandomProvider(rect.Bottom, rect.Top);
                        } while (map.GetAttributes(new Point(randomSpawX, randomSpawY)).Contains(MapAttributes.Safe));

                        foreach (var mob in _monsters)
                        {
                            mob.Active = true;

                            if (mob.Info.Monster == 135)
                            {
                                mob.Warp(_eventMap, randomSpawX, randomSpawY);
                            }
                            else
                            {
                                mob.Warp(
                                    _eventMap, 
                                    (byte)Program.RandomProvider(randomSpawX + 5, randomSpawX - 5),
                                    (byte)Program.RandomProvider(randomSpawY + 5, randomSpawY - 5)
                                    );
                            }
                        }
                        _logger.Information("Started in {0},{1}", randomSpawX, randomSpawY);
                        _ = Program.GlobalAnoucement($"The White Wizard and his corps has invaded {_eventMap}");
                        Trigger(EventState.Closed, TimeSpan.FromDays(1));
                    }
                    break;
                case EventState.Closed:
                    Trigger(EventState.Playing);
                    break;
            }
        }

        public override bool TryAdd(Player plr)
        {
            throw new NotImplementedException();
        }
    }
}


--file Extensions.cs
﻿using MuEmu.Network;
using Serilog;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu
{
    public static class Extensions
    {
        public static ILogger ForAccount(this ILogger logger, int id, string user)
        {
            return logger
                .ForContext("AID", id)
                .ForContext("AUser", user);
        }

        public static ILogger ForAccount(this ILogger logger, GSSession session)
        {
            var plr = session.Player;
            var acc = plr?.Account??null;
            return logger.ForAccount(session.ID, acc?.Nickname??"");
        }

        public static T AnonymousMap<T>(T dest, object src)
        {
            foreach (var ip in src.GetType().GetProperties())
            {
                var pInfo = dest.GetType()
                    .GetProperties()
                    .Where(x => x.Name == ip.Name)
                    .FirstOrDefault();

                try
                {
                    if (pInfo != null)
                        pInfo.SetValue(dest, ip.GetValue(src));
                }catch(Exception)
                { }
            }

            return dest;
        }
    }
}


--file Friends.cs
﻿using MU.DataBase;
using MuEmu.Entity;
using MU.Resources;
using MU.Network.Game;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu
{
    public class Friends
    {
        public static bool AddSet;
        private Character character;
        private List<Network.Data.FriendDto> _friends;
        private List<MemoDto> _memos;

        public Friends(Character character, CharacterDto characterDto)
        {
            this.character = character;
            var ids = characterDto.Friends.Select(
                x => x.FriendId == characterDto.CharacterId ? x.CharacterId : x.FriendId
                );

            using (var db = new GameContext())
            {
                var chars = ids.Select(x => db.Characters.First(z => z.CharacterId == x));
                var accs = chars.Select(x => db.Accounts.First(z => z.AccountId == x.AccountId));
                var info = from c in chars
                           from a in accs
                           where c.AccountId == a.AccountId
                           select new { c.CharacterId, c.Name, a.ServerCode, a.IsConnected };

                _friends = info.Select(x =>
                new Network.Data.FriendDto
                {
                    Name = x.Name,
                    Server = (byte)(x.IsConnected ? x.ServerCode : 255)
                }).ToList();

                var result = from f in db.Friends
                             from c in db.Characters
                             where c.CharacterId == f.FriendId && c.CharacterId == character.Id
                             select new SFriendAddSin { Name = c.Name };

                foreach (var msg in result)
                    character.Player.Session.SendAsync(msg).Wait();
            }

            _memos = characterDto.Memos;

            character.Player.Session.SendAsync(new SFriends {
                Friends = _friends.ToArray(),
                MailTotal = 50,
                MemoCount = (byte)_memos.Count(),
            }).Wait();
        }

        public async void ConnectFriend(string name, byte server)
        {
            var result = _friends.FirstOrDefault(x => x.Name == name);
            if (result == null)
                return;

            result.Server = server;

            character.Player.Session.SendAsync(new SFriends
            {
                Friends = _friends.ToArray(),
                MailTotal = 50,
                MemoCount = (byte)_memos.Count(),
            }).Wait();

            await character.Player.Session.SendAsync(new SNotice(NoticeType.Blue, name + " is now Online"));
        }

        public async void DisconnectFriend(string name)
        {
            var result = _friends.FirstOrDefault(x => x.Name == name);
            if (result == null)
                return;

            result.Server = 255;

            character.Player.Session.SendAsync(new SFriends
            {
                Friends = _friends.ToArray(),
                MailTotal = 50,
                MemoCount = (byte)_memos.Count(),
            }).Wait();

            await character.Player.Session.SendAsync(new SNotice(NoticeType.Blue, name + " is now Offline"));
        }

        internal void AddFriend(string name)
        {
            using (var db = new GameContext())
            {
                var @char = db.Characters.First(x => x.Name == name);
                @char.Account = db.Accounts.First(x => x.AccountId == @char.AccountId);

                if (@char.CharacterId == character.Id)
                {
                    character.Player.Session.SendAsync(new SFriendAddReq
                    {
                        Name = @char.Name,
                        Result = 5,
                        State = 255
                    }).Wait();
                    return;
                }

                var res = from f in db.Friends
                          where (f.CharacterId == character.Id || f.FriendId == character.Id) && (f.CharacterId == @char.CharacterId || f.FriendId == @char.CharacterId)
                          select f;

                if (res.Count() != 0)
                {
                    character.Player.Session.SendAsync(new SFriendAddReq
                    {
                        Name = @char.Name,
                        Result = 5,
                        State = 255
                    }).Wait();
                    return;
                }

                db.Friends.Add(new MU.DataBase.FriendDto
                {
                    CharacterId = character.Id,
                    FriendId = @char.CharacterId,
                    State = 0,
                });

                db.SaveChanges();

                character.Player.Session.SendAsync(new SFriendAddReq
                {
                    Name = @char.Name,
                    Result = 1,
                    State = 255
                }).Wait();
            }
            AddSet = true;
        }

        internal void AcceptFriend(string name, byte Result)
        {
            using (var db = new GameContext())
            {
                var @char = db.Characters.First(x => x.Name == name);
                var frdDto = db.Friends.First(x =>
                x.FriendId == character.Id && x.CharacterId == @char.CharacterId);

                if(Result == 1)
                {
                    frdDto.State = 1;
                }else
                {
                    db.Friends.Remove(frdDto);
                }

                db.SaveChanges();
                character.Player.Session.SendAsync(new SFriendAddReq
                {
                    Name = @char.Name,
                    Result = 1,
                    State = (byte)(@char.Account.IsConnected ? @char.Account.ServerCode : 255)
                }).Wait();

                if(@char.Account.IsConnected)
                {
                    var session = Program.server.Clients.FirstOrDefault(x => x.Player.Character.Name == @char.Name);
                    if(session != null)
                    {
                        session.SendAsync(new SFriendAddReq
                        {
                            Name = character.Name,
                            Result = 1,
                            State = (byte)Program.ServerCode
                        }).Wait();
                    }
                }
            }
        }

        public void Update()
        {
            if (!AddSet)
                return;

            using (var db = new GameContext())
            {
                var result = from f in db.Friends
                             from c in db.Characters
                             where c.CharacterId == f.FriendId && c.CharacterId == character.Id
                             select new SFriendAddSin { Name = c.Name };

                foreach (var msg in result)
                    character.Player.Session.SendAsync(result).Wait();
            }
        }
    }
}


--file ExpManagement.cs
﻿using MU.Network.Game;
using MuEmu.Network;
using MuEmu.Util;
using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu.Game
{
    public class ExpManagement
    {
        private float addEXPRate;
        private float experienceRate;
        private float goldChannel;
        private float baseExpRate;

        public float BaseExpRate
        {
            get => baseExpRate; 
            set => baseExpRate = value;
        }
        public float AddEXPRate
        {
            get => addEXPRate;
            set
            {
                addEXPRate = value;
                SendExpInfo();
            }
        }
        public float ExperienceRate
        {
            get => experienceRate;
            set
            {
                if (value != experienceRate)
                {
                    experienceRate = value;
                    SendExpInfo();
                }
            }
        }
        public float GoldChannel
        {
            get => goldChannel;
            set
            {
                goldChannel = value;
                SendExpInfo();
            }
        }

        public float FullExperate => (1.0f+BaseExpRate) * (1.0f + AddEXPRate) * (1.0f + ExperienceRate) * (1.0f + GoldChannel);

        public async void SendExpInfo()
        {
            if (Program.server != null)
                await Program.server.Clients.SendAsync(new SExpEventInfo
                {
                    PCBangRate = (ushort)(AddEXPRate * 100.0f),
                    EventExp = (ushort)(ExperienceRate * 100.0f),
                    GoldChannel = (ushort)(GoldChannel * 100.0f),
                });
        }
        public async void SendExpInfo(GSSession session)
        {
            await session.SendAsync(new SExpEventInfo
            {
                PCBangRate = (ushort)(AddEXPRate * 100.0f),
                EventExp = (ushort)(ExperienceRate * 100.0f),
                GoldChannel = (ushort)(GoldChannel * 100.0f),
            });
        }
    }
}


--file Gens.cs
﻿using MU.DataBase;
using MU.Resources;
using MuEmu.Entity;
using MU.Network.Game;
using System.Linq;
using System;
using System.Collections.Generic;
using System.Text;
using MU.Network.GensSystem;

namespace MuEmu
{
    public class Gens
    {
        private static Dictionary<GensType, int> _contribution;
        private static readonly Dictionary<int, int> _classSuperior = new Dictionary<int, int>
        {
            { 1, 1 },
            { 5, 2 },
            { 10, 3 },
            { 30, 4 },
            { 50, 5 },
            { 100, 6 },
            { 200, 7 },
            { 300, 8 },
            { 9999, 9 },
        };
        private static readonly Dictionary<int, int> _class = new Dictionary<int, int>
        {
            { 6000, 10 },
            { 3000, 11 },
            { 1500, 12 },
            { 500, 13 },
            { 0, 14 }
        };
        private Player player;
        public int Contribution { get; set; }
        public GensType Influence { get; internal set; }
        public int Ranking { get; internal set; }
        public int Class { get; internal set; }

        public static void Initialize()
        {
            _contribution = new Dictionary<GensType, int>();
            /*using(var db = new GameContext())
            {

            }*/
        }
        public static void Update()
        {
            
        }

        public Gens(Character @char, CharacterDto dto)
        {
            player = @char.Player;
            if(dto.Gens == null)
            {
                Influence = GensType.None;
                Class = 14;
                Ranking = 9999;
                Contribution = 0;
                return;
            }
            Influence = (GensType)dto.Gens.Influence;
            Ranking = dto.Gens.Ranking;
            Class = dto.Gens.Class;
            Contribution = dto.Gens.Contribution;
        }

        internal void SendMemberInfo()
        {
            var nextCP = 0;
            if (Contribution < 9999)
            {
                if (Class < 9)
                    Class = 14;

                nextCP = _class.First(x => x.Value == Class - 1).Key;
            }else
            {
                nextCP = 10000;
            }

            player.Session.SendAsync(new SGensSendInfoS9
            {
                Class = Class,
                ContributePoint = Contribution,
                Influence = Influence,
                NextContributePoint = nextCP,
                Ranking = Ranking
            }).Wait();
        }

        public void NPCTalk(ushort npc)
        {
            var obj = new SNPCDialog
            {
                Contribution = (uint)Contribution,
                NPC = npc,
            };

            player.Session.SendAsync(obj).Wait();
        }

        internal void UpdateInfo(GensDto dto)
        {
            Ranking = dto.Ranking;
        }

        internal void Join(GensType influence)
        {
            Influence = influence;
            SendMemberInfo();
        }
        internal void Leave()
        {
            Influence = GensType.None;
            Contribution = 0;
            Ranking = 9999;
            SendMemberInfo();
        }
    }
}


--file GremoryCase.cs
﻿using MU.DataBase;
using MU.Network.Game;
using MU.Resources;
using MuEmu.Entity;
using MuEmu.Util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu
{
    internal class  GremoryCaseItem
    {
        public GremoryStorage RewardInventory { get; set; }
        public GremorySource RewardSource { get; set; }
        public uint ItemGUID { get; set; }
        public uint AuthCode { get; set; }
        public DateTime ExpireTime { get; set; }
        public Item Item { get; set; }
    }
    public class GremoryCase
    {
        public const int MaxItems = 50;
        private bool _sended = false;

        private List<GremoryCaseItem> _items = new List<GremoryCaseItem>();
        public Character Character { get; private set; }

        public GremoryCase(Character @char, CharacterDto dto)
        {
            Character = @char;
            _items = dto.GremoryCases.Select(x => new GremoryCaseItem
            {
                AuthCode = x.Auth,
                ExpireTime = x.ExpireTime,
                ItemGUID = (uint)x.GiftId, //x.ItemGUID,
                RewardInventory = (GremoryStorage)x.Inventory,
                RewardSource = (GremorySource)x.Source,
                Item = new Item(x.ItemNumber, Options: new { x.Luck, Option28 = x.Option, x.Skill, x.Plus, x.OptionExe }),
            }).ToList();

            CheckIsInStorageItemAboutToExpire();
            CheckStorageExpiredItems();
            CheckInventoryCount();
        }

        public void CheckStorageExpiredItems()
        {
            var items = _items
                .Where(x => x.ExpireTime < DateTime.Now)
                .Select(x => x.ItemGUID)
                .ToList();

            items.ForEach(x => RemoveItem(x));
        }

        public async void CheckIsInStorageItemAboutToExpire()
        {
            var nextWeek = DateTime.Now.AddDays(7);
            var items = _items.Count(x => x.ExpireTime < nextWeek && x.ExpireTime > DateTime.Now);
            if(items != 0)
            {
                await Character.Player.Session.SendAsync(new SGremoryCaseNotice
                {
                    Status = GremoryNotice.ItemAboutToExpire,
                });
            }
        }

        public async void CheckInventoryCount()
        {
            var c1 = _items.Count(x => x.RewardInventory == GremoryStorage.Character);
            var c2 = _items.Count(x => x.RewardInventory == GremoryStorage.Server);

            if ((c1 >= MaxItems-5 && c1 < MaxItems) || (c2 >= MaxItems - 5 && c2 < MaxItems))
            {
                await Character.Player.Session.SendAsync(new SGremoryCaseNotice
                {
                    Status = GremoryNotice.InventoryToBeFilled,
                });
            }else if(c1 >= MaxItems || c2 >= MaxItems)
            {
                await Character.Player.Session.SendAsync(new SGremoryCaseNotice
                {
                    Status = GremoryNotice.InventoryFull,
                });
            }
        }

        public async void SendList()
        {
            if (_sended)
                return;

            _sended = true;

            await Character.Player.Session.SendAsync(new SGremoryCaseList 
            { 
                List = _items.Select(x => new GCItemDto 
                {
                    AuthCode = x.AuthCode, 
                    ExpireTime = (uint)x.ExpireTime.ToTimeT(), 
                    ItemGUID = x.ItemGUID, 
                    ItemInfo = x.Item.GetBytes(), 
                    RewardInventory = x.RewardInventory, 
                    RewardSource = x.RewardSource 
                }).ToArray() 
            });
        }

        public async void AddItem(Item it, DateTime ExpireTime, GremoryStorage storage, GremorySource source)
        {
            using(var db = new GameContext())
            {
                var tmp = new GremoryCaseDto
                {
                    AccountId = Character.Account.ID,
                    Auth = 0,//???
                    CharacterId = null,
                    Durability = it.Durability,
                    ExpireTime = ExpireTime,
                    HarmonyOption = it.Harmony,
                    Inventory = (byte)storage,
                    ItemNumber = it.Number,
                    Luck = it.Luck,
                    Option = it.Option28,
                    OptionExe = it.OptionExe,
                    Plus = it.Plus,
                    Skill = it.Skill,
                    Source = (byte)source,
                };

                if(storage == GremoryStorage.Character)
                {
                    tmp.CharacterId = Character.Id;
                }

                db.GremoryCase.Add(tmp);
                db.SaveChanges();

                await Character.Player.Session.SendAsync(new SGremoryCaseReceiveItem
                {
                    Item = new GCItemDto
                    {
                        AuthCode =tmp.Auth,
                        ExpireTime = (uint)tmp.ExpireTime.ToTimeT(),
                        ItemGUID = (uint)tmp.GiftId,
                        RewardInventory = storage,
                        RewardSource = source,
                        ItemInfo = it.GetBytes()
                    }
                });

                _items.Add(new GremoryCaseItem
                {
                    AuthCode = tmp.Auth,
                    ExpireTime = tmp.ExpireTime,
                    Item = it,
                    ItemGUID = (uint)tmp.GiftId,
                    RewardInventory = storage,
                    RewardSource = source,
                });
            }
        }

        public async void RemoveItem(uint GUID)
        {
            var it = _items.First(x => x.ItemGUID == GUID);
            _items.Remove(it);

            await Character.Player.Session.SendAsync(new SGremoryCaseDelete
            {
                AuthCode = it.AuthCode,
                ItemGUID = it.ItemGUID,
                ItemNumber = it.Item.Number,
                StorageType = it.RewardInventory,
            });

            using (var db = new GameContext())
            {
                var itDB = db.GremoryCase.First(x => x.GiftId == GUID);
                db.GremoryCase.Remove(itDB);
                db.SaveChanges();
            }
        }

        internal Item GetItem(GremoryStorage inventory, uint slot)
        {
            return _items.FirstOrDefault(x => x.RewardInventory == inventory && slot == x.ItemGUID)?.Item??null;
        }
    }
}


--file Guild.cs
﻿using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using MU.Network.Guild;
using MuEmu.Network.Data;
using Serilog;
using Serilog.Core;
using MuEmu.Entity;
using MU.DataBase;
using MU.Network.Game;
using MuEmu.Util;
using MuEmu.Monsters;
using MU.Resources;
using WebZen.Util;
using MU.Network;
using System.Threading.Tasks;

namespace MuEmu
{
    internal class GuildMatching
    {
        public Guild Guild { get; set; }
        public string Title { get; set; }
        public byte InterestType { get; set; }
        public byte LevelRange { get; set; }
    }
    public class GuildManager
    {
        public static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(GuildManager));
        public static GuildManager Instance { get; set; }

        public Dictionary<int,Guild> Guilds { get; set; }

        internal static IEnumerable<GuildMatchingListDto> GuildMatchingList(Character character, int page, string search, out int maxPage)
        {
            IEnumerable<GuildMatchingDto> info;
            using (var game = new GameContext())
            {
                maxPage = (int)Math.Ceiling(game.GuildMatching.Count()/5.0f);
                if (!string.IsNullOrEmpty(search))
                {
                    info = (from gm in game.GuildMatching
                    where gm.Title.Contains(search)
                    select gm)
                    .Skip((page-1) * 5)
                    .Take(5);
                }
                else
                {
                    info = (from gm in game.GuildMatching
                            select gm)
                    .Skip((page-1) * 5)
                    .Take(5);
                }

                var result = info
                    .ToList()
                    .Select(x => new GuildMatchingListDto
                {
                    GuildId = x.GuildId,
                    GuildName = x.Guild.Name,
                    InterestType = (GMInterestType)x.InterestType,
                    Name = x.Guild.MembersInfo.First().Memb.Name,
                    LevelRange = (GMLevelRange)x.LevelRange,
                    MasterClass = Character.GetClientClass((HeroClass)x.Guild.MembersInfo.First().Memb.Class),
                    MasterLevel = x.Guild.MembersInfo.First().Memb.Level,
                    MembersCount = (byte)x.Guild.MembersInfo.Count,
                    Gens = x.Guild.MembersInfo.First().Memb.Gens.Influence,
                    Text = x.Title,
                    ClassType = (GMClass)x.Class,
                    BoardNumber = 1,
                });

                return result;
            }
        }

        internal static async Task GuildMatchingRegister(Character character, string Title, GMInterestType interest, GMLevelRange levelRange, ushort @class)
        {
            using(var game = new GameContext())
            {
                game.GuildMatching.Add(new GuildMatchingDto
                {
                    GuildId = character.Guild.Index,
                    InterestType = (short)interest,
                    LevelRange = (short)levelRange,
                    Title = Title,
                    Class = @class
                });
                await game.SaveChangesAsync();
            }
        }
        internal static async Task GuildMatchingRegisterCancel(Character character)
        {
            using(var game = new GameContext())
            {
                var gm = game.GuildMatching.First(x => x.GuildId == character.Guild.Index);
                var gmj = game.GuildMatchingJoin.Where(x => x.GuildMatchingId == gm.Id);
                foreach(var j in gmj)
                {
                    j.State = 3;
                }

                game.GuildMatchingJoin.UpdateRange(gmj);
                game.GuildMatching.Remove(gm);
                await game.SaveChangesAsync();
            }
        }
        internal static async Task<int> GuildMatchingJoin(Character character, int guildID)
        {
            if(character.Guild != null)
                throw new Exception("You already have guild");

            using (var game = new GameContext())
            {
                var result = game.GuildMatching.First(x => x.GuildId == guildID);
                var prev = game.GuildMatchingJoin.Any(x => x.CharacterId == character.Id);

                if(prev)
                    throw new Exception("You already have guild request");

                game.GuildMatchingJoin.Add(new GuildMatchingJoinDto
                {
                    CharacterId = character.Id,
                    GuildMatchingId = result.Id,
                    State = 4,
                });
                await game.SaveChangesAsync();

                var guild = Get(guildID);
                guild.Master.Player?.Session.SendAsync(new SGuildMatchingNotifyMaster { Result = 0 });
                return 0;
            }
        }
        internal static async Task<int> GuildMatchingJoin(Character character, int type, string name)
        {
            using(var game = new GameContext())
            {
                var data = game.GuildMatchingJoin.First(x => x.Character.Name == name);
                data.Character = game.Characters.Single(x => x.CharacterId == data.CharacterId);

                if (type == 1)
                {
                    var guild = character.Guild.Add(data.Character.Name, GuildStatus.Member);
                    data.State = 1;
                }
                else
                {
                    data.State = 2;
                }
                await game.SaveChangesAsync();
                return 0;
            }
        }
        internal static async Task<IEnumerable<GuildMatchingJoinListDto>> GuildMatchingJoinList(Character character)
        {
            using (var game = new GameContext())
            {
                var GuildMatchingId = (from gm in game.GuildMatching
                                       where gm.GuildId == character.Guild.Index
                                       select gm.Id).Single();

                var waiting = (from gm in game.GuildMatchingJoin
                              where gm.GuildMatchingId == GuildMatchingId && gm.State == 4
                              select gm);

                var result = waiting.Select(x => new
                {
                    Name = x.Character.Name,
                    Level = (x.Character.Level),
                    Class = x.Character.Class,
                }).ToList();

                return result.Select(x => new GuildMatchingJoinListDto { Level = (uint)x.Level, Class = (byte)x.Class, Name = x.Name });
            }
        }
        internal static int GuildMatchingJoinInfo(Character character, out string gName, out string gMaster)
        {
            using (var game = new GameContext())
            {
                var info = (from gmj in game.GuildMatchingJoin
                            where gmj.CharacterId == character.Id
                            select gmj).Single();

                info.GuildMatching = (from gm in game.GuildMatching
                                      where gm.Id == info.GuildMatchingId
                                      select gm).Single();

                gName = info.GuildMatching.Guild.Name;
                gMaster = info.GuildMatching.Guild.MembersInfo.First().Memb.Name;

                return 0;
            }
        }
        internal static void GuildMatchingNotifications(Character character, GuildStatus rank)
        {
            using (var game = new GameContext())
            {
                if (rank == GuildStatus.GuildMaster)
                {
                    var gMatching = (from gm in game.GuildMatching
                                     where gm.GuildId == character.Guild.Index
                                     select gm).SingleOrDefault();

                    if (gMatching == null)
                        return;

                    var list = from gmj in game.GuildMatchingJoin
                               where gmj.GuildMatchingId == gMatching.Id && gmj.State == 4
                               select gmj;

                    if (list.Any())
                    {
                        character.Player.Session
                            .SendAsync(new SGuildMatchingNotifyMaster())
                            .Wait();
                    }
                }
                else
                {
                    var info = (from gmj in game.GuildMatchingJoin
                               where gmj.CharacterId == character.Id
                               select gmj).SingleOrDefault();

                    if(info == null)
                    {
                        return;
                    }

                    if(info.State != 4)
                    {
                        character.Player.Session.SendAsync(new SGuildMatchingNotify
                        {
                            Result = info.State
                        }).Wait();

                        game.GuildMatchingJoin.Remove(info);
                        game.SaveChanges();
                    }
                }
            }
        }

        GuildManager()
        {
            Guilds = new Dictionary<int, Guild>();
            using (var game = new GameContext())
            {
                foreach(var guild in game.Guilds.ToList())
                {
                    //guild.MembersInfo = game.GuildMembers.Where(x => x.GuildId == guild.GuildId).ToList();
                    Guilds.Add(guild.GuildId, new Guild(guild));
                }
                // Solve references
                foreach(var guild in game.Guilds.ToList())
                {
                    if (guild.AllianceId != null)
                    {
                        var masterAlliance = Guilds[(int)guild.AllianceId];
                        masterAlliance.Union.Add(Guilds[guild.GuildId]);
                        Guilds[guild.GuildId].Union = masterAlliance.Union;
                    }
                    for(var i =0; i < 5; i++)
                    {
                        var r = guild.Get("Rival" + (i + 1)) as int?;
                        if (r != null)
                        {
                            Guilds[guild.GuildId].Rival.Add(Guilds[(int)r]);
                        }
                    }
                }
            }
        }

        public static void Initialize()
        {
            if (Instance != null)
                return;

            Instance = new GuildManager();

            Logger.Information("Initializing Guild System");
        }

        public static void CreateGuild(Player master, string name, byte[] Mark, byte Type)
        {
            name.Trim();
            //if (name.Length < 2 || name.Length >= 8)
            //{
            //    master.Session.SendAsync(new SGuildCreateResult { Result = 2 });
            //    Logger.Error("Guild name long or short (4-8):{0} Master:{1}", name, master.Character.Name);
            //    return;
            //}

            if (Instance.Guilds.Any( x => x.Value.Name.ToLower() == name.ToLower()))
            {
                _=master.Session.SendAsync(new SGuildCreateResult { Result = 0, GuildType = Type });
                Logger.Error("Guild name in use:{0} Master:{1}", name, master.Character.Name);
                return;
            }

            var g = new Guild(name, Mark, Type);
            Instance.Guilds.Add(g.Index,g);
            master.Session.SendAsync(new SGuildCreateResult { Result = 1, GuildType = Type }).Wait();
            g.Add(master, GuildStatus.GuildMaster);
            Logger.Information("New guild added:{0} Master:{1}", name, master.Character.Name);
        }

        public static Guild Get(int guildID)
        {
            if(Instance.Guilds.ContainsKey(guildID))
                return Instance.Guilds[guildID];

            return null;
        }

        public void AddPlayer(Player plr)
        {
            var Guild = (from g in Guilds.Values
                        from m in g.Members
                        where m.Name == plr.Character.Name
                        select g).FirstOrDefault();

            if (Guild == null)
            {
                GuildMatchingNotifications(plr.Character, GuildStatus.NoMember);
            }
            else
            {
                Guild.ConnectMember(plr);
            }
        }
        public void RemovePlayer(Player plr)
        {
            var Guild = (from g in Guilds.Values
                         from m in g.Members
                         where m.Name == plr.Character.Name
                         select g).FirstOrDefault();

            Guild?.Remove(plr);
        }

        public GuildMember FindCharacter(string @char)
        {
            foreach(var guild in Guilds)
            {
                var ret = guild.Value.Find(@char);
                if (ret != null)
                    return ret;
            }

            return null;
        }

        public static void NPCTalk(Player plr, Monster npc)
        {
            if(plr.Character.Guild != null)
            {
                plr.Session.SendAsync(new SChatTarget(npc.Index, ""))
                    .Wait();
                return;
            }
            plr.Session.SendAsync(new SGuildMasterQuestion())
                .Wait();
        }

        public static void SendList(Player plr)
        {
            var guild = Instance.Guilds.Values.Where(x => x.Members.Any(y => y.Player == plr)).FirstOrDefault();
            object pMsg;

            if (guild == null)
            {
                pMsg = VersionSelector.CreateMessage<SGuildList>((byte)0);
                
                plr.Session.SendAsync(pMsg).Wait();
                return;
            }

            var members = guild.Members
                .OrderBy(x => x.Name)
                .OrderByDescending(x => x.Rank)
                .Select((x,i) => new GuildListDto
            {
                Name = x.Name,
                ConnectAServer = (byte)(x.Server != 0xff?(0x80| x.Server): 0x00),
                Number = (byte)i,
                btGuildStatus = x.Rank,
            });

            pMsg = VersionSelector.CreateMessage<SGuildList>((byte)1, guild.Score, guild.TotalScore, members.ToList(), guild.Rival.Select(x => x.Name).ToList());
            
            plr.Session.SendAsync(pMsg).Wait();
        }

        internal static Guild Get(string v)
        {
            return Instance.Guilds.First(x => x.Value.Name == v).Value;
        }

        internal static async Task<int> GuildMatchingJoin(Character character)
        {
            using(var game = new GameContext())
            {
                var info = game.GuildMatchingJoin.First(x => x.CharacterId == character.Id);
                game.GuildMatchingJoin.Remove(info);
                await game.SaveChangesAsync();

                return 0;
            }
        }
    }

    public class Guild
    {
        public GuildManager Guilds => GuildManager.Instance;

        public int Index { get; private set; }

        public string Name { get; private set; }
        public byte[] Mark { get; private set; }
        public byte Type { get; private set; }

        public List<Guild> Union { get; set; } = new List<Guild>();
        public List<Guild> Rival { get; set; } = new List<Guild>();

        public GuildMember Master => Members.First(x => x.Rank == GuildStatus.GuildMaster);
        public GuildMember Assistant => Members.FirstOrDefault(x => x.Rank == GuildStatus.Assistant);
        public IEnumerable<GuildMember> BattleMasters => Members.Where(x => x.Rank == GuildStatus.BattleMaster);
        public List<GuildMember> Members { get; set; }

        public List<GuildMember> ActiveMembers => Members.Where(x => x.Server != 0xff).ToList();

        public byte Score { get; internal set; }
        public int TotalScore { get; internal set; }
        public bool IsUnionMaster => (Union.Count > 1) && (Union[0] == this);

        public Guild(string name, byte[] mark, byte type)
        {
            Members = new List<GuildMember>();
            Name = name;
            Mark = mark;

            using (var game = new GameContext())
            {
                var guild = new GuildDto
                {
                    Name = name,
                    Mark = mark,
                    GuildType = type,
                };
                game.Add(guild);
                game.SaveChanges();

                Index = guild.GuildId;
            }
        }

        public Guild(GuildDto guildDto)
        {
            Index = guildDto.GuildId;
            Name = guildDto.Name;
            Mark = guildDto.Mark;
            Members = guildDto.MembersInfo.Select(x => new GuildMember(this, x.Memb.Name, (GuildStatus)x.Rank) { Server = 0xff }).ToList();
            Type = guildDto.GuildType;
            
        }

        public GuildMember Add(Player plr, GuildStatus rank)
        {
            var memb = Members.Where(x => x.Name == plr.Character.Name).FirstOrDefault();
            if(memb == null)
            {
                memb = new GuildMember(this, plr, rank);
                Members.Add(memb);
            }else
            {
                memb.Player = plr;
            }

            memb.Server = (byte)Program.ServerCode;
            plr.Character.Guild = this;
            memb.ViewPort();

            return memb;
        }

        public GuildMember Add(string name, GuildStatus rank)
        {
            var memb = Members.Where(x => x.Name == name).FirstOrDefault();
            if (memb == null)
            {
                memb = new GuildMember(this, name, rank);
                Members.Add(memb);
            }

            memb.ViewPort();
            return memb;
        }

        public GuildMember Find(string name)
        {
            return Members.FirstOrDefault(x => x.Name == name);
        }

        public void ConnectMember(Player plr)
        {
            var conMemb = Find(plr.Character.Name);
            conMemb.Player = plr;
            conMemb.ViewPort();
            conMemb.Server = (byte)Program.ServerCode;
            plr.Character.Guild = this;

            GuildManager.GuildMatchingNotifications(plr.Character, conMemb.Rank);
            var notice = new SNotice(NoticeType.Guild, $"Welcome back {plr.Character.Name}");

            ActiveMembers
                .Where(x => x.Player != null)
                .Select(x => x.Player.Session)
                .SendAsync(notice)
                .Wait();
        }

        public void Remove(Player plr)
        {
            var memb = Members
                .Where(x => x.Name == plr.Character.Name)
                .FirstOrDefault();

            Remove(memb);
        }

        public void Remove(GuildMember memb)
        {
            if (memb == null)
                throw new Exception("GUILD: Try to remove an Invalid Member");

            Members.Remove(memb);
            using (var game = new GameContext())
            {
                var charId = (from row in game.Characters where row.Name == memb.Name select row.CharacterId).FirstOrDefault();
                var dto = (from row in game.GuildMembers where row.MembId == charId select row).FirstOrDefault();

                game.Remove(dto);
                game.SaveChanges();
            }
        }

        public GuildRelation GetRelation(Guild guild)
        {
            if (Union.Contains(guild))
                return GuildRelation.Union;

            if (Rival.Contains(guild))
                return GuildRelation.Rival;

            return GuildRelation.None;
        }

        internal bool CanAdd()
        {
            var max = Master.Player.Character.Level / 10;
            if(Master.Player.Character.BaseClass == HeroClass.DarkLord)
            {
                max += Master.Player.Character.CommandTotal / 10;
            }

            if(max > 100)
            {
                max = 100;
            }

            return max > Members.Count();
        }

        internal void ChangeRelation(Guild guild, GuildUnionRequestType requestType, GuildRelationShipType relationShipType)
        {
            switch(requestType)
            {
                case GuildUnionRequestType.Join:
                    switch(relationShipType)
                    {
                        case GuildRelationShipType.Union:
                            if (Union.Count == 0)
                                Union.Add(this);

                            Union.Add(guild);
                            guild.Union = Union;
                            break;
                        case GuildRelationShipType.Rivals:
                            Rival.Add(guild);
                            guild.Rival.Add(this);
                            break;
                    }
                    break;
                case GuildUnionRequestType.BreakOff:
                    switch (relationShipType)
                    {
                        case GuildRelationShipType.Union:
                            if (this == guild)
                            {
                                Union[0].ChangeRelation(this, requestType, relationShipType);
                                return;
                            }
                            Union.Remove(guild);
                            if (Union.Count == 1)
                            {
                                Union.Remove(this);
                            }

                            guild.Union = new List<Guild>();
                            break;
                        case GuildRelationShipType.Rivals:
                            Rival.Remove(guild);
                            guild.Rival.Remove(this);
                            break;
                    }
                    break;
            }

            using (var game = new GameContext())
            {
                var guildDtoA = (from g in game.Guilds
                                 where g.GuildId == Index
                                 select g).Single();

                var guildDtoB = (from g in game.Guilds
                                 where g.GuildId == guild.Index
                                 select g).Single();

                guildDtoA.AllianceId = Union.FirstOrDefault()?.Index ?? null;
                guildDtoB.AllianceId = Union.FirstOrDefault()?.Index ?? null;
                for(var i = 0; i < 5; i++)
                {
                    var rivA = Rival.Count > i ? (int?)Rival[i].Index : null;
                    var rivB = guild.Rival.Count > i ? (int?)guild.Rival[i].Index : null;
                    guildDtoA.Set("Rival" + (i + 1), rivA);
                    guildDtoB.Set("Rival" + (i + 1), rivB);
                }

                game.Update(guildDtoA);
                game.Update(guildDtoB);
                game.SaveChanges();
            }
        }
    }

    public class GuildMember
    {
        public Guild Guild { get; private set; }

        public Player Player { get; set; }

        public string Name { get; }

        public byte Server { get; set; }

        public GuildStatus Rank { get; private set; }

        public GuildMember()
        {

        }

        public GuildMember(Guild guild, Player plr, GuildStatus rank)
        {
            Name = plr.Character.Name;
            Player = plr;
            Rank = rank;
            Guild = guild;

            using (var game = new GameContext())
            {
                var guildMember = new MU.DataBase.GuildMemberDto
                {
                    GuildId = guild.Index,
                    MembId = plr.Character.Id,
                    Rank = (int)rank,
                };
                game.Add(guildMember);
                game.SaveChanges();
            }
        }

        public GuildMember(Guild guild, string name, GuildStatus rank)
        {
            Name = name;
            Rank = rank;
            Guild = guild;
            Player = Program.server.Clients.FirstOrDefault(x => x.Player.Character.Name == name)?.Player??null;
        }

        public void ViewPort()
        {
            if (Player == null)
                return;

            var vp = new SGuildViewPort
            {
                Guilds = new GuildViewPortDto[] { new GuildViewPortDto {
                    ID = Guild.Index,
                    Number = (ushort)(Player.ID /*| (Rank == GuildStatus.GuildMaster ? 0x80 : 0x00)*/),
                    RelationShip = GuildRelation.None,
                    CastleState = 0,
                    Status = Rank,
                    Type = Guild.Type,
                } }
            };

            Player.SendV2Message(vp);
            Player.Session.SendAsync(vp).Wait();
        }

        public void UpdateRank(GuildStatus newStatus)
        {
            if (Rank == newStatus)
                return;

            using (var game = new GameContext())
            {
                var charId = (from row in game.Characters where row.Name == Name select row.CharacterId).FirstOrDefault();
                var guildMember = (from row in game.GuildMembers where row.MembId == charId select row).FirstOrDefault();
                guildMember.Rank = (int)Rank;
                game.Update(guildMember);
                game.SaveChanges();
            }

            Rank = newStatus;
        }
    }
}


--file HuntingRecord.cs
﻿using MU.DataBase;
using MU.Network.Game;
using MU.Resources;
using MuEmu.Entity;
using MuEmu.Monsters;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WebZen.Util;

namespace MuEmu
{
    internal class HuntingRecord
    {
        public HuntingDto Hunting { get; set; }
        public Character Character { get; }
        public bool Active { get; set; }
        public bool Visibility { get; internal set; }

        public HuntingRecord(Character character, CharacterDto characterDto)
        {
            Character = character;
            Hunting = new HuntingDto();
        }

        internal void GainExperience(long gain)
        {
            Hunting.Experience += gain;
        }

        internal void AttackPVM(float attack)
        {
            Hunting.AttackPVM += (long)attack;
        }

        internal void KilledMonster(Monster monster)
        {
            Hunting.KilledMonsters++;
        }

        internal void HealingUse(long addLife)
        {
            Hunting.HealingUse += addLife;
        }

        internal void ElementalAttackPVM(float dmg)
        {
            Hunting.ElementalAttackPVM += (long)dmg;
        }

        internal void Start()
        {
            using (var db = new GameContext())
            {
                Active = true;
                Hunting = (from hr in db.HuntingRecords
                          where 
                          hr.CharacterId == Character.Id && 
                          hr.DateTime.Date == DateTime.Now.Date &&
                          hr.Map == (ushort)Character.MapID
                           select hr).SingleOrDefault();

                if(Hunting == null)
                {
                    Hunting = new HuntingDto();
                    Hunting.CharacterId = Character.Id;
                    Hunting.Map = (ushort)Character.MapID;
                    Hunting.Level = Character.Level;
                }
                Hunting.DateTime = DateTime.Now;
            }            
        }

        internal void Save()
        {
            if (!Active) return;

            Active = false;
            using(var db = new GameContext())
            {
                Hunting.Duration += (int)(DateTime.Now - Hunting.DateTime).TotalSeconds;

                if (Hunting.Id == 0)
                    db.HuntingRecords.Add(Hunting);
                else
                    db.HuntingRecords.Update(Hunting);

                db.SaveChanges();
            }
        }

        internal Dictionary<int, HuntingDto> GetRecordList(Maps map)
        {
            var id = 1;
            using (var db = new GameContext())
            {
                return db.HuntingRecords
                    .Where(x => x.CharacterId == Character.Id && x.Map == (ushort)map)
                    .ToDictionary(x => id++);
            }
        }

        internal void Update()
        {
            if (Active == false)
                return;

            Character.Player.Session.SendAsync(new SHuntingRecordTime
            {
                Damage = Hunting.AttackPVM,
                ElementalDamage = Hunting.ElementalAttackPVM,
                Experience = Hunting.Experience.ShufleEnding(),
                Healing = (int)Hunting.HealingUse,
                KilledCount = Hunting.KilledMonsters,
                Time = (int)(DateTime.Now - Hunting.DateTime).TotalSeconds + Hunting.Duration,
            }).Wait();
        }
    }
}


--file Inventory.cs
﻿using MU.DataBase;
using MU.Resources;
using MuEmu.Entity;
using MuEmu.Network;
using MU.Network.Game;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MuEmu.Util;
using MuEmu.Resources;
using MU.Network.Event;
using MySqlX.XDevAPI;
using MuEmu.Network.Data;
using MU.Network;

namespace MuEmu
{
    internal class Transaction
    {
        public MoveItemFlags From;
        public byte fromIndex;
        public MoveItemFlags To;
        public byte toIndex;
    }
    public class Inventory : IDisposable
    {
        private static ILogger _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(Inventory));
        //public Player Player { get; set; }
        public Character Character { get; }

        private List<Item> _toDelete = new List<Item>();
        private Dictionary<Equipament, Item> _equipament;
        private Dictionary<StorageID, object> Storages;
        private Storage _inventory;
        private Storage _exInventory1;
        private Storage _exInventory2;
        private Storage _chaosBox;
        private Storage _personalShop;
        private Storage _tradeBox;
        private Storage _muun;
        private Storage _event;
        private List<Item> _pentagrama;
        private List<Item> _forDelete;
        private bool _needSave;
        private int _defense;
        private int _defenseRate;
        private float _excellentRate;
        private int _criticalRate;
        private float _reflect;
        private float _increaseHP;
        private float _increaseSD;
        private float _increaseSDRecovery;
        private float _increaseMP;
        private float _dropZen;
        private float _dmgDecrease;
        private float _increaseWizardryRate;
        private float _increaseLifeRate;
        private float _increaseManaRate;
        private float _increaseWizardry;
        private bool _tradeOpen;
        private List<Transaction> _transactions = new List<Transaction>();
        private float _increaseDamage;
        private float _attackSuccessRate;

        public float ExcellentRate => _excellentRate;
        public int CriticalRate => _criticalRate;
        public int Defense => _defense;
        public int DefenseRate => _defenseRate;
        public float IncreaseAttack => _increaseDamage;
        public float IncreaseWizardryRate => _increaseWizardryRate;
        public float IncreaseWizardry => _increaseWizardry;
        public float IncreaseLifeRate => _increaseLifeRate;
        public float IncreaseManaRate => _increaseManaRate;
        public float DropZen => _dropZen;
        public float Reflect => _reflect;
        public float IncreaseHP => _increaseHP;
        public float IncreaseSD => _increaseSD;
        public float IncreaseSDRecovery => _increaseSDRecovery;
        public float IncreaseMP => _increaseMP;
        public float DmgDecrease => _dmgDecrease;
        public float WingDmgAbsorb => (Get(Equipament.Wings)?.WingDmgAbsorb ?? 0.0f)+ Character.Spells.WingsDefensePowUp / 100.0f;
        public float WingDmgIncrease => (Get(Equipament.Wings)?.WingDmgAdd ?? 0.0f) + Character.Spells.WingsAttackPowUp / 100.0f;

        public Storage ChaosBox => _chaosBox;
        public Storage PersonalShop => _personalShop;
        public Storage TradeBox => _tradeBox;
        public bool TradeOk { get; set; }
        public bool TradeOpen { get => _tradeOpen; set
            {
                _tradeOpen = value;
                if (value == false)
                    _transactions.Clear();
            }
        }
        public PentagramJewelDto[] JewelList => GetJewelsInfo().ToArray();
        public Item ItemMoved { get; private set; }
        public Item Arrows { get; private set; }
        public bool Lock { get; set; }

        //muun
        public Item MainPet { get; private set; }
        public Item SubPet { get; private set; }

        // Pentagram
        public int PentagramAbsorbHP { get; internal set; }
        public int PentagramAbsorbShield { get; internal set; }
        public int PentagramAddAttackDamage { get; internal set; }
        public int PentagramAddDefense { get; internal set; }
        public int PentagramAbsorbDamagePVM { get; internal set; }
        public int PentagramAttackSuccessRatePVM { get; internal set; }
        public int PentagramAbsorbDamagePVP { get; internal set; }
        public int PentagramAttackSuccessRatePVP { get; internal set; }
        public int PentagramBind { get; internal set; }
        public int PentagramBleedingDamage { get; internal set; }
        public int PentagramBlind { get; internal set; }
        public int PentagramCriticalDamageRate { get; internal set; }
        public int PentagramParalyzing { get; internal set; }
        public int PentagramPunish { get; internal set; }
        public int PentagramDamageMaxPVM { get; internal set; }
        public int PentagramDamageMinPVM { get; internal set; }
        public int PentagramDefensePVM { get; internal set; }
        public int PentagramDefenseSuccessRatePVM { get; internal set; }
        public int PentagramIncreaseDamagePVM { get; internal set; }
        public int PentagramDamageMaxPVP { get; internal set; }
        public int PentagramDamageMinPVP { get; internal set; }

        public Inventory(Character @char, CharacterDto characterDto)
        {
            Character = @char;
            Storages = new Dictionary<StorageID, object>();
            _equipament = new Dictionary<Equipament, Item>();
            _inventory = new Storage(Storage.InventorySize, StorageID.Inventory);
            _personalShop = new Storage(Storage.TradeSize, StorageID.PersonalShop);
            _personalShop.NoMapped = (Program.Season >= ServerSeason.Season16Kor);
            _chaosBox = new Storage(Storage.ChaosBoxSize);
            _tradeBox = new Storage(Storage.TradeSize);
            _muun = new Storage(64);
            _muun.NoMapped = true;
            _muun.StorageID = StorageID.MuunInventory;
            _event = new Storage(Storage.Expansion);
            _event.StorageID = StorageID.EventInventory;
            _pentagrama = new List<Item>();
            _forDelete = new List<Item>();
            Storages.Add(StorageID.Equipament, _equipament);
            Storages.Add(StorageID.Inventory, _inventory);
            Storages.Add(StorageID.ChaosBox, _chaosBox);
            Storages.Add(StorageID.TradeBox, _tradeBox);
            Storages.Add(StorageID.PersonalShop, _personalShop);
            Storages.Add(StorageID.Pentagram, _pentagrama);
            Storages.Add(StorageID.MuunInventory, _muun);
            Storages.Add(StorageID.EventInventory, _event);

            if (characterDto.ExpandedInventory >= 1)
            {
                _exInventory1 = new Storage(Storage.Expansion, StorageID.ExpandedInventory1);
                Storages.Add(StorageID.ExpandedInventory1, _exInventory1);
            }

            if (characterDto.ExpandedInventory >= 2)
            {
                _exInventory2 = new Storage(Storage.Expansion, StorageID.ExpandedInventory2);
                Storages.Add(StorageID.ExpandedInventory2, _exInventory2);
            }

            foreach (var item in characterDto.Items.Where(x => x.VaultId != 10 && x.VaultId != (int)StorageID.Warehouse))
            {
                var it = new Item(item, @char?.Account, @char);
                object st;
                var pos = (byte)it.SlotId;
                if(Storages.TryGetValue(it.Storage, out st))
                {
                    if(it.Storage == StorageID.Equipament)
                    {
                        var sto = st as Dictionary<Equipament, Item>;
                        if (pos < (byte)StorageID.Inventory || pos == (byte)Equipament.Pentagrama)
                        {
                            if (!sto.ContainsKey((Equipament)pos))
                                sto.Add((Equipament)pos, it);
                            else
                            {
                                _logger.Error(ServerMessages.GetMessage(Messages.IV_IndexAlreadyUsed, Character, (Equipament)pos));
                                _logger.Error(it.ToString());
                                _toDelete.Add(it);
                                it.Delete();
                            }

                            if (it.Number.Type == ItemType.BowOrCrossbow && (it.Number.Index == 7 || it.Number.Index == 15))
                                Arrows = it;
                        }
                    }
                    else if(it.Storage == StorageID.Pentagram)
                    {
                        var sto = st as List<Item>;
                        sto.Add(it);
                    }
                    else
                    {
                        var sto = st as Storage;
                        try
                        {
                            sto.Add(pos, it);
                        }catch(Exception)
                        {
                            try
                            {
                                if(sto.Add(it)==0xff)
                                {
                                    it.Delete();
                                }
                            }
                            catch (Exception)
                            {
                                _forDelete.Add(it);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Add item to the firts free space in MuunInventory
        /// </summary>
        /// <param name="pickup"></param>
        /// <returns></returns>
        internal byte AddMuun(Item pickup)
        {
            pickup.Account = Character.Account;
            pickup.Character = Character;
            return _muun.Add(pickup, 2);
        }

        /// <summary>
        /// Equip a Muun pet
        /// </summary>
        /// <param name="toIndex">pet slot</param>
        /// <param name="it">pet</param>
        private void EquipMuun(byte toIndex, Item it)
        {
            _muun.Add(toIndex, it);
        }

        /// <summary>
        /// Unequip a Muun pet
        /// </summary>
        /// <param name="fromIndex">pet slot</param>
        /// <returns>removed pet</returns>
        private Item UnequipMuun(byte fromIndex)
        {
            var it = _muun.Get(fromIndex);
            _muun.Remove(fromIndex);
            return it;
        }

        /// <summary>
        /// Send the Myun inventory
        /// </summary>
        internal void SendMuunInventory()
        {
            var session = Character.Player.Session;
            _ = session.SendAsync(VersionSelector.CreateMessage<SMuunInventory>(_muun.GetInventory()));
        }

        /// <summary>
        /// Add item to event inventory
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        internal byte AddEvent(Item item)
        {
            item.Account = Character.Account;
            item.Character = Character;
            return _event.Add(item);
        }

        internal async void SendEventInventory()
        {
            var message = VersionSelector.CreateMessage<SEventInventory>() as IInventory;
            message.LoadItems(_event.GetInventory());
            await Character.Player.Session.SendAsync(message);
        }

        /// <summary>
        /// Find all item address in main inventory with the TypeIndex number
        /// </summary>
        /// <param name="num">TypeIndex</param>
        /// <returns>Array of matched items position</returns>
        public byte[] FindAll(ItemNumber num)
        {
            var res = new List<byte>();
            foreach (var e in _equipament)
            {
                if (e.Value.Number == num)
                {
                    res.Add((byte)e.Key);
                }
            }
            foreach (var inv in _inventory.Items)
            {
                if (inv.Value.Number == num)
                {
                    res.Add((byte)(inv.Key + _inventory.IndexTranslate));
                }
            }
            return res.ToArray();
        }

        /// <summary>
        /// Delete item from Event Inventory
        /// </summary>
        /// <param name="ipos"></param>
        internal void DeleteEvent(byte ipos)
        {
            var it = GetEvent(ipos);
            RemoveEvent(ipos);

            if(it.Serial != 0)
                _forDelete.Add(it);
        }

        /// <summary>
        /// Get item by address from Event Inventory
        /// </summary>
        /// <param name="ipos"></param>
        /// <returns></returns>
        internal Item GetEvent(byte ipos)
        {
            return _event.Get(ipos);
        }

        /// <summary>
        /// Get item by address from Event Inventory
        /// </summary>
        /// <param name="ipos"></param>
        /// <returns></returns>
        internal IEnumerable<byte> FindAllEvent(ItemNumber item)
        {
            return _event.Items.Where(x => x.Value.Number == item).Select(x => x.Key);
        }

        /// <summary>
        /// Find all items in main inventory with the TypeIndex number
        /// </summary>
        /// <param name="num"></param>
        /// <returns></returns>
        public List<Item> FindAllItems(ItemNumber num)
        {
            var res = new List<Item>();
            res.AddRange(_equipament.Values.Where(x => x.Number == num));
            res.AddRange(_inventory.Items.Values.Where(x => x.Number == num));

            if(_exInventory1 != null)
                res.AddRange(_exInventory1.Items.Values.Where(x => x.Number == num));
            if (_exInventory2 != null)
                res.AddRange(_exInventory2.Items.Values.Where(x => x.Number == num));

            return res;
        }

        /// <summary>
        /// Try add by default an item with size 5x3 (min free space for ChaosBox mixes)
        /// </summary>
        /// <returns>True: it can</returns>
        public bool TryAdd(System.Drawing.Size sz = new System.Drawing.Size())
        {
            var freeSpace = sz.IsEmpty?new System.Drawing.Size(5, 3):sz;
            return _inventory.TryAdd(freeSpace) | (_exInventory1?.TryAdd(freeSpace)??false) | (_exInventory2?.TryAdd(freeSpace) ?? false);
        }

        /// <summary>
        /// Remove item by address from Event Inventory
        /// </summary>
        /// <param name="ipos"></param>
        internal void RemoveEvent(byte ipos)
        {
            _event.Remove(ipos);
        }


        /// <summary>
        /// Try add a collection of items (Used for trade Sistem)
        /// </summary>
        /// <param name="items"></param>
        /// <returns></returns>
        public bool TryAdd(IEnumerable<Item> items)
        {
            return _inventory.TryAdd(items.Select(x => x.BasicInfo.Size).ToArray());
        }

        /// <summary>
        /// Add item to position and update client inventory
        /// </summary>
        /// <param name="pos"></param>
        /// <param name="item"></param>
        /// <param name="save"></param>
        private void Add(byte pos, Item item, bool save = true)
        {
            foreach(var st in Storages)
            {
                if (st.Value.GetType() == typeof(Storage))
                {
                    var sto = st.Value as Storage;
                    if (sto.CanContain(pos))
                    {
                        sto.Add(pos, item);
                        break;
                    }
                }
                else
                {
                    var sto = st.Value as Dictionary<Equipament, Item>;
                    if (pos < (byte)StorageID.Inventory || pos == (byte)Equipament.Pentagrama)
                    {
                        sto.Add((Equipament)pos, item);
                        if (item.Number.Type == ItemType.BowOrCrossbow && (item.Number.Index == 7 || item.Number.Index == 15))
                            Arrows = item;
                        break;
                    }
                }
            }
            
            if (Character != null)
            {
                //item.Account = Character.Account;
                item.Character = Character;
            }

            if (save)
                _needSave = true;
        }

        /// <summary>
        /// Calculate all statistics with items
        /// </summary>
        public void CalcStats()
        {
            _defense = 0;
            _defenseRate = 0;
            _criticalRate = 0;
            _excellentRate = 0;
            _increaseWizardryRate = 0;
            _increaseWizardry = 0;
            _increaseLifeRate = 0;
            _increaseManaRate = 0;
            _dropZen = 0;
            _reflect = 0;
            _dmgDecrease = 0;
            _increaseMP = 0;
            _increaseHP = 0;
            PentagramDamageMaxPVM = 0;

            foreach (var equip in _equipament)
            {
                var item = equip.Value;

                if (Character != null)
                    item.ApplyEffects(Character);

                if(item.IsPentagramItem)
                {
                    PentagramDamageMaxPVM = item.AttackMax;
                    PentagramDamageMaxPVP = item.AttackMax;
                    PentagramDamageMinPVM = item.AttackMin;
                    PentagramDamageMinPVP = item.AttackMin;
                    foreach (var pSerial in item.PentagramJewels.Where(x => x != 0))
                    {
                        var jewel = _pentagrama.FirstOrDefault(x => x.Serial == pSerial);
                        if (jewel == null)
                            continue;
                        var table0 = new[] { 10, 15, 20, 30, 40, 60, 80, 100, 150, 200, 250 };
                        var table1 = new[] { 3, 4, 5, 6, 7, 8, 9, 10, 12, 15, 20 };
                        var table2 = new[] { 10, 15, 20, 30, 40, 60, 80, 125, 175, 225, 275 };
                        switch (jewel.Number)
                        {
                            case 6365: //Errtel of Anger, 10, 15, 20, 30, 40, 60, 80, 100, 150, 200, 250
                                PentagramAddAttackDamage += table0[jewel.RankLevel[0]];
                                //
                                var factor = table0[jewel.RankLevel[2]];
                                PentagramDamageMaxPVM += factor;
                                PentagramDamageMaxPVP += factor;
                                PentagramDamageMinPVM += factor;
                                PentagramDamageMinPVP += factor;
                                break;
                        }
                    }
                }

                _defense += item.Defense + item.AditionalDefense;
                _defenseRate += item.BasicInfo.DefRate;

                _criticalRate += item.CriticalDamage;
                _excellentRate += item.ExcellentDmgRate;
                _increaseWizardryRate += item.IncreaseWizardryRate;
                _increaseWizardry += item.IncreaseWizardry;
                _increaseLifeRate += item.IncreaseLifeRate;
                _increaseManaRate += item.IncreaseManaRate;

                _dropZen += item.IncreaseZenRate;
                _reflect += item.ReflectDamage;
                _dmgDecrease += item.DamageDecrease;
                _increaseMP += item.IncreaseMana;
                _increaseHP += item.IncreaseHP;

                if(item.Option380)
                {
                    switch(item.Number.Type)
                    {
                        case ItemType.Sword:
                        case ItemType.Axe:
                        case ItemType.Scepter:
                        case ItemType.Spear:
                        case ItemType.BowOrCrossbow:
                        case ItemType.Staff:
                            _increaseDamage += 200.0f;
                            _attackSuccessRate += 10.0f;
                            break;
                        case ItemType.Helm:
                            _increaseSDRecovery += 20;
                            _defenseRate += 10;
                            break;
                        case ItemType.Armor:
                            _defenseRate += 10;
                            break;
                        case ItemType.Pant:
                            _defenseRate += 10;
                            break;
                        case ItemType.Gloves:
                            _increaseHP += 200;
                            _defenseRate += 10;
                            break;
                        case ItemType.Boots:
                            _increaseSD += 700;
                            _defenseRate += 10;
                            break;
                    }
                }
            }
        }

        internal Item GetMuun(byte v)
        {
            return _muun.Get(v);
        }

        /// <summary>
        /// Add item to the firts free space in Inventory including Expanded
        /// </summary>
        /// <param name="it">Item</param>
        /// <returns>void</returns>
        public byte Add(Item it)
        {
            if (Character != null)
            {
                it.Account = Character.Account;
                it.Character = Character;
            }
            _needSave = true;
            byte result = 0xff;

            var anyI1 = _inventory.Items.Any(x => x.Value.Number == it.Number && x.Value.Durability < x.Value.BasicInfo.MaxStack);
            var anyI2 = _exInventory1?.Items.Any(x => x.Value.Number == it.Number && x.Value.Durability < x.Value.BasicInfo.MaxStack)??false;
            var anyI3 = _exInventory2?.Items.Any(x => x.Value.Number == it.Number && x.Value.Durability < x.Value.BasicInfo.MaxStack)??false;

            if(anyI1)
                result = _inventory.Add(it);
            else if(anyI2)
                result = _exInventory1.Add(it);
            else if (anyI3)
                result = _exInventory2.Add(it);

            if(result == 0xff)
                result = _inventory.Add(it);

            if (result == 0xff && _exInventory1 != null)
                result = _exInventory1.Add(it);

            if (result == 0xff && _exInventory2 != null)
                result = _exInventory2.Add(it);

            return result;
        }


        /// <summary>
        /// Mount item in slot if have the stats to equip it and apply item effects to character
        /// </summary>
        /// <param name="slot">Target Slot</param>
        /// <param name="item">Item to be equiped</param>
        public void Equip(Equipament slot, Item item)
        {
            var bslot = (byte)slot;
            if (_equipament.ContainsKey(slot))
                throw new InvalidOperationException(ServerMessages.GetMessage(Messages.IVEX_AlreadyEquiped,slot));

            if (Character != null)
            {
                if (item.ReqStrength > Character.StrengthTotal)
                    throw new InvalidOperationException(ServerMessages.GetMessage(Messages.IVEX_NeedMoreStrength, item.ReqStrength));

                if (item.ReqAgility > Character.AgilityTotal)
                    throw new InvalidOperationException(ServerMessages.GetMessage(Messages.IVEX_NeedMoreAgility, item.ReqAgility));

                if (item.ReqVitality > Character.VitalityTotal)
                    throw new InvalidOperationException(ServerMessages.GetMessage(Messages.IVEX_NeedMoreVitality, item.ReqVitality));

                if (item.ReqEnergy > Character.EnergyTotal)
                    throw new InvalidOperationException(ServerMessages.GetMessage(Messages.IVEX_NeedMoreEnergy, item.ReqEnergy));

                if (item.ReqCommand > Character.CommandTotal)
                    throw new InvalidOperationException(ServerMessages.GetMessage(Messages.IVEX_NeedMoreCommand, item.ReqCommand));
            }
            else
            {
                throw new InvalidOperationException(ServerMessages.GetMessage(Messages.IVEX_CharNotLogged, item.ReqCommand));
            }

            item.SlotId = (int)slot;
            item.Storage = StorageID.Equipament;
            _equipament.Add(slot, item);
            item.ApplyEffects(Character);
            item.Character = Character;
            item.Account = Character.Account;

            if (item.Number.Type == ItemType.BowOrCrossbow && (item.Number.Index == 7 || item.Number.Index == 15))
                Arrows = item;

            CalcStats();
            Character.ObjCalc();
            if(Character.Skin == 0xffff && item.BasicInfo.Skin != 0xffff)
                Character.Skin = item.BasicInfo.Skin;
            Character.Change = true;
        }

        /// <summary>
        /// Unmount item from slot and remove item effects from character
        /// </summary>
        /// <param name="slot"></param>
        /// <returns></returns>
        public Item Unequip(Equipament slot)
        {
            if(!_equipament.ContainsKey(slot))
                throw new InvalidOperationException(ServerMessages.GetMessage(Messages.IVEX_UnequipNoEquiped, slot));

            var item = _equipament[slot];
            _equipament.Remove(slot);
            item.RemoveEffects();
            item.SlotId = 0xff;

            CalcStats();
            Character.ObjCalc();
            if (Arrows == item)
                Arrows = null;

            Character.Change = true;
            if (Character.Transformation && item.BasicInfo.Skin == Character.Skin)
            {
                Character.Skin = 0xffff;
                Character.Transformation = false;
                SubSystem.SelfUpdate(Character);
            }

            return item;
        }


        /// <summary>
        /// Move item from inventory
        /// </summary>
        /// <param name="from">Client source flag</param>
        /// <param name="fromIndex">Source Address</param>
        /// <param name="to">Client target flag</param>
        /// <param name="toIndex">Source Address</param>
        /// <returns>If is moved true if fail false</returns>
        public bool Move(MoveItemFlags from, byte fromIndex, MoveItemFlags to, byte toIndex)
        {
            Storage sFrom = null, sTo = null;
            switch(from)
            {
                case MoveItemFlags.Inventory:
                    if (fromIndex < (int)StorageID.ExpandedInventory1)
                    {
                        sFrom = _inventory;
                    }
                    else if (fromIndex < (int)StorageID.ExpandedInventory2)
                    {
                        sFrom = _exInventory1;
                    }
                    else
                    {
                        sFrom = _exInventory2;
                    }
                    break;
                case MoveItemFlags.Warehouse:
                    sFrom = Character.Account.Vault;
                    break;
                case MoveItemFlags.PersonalShop:
                    sFrom = _personalShop;
                    break;
                case MoveItemFlags.ChaosBox:
                case MoveItemFlags.DarkTrainer:
                case MoveItemFlags.OsboumeBox:
                case MoveItemFlags.ElpisBox:
                case MoveItemFlags.JerridonBox:
                case MoveItemFlags.UnsocketSeedBox:
                case MoveItemFlags.SeedMasterBox:
                case MoveItemFlags.SeedAplication:
                    sFrom = _chaosBox;
                    break;
                case MoveItemFlags.Trade:
                    sFrom = _tradeBox;
                    break;
                case MoveItemFlags.Event:
                    sFrom = _event;
                    break;
                case MoveItemFlags.Muun:
                    sFrom = _muun;
                    break;
                default:
                    _logger.Error("Invalid move flag:{0}", from);
                    return false;
            }
            switch (to)
            {
                case MoveItemFlags.Inventory:
                    if (toIndex < (int)StorageID.ExpandedInventory1)
                    {
                        sTo = _inventory;
                    }
                    else if (toIndex < (int)StorageID.ExpandedInventory2)
                    {
                        sTo = _exInventory1;
                    }
                    else
                    {
                        sTo = _exInventory2;
                    }
                    break;
                case MoveItemFlags.Warehouse:
                    sTo = Character.Account.Vault;
                    break;
                case MoveItemFlags.PersonalShop:
                    sTo = _personalShop;
                    break;
                case MoveItemFlags.ChaosBox:
                case MoveItemFlags.DarkTrainer:
                case MoveItemFlags.OsboumeBox:
                case MoveItemFlags.ElpisBox:
                case MoveItemFlags.JerridonBox:
                case MoveItemFlags.UnsocketSeedBox:
                case MoveItemFlags.SeedMasterBox:
                case MoveItemFlags.SeedAplication:
                    sTo = _chaosBox;
                    break;
                case MoveItemFlags.Trade:
                    sTo = _tradeBox;
                    break;
                case MoveItemFlags.Event:
                    sTo = _event;
                    break;
                case MoveItemFlags.Muun:
                    sTo = _muun;
                    break;
                default:
                    _logger.Error("Invalid move flag:{0}", to);
                    return false;
            }

            if (sFrom == null || sTo == null)
                return false;

            Item it = null;

            if (from == MoveItemFlags.Inventory && Enum.IsDefined(typeof(Equipament), (int)fromIndex))
            {
                it = Unequip((Equipament)fromIndex);
            }
            else if(from == MoveItemFlags.Muun && fromIndex < 2)
            {
                it = UnequipMuun(fromIndex);
            }
            else
            {
                it = sFrom.Get(fromIndex);
                sFrom.Remove(fromIndex);
            }
            it.Account = Character.Account;

            Log.Debug(ServerMessages.GetMessage(Messages.IV_MoveItem, from, fromIndex, to, toIndex, it.ToString()));

            try
            {
                if (to == MoveItemFlags.Inventory && Enum.IsDefined(typeof(Equipament), (int)toIndex))
                {
                    Equip((Equipament)toIndex, it);
                }
                else if(to == MoveItemFlags.Muun && toIndex < 2)
                {
                    //sTo.Add(toIndex, it);
                    EquipMuun(toIndex, it);
                }
                else
                {
                    sTo.Add(toIndex, it);

                    if (to == MoveItemFlags.Warehouse)
                    {
                        it.Storage = StorageID.Warehouse;
                        it.Character = null;
                    }
                    else
                    {
                        it.Character = Character;
                        switch(to)
                        {
                            case MoveItemFlags.Trade:
                                if ((it.IsPentagramItem || it.IsPentagramJewel) && it.Durability < 1)
                                    throw new Exception(ServerMessages.GetMessage(Messages.IVEX_PentagramTradeLimit));
                                break;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Log.Logger.Error(ex, ServerMessages.GetMessage(Messages.IV_CantMove));
                if (from == MoveItemFlags.Inventory && fromIndex <= (byte)Equipament.LeftRing)
                {
                    Equip((Equipament)fromIndex, it);
                }
                else
                {
                    sFrom.Add(fromIndex, it);
                }
                Character.Player.Session.Exception(ex);
                return false;
            }
            ItemMoved = it;
            _needSave = true;
            if (TradeOpen)
            {
                var session2 = Character.Player.Window as GSSession;
                _transactions.Add(new Transaction { From = from, fromIndex = fromIndex, To = to, toIndex = toIndex });
                Character.Player.Session.SendAsync(new CTradeButtonOk { Flag = 0 }).Wait();
                session2.SendAsync(new CTradeButtonOk { Flag = 2 }).Wait();
                session2.SendAsync(new STradeOtherAdd { Position = toIndex, ItemInfo = it.GetBytes() }).Wait();
            }
            return true;
        }

        /// <summary>
        /// Rollback any trade transaction
        /// </summary>
        public void TradeRollBack()
        {
            _transactions.Reverse();
            var clone = _transactions.ToList();
            TradeOpen = false;

            Character.Money += TradeBox.Money;

            foreach (var t in clone)
            {
                if (Move(t.To, t.toIndex, t.From, t.fromIndex) == false)
                    throw new Exception(ServerMessages.GetMessage(Messages.IV_CantMove));
            }
        }

        /// <summary>
        /// Returns the item slot passed
        /// </summary>
        /// <param name="from"></param>
        /// <returns>Item, if isn't equiped return null</returns>
        public Item Get(byte from)
        {
            var st = GetStorage(from);
            return st?.Get(from)??Get((Equipament)from);
        }

        /// <summary>
        /// Returns the item equiped in the slot passed
        /// </summary>
        /// <param name="from">The slot needed</param>
        /// <returns>Item, if isn't equiped return null</returns>
        public Item Get(Equipament from)
        {
            if (_equipament.ContainsKey(from))
                return _equipament[from];

            return null;
        }

        /// <summary>
        /// Return a list of item of slot array passed
        /// </summary>
        /// <param name="positions"></param>
        /// <returns></returns>
        public List<Item> Get(IEnumerable<byte> positions)
        {
            var returns = new List<Item>();

            foreach(var p in positions)
                returns.Add(Get(p));

            return returns;
        }

        /// <summary>
        /// Get Main storage object that hold the item
        /// </summary>
        /// <param name="from">item address</param>
        /// <returns>Storage container</returns>
        private Storage GetStorage(byte from)
        {
            foreach (Storage st in Storages.Where(x => x.Value.GetType() == typeof(Storage)).Select(x => (Storage)x.Value))
            {
                if (st.CanContain(from))
                    return st;
            }

            return null;
        }

        /// <summary>
        /// Returns a list of all items in the main inventory including extended inventorys
        /// </summary>
        /// <returns></returns>
        public List<Item> MainInventory()
        {
            var items = new List<Item>();
            items.AddRange(_equipament.Values);
            items.AddRange(_inventory.Items.Values);
            
            if(_exInventory1 != null)
                items.AddRange(_exInventory1.Items.Values);
            if (_exInventory2 != null)
                items.AddRange(_exInventory2.Items.Values);

            return items;
        }

        /// <summary>
        /// Get Main storage object that hold the item
        /// </summary>
        /// <param name="it">Item Object</param>
        /// <returns>Storage container</returns>
        private Storage GetStorage(Item it)
        {
            foreach (Storage st in Storages.Where(x => x.Value.GetType() == typeof(Storage)).Select(x => (Storage)x.Value))
            {
                if (st.Items.ContainsValue(it))
                    return st;
            }

            return null;
        }

        /// <summary>
        /// Remove item from character inventory without delete it from database
        /// </summary>
        /// <param name="from">Position</param>
        public async Task Remove(byte from, bool send = false)
        {
            var st = GetStorage(from);
            st?.Remove(from);
            _equipament.Remove((Equipament)from);

            if (send)
            {
                var session = Character.Player.Session;
                await session.SendAsync(new SInventoryItemDelete(from, 1));
            }
        }

        /// <summary>
        /// Delete item from Database
        /// </summary>
        /// <param name="target">Position</param>
        /// <param name="send">Update client inventory</param>
        /// <returns></returns>
        public async Task Delete(byte target, bool send = true)
        {
            var st = GetStorage(target);
            if (st == null)
                return;

            Item it = null;
            if(send)
            {
                var session = Character.Player.Session;
                await session.SendAsync(new SInventoryItemDelete(target, 1));
            }
            if(st.StorageID == StorageID.Equipament)
            {
                it = Unequip((Equipament)target);
            }
            else
            {
                it = st.Get(target);
                st.Remove(it);
            }
            _toDelete.Add(it);
            it.Delete();
        }

        /// <summary>
        /// Delete item from Database
        /// </summary>
        /// <param name="item">Item object</param>
        /// <param name="send">Update client inventory</param>
        /// <returns></returns>
        public async Task Delete(Item item, bool send = true)
        {
            var slot = (byte)item.SlotId;
            await Delete(slot, send);
        }

        /// <summary>
        /// Sends jewel inventory list
        /// </summary>
        public async void SendJewelsInfo()
        {
            await Character.Player.Session.SendAsync(new SPentagramJewelInfo(0, JewelList));
            await Character.Player.Session.SendAsync(new SPentagramJewelInfo(1, JewelList));
        }
        
        /// <summary>
        /// Sends main inventory item list
        /// </summary>
        public async void SendInventory()
        {
            var message = VersionSelector.CreateMessage<SInventory>() as IInventory;
            var list = new List<KeyValuePair<byte, byte[]>>();

            foreach (var it in _equipament)
            {
                list.Add(new KeyValuePair<byte, byte[]>((byte)it.Key, it.Value.GetBytes()));
            }

            list.AddRange(_inventory.GetInventory());
            if (_exInventory1 != null) list.AddRange(_exInventory1.GetInventory());
            if (_exInventory2 != null) list.AddRange(_exInventory2?.GetInventory());
            list.AddRange(_personalShop.GetInventory());

            message.LoadItems(list.ToArray());

            await Character.Player.Session.SendAsync(message);
        }


        /// <summary>
        /// Get the client charset for character previews
        /// </summary>
        /// <param name="class">Character class</param>
        /// <param name="inv">Inventory object</param>
        /// <param name="ActionNumber">Character action</param>
        /// <returns></returns>
        public static byte[] GetCharset(HeroClass @class, Inventory inv, byte ActionNumber)
        {
            var CharSet = new byte[20];
            var equip = inv._equipament;

            CharSet[0] = Character.GetClientClass(@class);
            switch(ActionNumber)
            {
                case 128:
                    CharSet[0] |= (byte)2u;
                    break;
                case 129:
                    CharSet[0] |= (byte)3u;
                    break;
            }
            var SmallLevel = 0u;

            if (equip.TryGetValue(Equipament.RightHand, out Item it))
            {
                //CS_WEAPON1_TYPE
                CharSet[1] = (byte)it.Number;
                //CS_WEAPON1_DATA
                CharSet[12] |= (byte)((it.Number & 0xF00) >> 4);
                CharSet[10] |= (byte)(it.OptionExe != 0 ? 0x04 : 0x00);
                CharSet[11] |= (byte)(it.SetOption != 0 ? 0x04 : 0x00);
                SmallLevel |= it.SmallPlus;
            } else
            {
                CharSet[1] = 0xff;
                CharSet[12] |= 0xF0;
            }

            if (equip.TryGetValue(Equipament.LeftHand, out it))
            {
                //CS_WEAPON2_TYPE
                CharSet[2] = (byte)it.Number;
                //CS_WEAPON2_DATA
                CharSet[13] |= (byte)((it.Number & 0xF00) >> 4);
                CharSet[10] |= (byte)(it.OptionExe != 0 ? 0x02 : 0x00);
                CharSet[11] |= (byte)(it.SetOption != 0 ? 0x02 : 0x00);
                SmallLevel |= (uint)(it.SmallPlus << 3);
            } else
            {
                CharSet[2] = 0xff;
                CharSet[13] |= 0xF0;
            }

            if(equip.TryGetValue(Equipament.Helm, out it))
            {
                //CS_SET_HELMET1
                CharSet[13] |= (byte)((it.Number.Number&0x1E0) >> 5); //1FF
                //CS_SET_HELMET2
                CharSet[9] |= (byte)((it.Number.Number & 0x10) << 3);
                //CS_SET_HELMET3
                CharSet[3] |= (byte)((it.Number.Number & 0x0F) << 4);
                CharSet[10] |= (byte)(it.OptionExe != 0 ? 0x80 : 0x00);
                CharSet[11] |= (byte)(it.SetOption != 0 ? 0x80 : 0x00);
                SmallLevel |= (uint)(it.SmallPlus << 6);
            }
            else
            {
                CharSet[13] |= 0x0F;
                CharSet[9] |= 0x80;
                CharSet[3] |= 0xF0;
            }

            if (equip.TryGetValue(Equipament.Armor, out it))
            {
                CharSet[14] |= (byte)((it.Number.Number & 0x1E0) >> 1); //1FF
                CharSet[9] |= (byte)((it.Number.Number & 0x10) << 2);
                CharSet[3] |= (byte)((it.Number.Number & 0x0F)/* << 4*/);
                CharSet[10] |= (byte)(it.OptionExe != 0 ? 0x40 : 0x00);
                CharSet[11] |= (byte)(it.SetOption != 0 ? 0x40 : 0x00);
                SmallLevel |= (uint)(it.SmallPlus << 9);
            }
            else
            {
                CharSet[14] |= 0xF0;
                CharSet[9] |= 0x40;
                CharSet[3] |= 0x0F;
            }

            if (equip.TryGetValue(Equipament.Pants, out it))
            {
                CharSet[14] |= (byte)((it.Number.Number & 0x1E0) >> 5); //1FF
                CharSet[9] |= (byte)((it.Number.Number & 0x10) << 1);
                CharSet[4] |= (byte)((it.Number.Number & 0x0F) << 4);
                CharSet[10] |= (byte)(it.OptionExe != 0 ? 0x20 : 0x00);
                CharSet[11] |= (byte)(it.SetOption != 0 ? 0x20 : 0x00);
                SmallLevel |= (uint)(it.SmallPlus << 12);
            }
            else
            {
                CharSet[14] |= 0x0F;
                CharSet[9] |= 0x20;
                CharSet[4] |= 0xF0;
            }

            if (equip.TryGetValue(Equipament.Gloves, out it))
            {
                CharSet[15] |= (byte)((it.Number.Number & 0x1E0) >> 1); //1FF
                CharSet[9] |= (byte)((it.Number.Number & 0x10)/* << 1*/);
                CharSet[4] |= (byte)((it.Number.Number & 0x0F)/* << 4*/);
                CharSet[10] |= (byte)(it.OptionExe != 0 ? 0x10 : 0x00);
                CharSet[11] |= (byte)(it.SetOption != 0 ? 0x10 : 0x00);
                SmallLevel |= (uint)(it.SmallPlus << 15);
            }
            else
            {
                CharSet[15] |= 0xF0;
                CharSet[9] |= 0x10;
                CharSet[4] |= 0x0F;
            }

            if (equip.TryGetValue(Equipament.Boots, out it))
            {
                CharSet[15] |= (byte)((it.Number.Number & 0x1E0) >> 5); //1FF
                CharSet[9] |= (byte)((it.Number.Number & 0x10) << 1);
                CharSet[5] |= (byte)((it.Number.Number & 0x0F) << 4);
                CharSet[10] |= (byte)(it.OptionExe != 0 ? 0x08 : 0x00);
                CharSet[11] |= (byte)(it.SetOption != 0 ? 0x08 : 0x00);
                SmallLevel |= (uint)(it.SmallPlus << 18);
            }
            else
            {
                CharSet[15] |= 0x0F;
                CharSet[9] |= 0x08;
                CharSet[5] |= 0xF0;
            }

            if (equip.TryGetValue(Equipament.Pet, out it))
            {
                if(
                    it.Number.Number == 6723 || //Rudolph
                    it.Number.Number == 6779 //??
                    )
                {
                    CharSet[5] |= 2;
                }

                if ((it.Number.Number & 0x03) != 0)
                {
                    CharSet[10] |= 0x01;
                    CharSet[5] |= (byte)(it.Number.Number & 0x03);
                }

                if(it.Number.Number == ItemNumber.FromTypeIndex(13,4))
                {
                    CharSet[12] |= 0x01;
                }
            }

            if(
                (equip.ContainsKey(Equipament.LeftRing) && (equip[Equipament.LeftRing].Number.Number == ItemNumber.FromTypeIndex(13,169) || equip[Equipament.LeftRing].Number.Number == ItemNumber.FromTypeIndex(13, 170))) ||
               (equip.ContainsKey(Equipament.RightRing) && (equip[Equipament.RightRing].Number.Number == ItemNumber.FromTypeIndex(13, 169) || equip[Equipament.RightRing].Number.Number == ItemNumber.FromTypeIndex(13, 170))))
            {
                CharSet[12] |= 0x08;
            }

            if(equip.TryGetValue(Equipament.Wings, out it))
            {
                Dictionary<int, byte[]> sub;
                // Pre season X
                sub = new Dictionary<int, byte[]>
                {
                                  //[5], [9], [16]
                    { 00, new byte[]{ 04, 0x01, 00 } }, //Wings of Fairy
                    { 01, new byte[]{ 04, 0x02, 00 } }, //Wings of Angel
                    { 02, new byte[]{ 04, 0x03, 00 } }, //Wings of Satan
                    { 03, new byte[]{ 08, 0x01, 00 } }, //Wings of Spirit
                    { 04, new byte[]{ 08, 0x02, 00 } }, //Wings of Soul
                    { 05, new byte[]{ 08, 0x03, 00 } }, //Wings of Dragon
                    { 06, new byte[]{ 08, 0x04, 00 } }, //Wings of Darkness
                    { 30, new byte[]{ 08, 0x05, 00 } },//Cape of lord
                    { 36, new byte[]{ 12, 0x01, 00 } },//Wing of Storm
                    { 37, new byte[]{ 12, 0x02, 00 } },//Wing of Space Time
                    { 38, new byte[]{ 12, 0x03, 00 } },//Wing of Illusion
                    { 39, new byte[]{ 12, 0x04, 00 } },//Wings of Hurricane
                    { 40, new byte[]{ 12, 0x05, 00 } },//Mantle of Monarch
                    { 41, new byte[]{ 04, 0x04, 00 } },//Wing of Mistery
                    { 42, new byte[]{ 12, 0x07, 00 } },//Wing of Despair
                    { 43, new byte[]{ 12, 0x06, 00 } },//Wings of Violent Wind
                    { 49, new byte[]{ 08, 0x07, 00 } },
                    { 50, new byte[]{ 12, 0x07, 00 } },
                    { 51, new byte[]{ 12, 0x00, 08 } },
                    { 52, new byte[]{ 12, 0x00, 09 } },
                    { 53, new byte[]{ 12, 0x00, 10 } },
                    { 54, new byte[]{ 12, 0x00, 11 } },
                    { 55, new byte[]{ 12, 0x00, 12 } },
                    { 56, new byte[]{ 12, 0x00, 13 } },
                    { 57, new byte[]{ 12, 0x00, 14 } },
                    { 139, new byte[]{ 0x00, 0x02, 0x02 << 2 } },
                    { 140, new byte[]{ 0x00, 0x02, 0x03 << 2 } },
                    { 141, new byte[]{ 0x00, 0x02, 0x04 << 2 } },
                    { 142, new byte[]{ 0x00, 0x02, 0x05 << 2 } },
                    { 143, new byte[]{ 0x00, 0x02, 0x06 << 2 } },
                    { 144, new byte[]{ 0x00, 0x02, 0x07 << 2 } },
                    { 145, new byte[]{ 0x00, 0x02, 0x08 << 2 } },
                    { 262, new byte[]{ 0x00, 0x03, 0x00 << 2 } },
                    { 263, new byte[]{ 0x00, 0x03, 0x01 << 2 } },
                    { 264, new byte[]{ 0x00, 0x03, 0x02 << 2 } },
                    { 265, new byte[]{ 0x00, 0x03, 0x03 << 2 } },
                    { 266, new byte[]{ 0x00, 0x03, 0x10 << 2 } },
                    { 267, new byte[]{ 0x00, 0x03, 0x14 << 2 } },
                    { 268, new byte[]{ 0x00, 0x03, 0x10 << 2 } },
                    { 269, new byte[]{ 0x00, 0x03, 0x1C << 2 } },
                    //{ 30, new byte[]{ 0x00, 0x03, 0x18 << 2 } },
                    { 270, new byte[]{ 0x00, 0x04, 0x00 << 2 } },
                    { 278, new byte[]{ 0x00, 0x04, 0x04 << 2 } },
                };

                var info = sub[it.Number.Index];
                CharSet[5] |= info[0];
                CharSet[9] |= info[1];
                CharSet[16] |= info[2];
            }

            if(equip.TryGetValue(Equipament.Pet, out it))
            {
                switch(it.Number.Number)
                {
                    case 6720:
                        CharSet[16] |= 0x20;
                        break;
                    case 6721:
                        CharSet[16] |= 0x40;
                        break;
                    case 6723:
                        CharSet[10] |= 0x01;
                        CharSet[16] |= 0x80;
                        break;
                    case 6736:
                        CharSet[16] |= 0xE0;
                        break;
                    case 6762:
                        CharSet[16] |= 0xA0;
                        break;
                    case 6779:
                        CharSet[16] |= 0x60;
                        break;
                }
            }

            if(inv.Character != null && inv.Character.HaveMount)
            {
                CharSet[12] |= 0x01;
            }

            CharSet[6] = (byte)((SmallLevel >> 16) & 0xff);
            CharSet[7] = (byte)((SmallLevel >>  8) & 0xff);
            CharSet[8] = (byte)(SmallLevel & 0xff);

            return CharSet;
        }

        internal void Remove(Item item, bool send = false) => Remove((byte)item.SlotId, send).Wait();

        /// <summary>
        /// Get the client charset for character previews of the current character
        /// </summary>
        /// <returns></returns>
        public byte[] GetCharset() => GetCharset(Character.Class, this, Character.Action);
        
        /// <summary>
        /// Clear all items in storage container and delete all from DataBase
        /// </summary>
        /// <param name="storage"></param>
        public void DeleteAll(Storage storage)
        {
            foreach(var it in storage.Items.Values)
            {
                _=Delete(it,false);
            }
            storage.Clear();
        }

        /// <summary>
        /// Full clear of ChaosBox
        /// </summary>
        public void DeleteChaosBox() => DeleteAll(ChaosBox);

        // Pentagram System

        /// <summary>
        /// Obtain Jewels Info from Pentagram inventory
        /// </summary>
        /// <returns></returns>
        private IEnumerable<PentagramJewelDto> GetJewelsInfo()
        {
            byte index = 0;
            foreach(var x in _pentagrama)
            {
                var tmp = new PentagramJewelDto
                {
                    MainAttribute = (byte)x.PentagramaMainAttribute,
                    ItemIndex = x.Number.Index,
                    ItemType = (byte)x.Number.Type,
                    JewelIndex = index,
                    JewelPos = 0,
                    Level = x.Plus,
                    Rank1Level = 0xf,
                    Rank1OptionNum = 0xf,
                    Rank2Level = 0xf,
                    Rank2OptionNum = 0xf,
                    Rank3Level = 0xf,
                    Rank3OptionNum = 0xf,
                    Rank4Level = 0xf,
                    Rank4OptionNum = 0xf,
                    Rank5Level = 0xf,
                    Rank5OptionNum = 0xf,
                };
                index++;
                var n = 1;
                foreach (var a in x.Slots)
                {
                    tmp.Set($"Rank{n}OptionNum", (byte)((byte)a & 0x0F));
                    tmp.Set($"Rank{n}Level", (byte)(((byte)a & 0xF0) >> 4));
                }
                yield return tmp;
            }
        }

        /// <summary>
        /// Register a Jewel in Pentagram Item
        /// </summary>
        /// <param name="pItem">Pentagram item to add Jewel</param>
        /// <param name="pJewel">Pentagram Jewel to add</param>
        /// <param name="pos">Slot to mount</param>
        /// <returns>Pentagram inventory jewel position</returns>
        internal int AddPentagramJewel(Item pItem, Item pJewel, int pos)
        {
            pItem.PentagramJewels[pos] = pJewel.Serial;
            var index = _pentagrama.Count;
            pJewel.Storage = StorageID.Pentagram;
            pJewel.SlotId = index;
            _pentagrama.Add(pJewel);
            return index;
        }

        /// <summary>
        /// Jewel list added to Pentagram item
        /// </summary>
        /// <param name="pItem">Pentagram item</param>
        /// <returns>Jewel list linked to item</returns>
        internal IEnumerable<Item> GetPenagramJewels(Item pItem)
        {
            foreach ( var j in _pentagrama.ToList())
            {
                if (pItem.PentagramJewels.Any(x => x == j.Serial))
                    yield return j;
            }
        }

        /// <summary>
        /// Remove pentagran jewel from item and return it to main inventory
        /// </summary>
        /// <param name="pItem"></param>
        /// <param name="pJewel"></param>
        /// <returns></returns>
        internal int DelPentagramJewel(Item pItem, int pJewel)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Transfer pentagram item to another character
        /// </summary>
        /// <param name="pItem"></param>
        /// <param name="inv"></param>
        internal void TransferPentagram(Item pItem, Inventory inv)
        {
            pItem.Durability--;
            foreach (var j in GetPenagramJewels(pItem))
            {
                _pentagrama.Remove(j);
                j.SlotId = inv._pentagrama.Count;
                inv._pentagrama.Add(j);
            }
        }

        internal void Add(List<Item> transfer)
        {
            transfer.ForEach(x => Add(x));
        }

        internal void Remove(List<Item> transfer)
        {
            transfer.ForEach(x => Remove((byte)x.SlotId).Wait());
        }

        public void Dispose()
        {
        }

        internal async Task Save(GameContext db)
        {
            var inv = (Storages[StorageID.Equipament] as Dictionary<Equipament, Item>).Values.ToList();
            inv.AddRange(Storages.Where(x => x.Key != StorageID.Equipament).Select(x => x.Value as Storage).Where(x => x != null).SelectMany(x => x.Items.Values));
            inv.AddRange(_toDelete);
            _toDelete.Clear();
            inv.ForEach(x => x.Save(db));
        }
    }
}


--file Item.cs
﻿using MU.DataBase;
using MuEmu.Data;
using MuEmu.Entity;
using MU.Network.Game;
using MuEmu.Resources;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MU.Resources;
using MuEmu.Util;

namespace MuEmu
{
    public enum ItemState
    {
        Created,
        CreatedAndChanged,
        Saved,
        SavedAndChanged,
        Deleting,
        Deleted,
    }
    public class Item : ICloneable
    {
        private static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(Item));
        public static Dictionary<int, Item> s_ItemDB = new Dictionary<int, Item>();
        private byte _plus;
        private byte _durability;
        private byte _option;
        private StorageID _vid;
        private int _slot;
        private float _durabilityDown;
        private SocketOption[] _slots;
        private JewelOfHarmony _jewelOfHarmony = new JewelOfHarmony();
        private byte _petLevel;
        private ItemNumber _number;
        private Account _account;
        private Character _character;

        private ItemState _state;
        public ItemState State { get => _state; private set
            {
                _state = value;
            }
        }

        private void OnCreate()
        {
            State = ItemState.Created;
        }
        private void OnChange()
        {
            State = State switch
            {
                ItemState.Created => ItemState.CreatedAndChanged,
                ItemState.Saved => Serial==0? ItemState.CreatedAndChanged:ItemState.SavedAndChanged,
                _ => State,
            };
        }
        private void OnDelete()
        {
            State = State switch
            {
                ItemState.Created => ItemState.Deleted,
                ItemState.CreatedAndChanged => ItemState.Deleted,
                ItemState.Saved => ItemState.Deleting,
                ItemState.SavedAndChanged => ItemState.Deleting,
                _ => State,
            };
        }

        public Account Account { get => _account; set
            {
                if (_account == value)
                    return;
                _account = value;
                OnChange();
            }
        }
        public Character Character
        {
            get => _character; set
            {
                if (_character == value)
                    return;
                _character = value;
                OnChange();
            }
        }
        public StorageID Storage
        {
            get => _vid;
            set
            {
                if (_vid == value)
                    return;
                _vid = value;
                OnChange();
            }
        }
        public int SlotId
        {
            get => _slot;
            set
            {
                if (_slot == value)
                    return;
                _slot = value;
                OnChange();
            }
        }
        public bool IsZen => ItemNumber.Zen == Number;

        public ItemInfo BasicInfo { get; set; }
        public ItemNumber Number
        {
            get => _number;
            set
            {
                if (_number == value)
                    return;

                _number = value;
                OnChange();
                OnItemChange();
            }
        }
        public long Serial { get; private set; }
        public byte Plus
        {
            get => _plus;
            set
            {
                if (_plus == value)
                    return;
                _plus = value;

                OnChange();
                OnItemChange();
            }
        }
        public byte SmallPlus => (byte)(Plus > 0 ? (Plus - 1) / 2 : 0);
        public bool Luck { get; set; }
        public bool Skill { get; set; }
        public Spell Spell { get; set; }
        public byte Durability
        {
            get => _durability;
            set
            {
                if (_durability == value)
                    return;

                if (BasicInfo.MaxStack != 0)
                    value = Math.Min(value, BasicInfo.MaxStack);
                else if (DurabilityBase > 0)
                    value = Math.Min(DurabilityBase, value);

                _durability = value;
                OnDurabilityChange(false); 
                OnChange();
            }
        }
        public byte DurabilityBase => GetDurabilityBase();
        public byte Option28
        {
            get => _option;
            set
            {
                if (_option == value)
                    return;

                _option = value;
                OnChange();
                OnItemChange();
            }
        }
        public DateTime ExpireTime { get; set; } = DateTime.MinValue;
        public byte OptionExe { get; set; }

        public byte ExcellentCount => CountOfExcellent();
        public byte SetOption { get; set; }

        public bool Option380 { get => (OptionExe & 0x80) == 1; set => OptionExe = (byte)((OptionExe & 0x7F) | (value ? 0x80 : 0x00)); }
        public uint BuyPrice { get; set; }
        public uint SellPrice { get; set; }
        public int RepairPrice => RepairItemPrice();
        //public HarmonyOption Harmony { get; set; }
        public SocketOption[] Slots
        {
            get => _slots;
            set
            {
                _slots = value;
                OnChange();
                OnItemChange();
            }
        }
        public byte[] RankLevel
        {
            get => _slots.Select(a => (byte)(((byte)a & 0xF0) >> 4)).ToArray();
        }
        public byte[] RankOption
        {
            get => _slots.Select(a => (byte)((byte)a & 0x0F)).ToArray();
        }
        public List<SpecialNumber> Special { get; set; } = new List<SpecialNumber>();
        public JewelOfHarmony Harmony
        {
            get => _jewelOfHarmony;
            set
            {
                _jewelOfHarmony = value;
                OnChange();
            }
        }
        public byte BonusSocket { get; set; }

        public bool IsPentagramItem => (Number.Type == ItemType.Wing_Orb_Seed && (Number.Index >= 200 && Number.Index <= 220));
        public bool IsPentagramJewel => (Number.Type == ItemType.Wing_Orb_Seed && ((Number.Index >= 144 && Number.Index <= 145) || Number.Index == 148 || (Number.Index >= 221 && Number.Index <= 270)));
        public Element PentagramaMainAttribute { get => (Element)(BonusSocket & 0x0f); set => BonusSocket = (byte)(((byte)value) | (BonusSocket & 0xF0)); }
        public long[] PentagramJewels { get; set; } = new long[5];

        public int WingType => ((ushort)Number) switch
        {
            6144 => 1,
            6145 => 1,
            6146 => 1,
            6147 => 2,
            6148 => 2,
            6149 => 2,
            6150 => 2,
            6180 => 3,
            6181 => 3,
            6182 => 3,
            6183 => 3,
            6184 => 3,
            6185 => 1,
            6186 => 2,
            6187 => 3,
            6406 => 4,
            6407 => 4,
            6408 => 4,
            6409 => 4,
            6410 => 4,
            6411 => 4,
            _ => 0,
        };

        /// <summary>
        ///  Wing Damage Absorb in percent
        /// </summary>
        public float WingDmgAbsorb => WingType switch
        {
            1 => 0.12f + Plus * 0.02f,
            2 => 0.25f + Plus * 0.02f,
            3 => 0.39f + Plus * 0.02f,
            4 => 0.43f + Plus * 0.02f,
            _ => 0.0f,
        };

        /// <summary>
        /// Wing Damage increment in percent
        /// </summary>
        public float WingDmgAdd => WingType switch
        {
            1 => 0.12f + Plus * 0.02f,
            2 => 0.32f + Plus * 0.01f,
            3 => 0.39f + Plus * 0.02f,
            4 => 0.55f + Plus * 0.01f,
            _ => 0.0f,
        };

        public uint PShopValueZ { get; set; }
        public ushort PShopValueB { get; set; }
        public ushort PShopValueS { get; set; }
        public ushort PShopValueC { get; set; }

        // Needed Stats
        public int ReqStrength { get; private set; }
        public int ReqAgility { get; private set; }
        public int ReqVitality { get; private set; }
        public int ReqEnergy { get; private set; }
        public int ReqCommand { get; private set; }

        // Options
        public int CriticalDamage => Special.Contains(SpecialNumber.CriticalDamage) ? 4 : 0;
        public int AditionalDamage => Special.Contains(SpecialNumber.AditionalDamage) ? Option28 * 4 : 0;
        public int AditionalMagic => Special.Contains(SpecialNumber.AditionalMagic) ? Option28 * 4 : 0;
        public int AditionalDefense => Special.Contains(SpecialNumber.AditionalDefense) ? Option28 * 4 : 0;
        public int AddLife => Special.Contains(SpecialNumber.AddLife) ? Character.Level * 5 + 50 : 0;
        public int AddMana => Special.Contains(SpecialNumber.AddMana) ? Character.Level * 5 + 50 : 0;
        public int AddStamina => Special.Contains(SpecialNumber.AddStamina) ? 50 : 0;
        public int AddLeaderShip => Special.Contains(SpecialNumber.AddLeaderShip) ? Character.Level * 5 + 10 : 0;

        // Weapon Excellent Effects
        public float ExcellentDmgRate => Number.Type <= ItemType.Shield ? ((((ExcellentOptionWeapons)OptionExe) & ExcellentOptionWeapons.ExcellentDmgRate) != 0 ? 0.1f : 0.0f) : 0.0f;
        public int IncreaseWizardry => Number.Type <= ItemType.Shield ? ((((ExcellentOptionWeapons)OptionExe) & ExcellentOptionWeapons.IncreaseWizardry) != 0 ? (Character?.Level ?? 0) / 20 : 0) : 0;
        public float IncreaseWizardryRate => Number.Type <= ItemType.Shield ? ((((ExcellentOptionWeapons)OptionExe) & ExcellentOptionWeapons.IncreaseWizardryRate) != 0 ? 0.2f : 0) : 0;
        public float IncreaseLifeRate => Number.Type <= ItemType.Shield ? ((((ExcellentOptionWeapons)OptionExe) & ExcellentOptionWeapons.IncreaseLifeRate) != 0 ? 1.0f / 8.0f : 0) : 0;
        public float IncreaseManaRate => Number.Type <= ItemType.Shield ? ((((ExcellentOptionWeapons)OptionExe) & ExcellentOptionWeapons.IncreaseManaRate) != 0 ? 1.0f / 8.0f : 0) : 0;

        // Armor Excellent Effects
        public float IncreaseZenRate => Number.Type > ItemType.Shield && Number.Type <= ItemType.Boots ? ((((ExcellentOptionArmor)OptionExe) & ExcellentOptionArmor.IncreaseZen) != 0 ? 0.4f : 0.0f) : 0.0f;
        public float DefenseSuccessRate => Number.Type > ItemType.Shield && Number.Type <= ItemType.Boots ? ((((ExcellentOptionArmor)OptionExe) & ExcellentOptionArmor.DefenseSuccessRate) != 0 ? 0.1f : 0.0f) : 0.0f;
        public float ReflectDamage => Number.Type > ItemType.Shield && Number.Type <= ItemType.Boots ? ((((ExcellentOptionArmor)OptionExe) & ExcellentOptionArmor.ReflectDamage) != 0 ? 0.05f : 0.0f) : 0.0f;
        public float DamageDecrease => Number.Type > ItemType.Shield && Number.Type <= ItemType.Boots ? ((((ExcellentOptionArmor)OptionExe) & ExcellentOptionArmor.DamageDecrease) != 0 ? 0.04f : 0.0f) : 0.0f;
        public float IncreaseMana => Number.Type > ItemType.Shield && Number.Type <= ItemType.Boots ? ((((ExcellentOptionArmor)OptionExe) & ExcellentOptionArmor.IncreaseMana) != 0 ? 0.04f : 0.0f) : 0.0f;
        public float IncreaseHP => Number.Type > ItemType.Shield && Number.Type <= ItemType.Boots ? ((((ExcellentOptionArmor)OptionExe) & ExcellentOptionArmor.IncreaseHP) != 0 ? 0.04f : 0.0f) : 0.0f;

        public int AttackMin { get; private set; }
        public int AttackMax { get; private set; }
        public bool Attack => AttackMax - AttackMin > 0;
        public int Defense { get; private set; }
        public int DefenseRate { get; private set; }
        public int MagicDefense { get; private set; }
        public long PetEXP { get; internal set; }
        public long PetNextEXP => GetExperienceFromLevel(_petLevel + 1);
        public byte PetLevel
        {
            get => _petLevel;
            internal set
            {
                _petLevel = value;
                if (Character == null)
                    return;

                AttackMin = _petLevel * 15 + Character.CommandTotal / 8 + 180;
                AttackMax = _petLevel * 15 + Character.CommandTotal / 4 + 200;
                AttackSpeed = _petLevel * 4 / 5 + Character.CommandTotal / 50 + 20;
                OnChange();
            }
        }

        public int AttackSpeed { get; internal set; }
        public bool IsMount => BasicInfo.IsMount;

        public static Item Zen(uint BuyPrice)
        {
            return new Item(ItemNumber.Zen, new { BuyPrice });
        }

        public Item(byte[] data)
        {
            using(var ms = new MemoryStream(data))
            {
                ItemNumber number = 0;
                number.Number = (ushort)ms.ReadByte();

                var tmp = ms.ReadByte();
                Skill = (tmp & 128) != 0;
                Luck = (tmp & 4) != 0;
                _option = (byte)(tmp & 3);
                _plus = (byte)((tmp >> 3) & 0xFF);

                _durability = (byte)ms.ReadByte();

                tmp = ms.ReadByte();
                OptionExe = (byte)(tmp & 0x3F);
                _option = (tmp & 0x40) != 0 ? (byte)4 : Option28;
                number.Number |= (ushort)((tmp << 1) & 0x100);

                SetOption = (byte)ms.ReadByte();

                tmp = ms.ReadByte();
                OptionExe |= (byte)((tmp << 4) & 0x80);
                number.Number |= (ushort)((tmp << 5) & 0x1E00);

                _number = number;
                var ItemDB = ResourceCache.Instance.GetItems();

                if (!ItemDB.ContainsKey(number))
                    throw new Exception("Item don't exists " + number);
                BasicInfo = ItemDB[number];

                tmp = ms.ReadByte();
                if (IsPentagramItem || IsPentagramJewel)
                    BonusSocket = (byte)tmp;
                else
                    Harmony = (byte)tmp;

                var l = new List<SocketOption>();
                tmp = ms.ReadByte();
                if (tmp != 0xff)
                    l.Add((SocketOption)tmp);
                tmp = ms.ReadByte();
                if (tmp != 0xff)
                    l.Add((SocketOption)tmp);
                tmp = ms.ReadByte();
                if (tmp != 0xff)
                    l.Add((SocketOption)tmp);
                tmp = ms.ReadByte();
                if (tmp != 0xff)
                    l.Add((SocketOption)tmp);
                tmp = ms.ReadByte();
                if (tmp != 0xff)
                    l.Add((SocketOption)tmp);

                Slots = l.ToArray();

                GetValue();
                CalcItemAttributes();
                State = ItemState.Created;
            }
        }

        public Item(ItemNumber number, object Options = null)
        {
            var ItemDB = ResourceCache.Instance.GetItems();

            if (!ItemDB.ContainsKey(number))
                throw new Exception("Item don't exists " + number);

            BasicInfo = ItemDB[number];
            _durability = BasicInfo.Durability;
            if (_durability == 0)
                _durability = 1;
            _slots = Array.Empty<SocketOption>();

            if (Options != null)
                Extensions.AnonymousMap(this, Options);

            Harmony.Item = this;

            Number = number;
            GetValue();
            CalcItemAttributes();
            State = ItemState.Created;
        }

        public Item(ItemDto dto, Account acc = null, Character @char = null)
        {
            var ItemDB = ResourceCache.Instance.GetItems();

            if (!ItemDB.ContainsKey(dto.Number))
                throw new Exception("Item don't exists " + dto.Number);

            _account = acc;
            _character = @char;
            BasicInfo = ItemDB[dto.Number];
            _slot = dto.SlotId;
            Serial = dto.ItemId;
            State = ItemState.Saved;
            Skill = dto.Skill;
            _number = dto.Number;
            _plus = dto.Plus;
            Luck = dto.Luck;
            _option = dto.Option;
            OptionExe = dto.OptionExe;
            _durability = dto.Durability;
            _vid = (StorageID)dto.VaultId;
            BonusSocket = dto.SocketBonus;
            PetEXP = dto.PetEXP;
            SetOption = dto.SetOption;
            _petLevel = dto.PetLevel;

            if (string.IsNullOrEmpty(dto.SocketOptions))
            {
                _slots = Array.Empty<SocketOption>();
            }
            else
            {
                var tmp = dto.SocketOptions.Split(",");
                _slots = tmp.Select(x => Enum.Parse<SocketOption>(x)).ToArray();
            }

            if (!string.IsNullOrEmpty(dto.PJewels))
            {
                var tmp = dto.PJewels.Split(",");
                PentagramJewels = tmp.Select(x => long.Parse(x)).ToArray();
            }

            _jewelOfHarmony = dto.HarmonyOption;
            Harmony.Item = this;

            GetValue();
            CalcItemAttributes();
            if (_durability == BasicInfo.MaxStack && BasicInfo.OnMaxStack != ItemNumber.Invalid)
            {
                Number = BasicInfo.OnMaxStack;
            }
            //OnChange();
        }

        internal void AddExperience(int gain)
        {
            byte type = 0;
            if (PetEXP < GetExperienceFromLevel(71))
                switch (Number)
                {
                    case 6660: //Dark Horse
                        PetEXP += gain;
                        type = 1;
                        break;
                    case 6661: //Dark Raven
                        PetEXP += gain;
                        break;
                }
            else
                PetEXP = GetExperienceFromLevel(71);

            if (PetEXP < 0)
                PetEXP = 0;

            var levelUp = false;
            while (PetEXP > PetNextEXP && PetLevel < 70)
            {
                PetLevel++;
                levelUp = true;
                OnChange();
            }

            if (levelUp)
                _ = Character.Player.Session.SendAsync(new SPetInfo
                {
                    Dur = Durability,
                    Exp = (int)PetEXP,
                    InvenType = 0xFE,
                    Level = PetLevel,
                    nPos = (byte)SlotId,
                    PetType = type,
                });
            else
            {
                _ = Character.Player.Session.SendAsync(new SPetInfo
                {
                    Dur = Durability,
                    Exp = (int)PetEXP,
                    InvenType = 0,
                    Level = PetLevel,
                    nPos = (byte)SlotId,
                    PetType = type,
                });
            }
        }

        internal long GetExperienceFromLevel(int level)
        {
            return ((long)100) * (level + 10) * level * level * level;
        }

        public byte[] GetBytes()
        {
            using (var ms = new MemoryStream(15))
            {
                ms.WriteByte((byte)(Number & 0xff));

                // Is ZEN?
                if (Number == ItemNumber.Zen)
                {
                    // 0 1 2 3
                    // 3 2 1 0
                    var arr = BitConverter.GetBytes(BuyPrice);
                    ms.WriteByte(arr[2]);
                    ms.WriteByte(arr[1]);
                    ms.WriteByte(0);
                    ms.WriteByte(arr[0]);
                    ms.WriteByte((byte)((Number & 0x1E00) >> 5));
                    ms.WriteByte(0);

                    ms.WriteByte(0);
                    ms.WriteByte(0);
                    ms.WriteByte(0);
                    ms.WriteByte(0);
                    ms.WriteByte(0);
                }
                else
                {
                    var tmp = (Plus << 3) | (Skill ? 128 : 0) | (Luck ? 4 : 0) | Option28 & 3;
                    ms.WriteByte((byte)tmp);
                    ms.WriteByte(Durability);
                    ms.WriteByte((byte)(((Number & 0x100) >> 1) | (Option28 > 3 ? 0x40 : 0) | (byte)(OptionExe & 0x3f)));
                    ms.WriteByte(SetOption); // Acient Option

                    byte itemPeriod = 0;
                    if (ExpireTime != DateTime.MinValue)
                    {
                        itemPeriod |= 0x01;
                        itemPeriod |= (byte)((DateTime.Now > ExpireTime) ? 0x02 : 0x00);
                        itemPeriod <<= 1;
                    }

                    byte Option380 = (byte)((OptionExe & 0x80) >> 4);
                    byte LeftItemType = (byte)((Number & 0x1E00) >> 5);
                    byte complete = (byte)(LeftItemType | Option380 | itemPeriod);

                    ms.WriteByte(complete);
                    if (IsPentagramItem || IsPentagramJewel)
                    {
                        ms.WriteByte(BonusSocket);
                    }
                    else
                    {
                        ms.WriteByte(Harmony); // Harmony
                    }
                    foreach (var slot in Slots)
                    {
                        ms.WriteByte((byte)slot);
                    }
                    for (var i = 0; i < 5 - Slots.Length; i++)
                    {
                        ms.WriteByte((byte)SocketOption.None);
                    }
                }
                ms.WriteByte(0);
                ms.WriteByte(0);
                ms.WriteByte(0);
                ms.WriteByte(0);
                return ms.GetBuffer().Take(15).ToArray();
            }
        }

        private void GetValue()
        {
            if (BuyPrice != 0)
                return;

            if (BasicInfo.Zen > 0)
            {
                var res = (int)Math.Log10(BasicInfo.Zen) - 1;
                if (res > 0)
                {
                    var div = (uint)Math.Pow(10, res);
                    BuyPrice = (uint)(BasicInfo.Zen / div);
                    BuyPrice *= div;
                }
                else
                {
                    BuyPrice = (uint)BasicInfo.Zen;
                }

                res = (int)Math.Log10(BasicInfo.Zen / 3.0) - 1;
                if (res > 0)
                {
                    var div = (uint)Math.Pow(10, res);
                    SellPrice = (uint)(BasicInfo.Zen / (3.0 * div));
                    SellPrice *= div;
                }
                else
                {
                    SellPrice = (uint)(BasicInfo.Zen / 3.0);
                }
            }
            else
            {
                var Gold = 0;
                var level2 = BasicInfo.Level + Plus * 3;

                if (((byte)ExcellentOptionArmor.FullItem & OptionExe) != 0)
                {
                    level2 += 25;
                }

                switch (Number)
                {
                    case 2063: //Arrow
                        Gold = Plus == 0 ? 70 : 1200 + (Plus - 1) * 800;
                        Gold *= Durability / BasicInfo.Durability;
                        break;
                    case 2055: //Arrow Crossbow
                        Gold = Plus == 0 ? 100 : 1400 + (Plus - 1) * 800;
                        Gold *= Durability / BasicInfo.Durability;
                        break;
                    case 7181: // Bless
                        Gold = 9000000;
                        break;
                    case 7182: // Soul
                        Gold = 6000000;
                        break;
                    case 6159: // Chaos
                        Gold = 8100000;
                        break;
                    case 7184: // Life
                        Gold = 45000000;
                        break;
                    case 7190: // Creation
                        Gold = 18000000;
                        break;
                    case 6174: // Pack of Bless
                        Gold = (Plus + 1) * 9000000 * 10;
                        break;
                    case 6175: // Pack of Soul
                        Gold = (Plus + 1) * 9000000 * 10;
                        break;
                    case 6671: // Fruits
                        Gold = 33000000;
                        break;
                    case 6670: // Blue Feather | Crest ofMonarch
                        Gold = Plus == 1 ? 7500000 : 180000;
                        break;
                    case 7199: // Jewel of Guardian
                        Gold = 30000000;
                        break;
                    case 14 * 512 + 7: // Siege Potion
                        Gold = Durability * (Plus == 0 ? 900000 : 450000);
                        break;
                    case 13 * 512 + 11: // Order(Guardian/Life Stone)
                        Gold = Plus == 0 ? 1000000 : 2400000;
                        break;
                    case 13 * 512 + 7: // Contract(Summon)
                        Gold = Plus == 0 ? 1500000 : 1200000;
                        break;
                    case 13 * 512 + 32: // Splinter of Armor
                        Gold = Durability * 150;
                        break;
                    case 13 * 512 + 33: // Bless of Guardian
                        Gold = Durability * 300;
                        break;
                    case 13 * 512 + 34: // Claw of Beast
                        Gold = Durability * 3000;
                        break;
                    case 13 * 512 + 35: // Piece of Horn
                        Gold = 30000;
                        break;
                    case 13 * 512 + 36: // Broken Horn
                        Gold = 90000;
                        break;
                    case 13 * 512 + 37: // Horn of Fenrir
                        Gold = 150000;
                        break;
                    case 14 * 512 + 35: // Small SD Potion
                        Gold = Durability * 2000;
                        break;
                    case 14 * 512 + 36: // SD Potion
                        Gold = Durability * 4000;
                        break;
                    case 14 * 512 + 37: // Large SD Potion
                        Gold = Durability * 6000;
                        break;
                    case 14 * 512 + 38: // Small Complex Potion
                        Gold = Durability * 2500;
                        break;
                    case 14 * 512 + 39: // Complex Potion
                        Gold = Durability * 5000;
                        break;
                    case 14 * 512 + 40: // Large Complex Potion
                        Gold = Durability * 7500;
                        break;
                    case 13 * 512 + 109:
                    case 13 * 512 + 110:
                    case 13 * 512 + 111:
                    case 13 * 512 + 112:
                    case 13 * 512 + 113:
                    case 13 * 512 + 114:
                    case 13 * 512 + 115:
                        Gold = 3000;
                        break;
                    case 13 * 512 + 3: // Dinorant
                        Gold = 960000;
                        break;
                    case 14 * 512 + 17: // Devil Eye
                    case 14 * 512 + 18: // Devil Key
                        Gold = (int)(15000 + (6000 * (Plus > 2 ? (Plus - 2) * 2.5 : 1)));
                        break;
                    case 14 * 512 + 19: // Devil Invitation
                        Gold = (int)(60000 + (24000 * (Plus > 2 ? (Plus - 2) * 2.5 : 1)));
                        break;
                    case 14 * 512 + 20: // Remedy of Love
                        Gold = 900;
                        break;
                    case 14 * 512 + 21: // Rena
                        switch (Plus)
                        {
                            case 0:
                                Gold = 9000;
                                Durability = BasicInfo.Durability;
                                break;
                            case 1:
                                Gold = 9000;
                                Durability = BasicInfo.Durability;
                                break;
                            case 3:
                                Gold = 3900 * Durability;
                                break;
                            default:
                                Durability = BasicInfo.Durability;
                                Gold = 9000;
                                break;
                        }
                        break;
                    case 14 * 512 + 9: // Ale
                        Gold = 1000;
                        break;
                    case 13 * 512 + 18: // Invisibility Cloak
                        Gold = 200000 + (Plus > 1 ? 20000 * (Plus - 1) : -150000);
                        break;
                    case 13 * 512 + 16: // Blood and Paper of BloodCastle
                    case 13 * 512 + 17:
                        switch (Plus)
                        {
                            case 1: Gold = 15000; break;
                            case 2: Gold = 21000; break;
                            case 3: Gold = 30000; break;
                            case 4: Gold = 39000; break;
                            case 5: Gold = 48000; break;
                            case 6: Gold = 60000; break;
                            case 7: Gold = 75000; break;
                        }
                        break;
                    case 13 * 512 + 29: // Armor of Guardman
                        Gold = 5000;
                        break;
                    case 13 * 512 + 20: // Wizards Ring
                        Gold = 30000;
                        break;
                    case 13 * 512 + 31: // Spirit
                        Gold = 30000000;
                        break;
                    case 14 * 512 + 28: // Lost Map
                        Gold = 600000;
                        break;
                    case 14 * 512 + 29: // Simbol of Kundum
                        Gold = (int)(10000.0f * Durability * 3.0f);
                        break;
                    case 14 * 512 + 45: // Haloween
                    case 14 * 512 + 46: // Haloween
                    case 14 * 512 + 47: // Haloween
                    case 14 * 512 + 48: // Haloween
                    case 14 * 512 + 49: // Haloween
                    case 14 * 512 + 50: // Haloween
                        Gold = (int)(50.0f * Durability * 3.0f);
                        break;
                    case 12 * 512 + 26: // Gem of Secret
                        Gold = 60000;
                        break;
                    case 14 * 512 + 51: // Sky Event Invitation
                        Gold = 200000;
                        break;
                    case 14 * 512 + 55: // Green Chaos Box
                    case 14 * 512 + 56: // Red Chaos Box
                    case 14 * 512 + 57: // Purple Chaos Box
                        Gold = 9000;
                        break;
                    case 13 * 512 + 49: // Scroll of Illusion
                    case 13 * 512 + 50: // Potion of Illusion
                    case 13 * 512 + 51: // Illusion's Plataform
                        switch (Plus)
                        {
                            case 1:
                                Gold = 500000;
                                break;
                            case 2:
                                Gold = 600000;
                                break;
                            case 3:
                                Gold = 800000;
                                break;
                            case 4:
                                Gold = 1000000;
                                break;
                            case 5:
                                Gold = 1200000;
                                break;
                            case 6:
                                Gold = 1400000;
                                break;
                            default:
                                Gold = 9000;
                                break;
                        }
                        break;
                    case 13 * 512 + 52: // Flame of Condor
                    case 13 * 512 + 53: // Condor's Feathers
                        Gold = 3000000;
                        break;
                    case 13 * 512 + 71: // Sword / Spear/ Blade / Axe
                    case 13 * 512 + 72: // Staff
                    case 13 * 512 + 73: // Bow / Crossbow
                    case 13 * 512 + 74: // Scepter
                    case 13 * 512 + 75: // Sticks
                        Gold = 1000000;
                        break;
                    case 14 * 512 + 23: // Scroll of the Emperor
                    case 14 * 512 + 24: // Broken Sword
                    case 14 * 512 + 25: // Tear of Elf
                    case 14 * 512 + 26: // Soul of Wizard
                    case 14 * 512 + 65: // Flame of Death Beam Knight
                    case 14 * 512 + 66: // Horn of Hell Maine
                    case 14 * 512 + 67: // Feather of Phoenix of Darkness
                    case 14 * 512 + 68: // Eye of the Abyss
                        Gold = 9000;
                        break;
                    case 12 * 512 + 136: // life boundle
                        Gold = (Plus + 1) * 22500000 * 10;
                        break;
                    case 12 * 512 + 137: // creation bundle
                        Gold = (Plus + 1) * 18000000 * 10;
                        break;
                    case 12 * 512 + 138: // guardian bundle
                        Gold = (Plus + 1) * 30000000 * 10;
                        break;
                    case 12 * 512 + 139: // gemstone bundle
                        Gold = (Plus + 1) * 18600 * 10;
                        break;
                    case 12 * 512 + 140: // harmony boundle
                        Gold = (Plus + 1) * 18600 * 10;
                        break;
                    case 12 * 512 + 141: // chaos bundle
                        Gold = (Plus + 1) * 810000 * 10;
                        break;
                    case 12 * 512 + 142: //  bundle
                        Gold = (Plus + 1) * 18600 * 10;
                        break;
                    case 12 * 512 + 143: //  bundle
                        Gold = (Plus + 1) * 18600 * 10;
                        break;
                    case 14 * 512 + 63: // Fireworks
                        Gold = 200000;
                        break;
                    case 14 * 512 + 85: // Cherry Blossom Wine
                    case 14 * 512 + 86: // Cherry Blossom Dumpling
                    case 14 * 512 + 87: // Cherry Blossom Petal
                    case 14 * 512 + 90: // White Cherry Blossom
                        Gold = Durability * 300;
                        break;
                    case 14 * 512 + 110: // 
                        Gold = Durability * 30000;
                        break;
                    case 14 * 512 + 111: // 
                        Gold = 600000;
                        break;
                    default:
                        if ((Number.Type == ItemType.Wing_Orb_Seed && ((Number.Index > 6 && Number.Index < 36))
                            || (Number.Index > 43 && Number.Index < 440))
                            || Number.Type == ItemType.Missellaneo || Number.Type == ItemType.Scroll)
                        {
                            Gold = level2 * level2 * level2 + 100;
                            break;
                        }

                        switch (Plus)
                        {
                            case 5: level2 += 4; break;
                            case 6: level2 += 10; break;
                            case 7: level2 += 25; break;
                            case 8: level2 += 45; break;
                            case 9: level2 += 65; break;
                            case 10: level2 += 95; break;
                            case 11: level2 += 135; break;
                            case 12: level2 += 185; break;
                            case 13: level2 += 245; break;
                        }

                        if (Number.Type == ItemType.Wing_Orb_Seed && Number.Index <= 6) // Wings
                        {
                            Gold = (level2 + 40) * level2 * level2 * 11 + 40000000;
                            break;
                        }

                        if (Number.Type == ItemType.Wing_Orb_Seed && Number.Index >= 36 && Number.Index <= 43) // Wings
                        {
                            Gold = (level2 + 40) * level2 * level2 * 11 + 40000000;
                            break;
                        }

                        if (Number.Type == ItemType.Wing_Orb_Seed && Number.Index == 50) // Wings
                        {
                            Gold = (level2 + 40) * level2 * level2 * 11 + 40000000;
                            break;
                        }

                        Gold = ((level2 + 40) * level2 * level2 / 8 + 100);

                        if (Number.Type >= ItemType.Sword && Number.Type <= ItemType.Shield)
                        {
                            if (BasicInfo.Size.Width == 1)
                            {
                                Gold = Gold * 80 / 100;
                            }
                        }

                        foreach (var sp in Special)
                        {
                            switch (sp)
                            {
                                case (SpecialNumber)18:
                                case (SpecialNumber)19:
                                case (SpecialNumber)20:
                                case (SpecialNumber)21:
                                case (SpecialNumber)22:
                                case (SpecialNumber)23:
                                case (SpecialNumber)24:
                                case (SpecialNumber)56:
                                    Gold = (int)(Gold * 1.5f);
                                    break;
                                case SpecialNumber.AditionalDamage:
                                case SpecialNumber.AditionalMagic:
                                case SpecialNumber.AditionalDefense:
                                case SpecialNumber.RecoverLife:
                                case SpecialNumber.CurseDamage:
                                    switch (Option28)
                                    {
                                        case 1:
                                            Gold += (int)(Gold * 6.0 / 10.0);
                                            break;

                                        case 2:
                                            Gold += (int)(Gold * 14.0 / 10.0);
                                            break;

                                        case 3:
                                            Gold += (int)(Gold * 28.0 / 10.0);
                                            break;

                                        case 4:
                                            Gold += (int)(Gold * 56.0 / 10.0);
                                            break;
                                    }
                                    break;
                                case SpecialNumber.SuccessFullBlocking:
                                    Gold += (int)(Gold * 25.0 / 100.0);
                                    break;

                                case (SpecialNumber)86:
                                case (SpecialNumber)87:
                                case (SpecialNumber)88:
                                case (SpecialNumber)89:
                                case (SpecialNumber)90:
                                case (SpecialNumber)91:
                                case (SpecialNumber)92:
                                case (SpecialNumber)93:
                                case (SpecialNumber)94:
                                case (SpecialNumber)95:
                                case (SpecialNumber)96:
                                case (SpecialNumber)97:
                                case (SpecialNumber)98:
                                case (SpecialNumber)99:
                                    Gold += Gold;
                                    break;

                                case (SpecialNumber)100:
                                case (SpecialNumber)101:
                                case (SpecialNumber)102:
                                case (SpecialNumber)103:
                                case (SpecialNumber)104:
                                case (SpecialNumber)108:
                                case (SpecialNumber)109:
                                case (SpecialNumber)110:
                                case (SpecialNumber)111:
                                    Gold += (int)(Gold * 25.0 / 100.0);
                                    break;
                            }
                        }
                        break;
                }

                if (BasicInfo.Zen > 0)
                {
                    Gold += (BasicInfo.Zen * BasicInfo.Zen * 10) / 12;

                    if (Number >= 14 * 512 + 0 && Number <= 14 * 512 + 8)
                    {
                        if ((int)Number == 14 * 512 + 3 || (int)Number == 14 * 512 + 6)
                        {
                            Gold *= 2;
                        }

                        if (Plus > 0)
                        {
                            Gold *= Plus * Plus; ;
                        }
                    }
                }

                BuyPrice = (uint)Gold;
                SellPrice = (uint)(Gold / 3.0);
            }
        }

        internal async Task<DateTimeOffset> Drop(byte mapX, byte mapY)
        {
            await Character.Player.Session
                .SendAsync(new SItemThrow { Source = (byte)SlotId, Result = 1 });

            var map = Character.Map;
            var output = map.AddItem(mapX, mapY, Clone() as Item, Character);
            //Delete();
            await Character?.Inventory.Delete(this);

            return output;
        }

        public void ApplyEffects(Character tTarget)
        {
            if (tTarget == null)
                return;

            Character = tTarget;
            if (Skill && Spell != Spell.None)
                Character.Spells.ItemSkillAdd(this.Spell);
        }

        public void RemoveEffects()
        {
            if (Skill && Spell != Spell.None)
                Character.Spells.ItemSkillDel(this.Spell);

            Character.CalcStats();
        }

        public ItemDto Save(GameContext db)
        {
            var log = Logger;
            ItemDto _db = null;
            
            if(Account != null)
                log = Logger.ForAccount(Account.Player.Session);

            if (State == ItemState.Deleted) return null;

            if(State == ItemState.Saved || State == ItemState.SavedAndChanged || State == ItemState.Deleting)
                _db = db.Items.Find(Serial);
            else if (State == ItemState.Created || State == ItemState.CreatedAndChanged)
                _db = new ItemDto();

            if (State == ItemState.Saved)
                return _db;

            if(State == ItemState.Deleting)
            {
                log.Information($"[A{_db.AccountId}->{_vid}:{_slot}]Item Removed:{ToString()}" + " {0}", State);
                State = ItemState.Deleted;
                db.Remove(_db);
                return null;
            }

            _db.AccountId = Account?.ID ?? 0;
            _db.CharacterId = Character?.Id ?? 0;
            _db.VaultId = (int)_vid;
            _db.SlotId = _slot;
            _db.Number = Number;
            _db.Plus = _plus;
            _db.Luck = Luck;
            _db.Skill = Skill;
            _db.Option = Option28;
            _db.OptionExe = OptionExe;
            _db.HarmonyOption = Harmony;
            _db.SocketOptions = string.Join(",", _slots.Select(x => x.ToString()));
            _db.Durability = Durability;
            _db.PJewels = string.Join(",", PentagramJewels.Select(x => x.ToString()));
            _db.PetLevel = PetLevel;
            _db.PetEXP = PetEXP;
            _db.SetOption = SetOption;

            var str = $"[A{_db.AccountId}->{_vid}:{_slot}]Item Saved:{ToString()}";
            log.Information(str+" {0}", State);

            db.Update(_db);
            if(State == ItemState.Created || State == ItemState.CreatedAndChanged)
            {
                db.SaveChanges();
                Serial = _db.ItemId;
            }
            State = ItemState.Saved;
            return _db;
        }

        public void Delete()
        {
            var log = Logger;

            if (Account != null)
                log = Logger.ForAccount(Account.Player.Session);

            OnDelete();
            log.Information($"[A{Account?.ID??0}->{_vid}:{_slot}]Item Deleting:{ToString()}" + " {0}", State);
        }

        private void CalcItemAttributes()
        {
            var itemLevel = BasicInfo.Level;
            if (SetOption != 0)
                itemLevel += 25;

            if (BasicInfo.Str != 0)
                ReqStrength = (BasicInfo.Str * (itemLevel + Plus * 3) * 3) / 100 + 20;

            if (BasicInfo.Ene != 0)
                ReqEnergy = (BasicInfo.Ene * (itemLevel + Plus * 3) * 3) / 100 + 20;

            if (BasicInfo.Agi != 0)
                ReqAgility = (BasicInfo.Agi * (itemLevel + Plus * 3) * 3) / 100 + 20;

            if (BasicInfo.Vit != 0)
                ReqVitality = (BasicInfo.Vit * (itemLevel + Plus * 3) * 3) / 100 + 20;

            if (BasicInfo.Cmd != 0)
                ReqCommand = (BasicInfo.Cmd * (itemLevel + Plus * 3) * 3) / 100 + 20;

            AttackMax = BasicInfo.Damage.Y + Plus * 3;
            AttackMin = BasicInfo.Damage.X + Plus * 3;
            Defense = BasicInfo.Def + Plus * 3;
            DefenseRate = BasicInfo.DefRate + Plus * 3;

            //if(Number == ItemNumber.FromTypeIndex(13,5)) // Dark Spirit
            //{
            //    ReqCommand = 
            //}

            switch (Harmony.Type)
            {
                case 1:
                    switch (Harmony.Option)
                    {
                        case 1:
                            AttackMin += Harmony.EffectValue;
                            break;
                        case 2:
                            AttackMax += Harmony.EffectValue;
                            break;
                        case 3: //DECREASE_REQUIRE_STR
                            ReqStrength -= Harmony.EffectValue;
                            break;
                        case 4: //DECREASE_REQUIRE_DEX
                            ReqAgility -= Harmony.EffectValue;
                            break;
                        case 5:
                            AttackMax += Harmony.EffectValue;
                            AttackMin += Harmony.EffectValue;
                            break;
                        case 6:
                            //CriticalDamage += Harmony.EffectValue;
                            break;
                        case 7:
                            break;
                    }
                    break;
                case 2:
                    switch (Harmony.Option)
                    {
                        case 2: //DECREASE_REQUIRE_STR
                            ReqStrength -= Harmony.EffectValue;
                            break;
                        case 3: //DECREASE_REQUIRE_DEX
                            ReqAgility -= Harmony.EffectValue;
                            break;
                    }
                    break;
                case 3:// Defense
                    switch (Harmony.Option)
                    {
                        case 1:
                            Defense += Harmony.EffectValue;
                            break;
                        case 2:
                            break;
                        case 3:
                            //IncreaseHP += Harmony.EffectValue;
                            break;
                    }
                    break;
            }


            if (Skill && BasicInfo.Skill != 0)
            {
                Spell = BasicInfo.Skill;
                if (Spell == Spell.ForceWave)
                {
                    Special.Add(0);
                }
                else
                {
                    Special.Add((SpecialNumber)Spell);
                }
            }
            else
            {
                Skill = false;
            }

            switch (Number)
            {
                // Dinorant
                case 13 * 512 + 3:
                    Skill = true;
                    Spell = Spell.FireBreath;
                    break;
                // DarkHorse
                case 13 * 512 + 4:
                    Skill = true;
                    Spell = Spell.Earthshake;
                    break;
                // Fenrir
                case 13 * 512 + 37:
                    Skill = true;
                    Spell = Spell.PlasmaStorm;
                    break;
                // Sahamut
                case 5 * 512 + 21:
                    Skill = true;
                    Spell = Spell.Sahamutt;
                    break;
                // Neil
                case 5 * 512 + 22:
                    Skill = true;
                    Spell = Spell.Neil;
                    break;
                // Ghost Phantom
                case 5 * 512 + 23:
                    Skill = true;
                    Spell = Spell.GhostPhantom;
                    break;
            }

            if (Luck)
            {
                if (Number.Type < ItemType.Wing_Orb_Seed)
                {
                    Special.Add(SpecialNumber.CriticalDamage);
                }
                else if (Number.Type == ItemType.Wing_Orb_Seed && Number.Index <= 6) // Wings
                {
                    Special.Add(SpecialNumber.CriticalDamage);
                }
                else if (Number.Type == ItemType.Wing_Orb_Seed && Number.Index >= 130 && Number.Index <= 135) // Wings
                {
                    Special.Add(SpecialNumber.CriticalDamage);
                }
                else if (Number.Type == ItemType.Wing_Orb_Seed && Number.Index >= 36 && Number.Index <= 43) // Wings S3
                {
                    Special.Add(SpecialNumber.CriticalDamage);
                }
                else if (Number.Type == ItemType.Wing_Orb_Seed && Number.Index == 50) // Wings S3
                {
                    Special.Add(SpecialNumber.CriticalDamage);
                }
                else if (Number == ItemNumber.FromTypeIndex(13, 30) || Number == ItemNumber.FromTypeIndex(12, 49)) // Cape of Lord
                {
                    Special.Add(SpecialNumber.CriticalDamage);
                }
            }

            if (Option28 > 0)
            {
                if (Number.Type < ItemType.Staff)
                {
                    Special.Add(SpecialNumber.AditionalDamage);
                    ReqStrength += Option28 * 4;
                }
                else if (Number.Type >= ItemType.Staff && Number.Type < ItemType.Shield)
                {
                    Special.Add(SpecialNumber.AditionalMagic);
                    ReqStrength += Option28 * 4;
                }
                else if (Number.Type >= ItemType.Shield && Number.Type < ItemType.Helm)
                {
                    Special.Add(SpecialNumber.AditionalDefense);
                    ReqStrength += Option28 * 4;
                }
                else if (Number.Type >= ItemType.Helm && Number.Type < ItemType.Wing_Orb_Seed)
                {
                    Special.Add(SpecialNumber.AditionalDefense);
                    ReqStrength += Option28 * 4;
                }
                else if (Number == ItemNumber.FromTypeIndex(12, 0)) // Wing elf
                {
                    Special.Add(SpecialNumber.RecoverLife);
                }
                else if (Number == ItemNumber.FromTypeIndex(12, 1)) // Wing Heaven
                {
                    Special.Add(SpecialNumber.AditionalMagic);
                    ReqStrength += Option28 * 4;
                }
                else if (Number == ItemNumber.FromTypeIndex(12, 2)) // Wing devil
                {
                    Special.Add(SpecialNumber.AditionalDamage);
                    ReqStrength += Option28 * 4;
                }
                else if (Number == ItemNumber.FromTypeIndex(12, 3)) // Wing spitits
                {
                    Special.Add(SpecialNumber.AditionalDamage);
                    ReqStrength += Option28 * 4;
                }
            }

            Defense = BasicInfo.Def;

            if (Defense > 0)
            {
                if (Number.Type == ItemType.Shield)
                {
                    Defense += Plus;
                }
                else
                {
                    if (SetOption != 0)
                    {
                        Defense += (Defense * 12) / BasicInfo.Level + (BasicInfo.Level / 5) + 4;
                        //Defense += (Defense * 3) / ItemLevel + (ItemLevel / 30) + 2;
                    }
                    else if (OptionExe != 0)
                    {
                        Defense = (Defense * 12) / BasicInfo.Level + BasicInfo.Level / 5 + 4;
                    }

                    switch (Number)
                    {
                        case 12 * 512 + 3:
                        case 12 * 512 + 4:
                        case 12 * 512 + 5:
                        case 12 * 512 + 6:
                        case 13 * 512 + 30:
                        case 12 * 512 + 49:
                        case 13 * 512 + 4:
                        case 12 * 512 + 42:
                            Defense += Plus * 2;
                            break;
                        //Third Wings Defense * 4
                        case 12 * 512 + 36:
                        case 12 * 512 + 37:
                        case 12 * 512 + 38:
                        case 12 * 512 + 39:
                        case 12 * 512 + 40:
                        case 12 * 512 + 43:
                        case 12 * 512 + 50:
                            Defense += Plus * 4;
                            break;
                        default:
                            Defense += Plus * 3;
                            if (Plus >= 10)
                            {
                                Defense += (Plus - 9) * (Plus - 8) / 2;
                            }
                            break;
                    }

                    switch (Number)
                    {
                        case 13 * 512 + 30:
                        case 12 * 512 + 49:
                            Defense += Plus * 2 + 15;
                            if (Plus >= 10)
                            {
                                Defense += (Plus - 9) * (Plus - 8) / 2;
                            }
                            break;
                        //Wings S3 FIX EXC 1
                        case 12 * 512 + 36:
                        case 12 * 512 + 37:
                        case 12 * 512 + 38:
                        case 12 * 512 + 39:
                        case 12 * 512 + 40:
                        case 12 * 512 + 41:
                        case 12 * 512 + 42:
                        case 12 * 512 + 43:
                            if (Plus >= 10)
                            {
                                Defense += (Plus - 9) * (Plus - 8) / 2;
                            }
                            break;
                    }
                }
            }
        }

        public void OnItemChange()
        {
            CalcItemAttributes();
            if (Character == null)
                return;

            var session = Character.Player.Session;

            //session?.SendAsync(new SInventoryItemDelete((byte)SlotId, 1));
            session?.Player.Character.Inventory.SendInventory();
            session?.Player.Character.Inventory.SendEventInventory();
        }

        private void OnDurabilityChange(bool flag)
        {
            if (Storage != StorageID.Inventory && Storage != StorageID.Equipament)
                return;

            var p = new SInventoryItemDurSend
            {
                IPos = (byte)SlotId,
                Dur = Durability,
                Flag = (byte)(flag ? 1 : 0)
            };
            Character?.Player.Session.SendAsync(p);

            OnChange();
        }

        public override string ToString()
        {
            return $"[{Serial}]" + BasicInfo.Name + (Plus > 0 ? " +" + Plus.ToString() : "") + (Luck ? " +Luck" : "") + (Skill ? " +Skill" : "") + (Option28 > 0 ? " +Option" : "") + (PentagramaMainAttribute != Element.None ? " (" + PentagramaMainAttribute.ToString() + ")" : "");
        }

        private byte CountOfExcellent()
        {
            byte count = 0;
            for (byte i = 0; i < 8; i++)
            {
                if (OptionExe.GetBit(i))
                {
                    count++;
                }
            }
            return count;
        }
        private int RepairItemPrice()
        {
            var baseDur = (float)DurabilityBase;
            var currDur = (float)Durability;

            if (baseDur == 0)
                return 0;

            var basePrice = 0u;

            float fixFactor = 1.0f - currDur / baseDur;

            if (Number.Type == ItemType.Wing_Orb_Seed && (Number.Index == 4 || Number.Index == 5))
                basePrice = BuyPrice;
            else
                basePrice = BuyPrice / 3;

            if (basePrice > 400000000)
                basePrice = 400000000;

            if (basePrice >= 1000)
                basePrice = basePrice / 100 * 100;
            else if (basePrice >= 100)
                basePrice = basePrice / 10 * 10;

            var repairPrice = 3.0f * Math.Sqrt(basePrice) * Math.Sqrt(Math.Sqrt(basePrice));
            repairPrice *= fixFactor;
            repairPrice += 1.0f;

            if (repairPrice >= 1000)
                repairPrice = repairPrice / 100 * 100;
            else if (repairPrice >= 100)
                repairPrice = repairPrice / 10 * 10;

            return (int)repairPrice;
        }

        private byte GetDurabilityBase()
        {
            var dur = BasicInfo.Durability + BasicInfo.MagicDur;
            if (Plus < 5)
            {
                dur += Plus;
            }
            else
            {
                switch (Plus)
                {
                    case 10:
                        dur += Plus * 2 - 3;
                        break;
                    case 11:
                        dur += Plus * 2 - 1;
                        break;
                    case 12:
                        dur += Plus * 2 + 2;
                        break;
                    case 13:
                        dur += Plus * 2 + 6;
                        break;
                    case 14:
                        dur += Plus * 2 + 9;
                        break;
                    case 15:
                        dur += Plus * 2 + 12;
                        break;
                    default:
                        dur += Plus * 2 - 4;
                        break;
                }
            }

            if (SetOption != 0)
                dur += 20;
            else if (OptionExe != 0)
                dur += 15;

            if (dur > 255)
                dur = 255;

            return (byte)dur;
        }

        public byte GetLevel(int level)
        {
            ushort itemlevel;
            if (level < 0)
                level = 0;

            if (BasicInfo.Level == 0xffff || BasicInfo.Level == 0)
                return 0xff;

            if (Number.Type == ItemType.Potion)
            {
                itemlevel = BasicInfo.Level;

                if (Number.Index == 15)
                    return 0xff;

                if (itemlevel >= (level - 8) && itemlevel <= level)
                {
                    return 0;
                }

                return 0xff;
            }

            if (Number.Type == ItemType.Missellaneo && Number.Index == 10)
            {
                byte ilevel;

                if (Program.RandomProvider(10) == 0)
                {
                    if (level < 0)
                        level = 0;

                    ilevel = (byte)(level / 10);

                    if (ilevel > 0)
                        ilevel--;

                    if (ilevel > 5)
                        ilevel = 5;

                    return ilevel;
                }

                return 0xff;
            }

            if (Number.Type == ItemType.Wing_Orb_Seed && Number.Index == 11)
            {
                byte ilevel;

                if (Program.RandomProvider(10) == 0)
                {
                    if (level < 0)
                        level = 0;

                    ilevel = (byte)(level / 10);

                    if (ilevel > 0)
                        ilevel--;

                    if (ilevel > 6)
                        ilevel = 6;

                    return ilevel;
                }

                return 0xff;
            }

            itemlevel = BasicInfo.Level;

            if (itemlevel >= level - 18 && itemlevel <= level)
            {
                if (Number.Type == ItemType.Scroll)
                    return 0;

                itemlevel = (byte)((level - itemlevel) / 3);

                if (Number.Type == ItemType.Missellaneo)
                {
                    if (Number.Index == 8 || Number.Index == 9 || Number.Index == 12 || Number.Index == 13 || Number.Index == 20 || Number.Index == 21 || Number.Index == 22 || Number.Index == 23 || Number.Index == 24 || Number.Index == 25 || Number.Index == 26 || Number.Index == 27 || Number.Index == 28)
                    {
                        if (itemlevel > 4)
                            itemlevel = 4;
                    }
                }

                return (byte)itemlevel;
            }
            return 0xff;
        }

        public int NormalWeaponDurabilityDown(int Defense)
        {
            if (Durability == 0)
            {
                return 0;
            }

            var div = BasicInfo.Damage.X * 1.5f;

            if (div == 0)
            {
                return 0;
            }

            var DurDecrease = Defense * 2 / div;

            _durabilityDown += DurDecrease;
            if (_durabilityDown > 564)
            {
                _durabilityDown = 0;
                if (Durability > 0)
                {
                    Durability -= 1;
                    return 2;
                }

                return 1;
            }

            return 0;
        }

        public int BowWeaponDurabilityDown(int Defense)
        {
            if (Durability == 0)
            {
                return 0;
            }

            var div = BasicInfo.Damage.X * 1.5f;

            if (div == 0)
            {
                return 0;
            }

            var DurDecrease = Defense * 2 / div;

            _durabilityDown += DurDecrease;
            if (_durabilityDown > 780)
            {
                _durabilityDown = 0;
                if (Durability > 0)
                {
                    Durability -= 1;
                    return 2;
                }

                return 1;
            }

            return 0;
        }

        public int ArmorDurabilityDown(int Attack)
        {
            if (Durability == 0)
            {
                return 0;
            }

            var div = Defense * 2;

            if (div == 0)
            {
                return 0;
            }

            var DurDecrease = Attack / div;

            _durabilityDown += DurDecrease;
            if (_durabilityDown > 69)
            {
                _durabilityDown = 0;
                if (Durability > 0)
                {
                    Durability -= 1;
                    return 2;
                }

                return 1;
            }

            return 0;
        }

        public object Clone()
        {
            var it = new Item(Number, new { Plus, Luck, Skill, Durability, Option28, OptionExe });
            Extensions.AnonymousMap(it, this);
            it.State = ItemState.Created;
            it.Serial = 0;
            it.Durability = Durability;
            it.Character = null;
            it.Account = null;
            it.SlotId = 0;
            if (it.DurabilityBase == 0 && Durability == 0)
            {
                it.Durability = 1;
            }
            return it;
        }

        public void NewOptionRand()
        {
            var randOp = Program.RandomProvider(100);
            OptionExe = 0;
            Option28 = 0;
            if (Program.RandomProvider(6) == 0)
            {
                int NOption;
                NOption = 1 << Program.RandomProvider(6);

                if ((NOption & 2) != 0)
                {
                    if (Program.RandomProvider(2) != 0)
                    {
                        NOption = 1 << Program.RandomProvider(6);
                    }
                }

                if (Program.RandomProvider(4) == 0)
                {
                    NOption |= 1 << Program.RandomProvider(6);
                }

                OptionExe = (byte)NOption;
            }

            if (((OptionExe & (byte)ExcellentOptionArmor.FullItem) != 0 && Program.RandomProvider(100) == 0) || Program.RandomProvider(6) == 0)
            {
                Luck = true;
            }
            else
            {
                Luck = false;
            }

            if (((OptionExe & (byte)ExcellentOptionArmor.FullItem) != 0 && Program.RandomProvider(2) == 0) || Program.RandomProvider(4) == 0 && Spell != Spell.None)
            {
                Skill = BasicInfo.Skill != Spell.None;
            }
            else
            {
                Skill = false;
            }

            if (BasicInfo.Option && Program.RandomProvider(randOp) == 0)
            {
                Option28 = (byte)Program.RandomProvider(4);
            }

            if (
                (Number.Type == ItemType.Helm && Number.Number >= 3629) || // Helm S4
                (Number.Type == ItemType.Armor && Number.Number >= 4141) || // Armor S4
                (Number.Type == ItemType.Pant && Number.Number >= 4653) || // Pants S4
                (Number.Type == ItemType.Gloves && Number.Number >= 5165) || // Gloves S4
                (Number.Type == ItemType.Boots && Number.Number >= 5677) ||// Boots S4
                (Number.Number >= 26 && Number.Number <= 28) || // Swords S4
                Number.Number == 1040 || // Frost Mace S4
                Number.Number == 2071 || // Dark Stinger Bow S4
                (Number.Number >= 2590 && Number.Number <= 2592) || // Imperial Staff S4
                (Number.Type == ItemType.Shield && Number.Number >= 3089) // Shields S4
                )
            {
                var randSocketNumber = Program.RandomProvider(5, 1);
                Slots = new SocketOption[randSocketNumber];
                for (var i = 0; i < randSocketNumber; i++)
                {
                    Slots[i] = SocketOption.EmptySocket;
                }

                OptionExe = 0;
            }
        }

        public byte Overlap(byte count)
        {
            byte left = 0;
            var tmpDurability = _durability;
            if (tmpDurability + count <= BasicInfo.MaxStack)
            {
                tmpDurability += count;
            }
            else
            {
                tmpDurability = BasicInfo.MaxStack;
                left = (byte)(count + tmpDurability - BasicInfo.MaxStack);
            }
            if (tmpDurability == BasicInfo.MaxStack && BasicInfo.OnMaxStack != ItemNumber.Invalid)
            {
                _durability = 1;
                Number = BasicInfo.OnMaxStack;
            }
            else
            {
                Durability = tmpDurability;
            }
            return left;
        }
        public Item Overlap(Item item)
        {
            if (item.Number != Number || item.Plus != Plus || _durability >= BasicInfo.MaxStack)
                throw new Exception($"Item {item} to {this} Can't be stacked {item.Number != Number} {item.Plus != Plus} {_durability >= BasicInfo.MaxStack}");

            item.Durability = Overlap(item.Durability);
            if (item.Durability == 0)
                return null;
            return item;
                //item.Delete();
        }
    }
}


--file ItemNumber.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu
{
    public struct ItemNumber
    {
        public ushort Number { get; set; }
        public ushort Index { get => (ushort)(Number % 512); set => Number = (ushort)((Number & ~511) | value); }
        public ItemType Type { get => (ItemType)(Number / 512); set => Number = (ushort)((Number & 511) | (int)value * 512); }
        public const ushort Invalid = 0xFFFF;

        public static readonly ItemNumber Zen = FromTypeIndex(14, 15);

        public ItemNumber(ushort number)
        {
            Number = number;
        }

        public ItemNumber(ItemType type, ushort index)
        {
            Number = (ushort)((byte)type * 512 + (index & 0x1FF));
        }

        public ItemNumber(byte type, ushort index)
        {
            Number = (ushort)(type * 512 + (index & 0x1FF));
        }

        public static implicit operator ItemNumber(ushort num)
        {
            return new ItemNumber(num);
        }

        public static bool operator ==(ItemNumber a, ItemNumber b)
        {
            return a.Number == b.Number;
        }

        public static bool operator !=(ItemNumber a, ItemNumber b)
        {
            return a.Number != b.Number;
        }

        public static bool operator ==(ItemNumber a, ushort b)
        {
            return a.Number == b;
        }

        public static bool operator !=(ItemNumber a, ushort b)
        {
            return a.Number != b;
        }

        public static implicit operator ushort(ItemNumber a)
        {
            return a.Number;
        }

        public override int GetHashCode()
        {
            return Number.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }

        public override string ToString()
        {
            return $"{Type}-I{Index}";
        }

        public static ItemNumber FromTypeIndex(byte type, ushort index)
        {
            return new ItemNumber(type, index);
        }

        public static ItemNumber FromTypeIndex(ItemType type, ushort index)
        {
            return new ItemNumber(type, index);
        }
    }
}


--file JewelOfHarmony.cs
﻿using MU.Resources;
using MU.Resources.Game;
using MuEmu.Resources;
using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu
{
    public class JewelOfHarmony
    {
        public byte Option { get; set; }
        public byte Level { get; set; }
        public Item Item { get; set; }
        public byte Type => GetItemType();
        public byte Index => (byte)(Type << 4 | Option);

        public static implicit operator byte(JewelOfHarmony a)
        {
            return (byte)(a.Option << 4 | a.Level);
        }

        public static implicit operator JewelOfHarmony(byte a)
        {
            return new JewelOfHarmony { Option = (byte)(a >> 4), Level = (byte)(a & 0x0f) };
        }

        public int EffectValue => GetEffectValue();
        public string EffectName => GetEffectName();

        public async void UseRefiningStone(Item refiningStone)
        {
            if (Option == 0)
                return;

            var percent = refiningStone.Number.Number == 7211 ? 25 : 75;

            if (percent < Program.RandomProvider(100))
            {
                Level = 0;
            }
            else
            {
                Level++;
            }
            Item.OnItemChange();
            await Item.Character.Inventory.Delete(refiningStone);
        }

        private byte GetItemType()
        {
            if (Item == null)
                return 0;

            if (Item.Number.Type < ItemType.Staff)
                return 1;

            if (Item.Number.Type == ItemType.Staff)
                return 2;

            if (Item.Number.Type <= ItemType.Boots)
                return 3;

            return 0;
        }
        private int GetEffectValue()
        {
            var joh = ResourceCache.Instance.GetJOH();

            JOHSectionDto dto = null;
            if (Option < 1)
                return 0;

            switch(Type)
            {
                case 1:
                    dto = joh.Weapon[Option-1];
                    break;
                case 2:
                    dto = joh.Staff[Option-1];
                    break;
                case 3:
                    dto = joh.Defense[Option-1];
                    break;
            }

            if (dto == null)
                return 0;

            var type = typeof(JOHSectionDto);
            var prop = type.GetProperty("Level" + Level);
            var get = prop.GetGetMethod();
            return (int)get.Invoke(dto, null);
        }
        private string GetEffectName()
        {
            var joh = ResourceCache.Instance.GetJOH();

            JOHSectionDto dto = null;
            if (Option < 1)
                return "";

            switch (Type)
            {
                case 1:
                    dto = joh.Weapon[Option - 1];
                    break;
                case 2:
                    dto = joh.Staff[Option - 1];
                    break;
                case 3:
                    dto = joh.Defense[Option - 1];
                    break;
            }

            if (dto == null)
                return "";

            return dto.Name;
        }
    }
}


--file MajesticLevel.cs
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu
{
    internal class MajesticLevel
    {
    }
}


--file Marlon.cs
﻿using MU.Resources;
using MuEmu.Monsters;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu
{
    public class Marlon
    {
        internal static ILogger _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(Marlon));

        private static Marlon s_instance;

        private readonly TimeSpan r_TeleportTime = TimeSpan.FromSeconds(900);

        private Monster _marlon;
        private DateTimeOffset _nextWarp;
        private int _refCount;

        private Marlon()
        {
            _marlon = MonstersMng.Instance.Monsters.Find(x => x.Info.Monster == (ushort)229);
            _nextWarp = DateTimeOffset.Now;
        }

        public static void Initialize()
        {
            s_instance = new Marlon();
        }

        public static void Run()
        {
            if ((s_instance?._marlon??null) == null)
                return;

            if(s_instance._nextWarp < DateTimeOffset.Now && s_instance._refCount == 0)
            {
                s_instance._nextWarp = DateTimeOffset.Now.Add(s_instance.r_TeleportTime);
                switch(Program.RandomProvider(4))
                {
                    case 0:
                        s_instance._marlon.Warp(Maps.Davias, 198, 47);
                        s_instance._marlon.Direction = 2;
                        _logger.Information("Warp to {0}", Maps.Davias);
                        break;
                    case 1:
                        s_instance._marlon.Warp(Maps.Lorencia, 137, 87);
                        s_instance._marlon.Direction = 1;
                        _logger.Information("Warp to {0}", Maps.Lorencia);
                        break;
                    case 2:
                        s_instance._marlon.Warp(Maps.Noria, 169, 89);
                        s_instance._marlon.Direction = 2;
                        _logger.Information("Warp to {0}", Maps.Noria);
                        break;
                    case 3:
                        s_instance._marlon.Warp(Maps.Atlans, 17, 25);
                        s_instance._marlon.Direction = 2;
                        _logger.Information("Warp to {0}", Maps.Atlans);
                        break;
                }
            }
        }

        public static void AddRef()
        {
            s_instance._refCount++;
        }

        public static void RemRef()
        {
            s_instance._refCount--;
        }
    }
}


--file MasterLevel.cs
﻿using MU.DataBase;
using MuEmu.Entity;
using MU.Network.Game;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Text;
using System.Threading.Tasks;
using MU.Resources;
using System.Linq;
using MuEmu.Resources.XML;
using System.IO;

namespace MuEmu
{
    public class MasterLevel
    {
        private bool _needSave;
        private ushort _level;
        private long _experience;
        private ushort _points;
        private ushort _mPoints;
        private bool _new;

        public static MasterSkillTreeDto MasterSkillTree { get; set; }

        public ushort Level
        {
            get => _level;
            set
            {
                _level = value;
                _needSave = true;
            }
        }
        public long Experience
        {
            get => _experience; set
            {
                _experience = value;
                _needSave = true;
            }
        }
        public long NextExperience => GetExperienceFromLevel((ushort)(Level + Character.Level-1));
        public ushort Points
        {
            get => _points; set
            {
                _needSave = true;
                _points = value;
            }
        }
        public ushort MPoints
        {
            get => _mPoints; set
            {
                _needSave = true;
                _mPoints = value;
            }
        }
        public Character Character { get; private set; }
        public static void Initialize()
        {
            if (MasterSkillTree == null)
                MasterSkillTree = Resources.ResourceLoader.XmlLoader<MasterSkillTreeDto>($"./Data/MasterLevel/MasterSkillTree_{Program.Season}.xml");

            var skillClear = MasterSkillTree.Trees.SelectMany(x => x.Skill).Where(x => string.IsNullOrEmpty(x.Ecuation));
            var skillSets = MasterSkillTree.Trees.SelectMany(x => x.Skill).Where(x => !string.IsNullOrEmpty(x.Ecuation));
            foreach(var skill in skillClear)
            {
                var result = skillSets.FirstOrDefault(x => x.MagicNumber == skill.MagicNumber);
                skill.Ecuation = result?.Ecuation ?? "";
                skill.Property = result?.Property ?? "";
            }
        }
        public MasterLevel(Character @char, CharacterDto @charDto)
        {
            Character = @char;
            _new = @charDto.MasterInfo == null;
            Level = @charDto.MasterInfo?.Level ?? 1;
            Experience = @charDto.MasterInfo?.Experience ?? 0;
            Points = @charDto.MasterInfo?.Points ?? 0;
        }

        public void GetExperience(long exp)
        {
            if(!Character.MasterClass || Character.Level != 400)
            {
                return;
            }

            Experience += exp;
            var level = Level;
            while(Experience >= NextExperience)
            {
                Level++;
            }

            if(level != Level)
            {
                var LevelAdd = Level - level;
                var levelPoint = Character.BaseClass == HeroClass.MagicGladiator || Character.BaseClass == HeroClass.DarkLord ? 7 : 5;

                Points += (ushort)(levelPoint*LevelAdd);
                Character.LevelUpPoints += (ushort)((levelPoint+1) * LevelAdd);
                if (Points > 200)
                    Points = 200;

                Character.CalcStats();
                Character.Player.Session
                    .SendAsync(new SMasterLevelUp(Level, (ushort)levelPoint, Points, maxPoints:(ushort)200, (ushort)Character.MaxHealth, (ushort)Character.MaxShield, (ushort)Character.MaxMana, (ushort)Character.MaxStamina)).Wait();

                Character.Player.Session.SendAsync(new SEffect(Character.Index, ClientEffect.LevelUp)).Wait();
            }
        }

        private long GetExperienceFromLevel(ushort level)
        {
            var exp = (((level + 9L) * level) * level) * 10L + ((level>255)?(((((long)(level - 255) + 9L) * (level - 255L)) * (level - 255L)) * 1000L):0L);
            if (level >= 400)
            {
                exp -= 3892250000;
                exp /= 2;
            }
            if (level > 600)
            {
                var Level3 = (double)((level - 600) * (level - 600));
                exp = (long)(exp * (1 + (Level3 * 1.2) / 100000.0));
            }
            return exp;
        }

        public async void SendInfo()
        {
            if (Character.MasterClass)
            {
                var XPSend = Character.Level >= 400 ? Experience : Character.Experience;
                await Character
                    .Player
                    .Session
                    .SendAsync(new SMasterInfo(
                        Level, 
                        XPSend, 
                        NextExperience, 
                        Points, 
                        (ushort)Character.MaxHealth, 
                        (ushort)Character.MaxShield, 
                        (ushort)Character.MaxMana, 
                        (ushort)Character.MaxStamina
                        ));
            }
            if(Character.MajesticClass)
            {
                await Character
                    .Player
                    .Session
                    .SendAsync(new SMajesticInfo
                    {
                        Points = MPoints,
                        SkillList = Array.Empty<MajesticInfoDto>(),
                    });

                await Character
                    .Player
                    .Session
                    .SendAsync(new SMajesticStatsInfo
                    {
                        SkillList = Array.Empty<MajesticInfoDto>(),
                    });
            }
        }

        public async Task Save(GameContext db)
        {
            if (!_needSave || !Character.MasterClass)
                return;

            if (_new)
            {
                db.MasterLevel.Add(new MasterInfoDto
                {
                    MasterInfoId = Character.Id,
                    Experience = Experience,
                    Level = Level,
                    Points = Points,
                });
                _new = false;
                return;
            }

            var info = db.MasterLevel.First(x => x.MasterInfoId == Character.Id);
            info.Experience = Experience;
            info.Level = Level;
            info.Points = Points;
            db.MasterLevel.Update(info);
        }
    }
}


--file Monster.cs
﻿using MU.Network.Game;
using MuEmu.Resources;
using MuEmu.Resources.Map;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Drawing;
using System.Text;
using System.Threading.Tasks;
using MuEmu.Data;
using System.Threading;
using MuEmu.Util;
using MU.Resources;
using MU.Network;

namespace MuEmu.Monsters
{
    public enum MonsterState
    {
        Idle,
        Walking,
        Battle,
    }

    public class Monster
    {
        private static byte[,] _walkDirs;
        private static MapAttributes[] _cantGo;
        private static ushort[] _maxItemIndex;
        private static Random _rand;
        private float _life;
        private ObjectState _state;
        private DateTimeOffset _regen;
        private Player _target;
        private DateTimeOffset _nextAction;
        private MonsterState _monsterState;
        private List<Point> _path = null;
        private Point _TPosition;

        public bool UseTeleport { get; set; }

        private bool _active;

        public ushort Index { get; set; }
        public ObjectState State
        {
            get => _state;
            set
            {
                if (_state == value)
                    return;

                switch(value)
                {
                    case ObjectState.Die:
                        _regen = DateTimeOffset.Now.AddSeconds(Info.RegenTime);
                        Die?.Invoke(this, new EventArgs());
                        break;
                    case ObjectState.Dying:
                        Dying?.Invoke(this, new EventArgs());
                        break;
                }

                _state = value;
            }
        }
        public ObjectType Type { get; set; }
        public MonsterState MonsterState { get => _monsterState; set => _monsterState = value; }
        public MonsterBase Info { get; }
        public ushort Level => Info.Level;
        public float Life
        {
            get => _life;
            set
            {
                if (_life == value)
                    return;

                _life = value;

                if (_life <= 0)
                {
                    _life = 0;
                    State = ObjectState.Dying;
                }

                var life = _life / MaxLife * 255.0f;

                ViewPort.Select(x => x.Session).SendAsync(new SLifeInfo { Life = (uint)life, MaxLife = 255u, Number = Index }).Wait();
            }
        }
        public float MaxLife => Info.HP;
        public float Mana { get; set; }
        public float MaxMana => Info.MP;
        public Spells Spells { get; set; }
        public Maps MapID { get; set; }
        public MapInfo Map { get; private set; }
        public Point Spawn { get; private set; }
        public Point Position { get; private set; }
        public Point TPosition
        {
            get => _TPosition;
            private set
            {
                _TPosition = value;
                if (Position != _TPosition)
                    MakePath();
            }
        }
        public Player Target
        {
            get => _target;
            set
            {
                if (_target == value)
                    return;

                if (_target != null && _target.Character != null)
                {
                    _target.Character.CharacterDie -= EnemyDie;
                    _target.Character.MapChanged -= EnemyDie;
                }

                _target = value;

                if (value == null)
                    return;

                _target.Character.CharacterDie += EnemyDie;
                _target.Character.MapChanged += EnemyDie;
            }
        }
        public List<Player> ViewPort { get; set; } = new List<Player>();
        public Player Killer { get; set; }
        public Player Caller { get; set; }
        public object Params { get; set; }
        public ushort DeadlyDmg { get; set; }
        public byte Direction { get; set; }
        public List<Item> ItemBag { get; set; }
        public bool Active { get => _active; set { _active = value; State = ObjectState.Regen; } }
        public Element Element { get; set; }

        public bool CanDrop { get; set; }
        public Dictionary<Player, int> DamageSum { get; private set; } = new Dictionary<Player, int>();
        public int Attack => Info.Attack + (_rand.Next(Info.DmgMin, Info.DmgMax));
        public int Defense => Info.Defense;

        /// <summary>
        /// On die monster trigger this event with sender as Monster object
        /// </summary>
        public event EventHandler Die;
        /// <summary>
        /// On Dying monster trigger this event with sender as Monster object
        /// </summary>
        public event EventHandler Dying;

        /// <summary>
        /// On regen monster trigger this event with sender as Monster object
        /// </summary>
        public event EventHandler Regen;

        // IA Unit
        public Monster Leader
        {
            get => _leader; set
            {
                _leader = value;
                _delta = _leader.Position.Substract(Position);
            }
        }
        public bool CanGoToBattleState { get; set; }
        private Point _delta;
        private Monster _leader;

        public Monster(ushort Monster, ObjectType type, Maps mapID, Point position, byte direction, Element element = Element.None)
        {
            CanGoToBattleState = true;
            Type = type;
            MapID = mapID;
            Spawn = position;
            Position = position;
            _TPosition = position;
            Direction = direction;
            Info = MonstersMng.Instance.MonsterInfo[Monster];
            Life = Info.HP;
            Mana = Info.MP;
            Active = true;
            CanDrop = true;
            Map = ResourceCache.Instance.GetMaps()[MapID];
            Map.AddMonster(this);
            State = ObjectState.Regen;
            Dying += OnDying;
            Spells = new Spells(this);
            ItemBag = new List<Item>();
            _nextAction = DateTimeOffset.Now;
            Element = element;
            if (_rand == null)
            {
                _rand = new Random();
                _maxItemIndex = new ushort[(int)ItemType.End];
                _cantGo = new MapAttributes[] { MapAttributes.Hide, MapAttributes.NoWalk, MapAttributes.Safe };
                _walkDirs = new byte[3, 3]{
                    { 0, 1, 2 },
                    { 7, 0, 3 },
                    { 6, 5, 4 },
                };

                foreach (var t in Enum.GetValues(typeof(ItemType)))
                {
                    if ((ItemType)t == ItemType.End)
                        break;

                    _maxItemIndex[(int)(ItemType)t] = (ushort)ResourceCache.Instance.GetItems().Where(x => (new ItemNumber(x.Key)).Type == (ItemType)(t)).Count();
                }
            }
        }

        public async Task GetAttacked(Player plr, int dmg, DamageType type, int eDmg)
        {
            if (State != ObjectState.Live || Type == ObjectType.NPC)
                return;

            if (dmg < 0)
                dmg = 0;

            if (DamageSum.ContainsKey(plr))
                DamageSum[plr] += dmg;
            else
                DamageSum.Add(plr, dmg);
            Killer = plr;
            if (Life < dmg + eDmg)
            {
                var tot = dmg + eDmg;
                dmg = (int)(dmg * Life / tot);
                eDmg = (int)(eDmg * Life / tot);
                Life = 0;
            }
            else
            {
                Life -= dmg + eDmg;
            }

            var dmgSend = dmg < ushort.MaxValue ? (ushort)dmg : ushort.MaxValue;
            DeadlyDmg = dmgSend;
            plr.Character.HuntingRecord.AttackPVM(dmg);
            plr.Character.HuntingRecord.ElementalAttackPVM(eDmg);

            if (State != ObjectState.Dying)
            {
                var attack = VersionSelector.CreateMessage<SAttackResult>(Index, dmgSend, type, (ushort)0);
                await plr.Session.SendAsync(attack);
            }
        }

        public void GetAttackedDelayed(Player plr, int dmg, DamageType type, TimeSpan delay)
        {
            if (State != ObjectState.Live || Type == ObjectType.NPC)
                return;

            if (DamageSum.ContainsKey(plr))
                DamageSum[plr] += dmg;
            else
                DamageSum.Add(plr, dmg);

            var dmgSend = dmg < ushort.MaxValue ? (ushort)dmg : ushort.MaxValue;
            DeadlyDmg = dmgSend;
            Killer = plr;
            Life -= dmg;

            if (State != ObjectState.Dying)
            {
                object message = VersionSelector.CreateMessage<SAttackResult>(Index, dmgSend, type, (ushort)0);
                SubSystem.Instance.AddDelayedMessage(plr, TimeSpan.FromMilliseconds(100), message);
            }
        }

        public void TryRegen()
        {
            if (_regen > DateTimeOffset.Now)
                return;

            DamageSum.Clear();
            Life = MaxLife;
            Mana = MaxMana;
            Position = Spawn;
            TPosition = Spawn;
            ViewPort.Clear();
            Target = null;
            Killer = null;
            DeadlyDmg = 0;
            _monsterState = MonsterState.Idle;
            State = ObjectState.Regen;

            Regen?.Invoke(this, new EventArgs());
        }

        private int Distance(Point A, Point B)
        {
            return (int)Math.Sqrt((A.X - B.X) * (A.X - B.X) + (A.Y - B.Y) * (A.Y - B.Y));
        }

        public void Update()
        {
            if (Type != ObjectType.Monster)
                return;

            if (Life == 0 && State == ObjectState.Live)
                Life = MaxLife;

            if (_nextAction > DateTimeOffset.Now || Spells.BufActive(SkillStates.SkillSleep))
                return;

            lock (ViewPort)
            {
                if (Map.Map == (int)Maps.NewQuest)
                {
                    var instance = Params as Quest4thInfo;
                    if (instance.Master.Character == null)
                    {
                        Quest4th.RemoveInstance(instance.Master);
                    }
                    else
                    {
                        ViewPort = instance.Master.Character.Party?.Members.ToList() ?? new List<Player> { instance.Master };
                    }
                }
                else {
                    ViewPort = Map.Players
                        .Where(x => x.Player.Status == LoginStatus.Playing && Distance(x.Position, Position) <= 18)
                        .Select(x => x.Player)
                        .ToList();
                }
            }

            if (Target == null && Leader != null)
            {
                _monsterState = Leader._monsterState;
                TPosition = Leader.TPosition.Add(_delta);
            }

            if (_monsterState == MonsterState.Walking)
            {
                _nextAction = DateTimeOffset.Now.AddMilliseconds(Info.MoveSpeed);

                if (_path.Count == 0)
                {
                    _monsterState = Target != null ? MonsterState.Battle : MonsterState.Idle;
                }
                else
                {
                    Position = _path[0];
                    _path.RemoveAt(0);

                    if (Target != null && Target.Character != null)
                    {
                        try
                        {
                            var dis = Distance(Target.Character.Position, Position);
                            if (dis <= Info.AttackRange)
                            {
                                _monsterState = MonsterState.Battle;
                                _path.Clear();
                                return;
                            }
                            else if (dis > Info.ViewRange)
                            {
                                _monsterState = MonsterState.Idle;
                                _path.Clear();
                                return;
                            }
                        }catch(Exception)
                        {
                            Target = null;
                        }
                    }
                }
            }
            if (_monsterState == MonsterState.Battle)
            {
                if (Target == null || Target.Status != LoginStatus.Playing)
                {
                    _monsterState = MonsterState.Idle;
                    return;
                }
                var dis = Distance(Target.Character.Position, Position);
                if (dis <= Info.AttackRange && CanGoToBattleState)
                {
                    _nextAction = DateTimeOffset.Now.AddMilliseconds(Info.AttackSpeed);
                    DamageType type = DamageType.Miss;

                    var attack = MonsterAttack(out type, out Spell isMagic);
                    Target.Character
                        .GetAttacked(Index, Direction, 120, attack, type, isMagic, 0)
                        .Wait();
                    TPosition = Position;
                    return;
                }
                else if (dis > Info.ViewRange)
                {
                    _monsterState = MonsterState.Idle;
                    Target = null;
                    _nextAction = DateTimeOffset.Now.AddMilliseconds(Info.AttackSpeed);
                    return;
                }
                else
                {
                    TPosition = Target.Character.Position;
                }
            }
            if (_monsterState == MonsterState.Idle)
            {
                var possibleTarget1 = from plr in ViewPort
                                     let dist = Distance(plr.Character?.Position ?? new Point(), Position)
                                     where dist <= Info.ViewRange
                                     orderby dist ascending
                                     select plr;
                var possibleTarget2 = DamageSum
                    .Where(x => possibleTarget1.Contains(x.Key))
                    .OrderByDescending(x => x.Value);

                if(possibleTarget2.Any())
                {
                    Target = possibleTarget2.First().Key;
                    TPosition = Target.Character.Position;
                }
                else if(possibleTarget1.Any())
                {
                    Target = possibleTarget1.First();
                    TPosition = Target.Character.Position;
                }
                else
                {
                    var minX = Math.Max(Spawn.X - Info.MoveRange, 0);
                    var maxX = Math.Min(Spawn.X + Info.MoveRange, 255);
                    var minY = Math.Max(Spawn.Y - Info.MoveRange, 0);
                    var maxY = Math.Min(Spawn.Y + Info.MoveRange, 255);
                    var i = 0;
                    Point newPoint;
                    do {
                        newPoint = new Point(Program.RandomProvider(maxX, minX), Program.RandomProvider(maxY, minY));
                        if(!Map.ContainsAny(newPoint.X, newPoint.Y, _cantGo))
                        {
                            TPosition = newPoint;
                            return;
                        }
                    } while (i++ < 10);
                }                
            }
        }

        private void MakePath()
        {
            var pf = new PathFinding(Position, TPosition, Map, _cantGo);
            var fpt = TPosition;

            if (pf.FindPath())
            {
                _path = pf.GetPath();
                _path.RemoveAt(0);

                int count = 0;
                if (Target != null && Target.Character != null)
                {
                    foreach (var pt in _path)
                    {
                        count++;
                        var dis = Distance(Target.Character.Position, pt);
                        if (dis <= Info.AttackRange)
                        {
                            _TPosition = pt;
                            break;
                        }
                    }
                }
                else
                {
                    count = _path.Count;
                }

                var dx = fpt.X - TPosition.X;
                var dy = fpt.Y - TPosition.Y;
                dx = dx != 0 ? dx / Math.Abs(dx) : 0;
                dy = dy != 0 ? dy / Math.Abs(dy) : 0;

                Direction = _walkDirs[dy + 1, dx + 1];

                foreach (var obj in ViewPort.ToList())
                    obj.Session
                        .SendAsync(new SMove(Index, (byte)TPosition.X, (byte)TPosition.Y, Direction))
                        .Wait();

                _nextAction = DateTimeOffset.Now.AddMilliseconds(Info.MoveSpeed * count);
                _monsterState = MonsterState.Walking;
                return;
            }

            _TPosition = Position;
            _monsterState = MonsterState.Idle;
        }

        public int MonsterAttack(out DamageType type, out Spell isMagic)
        {
            var @char = Target.Character;
            var attack = 0;
            type = DamageType.Regular;
            isMagic = Info.Spell;

            if (!MissCheck())
            {
                type = DamageType.Miss;
                return 0;
            }

            if (Info.Spell != Spell.None)
            {
                SpellInfo si = ResourceCache.Instance.GetSkills()[Info.Spell];
                var baseAttack = _rand.Next(si.Damage.X + Info.DmgMin, si.Damage.Y + Info.DmgMax);
                type = DamageType.Regular;
                attack = baseAttack - @char.Defense;
            }
            else
            {
                var M = Math.Max(Info.DmgMin, Info.DmgMax);
                var m = Math.Min(Info.DmgMin, Info.DmgMax);
                var baseAttack = _rand.Next(m, M);
                attack = baseAttack - @char.Defense;
            }

            if (attack <= 0)
            {
                attack = 0;
                type = DamageType.Miss;
            }

            return attack;
        }

        private bool MissCheck()
        {
            var @char = Target.Character;
            var sqr = Math.Sqrt(@char.DefenseRatePvM);

            if (Info.Success < sqr)
            {
                if (_rand.Next(100) >= 5)
                {
                    return false;
                }
            }
            else
            {
                if (_rand.Next(Info.Success) < sqr)
                {
                    return false;
                }
            }
            return true;
        }

        private void OnDying(object obj, EventArgs args)
        {
            gObjGiveItemSearch(Level);

            var die = new SDiePlayer(Index, 1, (ushort)(Killer?.Session?.ID ?? 0xffff));

            if (Killer?.Character == null)
            {
                return;
            }
            Killer.Character.Quests.OnMonsterDie(this);
            Killer.Character.PKTimeEnds = Killer.Character.PKTimeEnds.AddSeconds(Level*-1);
            Killer.Character.HuntingRecord.KilledMonster(this);

            var result = DamageSum.Where(x => x.Key.Status != LoginStatus.Playing).Select(x => x.Key);
            foreach (var r in result)
                DamageSum.Remove(r);

            foreach (var plr in ViewPort)
                plr.Session.SendAsync(die).Wait();

            var baseEXP = ((Level + 10) * Level) / 4;

            var partys = DamageSum
                .Where(x => x.Key.Character.Party != null)
                .GroupBy(x => x.Key.Character.Party);

            float Zen = 0;

            // Party EXP division based on WebZen
            foreach (var p in partys)
            {
                var dmg = p.Sum(x => x.Value);
                float EXP = baseEXP;
                if (Level + 10 < p.Key.MaxLevel)
                    EXP = EXP * (Level + 10) / p.Key.MaxLevel;

                if (EXP / 2.0f > 1.0f)
                    EXP += _rand.Next((int)(EXP / 2.0f));

                EXP *= dmg / MaxLife;
                Zen = EXP;
                EXP *= Program.Experience.FullExperate + 1.0f;
                Zen *= Program.Zen;

                p.Key.ExpDivision(Index, EXP, Killer, DeadlyDmg);
            }

            // Monster EXP division based on DMG excluding Partys
            foreach (var pair in DamageSum.Where(x => x.Key.Character.Party == null))
            {
                float EXP = baseEXP;
                if (Level + 10 < pair.Key.Character.Level)
                    EXP = EXP * (Level + 10) / pair.Key.Character.Level;

                if (EXP / 2.0f > 1.0f)
                    EXP += _rand.Next((int)(EXP / 2.0f));

                EXP *= Math.Min(pair.Value / MaxLife, 1.0f);

                if (pair.Key == Killer)
                    Zen = EXP * (1.0f + Killer.Character.Inventory.DropZen + Killer.Character.Spells.IncreaseZen);

                EXP *= Program.Experience.FullExperate + 1.0f + Killer.Character.Spells.IncreaseExperience;
                Zen *= Program.Zen;

                pair.Key.Character.Experience += (long)EXP;
                switch (Program.Season)
                {
                    case ServerSeason.Season9Eng:
                        pair.Key.Session
                            .SendAsync(new SKillPlayerEXT(Index, (int)EXP, pair.Key == Killer ? DeadlyDmg : (ushort)0))
                            .Wait();
                        break;
                    default:
                        pair.Key.Session
                            .SendAsync(new SKillPlayer(Index, (ushort)EXP, pair.Key == Killer ? DeadlyDmg : (ushort)0))
                            .Wait();
                        break;
                }

                var usedMana = pair.Key.Character.MaxMana - pair.Key.Character.Mana;
                var usedHealth = pair.Key.Character.MaxHealth - pair.Key.Character.Health;

                pair.Key.Character.Mana += usedMana * Killer.Character.Inventory.IncreaseManaRate;
                pair.Key.Character.Health += usedHealth * Killer.Character.Inventory.IncreaseLifeRate;
            }

            Item reward = null;
            if (Info.Bag != null)
            {
                var bag = Info.Bag as Bag;
                reward = bag.GetReward().FirstOrDefault();
            }

            if (reward == null)
            {
                if (_rand.Next(100) < Program.DropRate && CanDrop)
                {
                    if (_rand.Next(2) == 0)
                    {
                        reward = Program.GlobalEventsManager.GetItem(Level, MapID);

                        if (reward == null)
                            reward = Pentagrama.Drop(this);

                        if (reward == null && ItemBag.Count > 0)
                        {
                            reward = ItemBag[_rand.Next(ItemBag.Count)].Clone() as Item;
                            reward.NewOptionRand();
                        }
                    }

                    if (reward == null)
                        reward = Item.Zen((uint)Zen);
                }
            }

            Map.AddItem(Position.X, Position.Y, reward);
        }

        private void EnemyDie(object obj, EventArgs args)
        {
            Target = null;
        }

        private void gObjGiveItemSearch(int maxlevel)
        {
            if (ItemBag.Count == 100 || !CanDrop)
                return;

            var items = ResourceCache.Instance.GetItems();

            int[] BallTable = new int[17];
            ItemNumber itNum = new ItemNumber();

            BallTable[0] = 7;
            BallTable[1] = 8;
            BallTable[2] = 9;
            BallTable[3] = 10;
            BallTable[4] = 11;
            BallTable[5] = 12;
            BallTable[6] = 13;
            BallTable[7] = 14;
            BallTable[8] = 16;
            BallTable[9] = 17;
            BallTable[10] = 18;
            BallTable[11] = 19;
            BallTable[12] = 21;
            BallTable[13] = 22;
            BallTable[14] = 23;
            BallTable[15] = 24;
            BallTable[16] = 35;

            if (ItemBag.Count < 100)
            {
            start:
                if (_rand.Next(20) == 0)
                {
                    if (_rand.Next(2) != 0)
                    {
                        itNum.Type = ItemType.Scroll;
                        itNum.Index = (ushort)_rand.Next(_maxItemIndex[(int)itNum.Type] + 1);
                    }
                    else
                    {
                        itNum.Type = ItemType.Wing_Orb_Seed;
                        itNum.Index = (ushort)BallTable[_rand.Next(BallTable.Length)];
                    }
                }
                else
                {
                    itNum.Type = (ItemType)_rand.Next((int)ItemType.End);
                    itNum.Index = (ushort)_rand.Next(_maxItemIndex[(int)itNum.Type] + 1);

                    if (itNum.Type == ItemType.Scroll || (itNum.Type == ItemType.Wing_Orb_Seed && itNum.Index != 15))
                        goto start;
                }

                if (itNum.Type == ItemType.Missellaneo && itNum.Index == 3) //Horn of Dinorant
                    goto start;

                if ((itNum.Type == ItemType.Missellaneo && itNum.Index == 32) // Fenrrir Items
                      || (itNum.Type == ItemType.Missellaneo && itNum.Index == 33)
                      || (itNum.Type == ItemType.Missellaneo && itNum.Index == 34)
                      || (itNum.Type == ItemType.Missellaneo && itNum.Index == 35)
                      || (itNum.Type == ItemType.Missellaneo && itNum.Index == 36)
                      || (itNum.Type == ItemType.Missellaneo && itNum.Index == 37))
                {
                    goto start;
                }

                if ((itNum.Type == ItemType.Potion && itNum.Index == 35) // Potion SD
                  || (itNum.Type == ItemType.Potion && itNum.Index == 36)
                  || (itNum.Type == ItemType.Potion && itNum.Index == 37)
                  || (itNum.Type == ItemType.Potion && itNum.Index == 38) // Potion Complex
                  || (itNum.Type == ItemType.Potion && itNum.Index == 39)
                  || (itNum.Type == ItemType.Potion && itNum.Index == 40))
                {
                    goto start;
                }

                if ((itNum.Type == ItemType.Missellaneo && itNum.Index < 8) || // Pets
                (itNum.Type == ItemType.Potion && (itNum.Index == 9 || itNum.Index == 10 || itNum.Index == 13 || itNum.Index == 14 || itNum.Index == 16 || itNum.Index == 17 || itNum.Index == 18 || itNum.Index == 22)) || // Misc
                (itNum.Type == ItemType.Wing_Orb_Seed && itNum.Index == 15) || // Jewel of Chaos
                (itNum.Type == ItemType.Missellaneo && itNum.Index == 14) || // Loch's Feather
                (itNum.Type == ItemType.Potion && itNum.Index == 31)) // Jewel of Guardian
                {
                    var perc = 0;
                    if (itNum.Type == ItemType.Wing_Orb_Seed && itNum.Index == 15) // Jewel of Chaos
                    {
                        if (Level >= 13 && Level <= 66) // 42%
                        {
                            perc = _rand.Next(7);

                            if (perc < 3)
                            {
                                perc = 0;
                            }
                        }
                        else
                        {
                            perc = 1;
                        }
                    }

                    if ((itNum.Type == ItemType.Potion && itNum.Index == 17) || // Devil Eye
                       (itNum.Type == ItemType.Potion && itNum.Index == 18))   // Devil Key
                    {
                        perc = 0;
                    }

                    if (perc == 0)
                    {
                        if (itNum.Type == ItemType.Potion && (itNum.Index == 17 || itNum.Index == 18))
                        {
                            byte Plus;

                            if (Level < 3)
                                Plus = 0;
                            else if (Level < 36)
                                Plus = 1;
                            else if (Level < 47)
                                Plus = 2;
                            else if (Level < 60)
                                Plus = 3;
                            else if (Level < 70)
                                Plus = 4;
                            else if (Level < 80)
                                Plus = 5;
                            else
                                Plus = 6;

                            ItemBag.Add(new Item(itNum, new { Plus }));
                        }
                        else
                        {
                            if (!items.ContainsKey(itNum))
                                goto start;

                            var it = items[itNum];
                            if (it.Level < Level)
                                ItemBag.Add(new Item(itNum));
                        }
                    }
                }
                else
                {
                    if (!items.ContainsKey(itNum))
                        goto start;

                    var it = new Item(itNum);
                    var result = it.GetLevel(Level);

                    if (result >= 0)
                    {
                        if ((it.Number.Type == ItemType.Missellaneo && it.Number.Index == 10) || (it.Number.Type == ItemType.Wing_Orb_Seed && it.Number.Index == 11))
                        {
                            it.Plus = result;
                            ItemBag.Add(it);
                        }
                        else if (result <= maxlevel)
                        {
                            if (it.Number.Type == ItemType.Wing_Orb_Seed)
                            {
                                if (it.Number.Index != 11)
                                    result = 0;
                            }

                            if (it.Number.Type == ItemType.Wing_Orb_Seed && it.Number.Index == 11)
                            {

                            }
                            else
                            {
                                if (result > maxlevel)
                                {
                                    result = (byte)maxlevel;
                                }
                            }

                            if ((it.Number.Type == ItemType.BowOrCrossbow && it.Number.Index == 7) || (it.Number.Type == ItemType.BowOrCrossbow && it.Number.Index == 15))
                                result = 0;

                            it.Plus = result;

                            ItemBag.Add(it);
                        }
                    }
                }
            }
        }

        public void Warp(Maps map, byte x, byte y)
        {
            var att = Map.GetAttributes(x, y);
            if(att.Contains(MapAttributes.NoWalk) || att.Contains(MapAttributes.Hide))
            {
                return;
            }

            Map.DelMonster(this);
            Map = ResourceCache.Instance.GetMaps()[map];
            Map.AddMonster(this);
            var msg = VersionSelector.CreateMessage<SMagicAttack>(Spell.Teleport, Index, Index);
            ViewPort.Where(x => x.Character.MonstersVP.Contains(Index)).SendAsync(msg).Wait();
            Position = new Point(x, y);
            _TPosition = new Point(x, y);
            UseTeleport = true;
        }
    }
}


--file MonsterBase.cs
﻿using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace MuEmu.Monsters
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("Monster")]
    public class XmlMonsterInfo
    {
        [XmlElement("Info")] public MonsterBase[] Monsters { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class MonsterBase
    {
        [XmlAttribute] public ushort Monster { get; set; }
        [XmlAttribute] public int Rate { get; set; }
        [XmlAttribute] public string Name { get; set; }
        [XmlAttribute] public ushort Level { get; set; }
        [XmlAttribute] public int HP { get; set; }
        [XmlAttribute] public int MP { get; set; }
        [XmlAttribute] public int DmgMin { get; set; }
        [XmlAttribute] public int DmgMax { get; set; }
        [XmlAttribute] public int Defense { get; set; }
        [XmlAttribute] public int MagicDefense { get; set; }
        [XmlAttribute] public int Attack { get; set; }
        [XmlAttribute] public int Success { get; set; }
        [XmlAttribute] public int MoveRange { get; set; }
        [XmlAttribute] public Spell Spell { get; set; }
        [XmlAttribute] public int AttackRange { get; set; }
        [XmlAttribute] public int ViewRange { get; set; }
        [XmlAttribute] public int MoveSpeed { get; set; }
        [XmlAttribute] public int AttackSpeed { get; set; }
        [XmlAttribute] public int RegenTime { get; set; }
        [XmlAttribute] public int Attribute { get; set; }
        [XmlAttribute] public int ItemRate { get; set; }
        [XmlAttribute] public int M_Rate { get; set; }
        [XmlAttribute] public int MaxItem { get; set; }
        [XmlAttribute] public int Skill { get; set; }
        [XmlAttribute] public int Ice_Resistance { get; set; }
        [XmlAttribute] public int Possion_Resistance { get; set; }
        [XmlAttribute] public int Lightning_Resistance { get; set; }
        [XmlAttribute] public int Fire_Resistance { get; set; }
        public int MainAttribute { get; set; } = 0;
        public int AttributePattern { get; set; } = 0;
        public int PentagramDamageMin { get; set; } = 0;
        public int PentagramDamageMax { get; set; } = 0;
        public int PentagramAttackRate { get; set; } = 0;
        public int PentagramDefenseRate { get; set; } = 0;
        public int PentagramDefense { get; set; } = 7;
        [XmlIgnore] public object Bag { get; set; }
    }

    [XmlType(AnonymousType = true)]
    [XmlRoot("SetBase")]
    public class XmlMonsterSetBase
    {
        [XmlElement("NPC")] public MonsterSet[] NPCs { get; set; }
        [XmlElement("Spot")] public MonsterSpot[] Spots { get; set; }
        [XmlElement("Normal")] public MonsterSet[] Normal { get; set; }
        [XmlElement("Golden")] public MonsterSpot[] Golden { get; set; }
        [XmlElement("BloodCastle")] public MonsterSet[] BloodCastles { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class MonsterSet
    {
        [XmlAttribute] public ushort Type { get; set; }
        [XmlAttribute] public Maps Map { get; set; }
        [XmlAttribute] public byte Radio { get; set; }
        [XmlAttribute] public byte PosX { get; set; }
        [XmlAttribute] public byte PosY { get; set; }
        [XmlAttribute] public sbyte Dir { get; set; }

        [XmlText]
        public string Name { get; set; }
    }

    [XmlType(AnonymousType = true)]
    public class MonsterSpot
    {
        [XmlAttribute] public ushort Type { get; set; }
        [XmlAttribute] public Maps Map { get; set; }
        [XmlAttribute] public byte Radio { get; set; }
        [XmlAttribute] public byte PosX { get; set; }
        [XmlAttribute] public byte PosY { get; set; }
        [XmlAttribute] public byte PosX2 { get; set; }
        [XmlAttribute] public byte PosY2 { get; set; }
        [XmlAttribute] public sbyte Dir { get; set; }
        [XmlAttribute] public byte Quant { get; set; }

        [XmlText]
        public string Name { get; set; }

        public Element Element { get; set; }
    }
}


--file MonsterIA.cs
﻿using MU.Resources;
using MuEmu.Resources;
using MuEmu.Util;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml.Serialization;

namespace MuEmu.Monsters
{
    [XmlType(AnonymousType = true)]
    [XmlRoot("MonsterIA")]
    public class XmlMonsterIAInfo
    {
        [XmlElement("Info")] public MonsterIAGroup[] Monsters { get; set; }
    }
    public class MonsterIAGroup
    {
        [XmlAttribute] public int GroupNumber { get; set; }
        [XmlAttribute] public int Guid { get; set; }
        [XmlAttribute] public ushort Class { get; set; }
        [XmlAttribute] public int Rank { get; set; }
        [XmlAttribute] public int StartAI { get; set; }
        [XmlAttribute] public int AI01 { get; set; }
        [XmlAttribute] public int AI02 { get; set; }
        [XmlAttribute] public int AI03 { get; set; }
        [XmlAttribute] public int CreateType { get; set; }
        [XmlAttribute] public Maps MapNumber { get; set; }
        [XmlAttribute] public int StartX { get; set; }
        [XmlAttribute] public int StartY { get; set; }
        [XmlAttribute] public sbyte StartDir { get; set; }
        [XmlAttribute] public int RegenType { get; set; }

        internal Monster monster;
    }
    public class MonsterIA
    {
        private static MonsterIA _instance;
        private Dictionary<int, List<MonsterIAGroup>> _IAGroups;
        private static ILogger _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(MonsterIA));

        private MonsterIA(string root)
        {
            LoadGroups(root + "MonsterAIGroup.txt");
        }

        private void LoadGroups(string file)
        {
            var loader = new LoadWZTXT<XmlMonsterIAInfo>();
            var xml = loader.Load(file);
            _IAGroups = xml.Monsters.GroupBy(x => x.GroupNumber)
                .ToDictionary(g => g.Key, g => g.ToList());
        }

        public static void Initialize(string root)
        {
            if (_instance != null)
                throw new InvalidOperationException();

            _instance = new MonsterIA(root);
        }

        public static int InitGroup(int group, EventHandler die = null)
        {
            _logger.Information(ServerMessages.GetMessage(Messages.IA_CreateGroup, group)/*"Loading group {0}"*/);
            Monster Leader = null;
            foreach (var mob in _instance._IAGroups[group])
            {
                Point point = new Point();
                var mapInfo = ResourceCache.Instance.GetMaps()[mob.MapNumber];
                switch (mob.CreateType)
                {
                    case 0:
                        point = new Point(mob.StartX, mob.StartY);
                        break;
                    case 1:
                        for (var y = mob.StartY - 5; y <= (mob.StartY + 5) && point.X == 0; y++)
                            for (var x = mob.StartX - 5; x <= (mob.StartX + 5) && point.X == 0; x++)
                            {
                                if (mapInfo.GetAttributes(x, y).Length == 0)
                                {
                                    point = new Point(mob.StartX, mob.StartY);
                                }
                            }
                        break;
                    default:
                        continue;
                }
                if (point.X == 0)
                    continue;

                mob.monster = MonstersMng.Instance.CreateMonster(mob.Class, ObjectType.Monster, mob.MapNumber, point, mob.StartDir == -1 ? (byte)Program.RandomProvider(7) : (byte)mob.StartDir);
                //mob.monster.Active = false;
                mob.monster.Die += die;
                if(mob.Rank == 0)
                {
                    Leader = mob.monster;
                }
                else if(Leader != null)
                {
                    mob.monster.Leader = Leader;
                }
            }

            return _instance._IAGroups[group].Count;
        }

        public static void DelGroup(int group)
        {
            _logger.Information(ServerMessages.GetMessage(Messages.IA_DeleteGroup, group)/*"Removing group {0}"*/);
            foreach (var mob in _instance._IAGroups[group])
            {
                MonstersMng.Instance.DeleteMonster(mob.monster);
            }
        }
    }
}


--file MonstersMng.cs
﻿using MU.Resources;
using MuEmu.Resources;
using MuEmu.Resources.Game;
using MuEmu.Resources.Map;
using MuEmu.Util;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace MuEmu.Monsters
{
    public class MonstersMng
    {
        private static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(MonstersMng));
        public const ushort MonsterStartIndex = 2000;
        private Random _rand = new Random();
        private Dictionary<ushort, MonsterBase> _monsterInfo;

        private List<ushort> _clearIndex = new List<ushort>();
        private ushort _lastUsedIndex = MonsterStartIndex-1;

        public Dictionary<ushort, MonsterBase> MonsterInfo => _monsterInfo;
        public static MonstersMng Instance { get; set; }
        public List<Monster> Monsters { get; set; }

        public MonstersMng()
        {
            if (Instance != null)
                throw new Exception("Already Initialized");

            _monsterInfo = new Dictionary<ushort, MonsterBase>();
            Monsters = new List<Monster>();
        }

        public ushort GetNewIndex()
        {
            var clearIndex = _clearIndex.FirstOrDefault();
            if (clearIndex != 0)
            {
                _clearIndex.Remove(clearIndex);
                return clearIndex;
            }

            if (Monsters.Count() == 65535)
                throw new OverflowException();

            return ++_lastUsedIndex;
        }

        public Monster CreateMonster(ushort monsterID, ObjectType type, Maps mapId, Point position, byte dir, Element element = Element.None)
        {
            var mob = new Monster(monsterID, type, mapId, position, dir, element);
            mob.Index = GetNewIndex();
            Monsters.Add(mob);
            return mob;
        }
        public void DeleteMonster(Monster mob)
        {
            if (mob == null)
                return;

            mob.Map.DelMonster(mob);
            mob.ViewPort.ForEach(x => x.Character?.MonstersVP.Remove(mob.Index));
            _clearIndex.Add(mob.Index);
            Monsters.Remove(mob);
        }

        public void LoadMonster(string file)
        {
            if(File.Exists(file+".xml"))
            {
                Logger.Information(ServerMessages.GetMessage(Messages.MonsterMng_Loading), file + ".xml");
                var xml = ResourceLoader.XmlLoader<XmlMonsterInfo>(file + ".xml");
                _monsterInfo = xml.Monsters.ToDictionary(x => x.Monster);
            }
            else if (File.Exists(file + ".txt"))
            {
                Logger.Information(ServerMessages.GetMessage(Messages.MonsterMng_Loading), file + ".txt");
                var loader = new LoadWZTXT<XmlMonsterInfo>();
                var xml = loader.Load(file + ".txt");
                foreach (var monst in xml.Monsters)
                {
                    if (monst.Spell >= (Spell)100 && monst.Spell < (Spell)200)
                    {
                        monst.Spell -= 100;
                        monst.AttackRange += 2;
                    }
                    _monsterInfo.Add(monst.Monster, monst);
                }

                //xml.Monsters = _monsterInfo.Select(x => x.Value).ToArray();
                ResourceLoader.XmlSaver(file + ".xml", xml);
            }

            var bags = ResourceCache.Instance.GetItemBags();
            foreach(var mob in _monsterInfo.Values)
            {
                mob.Bag = bags.FirstOrDefault(x => x.Monster == mob.Monster);
            }
            Logger.Information(ServerMessages.GetMessage(Messages.MonsterMng_Types), _monsterInfo.Count);
        }

        public void LoadSetBase(string file)
        {
            XmlMonsterSetBase xml = null;
            if (File.Exists(file + ".xml"))
            {
                Logger.Information(ServerMessages.GetMessage(Messages.MonsterMng_Loading2), file + ".xml");
                xml = ResourceLoader.XmlLoader<XmlMonsterSetBase>(file + ".xml");
            }
            else if (File.Exists(file + ".txt"))
            {
                Logger.Information(ServerMessages.GetMessage(Messages.MonsterMng_Loading2), file + ".txt");
                var loader = new LoadWZTXT<XmlMonsterSetBase>();
                xml = loader.Load(file + ".txt");
                ResourceLoader.XmlSaver(file + ".xml", xml);
            }

            foreach(var npc in xml.NPCs)
                Monsters.Add(new Monster(npc.Type, ObjectType.NPC, npc.Map, new Point(npc.PosX, npc.PosY), (byte)npc.Dir) { Index = GetNewIndex() });

            foreach (var npc in xml.Normal)
                Monsters.Add(new Monster(npc.Type, ObjectType.Monster, npc.Map, new Point(npc.PosX, npc.PosY), (byte)npc.Dir) { Index = GetNewIndex() });

            foreach (var npc in xml.BloodCastles)
                Monsters.Add(new Monster(npc.Type, ObjectType.Monster, npc.Map, new Point(npc.PosX, npc.PosY), (byte)npc.Dir) { Index = GetNewIndex() });

            foreach (var npc in xml.Golden)
            {
                for (var i = 0; i < npc.Quant; i++)
                {
                    var dir = (byte)_rand.Next(7);
                    var mPos = GetSpawn(npc.Map, npc.PosX, npc.PosX2, npc.PosY, npc.PosY2);
                    var mob = new Monster(npc.Type, ObjectType.Monster, npc.Map, mPos, dir) { Index = GetNewIndex() };
                    Monsters.Add(mob);
                    Program.GoldenInvasionManager.AddMonster(mob);
                }
            }

            foreach (var npc in xml.Spots)
            {
                for (var i = 0; i < npc.Quant; i++)
                {
                    try
                    {
                        var dir = (byte)_rand.Next(7);
                        var mPos = GetSpawn(npc.Map, npc.PosX, npc.PosX2, npc.PosY, npc.PosY2);
                        var mob = new Monster(npc.Type, ObjectType.Monster, npc.Map, mPos, dir, npc.Element) { Index = GetNewIndex() };
                        Monsters.Add(mob);
                    }catch(InvalidOperationException)
                    { }
                }
            }
            Logger.Information(ServerMessages.GetMessage(Messages.MonsterMng_Loaded), Monsters.Count);
        }

        public Monster GetMonster(ushort Index)
        {
            return Monsters.FirstOrDefault(x => x.Index == Index);
        }
        
        public static void Initialize()
        {
            Instance = new MonstersMng();
        }

        public Point GetSpawn(Maps map, int minX, int maxX, int minY, int maxY)
        {
            var x = 0;
            var y = 0;
            var z = 0;
            var mMap = ResourceCache.Instance.GetMaps()[map];

            if(maxX == 0 && maxY == 0)
                return new Point(minX, minY);

            var _minX = Math.Min(minX, maxX);
            var _maxX = Math.Max(minX, maxX);
            var _minY = Math.Min(minY, maxY);
            var _maxY = Math.Max(minY, maxY);

            MapAttributes[] att = new MapAttributes[] { MapAttributes.Safe, MapAttributes.NoWalk, MapAttributes.Hide};
            do
            {
                x = _rand.Next(_minX, _maxX);
                y = _rand.Next(_minY, _maxY);
            } while (
                mMap.ContainsAny(x,y, att)
                && ++z < 10
                );

            if (z == 10)
                throw new InvalidOperationException();

            return new Point(x, y);
        }
    }
}


--file MossMerchant.cs
﻿using MU.Network;
using MU.Network.Game;
using MU.Resources;
using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

namespace MuEmu.Monsters
{
    internal class MossMerchant
    {
        internal static void Talk(Player player)
        {
            _ = player.Session.SendAsync(new STalk { Result = (NPCWindow)0x38 });
            var ibags = Resources.ResourceCache.Instance.GetItemBags();
            var availableBags = ibags
                .Where(x => x.Monster == 0x1EC)
                .Select(x => x.Plus);

            var list = new byte[11];
            foreach(var x in availableBags)
            {
                list[x] = 1;
            }    

            _ = player.Session.SendAsync(new SMossMerchantOpen
            {
                List = list
            });
            //var msg = VersionSelector.CreateMessage<SItemGet>(player.Character.Money, (ushort)0xffff);
            //_ = player.Session.SendAsync(msg);
        }

        internal static Item Gamble(Player player, int section)
        {
            var ibags = Resources.ResourceCache.Instance.GetItemBags();
            var bag = ibags.Where(x => x.Monster == 0x1EC && x.Plus == section).Single();
            return bag.GetReward().First();
        }
    }
}


--file PatternManager.cs
﻿using MU.Network.Game;
using MU.Resources;
using MU.Resources.XML;
using MuEmu.Resources;
using MuEmu.Util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu.Monsters
{
    internal class PatternManager
    {
        private List<List<MonsterSpell>> _patterns = new List<List<MonsterSpell>>();
        private DateTime _nextSkill = DateTime.MinValue;
        public PatternManager(Monster monster, string pattern)
        {
            Monster = monster;
            Monster.CanGoToBattleState = false;
            var xml = ResourceLoader.XmlLoader<PatternsDto>(pattern);
            foreach(var x in xml.Pattern.OrderBy(x => x.Number))
            {
                _patterns.Add(x.Skill.ToList());
            }
        }

        public Monster Monster { get; }
        public event EventHandler<UseSkillEventArgs> UseSkill;

        public void Update()
        {
            if (Monster.Active == false || _nextSkill > DateTime.Now)
                return;

            var currPatter = (int)((1.0f - Monster.Life / Monster.MaxLife) * _patterns.Count);
            var patter = _patterns[currPatter];
            var randomSkill = Program.RandomProvider(patter.Count);
            var skill = patter[randomSkill];

            UseSkill?.Invoke(Monster, new UseSkillEventArgs { Spell = skill });
            _ = Monster.ViewPort.Select(x => x.Session).SendAsync(new SMonsterSkillS9Eng
            {
                MonsterSkillNumber = (ushort)skill,
                ObjIndex = Monster.Index,
                TargetObjIndex = Monster.Target?.ID ?? 0xffff
            });

            var maxDelay = (int)MathF.Max(10000.0f * Monster.Life / Monster.MaxLife, 3000.0f);
            var delay = Program.RandomProvider(maxDelay, 300);
            _nextSkill = DateTime.Now.AddMilliseconds(delay);
        }
    }

    public class UseSkillEventArgs
    {
        public MonsterSpell Spell { get; set; }
    }
}


--file MuBot.cs
﻿using MU.Network.Game;
using MuEmu.Network.GameServices;
using MuEmu.Resources.Map;
using MuEmu.Util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using WebZen.Util;

namespace MuEmu
{
    public class MuBot
    {
        private bool _state;
        private DateTime _start;
        private uint TotalMinutes => (uint)(DateTime.Now - _start).TotalMinutes;

        public Player Player { get; private set; }
        public CMUBotData Configuration { get; internal set; }

        public MuBot(Player player)
        {
            Player = player;
            Player.Character.CharacterDie += Character_CharacterDie;
            Player.OnStatusChange += Player_OnStatusChange;
        }

        private void Player_OnStatusChange(object sender, EventArgs e)
        {
            Enable(false);
        }

        private void Character_CharacterDie(object sender, EventArgs e)
        {
            Enable(false);
        }

        public void Enable(bool state = true)
        {
            _start = DateTime.Now;

            if (!_state && state)
                Player.Character.HuntingRecord.Start();

            if (_state && !state)
                Player.Character.HuntingRecord.Save();

            _state = state;

            _ = Player.Session.SendAsync(new SMuHelperState {
                Status = (byte)(state ? 0 : 1),
                Money = 0,
                usTime = 0
            });
        }

        public void Update()
        {
            if (!_state)
                return;

            var time = DateTime.Now - _start;
            var minutes = (int)time.TotalMinutes;

            if (minutes <= 0 || (minutes % 5) != 0)
                return;

            uint money = (uint)(10 * Player.Character.Level);
            if (money > Player.Character.Money)
            {
                _state = false;
                Player.Character.Money = 0;
            }

            _ = Player.Session.SendAsync(new SMuHelperState
            {
                Status = (byte)(_state ? 0 : 1),
                Money = money,
                usTime = (ushort)minutes
            });
        }
    }
}


--file AntiHackServices.cs
﻿using MU.Network.AntiHack;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Handlers;

namespace MuEmu.Network
{
    public class AntiHackServices : MessageHandler
    {
        [MessageHandler(typeof(CAHCheck))]
        public void AHCheck(GSSession session, CAHCheck message)
        { }
    }
}

--file AuthServices.cs
﻿using MU.Resources;
using MuEmu.Entity;
using MuEmu.Events;
using MU.Network.Event;
using MU.Network.Game;
using MU.Network.GensSystem;
using MU.Network.Global;
using MU.Network.Pentagrama;
using MuEmu.Network.UBFSystem;
using MuEmu.Resources;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using WebZen.Handlers;
using WebZen.Util;
using MU.Network.Auth;
using MuEmu.Network.ConnectServer;
using System.Security.Cryptography;
using MU.Network;

namespace MuEmu.Network
{
    public class AuthServices : MessageHandler
    {
        public static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(AuthServices));


        [MessageHandler(typeof(CIDAndPassS12))]
        public async Task CIDAndPassS12(GSSession session, CIDAndPassS12 message)
        {
            await CIDAndPass(session, new CIDAndPass
            {
                btAccount = message.btAccount,
                ClientSerial = message.ClientSerial,
                ClientVersion = message.ClientVersion,
                btPassword = message.btPassword,
                TickCount = message.TickCount
            });
        }

        [MessageHandler(typeof(CIDAndPass))]
        public async Task CIDAndPass(GSSession session, CIDAndPass message)
        {
            BuxDecode.Decode(message.btAccount);
            BuxDecode.Decode(message.btPassword);

            if(session.TryLoginCount>2)
            {
                await session.SendAsync(new SLoginResult(LoginResult.ConnectionClosed3Fail));
                return;
            }

            if(Program.server.ClientVersion != message.ClientVersion)
            {
                Logger.Error("Bad client version {0} != {1}", Program.server.ClientVersion, message.ClientVersion);
                await session.SendAsync(new SLoginResult(LoginResult.OldVersion));
                session.Disconnect();
                return;
            }

            if(Program.server.ClientSerial != message.ClientSerial)
            {
                Logger.Error("Bad client serial {0} != {1}", Program.server.ClientSerial, message.ClientSerial);
                await session.SendAsync(new SLoginResult(LoginResult.OldVersion));
                session.Disconnect();
                return;
            }

            if(string.IsNullOrWhiteSpace(message.Account) || string.IsNullOrWhiteSpace(message.Password))
            {
                await session.SendAsync(new SLoginResult(LoginResult.AccountError));
                return;
            }    

            using (var db = new GameContext())
            {
                var acc = (from account in db.Accounts
                          where account.Account.ToLower() == message.Account.ToLower()
                          select account)
                          .SingleOrDefault();

                if(acc == null)
                {
                    Logger.Information("Account {0} Don't exists", message.Account);
                    if (!Program.AutoRegistre)
                    {
                        await session.SendAsync(new SLoginResult(LoginResult.AccountError));
                        return;
                    }else
                    {
                        acc = new MU.DataBase.AccountDto
                        {
                            Account = message.Account,
                            //Password = Convert.ToBase64String(hash),
                            //Salt = Convert.ToBase64String(newSalt),
                            Characters = new List<MU.DataBase.CharacterDto>(),
                            VaultCount = 1,
                            VaultMoney = 0,
                            LastConnection = DateTime.Now,
                            IsConnected = false,
                            ServerCode = 0,
                        };

                        string Salt = "";
                        acc.Password = GetHashPassword(message.Password, ref Salt);
                        acc.Salt = Salt;
                        db.Accounts.Add(acc);
                        db.SaveChanges();
                        Logger.Information("Account Created");
                    }
                }


                var salt = acc.Salt;
                if (string.IsNullOrEmpty(salt))
                {
                    acc.Password = GetHashPassword(acc.Password, ref salt);
                    acc.Salt = salt;
                }

                if (acc.Password != GetHashPassword(message.Password, ref salt))
                {
                    await session.SendAsync(new SLoginResult(LoginResult.PasswordError));
                    session.TryLoginCount++;
                    return;
                }

                if (acc.IsConnected == true)
                {
                    await session.SendAsync(new SLoginResult(LoginResult.IsConnected));
                    return;
                }

                session.PreviousCode = 0xffff;
                acc.ServerCode = Program.ServerCode;
                acc.IsConnected = true;
                acc.LastConnection = DateTime.Now;
                db.Accounts.Update(acc);
                db.SaveChanges();

                session.Player.SetAccount(acc);
            }
            
            await session.SendAsync(new SLoginResult(LoginResult.Ok));
        }

        internal string GetHashPassword(string pwd, ref string salt)
        {
            if (string.IsNullOrEmpty(salt))
            {
                var newSalt = new byte[24];
                using (var csprng = new RNGCryptoServiceProvider())
                {
                    csprng.GetBytes(newSalt);
                }

                salt = Convert.ToBase64String(newSalt);
            }

            var hash = new Rfc2898DeriveBytes(pwd, Convert.FromBase64String(salt), 24000).GetBytes(24);
            return Convert.ToBase64String(hash);
        }

        [MessageHandler(typeof(CCharacterList))]
        public async Task CCharacterList(GSSession session)
        {
            using (var db = new GameContext())
            {
                var acc = session.Player.Account;

                byte y = 0;
                acc.Characters = (from @char in db.Characters
                                  where @char.AccountId == acc.ID
                                  select @char).ToDictionary(x => y++);

                var resetList = new SResetCharList();

                byte mClass = 0;
                var maxLevel = acc.Characters.Any()?acc.Characters.Max(x => x.Value.Level):1;

                if (maxLevel > 250)
                    mClass = 4;
                else if (maxLevel > 220)
                    mClass = 3;
                else if (maxLevel > 210)
                    mClass = 2;
                else if(maxLevel > 200)
                    mClass = 1;

                var charList = VersionSelector.CreateMessage<SCharacterList>(mClass, (byte)0, (byte)5, (byte)3) as CharList;

                foreach (var @char in acc.Characters)
                {
                    @char.Value.Items = (from item in db.Items
                                         where item.CharacterId == @char.Value.CharacterId
                                         select item).ToList();

                    charList.AddChar(
                        @char.Key,
                        @char.Value,
                        Inventory.GetCharset((HeroClass)@char.Value.Class, new Inventory(null, @char.Value), 0),
                        GuildManager.Instance.FindCharacter(@char.Value.Name)?.Rank ?? GuildStatus.NoMember);
                }

                if(Program.Season == ServerSeason.Season9Eng)
                    await session.SendAsync(resetList);

                await session.SendAsync(charList);

                await session.SendAsync(new SEnableCreation { 
                    EnableCreation = EnableClassCreation.Summoner | EnableClassCreation.RageFighter | EnableClassCreation.MagicGladiator | EnableClassCreation.GrowLancer | EnableClassCreation.DarkLord 
                });
            }
        }

        [MessageHandler(typeof(CCharacterMapJoin))]
        public async Task CCharacterMapJoin(GSSession session, CCharacterMapJoin Character)
        {
            var valid = session.Player.Account.Characters.Any(x => x.Value.Name == Character.Name);
            Logger.ForAccount(session)
                .Information("Try to join with {0}", Character.Name);
            await session.SendAsync(new SCharacterMapJoin { Name = Character.Name, Valid = (byte)(valid ? 0 : 1) });
        }

        [MessageHandler(typeof(CServerList))]
        public async Task CServerList(GSSession session)
        {
            //Program.client.
            Program.client.SendAsync(new SCServerList());
            await session.SendAsync(new SServerList
            {
                List = Program.ServerList?.ToArray()??Array.Empty<MU.Network.Auth.ServerDto>()
            });
            //type:1nopvp,2pvp
        }

        [MessageHandler(typeof(CCharacterMapJoin2))]
        public async Task CCharacterMapJoin2(GSSession session, CCharacterMapJoin2 Character)
        {
            Logger.ForAccount(session)
                .Information("Join with {0}", Character.Name);
            var charDto = session.Player.Account.Characters
                .Select(x => x.Value)
                .FirstOrDefault(x => x.Name == Character.Name);

            if(!MapServerManager.CheckMapServerMove(session, (Maps)charDto.Map))
                return;

            using (var db = new GameContext())
            {
                charDto.Items = (from it in db.Items
                                 where it.CharacterId == charDto.CharacterId
                                 select it).ToList();

                charDto.Spells = (from spell in db.Spells
                                  where spell.CharacterId == charDto.CharacterId
                                  select spell).ToList();

                charDto.Quests = (from quest in db.Quests
                                   where quest.CharacterId == charDto.CharacterId
                                   select quest).ToList();

                charDto.QuestEX = (from quest in db.QuestsEX
                                  where quest.CharacterId == charDto.CharacterId
                                  select quest).ToList();

                charDto.SkillKey = (from config in db.Config
                                    where config.SkillKeyId == charDto.CharacterId
                                    select config).FirstOrDefault();

                charDto.Favorites = (from config in db.Favorites
                                    where config.CharacterId == charDto.CharacterId
                                    select config).FirstOrDefault();

                charDto.Friends = (from friend in db.Friends
                                 where (friend.FriendId == charDto.CharacterId || friend.CharacterId == charDto.CharacterId) && friend.State == 1
                                 select friend).ToList();

                charDto.Memos = (from letter in db.Letters
                            where letter.CharacterId == charDto.CharacterId
                            select letter).ToList();

                charDto.MasterInfo = (from mi in db.MasterLevel
                                     where mi.MasterInfoId == charDto.CharacterId
                                     select mi).FirstOrDefault();

                charDto.GremoryCases = (from gc in db.GremoryCase
                                        where gc.CharacterId == charDto.CharacterId && gc.AccountId == charDto.AccountId && (gc.Inventory == (byte)GremoryStorage.Character || gc.Inventory == (byte)GremoryStorage.Server)
                                        select gc).ToList();
            }

            if (@charDto == null)
                return;

            await session.SendAsync(new SCheckSum { Key = session.Player.CheckSum.GetKey(), Padding = 0xff });

            session.Player.Character = new Character(session.Player, @charDto);
            var @char = session.Player.Character;

            await session.SendAsync(new SPeriodItemCount());
            
            await session.SendAsync(new SKillCount { KillCount = 1 });
            
            if (charDto.SkillKey != null)
            {
                var skillKey = new SSkillKey
                {
                    SkillKey = charDto.SkillKey.SkillKey,
                    ChatWindow = charDto.SkillKey.ChatWindow,
                    E_Key = charDto.SkillKey.EkeyDefine,
                    GameOption = charDto.SkillKey.GameOption,
                    Q_Key = charDto.SkillKey.QkeyDefine,
                    R_Key = charDto.SkillKey.RkeyDefine,
                    W_Key = charDto.SkillKey.WkeyDefine,
                };
                if(skillKey.SkillKey == null)
                {
                    skillKey.SkillKey = Array.Empty<byte>();
                }
                await session.SendAsync(skillKey);
            }
            if(charDto.Favorites != null)
            {
                var fav = new CFavoritesList
                {
                    Region = new int[]
                    {
                        charDto.Favorites.Fav01,
                        charDto.Favorites.Fav02,
                        charDto.Favorites.Fav03,
                        charDto.Favorites.Fav04,
                        charDto.Favorites.Fav05,
                    }
                };

                await session.SendAsync(fav);
            }
            session.Player.Status = LoginStatus.Playing;

            GuildManager.Instance.AddPlayer(session.Player);

            //await session.SendAsync(new SNewQuestInfo());
            session.Player.Character.Inventory.SendJewelsInfo();

            await session.SendAsync(new SUBFInfo { Result = 1 });
            await session.SendAsync(new SMapMoveCheckSum { key = 0x0010 });

            if(Program.GlobalEventsManager.AnyEvent)
                await session.SendAsync(new SSendBanner { Type = BannerType.EvenInven });

            var bannerList = Program.EventManager.GetEvents()
                .Where(x => x.CurrentState != EventState.None && x.GetBanner() != (BannerType)0xff)
                .Select(x => x.GetBanner())
                .ToList();

            foreach( var banner in bannerList)
                await session.SendAsync(new SSendBanner { Type = banner });

            //ConnectServer dataSend
            Program.client.SendAsync(new SCAdd { Server = (byte)Program.ServerCode, btName = @charDto.Name.GetBytes() });

            if((@char.CtlCode & ControlCode.GameMaster) == ControlCode.GameMaster)
            {
                @char.Spells.SetBuff(SkillStates.GameMaster, TimeSpan.FromDays(100));
            }

            @char.DataLoaded = true;
        }

        [MessageHandler(typeof(CCharacterCreate))]
        public async Task CCharacterCreate(GSSession session, CCharacterCreate message)
        {
            var log = Logger.ForAccount(session);

            using (var db = new GameContext())
            {
                var exists = (from @char in db.Characters
                              where @char.Name.ToLower() == message.Name.ToLower()
                              select @char).Any();

                if(exists)
                {
                    log.Information("Character name {0} is in use", message.Name);
                    await session.SendAsync(new SCharacterCreate(0));
                    return;
                }

                log.Information("Creating character {0} class:{1}", message.Name, message.Class);

                var defaultChar = ResourceCache.Instance.GetDefChar()[message.Class];

                var gate = ResourceCache.Instance.GetGates()
                    .Where(s => s.Value.Map == defaultChar.Map && s.Value.GateType == GateType.Warp)
                    .Select(s => s.Value)
                    .FirstOrDefault();

                var rand = new Random();
                var x = (byte)rand.Next(gate?.Door.Left ?? 0, gate?.Door.Right ?? 126);
                var y = (byte)rand.Next(gate?.Door.Top ?? 0, gate?.Door.Bottom ?? 126);

                var newChar = new MU.DataBase.CharacterDto
                {
                    AccountId = session.Player.Account.ID,
                    Class = (byte)message.Class,
                    Experience = 0,
                    GuildId = null,
                    Level = defaultChar.Level,
                    LevelUpPoints = 0,
                    Name = message.Name,
                    Quests = new List<MU.DataBase.QuestDto>(),
                    Items = new List<MU.DataBase.ItemDto>(),
                    // Map
                    Map = (byte)defaultChar.Map,
                    X = x,
                    Y = y,
                    // Stats
                    Str = (ushort)defaultChar.Stats.Str,
                    Agility = (ushort)defaultChar.Stats.Agi,
                    Vitality = (ushort)defaultChar.Stats.Vit,
                    Energy = (ushort)defaultChar.Stats.Ene,
                    Command = (ushort)defaultChar.Stats.Cmd,
                    CtlCode = 0,
                    Life = (ushort)defaultChar.Attributes.Life,
                    Mana = (ushort)defaultChar.Attributes.Mana,
                    MaxLife = (ushort)defaultChar.Attributes.Life,
                    MaxMana = (ushort)defaultChar.Attributes.Mana,
                    Resets = 0
                };

                db.Characters.Add(newChar);
                db.SaveChanges();

                var position = (byte)session.Player.Account.Characters.Count();

                session.Player.Account.Characters.Add(position, newChar);

                var items = defaultChar.Equipament.Select(eq => new MU.DataBase.ItemDto
                {
                    AccountId = session.Player.Account.ID,
                    CharacterId = newChar.CharacterId,
                    VaultId = eq.Key >= 12 ? 12 : 0,
                    SlotId = eq.Key,
                    DateCreation = DateTime.Now,
                    Durability = eq.Value.Durability,
                    HarmonyOption = eq.Value.Harmony.Option,
                    Luck = eq.Value.Luck,
                    Number = eq.Value.Number,
                    Option = eq.Value.Option28,
                    OptionExe = (byte)eq.Value.OptionExe,
                    Plus = eq.Value.Plus,
                    Skill = eq.Value.Skill,
                    SocketOptions = string.Join(",", eq.Value.Slots.Select(s => s.ToString())),
                });

                db.Items.AddRange(items.ToArray());
                db.SaveChanges();

                await session.SendAsync(new SCharacterCreate(1, 
                    message.Name,
                    position,
                    newChar.Level, 
                    Array.Empty<byte>(),
                    Character.GetClientClass(message.Class)
                    ));
            }
        }

        [MessageHandler(typeof(CCharacterDelete))]
        public async Task CCharacterDelete(GSSession session, CCharacterDelete message)
        {
            var result = CharacterDeleteResult.Error;
            using (var db = new GameContext())
            {
                var @char = db.Characters.FirstOrDefault(x => x.Name == message.Name);
                if (@char != null)
                {
                    if (@char.GuildId == null)
                    {
                        db.Characters.Remove(@char);
                        db.SaveChanges();

                        var pk = session.Player.Account.Characters.FirstOrDefault(x => x.Value.Name == message.Name);
                        session.Player.Account.Characters.Remove(pk.Key);
                        result = CharacterDeleteResult.Success;
                    }
                }
            }
            await session.SendAsync(new SCharacterDelete { Result = result });
        }

        [MessageHandler(typeof(SSkillKey))]
        public void CSkillKey(GSSession session, SSkillKey message)
        {
            if (session.Player == null || session.Player.Character == null)
                return;

            using (var db = new GameContext())
            {
                var res = db.Config.FirstOrDefault(x => x.SkillKeyId == session.Player.Character.Id);
                if(res == null)
                {
                    db.Config.Add(new MU.DataBase.SkillKeyDto
                    {
                        SkillKeyId = session.Player.Character.Id,
                        SkillKey = message.SkillKey,
                        QkeyDefine = message.Q_Key,
                        EkeyDefine = message.E_Key,
                        WkeyDefine = message.W_Key,
                        GameOption = message.GameOption,
                        ChatWindow = message.ChatWindow,
                        RkeyDefine = message.R_Key,
                        //                    QWERLevelDefine = message.q
                    });
                }
                else
                {
                    //res.SkillKeyId = session.Player.Character.Id;
                    res.SkillKey = message.SkillKey;
                    res.QkeyDefine = message.Q_Key;
                    res.EkeyDefine = message.E_Key;
                    res.WkeyDefine = message.W_Key;
                    res.GameOption = message.GameOption;
                    res.ChatWindow = message.ChatWindow;
                    res.RkeyDefine = message.R_Key;
                    db.Config.Update(res);
                }

                db.SaveChanges();
            }
        }

        [MessageHandler(typeof(CServerMove))]
        public async Task CServerMove(GSSession session, CServerMove message)
        {
            Logger.ForAccount(session).Information("Server move recv");
            BuxDecode.Decode(message.btAccount);

            if (Program.server.ClientVersion != message.ClientVersion)
            {
                Logger.Error("Bad client version {0} != {1}", Program.server.ClientVersion, message.ClientVersion);
                await session.SendAsync(new SLoginResult(LoginResult.OldVersion));
                session.Disconnect();
                return;
            }

            if (Program.server.ClientSerial != message.ClientSerial)
            {
                Logger.Error("Bad client serial {0} != {1}", Program.server.ClientSerial, message.ClientSerial);
                await session.SendAsync(new SLoginResult(LoginResult.OldVersion));
                session.Disconnect();
                return;
            }

            using (var db = new GameContext())
            {
                var acc = (from account in db.Accounts
                           where string.Equals(account.Account, message.Account, StringComparison.InvariantCultureIgnoreCase)
                           select account)
                          .FirstOrDefault();

                var token = $"{message.AuthCode1:X8}{message.AuthCode2:X8}{message.AuthCode3:X8}{message.AuthCode4:X8}";

                if (acc.AuthToken != token)
                {
                    await session.SendAsync(new SLoginResult(LoginResult.ConnectionError));
                    return;
                }

                session.PreviousCode = (ushort)acc.ServerCode;
                acc.ServerCode = Program.ServerCode;
                acc.IsConnected = true;
                acc.LastConnection = DateTime.Now;
                db.Accounts.Update(acc);
                db.SaveChanges();

                byte y = 0;
                session.Player.SetAccount(acc);
                var _acc = session.Player.Account;
                _acc.Characters = (from @char in db.Characters
                                  where @char.AccountId == acc.AccountId
                                  select @char).ToDictionary(x => y++);

                foreach (var @char in _acc.Characters)
                {
                    @char.Value.Items = (from item in db.Items
                                         where item.CharacterId == @char.Value.CharacterId
                                         select item).ToList();
                }
            }

            await CCharacterMapJoin2(session, new CCharacterMapJoin2 { Name = message.Character });
        }
    }
}


--file CashShopServices.cs
﻿using MU.Network.CashShop;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Handlers;

namespace MuEmu.Network
{
    public class CashShopServices : MessageHandler
    {
        [MessageHandler(typeof(CCashOpen))]
        public void CashOpen(GSSession session)
        {
            var result = !session.Player.Character.CashShop.IsOpen && session.Player.Window == null;
            session.SendAsync(new SCashOpen { Result = (byte)(result?1:0) }).Wait();

            session.Player.Character.CashShop.IsOpen = result;
        }
        [MessageHandler(typeof(CCashPoints))]
        public void CashPoints(GSSession session)
        {
            session.Player.Character.CashShop.SendPoints();
        }
        [MessageHandler(typeof(CCashInventoryItem))]
        public void CashInventoryItem(GSSession session, CCashInventoryItem message)
        {
            session.Player.Character.CashShop.SendInventory(message);
        }
        [MessageHandler(typeof(CCashItemBuy))]
        public void CashItemBuy(GSSession session, CCashItemBuy message)
        {
            session.Player.Character.CashShop.BuyItem(message);
        }
    }
}


--file CSClient.cs
﻿using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using WebZen.Handlers;
using WebZen.Network;

namespace MuEmu.Network.ConnectServer
{
    public class CSClient : WZClient
    {
        public ushort Index { get; }
        private static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(CSClient));
        private WZPacketDecoderSimple _decoder;
        private WZPacketEncoder _encoder;
        private MessageHandler[] _handler;
        private TcpClient _client;
        private byte[] _buffer;
        private string _token;

        public CSClient(
            IPEndPoint ip, 
            MessageHandler[] handlers, 
            MessageFactory[] factories, 
            ushort index, 
            WZServer server, 
            byte show, 
            string token, 
            string name) : base(null, null, null)
        {
            _client = new TcpClient();
            _client.Connect(ip);
            _sock = _client.Client;

            _buffer = new byte[1024];
            _handler = handlers;

            _decoder = new WZPacketDecoderSimple(factories);
            _encoder = new WZPacketEncoder(factories,false);

            _client.Client.BeginReceive(_buffer, 0, 1024, SocketFlags.None, ReceiveCallback, this);

            Index = index;
            _server = server;

            var thread = new Thread(Worker);
            thread.Start(this);

            _token = token;
            SendAsync(new CRegistryReq { 
                Index = index, 
                Address = server.IPPublic, 
                Port = server.Port, 
                Show = show, 
                Token = token, 
                Name = name,
                Type = (byte)(Program.XMLConfiguration.GamePlay.PVP?0:1)
            });
        }

        private static void Worker(object param)
        {
            CSClient instance = param as CSClient;

            while (true)
            {
                Thread.Sleep(10000);

                instance.SendAsync(new CKeepAlive { Index = instance.Index, Load = (byte)instance._server.Load, Token = instance._token });
            }
        }

        private static async void ReceiveCallback(IAsyncResult ar)
        {
            CSClient instance = ar.AsyncState as CSClient;
            var messages = new List<object>();

            try
            {
                var btRecived = instance._client.Client.EndReceive(ar);

                if (btRecived == 0)
                {
                    instance._client.Client.Disconnect(false);
                    return;
                }
                //Logger.Information($"Receive " + btRecived + " Buffer:" + string.Join("", instance._buffer.Select(x => x.ToString("X2"))));
                using (var mem = new MemoryStream(instance._buffer, 0, btRecived))
                {
                    int readed = 0;
                    do
                    {
                        short serial;
                        readed += instance._decoder.Decode(mem, out serial, messages);

                    } while (readed < mem.Length);
                }

                foreach (var message in messages)
                {
                    foreach (var handler in instance._handler)
                    {
                        await handler.OnMessageReceived(instance, message);
                    }
                }

                instance._client.Client
                    .BeginReceive(instance._buffer, 0, 1024, SocketFlags.None, ReceiveCallback, instance);
            }
            catch(Exception)
            {
                instance._client.Client.Disconnect(false);
            }
        }

        public void SendAsync(object message)
        {
            try
            {
                _client.Client.Send(_encoder.Encode(message, ref _outSerial, this));
            }
            catch (SocketException)
            {
                _client.Client.Disconnect(false);
            }
            catch(Exception)
            { }
        }
    }
}


--file CSMessageFactory.cs
﻿using MU.Network;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Network;

namespace MuEmu.Network.ConnectServer
{
    public interface ICSMessage
    { }

    public class CSMessageFactory : MessageFactory<ConOpCode, ICSMessage>
    {
        public CSMessageFactory()
        {
            Register<CWelcome>(ConOpCode.CSWelcome);
            Register<CRegistryReq>(ConOpCode.GSJoin);
            Register<CKeepAlive>(ConOpCode.GSKeep);
            Register<SCAdd>(ConOpCode.GSClientAdd);
            Register<SCChat>(ConOpCode.GSClientChat);
            Register<SCRem>(ConOpCode.GSClientRem);
            Register<CSServerList>(ConOpCode.ServerList);
            Register<SCServerList>(ConOpCode.ServerList);
        }
    }
}


--file CSMessages.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Serialization;
using WebZen.Util;

namespace MuEmu.Network.ConnectServer
{
    [WZContract]
    public class CWelcome : ICSMessage
    { }

    [WZContract]
    public class CRegistryReq : ICSMessage
    {
        [WZMember(0)]
        public ushort Index { get; set; }

        [WZMember(1, 16)]
        public byte[] btAddress { get; set; }

        [WZMember(2)]
        public ushort Port { get; set; }

        [WZMember(3)]
        public byte Show { get; set; }

        [WZMember(4, 16)]
        public byte[] btToken { get; set; }

        [WZMember(5, 16)]
        public byte[] btName { get; set; }
        [WZMember(6)] public byte Type { get; internal set; }

        public string Address { get => btAddress.MakeString(); set => btAddress = value.GetBytes(); }
        public string Token { get => btToken.MakeString(); set => btToken = value.GetBytes(); }
        public string Name { get => btName.MakeString(); set => btName = value.GetBytes(); }
    }

    [WZContract]
    public class CKeepAlive : ICSMessage
    {
        [WZMember(0)]
        public ushort Index { get; set; }

        [WZMember(1)]
        public byte Load { get; set; }

        [WZMember(2, 16)]
        public byte[] btToken { get; set; }
        public string Token { get => btToken.MakeString(); set => btToken = value.GetBytes(); }
    }

    [WZContract]
    public class SCAdd : ICSMessage
    {
        [WZMember(0)]
        public byte Server { get; set; }

        [WZMember(1, 10)]
        public byte[] btName { get; set; }
    }

    [WZContract]
    public class SCServerList : ICSMessage
    {
    }
    
    [WZContract]
    public class ServerDto
    {
        [WZMember(0)]
        public ushort Index { get; set; }

        [WZMember(1)]
        public byte Load { get; set; }

        [WZMember(2)]
        public byte Type { get; set; }
    }

    [WZContract(LongMessage = true)]
    public class CSServerList : ICSMessage
    {
        [WZMember(0)]
        public byte CountH { get; set; }

        [WZMember(1)]
        public byte CountL { get; set; }

        [WZMember(2, SerializerType = typeof(ArraySerializer))]
        public ServerDto[] List { get; set; }

        public CSServerList()
        { }

        public CSServerList(ServerDto[] list)
        {
            CountH = (byte)(list.Length >> 8);
            CountL = (byte)(list.Length & 0xff);
            List = list;
        }
    }

    [WZContract]
    public class SCChat : ICSMessage
    {
        [WZMember(0)]
        public byte Server { get; set; }

        [WZMember(1, 10)]
        public byte[] btName { get; set; }

        [WZMember(2, 100)]
        public byte[] btChat { get; set; }
    }

    [WZContract]
    public class SCRem : ICSMessage
    {
        [WZMember(0)]
        public byte Server { get; set; }

        [WZMember(1, typeof(ArrayWithScalarSerializer<short>))]
        public CliRemDto[] List { get; set; }
    }

    [WZContract]
    public class CliRemDto : ICSMessage
    {
        [WZMember(0, 10)]
        public byte[] btName { get; set; }
    }
}


--file CSServices.cs
﻿using MU.Network.Auth;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WebZen.Handlers;
using WebZen.Util;

namespace MuEmu.Network.ConnectServer
{
    public class CSServices : MessageHandler
    {
        private static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(CSServices));
        [MessageHandler(typeof(SCAdd))]
        public void SCAdd(CSClient session, SCAdd message)
        {
            foreach(var c in Program.server.Clients.Where(x => x.Player != null && x.Player.Status == MU.Resources.LoginStatus.Playing))
            {
                var name = message.btName.MakeString();
                c.Player.Character.Friends.ConnectFriend(name, message.Server);
                var m = c.Player.Character.Guild?.Find(name)??null;
                if(m != null && message.Server != Program.ServerCode)
                {
                    m.Server = message.Server;
                }
            }
        }

        [MessageHandler(typeof(SCRem))]
        public void SCRem(CSClient session, SCRem message)
        {
            foreach (var c in Program.server.Clients.Where(x => x.Player != null && x.Player.Status == MU.Resources.LoginStatus.Playing))
            {
                foreach(var p in message.List)
                {
                    var name = p.btName.MakeString();
                    c.Player.Character?.Friends.DisconnectFriend(name);
                    var m = c.Player.Character.Guild?.Find(name)??null;
                    if (m != null && message.Server != Program.ServerCode)
                    {
                        m.Server = 0xff;
                    }
                }                
            }
        }

        [MessageHandler(typeof(CSServerList))]
        public void SServerList(CSClient session, CSServerList message)
        {
            Program.ServerList = message.List.Take((message.CountH<<8)+message.CountL).Select(x => new MU.Network.Auth.ServerDto {
                type = x.Type,
                data1 = 32,
                data2 = 0,
                gold = 0,
                server = x.Index,
            });
        }
    }
}


--file EventServices.cs
﻿using MU.Network;
using MU.Network.CastleSiege;
using MU.Network.Event;
using MU.Network.Game;
using MU.Resources;
using MuEmu.Events;
using MuEmu.Events.AcheronGuardian;
using MuEmu.Events.BloodCastle;
using MuEmu.Events.CastleSiege;
using MuEmu.Events.ChaosCastle;
using MuEmu.Events.Crywolf;
using MuEmu.Events.DevilSquare;
using MuEmu.Events.Event_Egg;
using MuEmu.Events.ImperialGuardian;
using MuEmu.Events.Kanturu;
using MuEmu.Events.LuckyCoins;
using MuEmu.Events.Minigames;
using MuEmu.Monsters;
using MuEmu.Resources;
using MuEmu.Util;
using System;
using System.Linq;
using System.Threading.Tasks;
using WebZen.Handlers;
using WebZen.Util;

namespace MuEmu.Network
{
    public class EventServices : MessageHandler
    {
        [MessageHandler(typeof(CEventRemainTime))]
        public async Task CEventRemainTime(GSSession session, CEventRemainTime message)
        {
            var res = new SEventRemainTime { EventType = message.EventType };
            switch (message.EventType)
            {
                case EventEnterType.DevilSquare:
                    var evds = Program.EventManager.GetEvent<DevilSquares>();
                    res.RemainTime = evds.RemainTime;
                    res.EnteredUser = evds.Count;
                    break;
                case EventEnterType.BloodCastle:
                    var evbc = Program.EventManager.GetEvent<BloodCastles>();
                    res.RemainTime = evbc.RemainTime;
                    break;
                case EventEnterType.ChaosCastle:
                    var ev = Program.EventManager.GetEvent<ChaosCastles>();
                    res.RemainTime = ev.RemainTime;
                    res.EnteredUser = ev.Count;
                    break;
                case EventEnterType.IllusionTemple:
                    res.RemainTime = 0;
                    break;
            }

            await session.SendAsync(res);
        }

        [MessageHandler(typeof(CLuckyCoinsCount))]
        public async Task CLuckyCoinsCount(GSSession session/*, CLuckyCoinsCount message*/)
        {
            var coins = await LuckyCoins.Registered(session.Player);
            await session.SendAsync(new SLuckyCoinsCount(coins));
        }

        [MessageHandler(typeof(CLuckyCoinsRegistre))]
        public async Task CLuckyCoinsRegistre(GSSession session/*, CLuckyCoinsRegistre message*/)
        {
            var coins = await LuckyCoins.Registre(session.Player);
            await session.SendAsync(new SLuckyCoinsCount(coins));
        }

        [MessageHandler(typeof(CBloodCastleMove))]
        public async Task CBloodCastleMove(GSSession session, CBloodCastleMove message)
        {
            var plr = session.Player;
            var @char = session.Player.Character;

            var invisibleCloack = @char.Inventory.Get(message.ItemPos);
            var evbc = Program.EventManager.GetEvent<BloodCastles>();
            var itemLevel = evbc.GetEventNumber(plr);

            if (invisibleCloack.Plus != message.Bridge && invisibleCloack.Number != ItemNumber.FromTypeIndex(13, 47))
            {
                await session.SendAsync(new SBloodCastleMove(1));
                return;
            }

            if (itemLevel != invisibleCloack.Plus)
            {
                await session.SendAsync(new SBloodCastleMove((byte)(itemLevel > invisibleCloack.Plus ? 4 : 3)));
                return;
            }

            if (!evbc.TryAdd(plr))
            {
                await session.SendAsync(new SBloodCastleMove(5));
                return;
            }

            await @char.Inventory.Delete(message.ItemPos);
        }

        [MessageHandler(typeof(CCrywolfBenefit))]
        public void CCrywolfBenefit(GSSession session)
        {
            Program.EventManager
                .GetEvent<Crywolf>()
                .SendBenefit(session);
        }

        [MessageHandler(typeof(CCrywolfState))]
        public void CCrywolfState(GSSession session)
        {
            Program.EventManager
                .GetEvent<Crywolf>()
                .SendState(session);
        }

        [MessageHandler(typeof(CCrywolfContract))]
        public void CCrywolfContract(GSSession session, CCrywolfContract message)
        {
            session.Player.Window = MonstersMng.Instance.GetMonster(message.Index);
            Program.EventManager
                .GetEvent<Crywolf>()
                .NPCTalk(session.Player);
        }

        [MessageHandler(typeof(CDevilSquareMove))]
        public async Task CDevilSquareMove(GSSession session, CDevilSquareMove message)
        {
            var plr = session.Player;
            var @char = plr.Character;

            var itemPos = (byte)(message.InvitationItemPos - 12);
            var item = @char.Inventory.Get(itemPos);
            if (item.Plus != message.SquareNumber + 1)
                return;

            var dsm = Program.EventManager.GetEvent<DevilSquares>();
            if (dsm.GetPlayerDS(plr) != message.SquareNumber + 1)
                return;

            if (!dsm.TryAdd(plr))
                return;

            await @char.Inventory.Delete(itemPos);
        }

        [MessageHandler(typeof(CChaosCastleMove))]
        public async Task CChaosCastleMove(GSSession session, CChaosCastleMove message)
        {
            var plr = session.Player;
            var @char = plr.Character;

            var item = @char.Inventory.Get(message.InvitationItemPos);

            var dsm = Program.EventManager.GetEvent<ChaosCastles>();

            if (!dsm.TryAdd(plr))
                return;

            await @char.Inventory.Delete(item);
        }

        [MessageHandler(typeof(CKanturuStateInfo))]
        public void CKanturuStateInfo(GSSession session)
        {
            var kanturu = Program.EventManager.GetEvent<Kanturu>();
            kanturu.NPCTalk(session.Player);
        }

        [MessageHandler(typeof(CKanturuEnterBossMap))]
        public void CKanturuEnterBossMap(GSSession session)
        {
            var kanturu = Program.EventManager.GetEvent<Kanturu>();
            kanturu.TryAdd(session.Player);
        }

        [MessageHandler(typeof(CImperialGuardianEnter))]
        public void CImperialGuardianEnter(GSSession session)
        {
            Program.EventManager.GetEvent<ImperialGuardian>()
                .TryAdd(session.Player);
        }

        [MessageHandler(typeof(CEventInventoryOpenS16))]
        public async Task EventInventoryOpen(GSSession session, CEventInventoryOpenS16 message)
        {
            var msg = new SEventInventoryOpenS16
            {
                Result = 3,
                EventTime = 0,
            };

            var muRummy = Program.EventManager.GetEvent<MuRummy>();
            var JewelBingo = Program.EventManager.GetEvent<JeweldryBingo>();
            var ballsAndCows = Program.EventManager.GetEvent<BallsAndCows>();
            var eventEgg = Program.EventManager.GetEvent<EventEgg>();

            switch ((BannerType)message.Event)
            {
                case BannerType.Evomon:
                    msg.Id = EventInventoryType.Evomon;
                    break;
                case BannerType.MineSweeper:
                    await session.SendAsync(new SMineSweeperOpen
                    {
                        Result = (byte)(Program.EventManager.GetEvent<MineSweeper>().CurrentState == EventState.Open ? 1 : 0),
                        Cells = Array.Empty<ushort>(),
                    });
                    return;
                case BannerType.MuRummy:
                    if (muRummy.CurrentState == EventState.Open)
                    {
                        msg.EventTime = ((int)muRummy.TimeLeft.TotalSeconds).ShufleEnding();
                        msg.Result = 1;
                        msg.Id = EventInventoryType.MuRummy;
                        msg.Data = 1;
                    }
                    break;
                case BannerType.JeweldryBingo:
                    if (JewelBingo.CurrentState != EventState.None)
                    {
                        await session.SendAsync(new SJewelBingoState
                        {
                            State = JBState.Open,
                        });
                        msg.EventTime = ((int)JewelBingo.TimeLeft.TotalSeconds).ShufleEnding();
                        msg.Id = EventInventoryType.JeweldryBingo;
                    }
                    break;
                case BannerType.MerryXMas:
                    msg.Id = EventInventoryType.XMas;
                    break;
                case BannerType.NewYear:
                    msg.Id = EventInventoryType.NewYear;
                    break;
                case BannerType.BallsAndCows:
                    msg.EventTime = ((int)ballsAndCows.TimeLeft.TotalSeconds).ShufleEnding();
                    msg.Id = EventInventoryType.BallsAndCows;
                    await session.SendAsync(new SBallsAndCowsOpen
                    {
                        Result = 1,
                        Ball = new byte[5],
                        Strikes = new byte[5],
                        Numbers = new byte[15],
                    });
                    return;
                case BannerType.UnityBattleField:
                    msg.Id = EventInventoryType.BattleCore;
                    break;
                default:
                    break;
            }
            await session.SendAsync(msg);
        }

        [MessageHandler(typeof(CBallsAndCowsStart))]
        public async Task BallsAndCowsStart(GSSession session)
        {
            var @event = Program.EventManager.GetEvent<BallsAndCows>();
            var game = @event.GetGame(session.Player);

            if (game.State == 0)
            {
                var cardDecks = session.Player.Character.Inventory.FindAllEvent(7384);
                if (cardDecks.Count() == 0)
                {
                    await session.SendAsync(new SBallsAndCowsStart { Result = 0x0E });
                    return;
                }
                session.Player.Character.Inventory.DeleteEvent(cardDecks.First());
                session.Player.Character.Inventory.SendEventInventory();
                game.Start();
            }

            await session.SendAsync(new SBallsAndCowsStart { Result = 0x0 });
            if (game.State == 1)
            {
                await session.SendAsync(new SBallsAndCowsOpen {
                    Result = 2,
                    Ball = game.Ball,
                    Strikes = game.Strikes,
                    Numbers = game.Numbers,
                    Score = game.Score,
                });
            }
        }
        [MessageHandler(typeof(CBallsAndCowsPick))]
        public async Task BallsAndCowsPick(GSSession session, CBallsAndCowsPick message)
        {
            var @event = Program.EventManager.GetEvent<BallsAndCows>();
            var game = @event.GetGame(session.Player);

            game.SetNumber(message.Numbers);         

            if(game.State == 2)
            {
                var result = game.Strikes.Any(x => x == 3);
                var msg = new SBallsAndCowsResult
                {
                    Ball = game.Ball,
                    Strikes = game.Strikes,
                    Numbers = game.Hidden,
                    Score = game.Score,
                    Result = (byte)(result ? 3 : 2),
                    Data4 = (byte)(result ? 3 : 2),
                };
                await session.SendAsync(msg);
                var it = new Item(7591);
                if(game.Score > 450)
                {
                    it.Number = 7593;
                }
                else if(game.Score > 300)
                {
                    it.Number = 7592;
                }
                session.Player.Character.GremoryCase.AddItem(it, DateTime.Now.AddDays(1), GremoryStorage.Character, GremorySource.Event);
                @event.ClearGame(session.Player);
            }
            else
            {
                await session.SendAsync(new SBallsAndCowsOpen
                {
                    Result = 2,
                    Ball = game.Ball,
                    Strikes = game.Strikes,
                    Numbers = game.Numbers,
                    Score = game.Score,
                });
            }
        }

        [MessageHandler(typeof(CMuRummyStart))]
        public async Task MuRummyStart(GSSession session, CMuRummyStart message)
        {
            var @event = Program.EventManager.GetEvent<MuRummy>();
            var game = @event.GetGame(session.Player);

            if (game.State == 0)
            {
                var cardDecks = session.Player.Character.Inventory.FindAllEvent((ushort)(message.Type == 1 ? 7445 : 7384));
                if (cardDecks.Count() == 0)
                {
                    await session.SendAsync(new SMuRummyMessage { Index = (byte)(message.Type == 1 ? 12 : 0), Value = new ushortle(0) });
                    return;
                }
                session.Player.Character.Inventory.DeleteEvent(cardDecks.First());
                session.Player.Character.Inventory.SendEventInventory();
                game.Start(message.Type);
            }

            await session.SendAsync(new SMuRummyStart
            {
                CardCount = game.CardCount,
                CardInfo = game.GetCardInfo(),
                Score = game.Score,
                SlotStatus = game.GetSlotStatus(),
                SpecialCardCount = game.SpecialCardCount,
                Type = game.Type,
            });
        }

        [MessageHandler(typeof(CMuRummyPlayCard))]
        public async Task MuRummyPlayCard(GSSession session, CMuRummyPlayCard message)
        {
            var @event = Program.EventManager.GetEvent<MuRummy>();
            var game = @event.GetGame(session.Player);

            var pc = game.MovePlayCard(message.From, message.To);

            await session.SendAsync(new SMuRummyPlayCard
            {
                From = message.From,
                To = message.To,
                Color = pc.Color,
                Number = pc.Number,
            });
        }
        [MessageHandler(typeof(CMuRummyThrow))]
        public async Task MuRummyThrow(GSSession session, CMuRummyThrow message)
        {
            var @event = Program.EventManager.GetEvent<MuRummy>();
            var game = @event.GetGame(session.Player);

            var newCard = game.ThrowPlayCard(message.From);
            await session.SendAsync(message);
            await session.SendAsync(new SMuRummyMessage { Index = 4 });
        }

        [MessageHandler(typeof(CMuRummyReveal))]
        public async Task MuRummyReveal(GSSession session)
        {
            var @event = Program.EventManager.GetEvent<MuRummy>();
            var game = @event.GetGame(session.Player);

            if(game.CardCount == 0 || !game.GetCardInfo().Take(5).Any(x => x.Color == 0))
            {
                await session.SendAsync(new SMuRummyMessage { Index = 2 });
                return;
            }

            if(game.GetPlayedCard().Any(x => x.Color != 0))
            {
                await session.SendAsync(new SMuRummyMessage { Index = 3 });
                return;
            }

            var result = game.Reveal();

            await session.SendAsync(new SMuRummyReveal
            {
                CardCount = game.CardCount,
                CardInfo = result.ToArray(),
                SpecialCardCount = game.SpecialCardCount,
            });
        }

        [MessageHandler(typeof(CMuRummyExit))]
        public async Task MuRummyExit(GSSession session)
        {
            var @event = Program.EventManager.GetEvent<MuRummy>();
            var game = @event.GetGame(session.Player);
            var @char = session.Player.Character;


            if (game.Score < 250)
            {
                if(@char.Money == int.MaxValue)
                {
                    await session.SendAsync(new SMuRummyMessage { Index = 11 });
                    return;
                }
                @char.Money += 500000;
                await session.SendAsync(new SMuRummyMessage { Index = 10 });
            }
            else
            {
                var it = new Item(7537);
                if(game.Score < 400)
                {
                    it.Number = 7535;
                }
                else if (game.Score < 500)
                {
                    it.Number = 7536;
                }
                @char.GremoryCase.AddItem(it, DateTime.Now.AddDays(1), GremoryStorage.Character, GremorySource.Event);
                await session.SendAsync(new SMuRummyMessage { Index = 9, Value = it.Number.Number });
            }

            await session.SendAsync(new SMuRummyExit { Result = 1 });
            await session.SendAsync(new SMuRummyMessage { Index = 8 });
            @event.ClearGame(session.Player);
        }
        [MessageHandler(typeof(CMuRummySpecialMatch))]
        public async Task MuRummySpecialMatch(GSSession session)
        {
            await MuRummyMatch(session);
        }

        [MessageHandler(typeof(CMuRummyMatch))]
        public async Task MuRummyMatch(GSSession session)
        {
            var @event = Program.EventManager.GetEvent<MuRummy>();
            var game = @event.GetGame(session.Player);

            var score = game.Match();
            if(score == 0)
            {
                await session.SendAsync(new SMuRummyMessage
                {
                    Index = 6,
                    Value = new ushortle(0),
                });
            }
            else
            {
                await session.SendAsync(new SMuRummyMatch
                {
                    Result = 1,
                    Score = score,
                    TotalScore = game.Score
                });
                await session.SendAsync(new SMuRummyMessage
                {
                    Index = 5,
                    Value = new ushortle(0),
                });
            }

            await session.SendAsync(new SMuRummyCardList
            {
                CardInfo = game.GetCardInfo()
            });
        }

        [MessageHandler(typeof(CMineSweeperOpen))]
        public async Task CMineSweeperOpen(GSSession session)
        {
            await EventInventoryOpen(session, new CEventInventoryOpenS16 { Event = (byte)BannerType.MineSweeper });
        }

        [MessageHandler(typeof(CMineSweeperStart))]
        public async Task CMineSweeperStart(GSSession session)
        {
            var @event = Program.EventManager.GetEvent<MineSweeper>();
            var game = @event.GetGame(session.Player);
            var cardDecks = session.Player.Character.Inventory.FindAllEvent(7384);
            var msg = new SMineSweeperStart
            {
                Result = 0,
            };
            if (cardDecks.Count() == 0)
            {
                msg.Result = 1;
                await session.SendAsync(msg);
                return;
            }
            session.Player.Character.Inventory.DeleteEvent(cardDecks.First());
            session.Player.Character.Inventory.SendEventInventory();

            var board = game.GetBoard();
            var msg2 = new SMineSweeperOpen
            {
                Result = 2,
                Cells = board.ToArray(),
                Count = (byte)board.Count(),
                CurrentScore = game.Score,
                RemainBombs = game.RemainMines,
            };
            await session.SendAsync(msg);
            await session.SendAsync(new SMineSweeperCreateCell { Effect = 11, X = 8, Y = 6 });
            await session.SendAsync(msg2);
        }

        [MessageHandler(typeof(CMineSweeperReveal))]
        public void CMineSweeperReveal(GSSession session, CMineSweeperReveal message)
        {
            var @event = Program.EventManager.GetEvent<MineSweeper>();
            var game = @event.GetGame(session.Player);

            var result = game.Reveal(message.Cell).ToArray();

            _ = session.SendAsync(new SMineSweeperReveal
            {
                Cell = message.Cell,
                Cells = result,
                Score = game.Score,
            });

            if(!result.Any())
            {
                game.Finish(true);
            }

            if(game.IsClear())
            {
                MineSweeperSendScore(session, game);
            }
        }

        private void MineSweeperSendScore(GSSession session, MineSweeperGame game)
        {
            var cells = game.FailedBomb.Select(x => x.Cell);
            _ = session.SendAsync(new SMineSweeperEnd
            {
                SteppedOnBomb = (byte)(game.Losed ? 50 : 0),
                Cells = cells.ToArray(),
                Count = (byte)cells.Count(),
                BombsFound = (ushort)(game.Correct * 50),
                BombsFailure = (ushort)(game.Incorrect * 20),
                Clear = (byte)(game.Losed ? 0 : 500),
                Result = (byte)(game.Losed ? 1 : 0),
                Score = game.Score,
                TotalScore = game.TotalScore,
            });
        }
        [MessageHandler(typeof(CMineSweeperMark))]
        public void CMineSweeperMark(GSSession session, CMineSweeperMark message)
        {
            var @event = Program.EventManager.GetEvent<MineSweeper>();
            var game = @event.GetGame(session.Player);

            var result = game.Mark(message.Cell);

            _ = session.SendAsync(new SMineSweeperMark
            {
                Cell = message.Cell,
                RemainBombs = game.RemainMines,
                Result = result,
            });

            if(game.Finished)
            {
                MineSweeperSendScore(session, game);
            }
        }

        [MessageHandler(typeof(CMineSweeperGetReward))]
        public void CMineSweeperGetReward(GSSession session)
        {
            var @event = Program.EventManager.GetEvent<MineSweeper>();
            var game = @event.GetGame(session.Player);

            if(!game.Finished)
            {
                return;
            }

            var reward = game.GetReward();
            @event.ClearGame(session.Player);

            session.Player.Character.GremoryCase.AddItem(reward, DateTime.Now.AddDays(1), GremoryStorage.Character, GremorySource.Event);
            session.Player.Character.GremoryCase.SendList();

            _ = session.SendAsync(new SMineSweeperGetReward
            {
                Result = 0,
            });
        }

        [MessageHandler(typeof(CJewelBingoStart))]
        public async Task CJewelBingoStart(GSSession session)
        {
            var @event = Program.EventManager.GetEvent<JeweldryBingo>();
            var game = @event.GetGame(session.Player);

            if (game.State == JBState.Open)
            {
                var cardDecks = session.Player.Character.Inventory.FindAllEvent(7384);
                if(cardDecks.Count() == 0)
                {
                    await session.SendAsync(new SJewelBingoState
                    {
                        State = JBState.InsuficientCardDeck,
                    });                    
                    return;
                }
                session.Player.Character.Inventory.DeleteEvent(cardDecks.First());
                session.Player.Character.Inventory.SendEventInventory();
                game.State = JBState.State1;
            }

            if (game.State == JBState.State1)
            {
                await session.SendAsync(new SJewelBingoInfo
                {
                    CurrentJewel = game.AvailableJewels,
                    Grid = game.GetGrid(),
                    Result = 0,
                });
            }else if(game.State == JBState.BoxSelect)
            {
                _= session.SendAsync(new SJewelBingoBox());
            }else if(game.State == JBState.Playing)
            {
                _= session.SendAsync(new SJewelBingoPlayInfo
                {
                    CurrentBox = game.Box,
                    CurrentJewel = game.CurrentJewel,
                    Grid = game.GetGrid(),
                    JewelCount = game.LeftJewels,
                    MatchingJewel = game.GetMatching(),
                    Result = 0
                });
            }else if(game.State == JBState.State6)
            {
                _= session.SendAsync(new SJewelBingoPlayResult
                {
                    Grid = game.GetGrid(),
                    MatchingJewel = game.GetMatching(),
                    Result = 0,
                    LuckyClear = game.LuckyScore,
                    NormalClear = game.NormalScore,
                    JewelryClear = game.JewelryScore,
                });
            }
        }

        [MessageHandler(typeof(CJewelBingoMove))]
        public async Task CJewelBingoMove(GSSession session, CJewelBingoMove message)
        {
            var @event = Program.EventManager.GetEvent<JeweldryBingo>();
            var game = @event.GetGame(session.Player);

            if (message.Type == 0)
                game.Place(message.Slot, message.JewelType);
            else
                game.AutoPlace();

            await session.SendAsync(new SJewelBingoInfo
            {
                CurrentJewel = game.AvailableJewels,
                Grid = game.GetGrid(),
                Result = 0,
            });

            if(game.AvailableJewels.Sum(x => x) == 0)
            {
                game.State = JBState.BoxSelect;
                await session.SendAsync(new SJewelBingoState
                {
                    State = game.State,
                });
                await session.SendAsync(new SJewelBingoBox());
            }
        }

        [MessageHandler(typeof(CJewelBingoBox))]
        public async Task CJewelBingoBox(GSSession session, CJewelBingoBox message)
        {
            var @event = Program.EventManager.GetEvent<JeweldryBingo>();
            var game = @event.GetGame(session.Player);

            game.SelectBox(message.Box);
            game.State = JBState.Playing;
            await session.SendAsync(new SJewelBingoState
            {
                State = game.State,
            });
            await session.SendAsync(new SJewelBingoPlayInfo
            {
                CurrentBox = game.Box,
                CurrentJewel = game.CurrentJewel,
                Grid = game.GetGrid(),
                JewelCount = game.LeftJewels,
                MatchingJewel = game.GetMatching(),
                Result = 0
            });
        }
        [MessageHandler(typeof(CJewelBingoSelect))]
        public async Task CJewelBingoSelect(GSSession session, CJewelBingoSelect message)
        {
            var @event = Program.EventManager.GetEvent<JeweldryBingo>();
            var game = @event.GetGame(session.Player);

            game.SelectJewel(message.Slot, message.JewelType);
            await session.SendAsync(message);
            if (game.LeftJewels > 0)
            {
                await session.SendAsync(new SJewelBingoPlayInfo
                {
                    CurrentBox = game.Box,
                    CurrentJewel = game.CurrentJewel,
                    Grid = game.GetGrid(),
                    JewelCount = game.LeftJewels,
                    MatchingJewel = game.GetMatching(),
                    Result = 0
                });
            }
            else
            {
                game.State = JBState.Playing;
                await session.SendAsync(new SJewelBingoState
                {
                    State = game.State,
                });
                await session.SendAsync(new SJewelBingoPlayResult
                {
                    Grid = game.GetGrid(),
                    MatchingJewel = game.GetMatching(),
                    Result = 0,
                    LuckyClear = game.LuckyScore,
                    NormalClear = game.NormalScore,
                    JewelryClear = game.JewelryScore,
                });
            }
        }

        [MessageHandler(typeof(CJewelBingoGetReward))]
        public async Task CJewelBingoGetReward(GSSession session)
        {
            var @event = Program.EventManager.GetEvent<JeweldryBingo>();
            var game = @event.GetGame(session.Player);

            var reward = game.GetReward();
            @event.ClearGame(session.Player);

            session.Player.Character.GremoryCase.AddItem(reward, DateTime.Now.AddDays(1), GremoryStorage.Character, GremorySource.Event);
            session.Player.Character.GremoryCase.SendList();
            await session.SendAsync(new SJewelBingoState { State = JBState.Open });
        }

        [MessageHandler(typeof(CEventItemGet))]
        public async Task CEventItemGet(GSSession session, CEventItemGet message)
        {
            var @char = session.Player.Character;
            var map = @char.Map;
            Item item;

            var msg = VersionSelector.CreateMessage<SEventItemGet>((byte)0xff, Array.Empty<byte>(), message.Number);

            try
            {
                item = map.ItemPickUp(@char, message.Number);
            } catch (Exception ex)
            {
                await session.SendAsync(msg);
                session.Exception(ex);
                return;
            }

            var pos = @char.Inventory.AddEvent(item);
            msg.Set("Result", pos);
            msg.Set("Item", item.GetBytes());
            _ = session.SendAsync(msg);
            var msg2 = @char.Map.ItemGive(message.Number);
            _ = session.SendAsync(msg2);
            session.Player.SendV2Message(msg2);
        }

        [MessageHandler(typeof(CEventItemThrow))]
        public void CEventItemThrow(GSSession session, CEventItemThrow message)
        {
            var plr = session.Player;
            var inv = plr.Character.Inventory;
            var item = inv.GetEvent(message.Ipos);
            if (item == null)
                return;

            var bag = (from b in ResourceCache.Instance.GetItemBags()
                       where b.Number == item.Number && (b.Plus == item.Plus || b.Plus == 0xffff)
                       select b).FirstOrDefault();

            _ = session.SendAsync(new SEventItemThrow { Result = 1, Pos = message.Ipos });
            if (bag != null)
            {
                if (bag.LevelMin <= plr.Character.Level)
                {
                    inv.DeleteEvent(message.Ipos);
                    foreach (var reward in bag.GetReward())
                    {
                        plr.Character.Map.AddItem(message.px, message.py, reward, plr.Character);
                    }
                    var msg = new SCommand(ServerCommandType.Fireworks, (byte)plr.Character.Position.X, (byte)plr.Character.Position.X);
                    _ = plr.Session.SendAsync(msg);
                    plr.SendV2Message(msg);
                }
                else
                {
                    _ = item.Drop(message.px, message.py);
                    return;
                }
            }
            else
            {
                _ = item.Drop(message.px, message.py);
                inv.RemoveEvent(message.Ipos);
            }
        }

        [MessageHandler(typeof(CSiegeState))]
        public async Task CSiegeState(GSSession session)
        {
            var siege = Program.EventManager.GetEvent<CastleSiege>();

            var msg = new SSiegeState
            {
                Result = 1,
                CastleSiegeState = (byte)siege.State,
                StartYear = ((ushort)siege.StateStart.Year).ShufleEnding(),
                StartMonth = (byte)siege.StateStart.Month,
                StartDay = (byte)siege.StateStart.Day,
                StartHour = (byte)siege.StateStart.Hour,
                StartMinute = (byte)siege.StateStart.Minute,
                EndYear = ((ushort)siege.StateEnd.Year).ShufleEnding(),
                EndMonth = (byte)siege.StateEnd.Month,
                EndDay = (byte)siege.StateEnd.Day,
                EndHour = (byte)siege.StateEnd.Hour,
                EndMinute = (byte)siege.StateEnd.Minute,
                SiegeStartYear = ((ushort)siege.SiegeExpectedPeriod.Year).ShufleEnding(),
                SiegeStartMonth = (byte)siege.SiegeExpectedPeriod.Month,
                SiegeStartDay = (byte)siege.SiegeExpectedPeriod.Day,
                SiegeStartHour = (byte)siege.SiegeExpectedPeriod.Hour,
                SiegeStartMinute = (byte)siege.SiegeExpectedPeriod.Minute,
                StateLeftSec = siege.StageTimeLeft.ShufleEnding(),
                OwnerGuild = siege.Owner?.Name??"",
                OwnerGuildMaster = siege.Owner?.Master.Name??"",
            };
            await session.SendAsync(msg);
        }

        [MessageHandler(typeof(CGuildRegisteInfo))]
        public async Task CGuildRegisteInfo(GSSession session)
        {
            var siege = Program.EventManager.GetEvent<CastleSiege>();

            var rank = siege.AttackGuild.OrderByDescending(x => x.Marks).ToList();
            var guildInfo = rank.FirstOrDefault(x => x.Guild == session.Player.Character.Guild);

            var msg = new SGuildRegisteInfo
            {
                Result = 0,
                GuildName = session.Player.Character.Guild?.Name??"",
            };

            if (guildInfo != null)
            {
                msg.Result = 1;
                msg.RegRank = (byte)(rank.IndexOf(guildInfo)+1);
                msg.IsGiveUp = (byte)(guildInfo.GiveUp ? 1 : 0);
                msg.GuildMark = guildInfo.Marks;
            }

            await session.SendAsync(msg);
        }

        [MessageHandler(typeof(CGuildMarkOfCastleOwner))]
        public async Task CGuildMarkOfCastleOwner(GSSession session)
        {
            var siege = Program.EventManager.GetEvent<CastleSiege>();
            var msg = new SGuildMarkOfCastleOwner { Mark = new byte[32] };
            Array.Fill(msg.Mark, (byte)0xcc);
            if(siege.Owner != null)
            {
                msg.Mark = siege.Owner.Mark;
            }
            await session.SendAsync(msg);
        }

        [MessageHandler(typeof(CGuildRegiste))]
        public async Task CGuildRegiste(GSSession session)
        {
            var siege = Program.EventManager.GetEvent<CastleSiege>();

            if(siege.State != SiegeStates.RegisteSiege)
            {
                await session.SendAsync(new SGuildRegiste { Result = 7 });
                return;
            }

            if (session.Player.Character.Guild == null)
            {
                await session.SendAsync(new SGuildRegiste { Result = 6 });
                return;
            }

            if (!session.Player.Character.Guild.IsUnionMaster)
            {
                await session.SendAsync(new SGuildRegiste { Result = 0 });
                return;
            }

            if (siege.Owner == session.Player.Character.Guild.Union[0])
            {
                await session.SendAsync(new SGuildRegiste { Result = 3 });
                return;
            }

            siege.RegisteAttackGuild(session.Player);
        }

        [MessageHandler(typeof(CSiegeGuildList))]
        public async Task CSiegeGuildList(GSSession session)
        {
            var siege = Program.EventManager.GetEvent<CastleSiege>();

            var list = siege
                .AttackGuild
                .OrderByDescending(x => x.Marks)
                .Select((x, i) => new SiegueGuildDto { GuildName = x.Guild.Name, IsGiveUp = (byte)(x.GiveUp ? 1 : 0), SeqNum = (byte)(i+1), RegMarks = x.Marks})
                .ToArray();

            await session.SendAsync(new SSiegeGuildList { List = list, Result = 1 });
        }

        [MessageHandler(typeof(CSiegeRegisteMark))]
        public async Task CSiegeRegisteMark(GSSession session, CSiegeRegisteMark message)
        {
            var siege = Program.EventManager.GetEvent<CastleSiege>();
            var item = session.Player.Character.Inventory.FindAllItems(7189).Where(x => x.Plus == 3).FirstOrDefault();
            var guild = session.Player.Character.Guild;

            var msg = new SSiegeRegisteMark
            {
                Result = 3,
                GuildName = guild?.Name??"",
            };

            if (siege.State != SiegeStates.RegisteMark || guild==null || item == null)
            {
                await session.SendAsync(msg);
                return;
            }

            msg.Result = 1;
            msg.GuildMark = siege.RegisteMark(guild, item.Durability);
            if(msg.GuildMark == 0)
            {
                msg.Result = 0;
            }
            else
            {
                await session.Player.Character.Inventory.Delete((byte)item.SlotId);
            }
            await session.SendAsync(msg);
        }

        [MessageHandler(typeof(CAcheronEventEnter))]
        public void AcheronEventEnter(GSSession session)
        {
            Program.EventManager.GetEvent<AcheronGuardian>()
                .TryAdd(session.Player);
        }
    }
}


--file FilteredMessageHandler.cs
﻿using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using WebZen.Handlers;
using WebZen.Network;
using System.Threading.Tasks;
using BlubLib.Collections.Generic;
using Serilog;
using Serilog.Core;

namespace MuEmu.Network
{
    public class FilteredMessageHandler<TSession> : MessageHandler
        where TSession : WZClient
    {
        private static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(FilteredMessageHandler<TSession>));
        private readonly IDictionary<Type, List<Predicate<TSession>>> _filter = new Dictionary<Type, List<Predicate<TSession>>>();
        private readonly IList<IMessageHandler> _messageHandlers = new List<IMessageHandler>();

        public override async Task<bool> OnMessageReceived(WZClient wzsession, object message)
        {
            List<Predicate<TSession>> predicates;
            _filter.TryGetValue(message.GetType(), out predicates);

            TSession session = (TSession)wzsession;

            if (predicates != null && predicates.Any(predicate => !predicate(session)))
            {
                Logger.Debug("Dropping message {messageName} from client {remoteAddress}", message.GetType().Name, session.ID);
                return false;
            }

            var handled = false;
            foreach (var messageHandler in _messageHandlers)
            {
                var result = await messageHandler.OnMessageReceived(wzsession, message);
                if (result)
                    handled = true;
            }
            
            return handled;
        }

        public FilteredMessageHandler<TSession> AddHandler(IMessageHandler handler)
        {
            _messageHandlers.Add(handler);
            return this;
        }

        public FilteredMessageHandler<TSession> RegisterRule<T>(params Predicate<TSession>[] predicates)
        {
            if (predicates == null)
                throw new ArgumentNullException(nameof(predicates));

            _filter.AddOrUpdate(typeof(T),
                new List<Predicate<TSession>>(predicates),
                (key, oldValue) =>
                {
                    oldValue.AddRange(predicates);
                    return oldValue;
                });
            return this;
        }

        public FilteredMessageHandler<TSession> RegisterRule<T>(Predicate<TSession> predicate)
        {
            _filter.AddOrUpdate(typeof(T),
                new List<Predicate<TSession>> { predicate },
                (key, oldValue) =>
                {
                    oldValue.Add(predicate);
                    return oldValue;
                });
            return this;
        }
    }
}


--file BattleServices.cs
﻿using MU.Network;
using MU.Network.Game;
using MU.Resources;
using MuEmu.Monsters;
using MuEmu.Resources;
using MuEmu.Util;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WebZen.Handlers;
using WebZen.Util;

namespace MuEmu.Network.GameServices
{
    public partial class GameServices
    {
        [MessageHandler(typeof(CAttackS5E2))]
        public async Task CAttackS5E2(GSSession session, CAttackS5E2 message)
        {
            await CAttack(session, new CAttack { AttackAction = message.AttackAction, DirDis = message.DirDis, wzNumber = message.Number });
        }

        [MessageHandler(typeof(CAttack))]
        public async Task CAttack(GSSession session, CAttack message)
        {
            var targetId = message.Number;
            var Dir = message.DirDis & 0x0F;
            var Dis = (message.DirDis & 0xF0) >> 4;

            session.Player.Character.Direction = message.DirDis;

            if (message.Number >= MonstersMng.MonsterStartIndex) // Is Monster
            {
                try
                {
                    var monster = MonstersMng.Instance.GetMonster(targetId);

                    if (monster.Life <= 0)
                        return;

                    session.Player.SendV2Message(new SAction((ushort)session.ID, message.DirDis, message.AttackAction, targetId));
                    if (monster.Type == ObjectType.NPC)
                    {
                        return;
                    }

                    DamageType type;
                    var attack = session.Player.Character.Attack(monster, out type);
                    var eAttack = await session.Player.Character.PentagramAttack(monster);
                    await monster.GetAttacked(session.Player, attack, type, eAttack);
                }
                catch (Exception ex)
                {
                    Logger.ForAccount(session)
                        .Error(ex, "Invalid monster #{0}", targetId);
                }
            }
            else
            {
                try
                {
                    var target = Program.server.Clients.First(x => x.ID == targetId);
                    if (target.Player.Character.Health <= 0.0f)
                        return;

                    var rivals = session.Player.Character.Duel == target.Player.Character.Duel;

                    if (!(Program.XMLConfiguration.GamePlay.PVP || rivals))
                        return;

                    /*await session.Player
                        .SendV2Message(new SAction((ushort)session.ID, message.DirDis, message.AttackAction, targetId));*/

                    var attack = session.Player.Character
                        .Attack(target.Player.Character, out DamageType type);

                    var eattack = await session.Player.Character
                        .PentagramAttack(target.Player.Character);

                    await target.Player.Character
                        .GetAttacked((ushort)session.ID, message.DirDis, message.AttackAction, attack, type, Spell.None, eattack);
                }
                catch (Exception ex)
                {
                    Logger.ForAccount(session)
                        .Error(ex, "Invalid player #{0}", targetId);
                }
            }
        }

        [MessageHandler(typeof(CMagicAttack))]
        public void CMagicAttack(GSSession session, CMagicAttack message)
        {
            var @char = session.Player.Character;
            var target = message.Target;
            MuEmu.Data.SpellInfo spell;
            Spells spells = null;
            Monster monster = null;
            Player player = null;
            Point pos;
            int defense = 0;

            if (!@char.Spells.SpellDictionary.ContainsKey(message.MagicNumber))
            {
                Logger.Error("Invalid Magic, user don't own this spell {0}", message.MagicNumber);
                return;
            }

            spell = @char.Spells.SpellDictionary[message.MagicNumber];
            int eDmg = 0;

            try
            {
                if (target >= MonstersMng.MonsterStartIndex) // Is Monster
                {
                    monster = MonstersMng.Instance.GetMonster(target);
                    spells = monster.Spells;
                    defense = monster.Defense;
                    pos = monster.Position;
                    eDmg = @char.PentagramAttack(monster).Result;
                }
                else
                {
                    player = Program.server.Clients.First(x => x.ID == target).Player;
                    spells = player.Character.Spells;
                    defense = player.Character.Defense;
                    pos = player.Character.Position;
                    eDmg = @char.PentagramAttack(player.Character).Result;
                }
            }
            catch (Exception)
            {
                Logger.Error("MagicAttack: Invalid target");
                return;
            }

            var mana = @char.Mana - spell.Mana;
            var bp = @char.Stamina;

            if (mana >= 0 && bp >= 0)
            {
                switch (spell.Number)
                {
                    case Spell.Poison:
                        @char.Spells.AttackSend(spell.Number, message.Target, false);
                        spells.SetBuff(SkillStates.Poison, TimeSpan.FromSeconds(60), @char);
                        break;
                    case Spell.Ice:
                        @char.Spells.AttackSend(spell.Number, message.Target, false);
                        spells.SetBuff(SkillStates.Ice, TimeSpan.FromSeconds(60), @char);
                        break;
                    case Spell.InfinityArrow:
                        if (@char.BaseClass != HeroClass.FaryElf)
                            return;
                        spells.SetBuff(SkillStates.InfinityArrow, TimeSpan.FromSeconds(1800), @char);
                        @char.Spells.AttackSend(spell.Number, message.Target, true);
                        break;
                    case Spell.Heal:
                    case Spell.Heal1:
                    case Spell.Heal2:
                    case Spell.Heal3:
                    case Spell.Heal4:
                    case Spell.Heal5:
                        if (@char.BaseClass != HeroClass.FaryElf)
                            return;

                        var addLife = @char.EnergyTotal / 5;

                        if (spells.Character == null)
                        {
                            return;
                        }

                        spells.Character.Health += addLife;
                        @char.Spells.AttackSend(spell.Number, message.Target, true);
                        break;
                    case Spell.GreaterDefense:
                    case Spell.GreaterDefense1:
                    case Spell.GreaterDefense2:
                    case Spell.GreaterDefense3:
                    case Spell.GreaterDefense4:
                    case Spell.GreaterDefense5:
                        if (@char.BaseClass != HeroClass.FaryElf)
                            return;

                        spells.SetBuff(SkillStates.Defense, TimeSpan.FromSeconds(1800), @char);
                        @char.Spells.AttackSend(spell.Number, message.Target, true);
                        break;
                    case Spell.GreaterDamage:
                    case Spell.GreaterDamage1:
                    case Spell.GreaterDamage2:
                    case Spell.GreaterDamage3:
                    case Spell.GreaterDamage4:
                    case Spell.GreaterDamage5:
                        if (@char.BaseClass != HeroClass.FaryElf)
                            return;

                        spells.SetBuff(SkillStates.Attack, TimeSpan.FromSeconds(1800), @char);
                        @char.Spells.AttackSend(spell.Number, message.Target, true);
                        break;

                    case Spell.SoulBarrier:
                    case Spell.SoulBarrier1:
                    case Spell.SoulBarrier2:
                    case Spell.SoulBarrier3:
                    case Spell.SoulBarrier4:
                    case Spell.SoulBarrier5:
                        spells.SetBuff(SkillStates.SoulBarrier, TimeSpan.FromSeconds(60 + @char.EnergyTotal / 40), @char);
                        @char.Spells.AttackSend(spell.Number, message.Target, true);
                        break;

                    case Spell.GreaterFortitude:
                    case Spell.GreatFortitude1:
                    case Spell.GreatFortitude2:
                    case Spell.GreatFortitude3:
                    case Spell.GreatFortitude4:
                    case Spell.GreatFortitude5:
                        spells.SetBuff(SkillStates.SwellLife, TimeSpan.FromSeconds(60 + @char.EnergyTotal / 10), @char);
                        if (@char.Party != null)
                        {
                            foreach (var a in @char.Party.Members)
                                a.Character.Spells.SetBuff(SkillStates.SwellLife, TimeSpan.FromSeconds(60 + @char.EnergyTotal / 10), @char);
                        }
                        @char.Spells.AttackSend(spell.Number, message.Target, true);
                        break;
                    case Spell.Reflex:
                        spells.SetBuff(SkillStates.SkillDamageDeflection, TimeSpan.FromSeconds(60 + @char.EnergyTotal / 40), @char);
                        @char.Spells.AttackSend(spell.Number, message.Target, true);
                        break;
                    case Spell.Berseker:
                        spells.SetBuff(SkillStates.Berseker, TimeSpan.FromSeconds(60 + @char.EnergyTotal / 40), @char);
                        @char.Spells.AttackSend(spell.Number, message.Target, true);
                        break;
                    case Spell.Sleep:
                        spells.SetBuff(SkillStates.SkillSleep, TimeSpan.FromSeconds(30 + @char.EnergyTotal / 25), @char);
                        @char.Spells.AttackSend(spell.Number, message.Target, true);
                        break;
                    default:
                        @char.Spells.AttackSend(spell.Number, message.Target, false);
                        break;
                }

                @char.Mana = mana;
                DamageType type = DamageType.Regular;
                var attack = 0.0f;
                switch (spell.Number)
                {
                    case Spell.Falling_Slash:
                    case Spell.Lunge:
                    case Spell.Uppercut:
                    case Spell.Cyclone:
                    case Spell.Slash:
                    case Spell.TwistingSlash:
                    case Spell.TwistingSlash1:
                    case Spell.TwistingSlash2:
                    case Spell.TwistingSlash3:
                    case Spell.TwistingSlash4:
                    case Spell.TwistingSlash5:
                    case Spell.RagefulBlow:
                    case Spell.RagefulBlow1:
                    case Spell.RagefulBlow2:
                    case Spell.RagefulBlow3:
                    case Spell.RagefulBlow4:
                    case Spell.RagefulBlow5:
                    case Spell.DeathStab:
                    case Spell.DeathStab1:
                    case Spell.DeathStab2:
                    case Spell.DeathStab3:
                    case Spell.DeathStab4:
                    case Spell.DeathStab5:
                    case Spell.CrescentMoonSlash:
                    case Spell.Impale:
                    case Spell.FireBreath:
                        attack = @char.SkillAttack(spell, defense, out type);
                        //else
                        //    @char.SkillAttack(spell, player, out type);
                        break;
                    case Spell.Heal:
                    case Spell.Heal1:
                    case Spell.Heal2:
                    case Spell.Heal3:
                    case Spell.Heal4:
                    case Spell.Heal5:
                    case Spell.GreaterDamage:
                    case Spell.GreaterDamage1:
                    case Spell.GreaterDamage2:
                    case Spell.GreaterDamage3:
                    case Spell.GreaterDamage4:
                    case Spell.GreaterDamage5:
                    case Spell.GreaterDefense:
                    case Spell.GreaterDefense1:
                    case Spell.GreaterDefense2:
                    case Spell.GreaterDefense3:
                    case Spell.GreaterDefense4:
                    case Spell.GreaterDefense5:
                    case Spell.GreaterFortitude:
                    case Spell.GreatFortitude1:
                    case Spell.GreatFortitude2:
                    case Spell.GreatFortitude3:
                    case Spell.GreatFortitude4:
                    case Spell.GreatFortitude5:
                    case Spell.SoulBarrier:
                    case Spell.SoulBarrier1:
                    case Spell.SoulBarrier2:
                    case Spell.SoulBarrier3:
                    case Spell.SoulBarrier4:
                    case Spell.SoulBarrier5:
                    case Spell.Teleport:
                    case Spell.InfinityArrow:
                        return;
                    default:
                        if (spell.IsDamage == 0)
                            return;

                        if (@char.BaseClass == HeroClass.Summoner || @char.BaseClass == HeroClass.DarkWizard || @char.BaseClass == HeroClass.MagicGladiator)
                        {
                            attack = @char.MagicAttack(spell, defense, out type);
                        }
                        else
                        {
                            attack = @char.SkillAttack(spell, defense, out type);
                        }

                        if (attack <= 0)
                        {
                            attack = 0;
                            type = DamageType.Miss;
                        }
                        break;
                }

                if (@char.Spells.CheckCombo(spell.Number))
                {
                    attack += (@char.StrengthTotal + @char.AgilityTotal + @char.EnergyTotal)/2.0f;
                    @char.Spells.AttackSend(Spell.Combo, target, true);
                }

                player?.Character.GetAttacked((ushort)@char.Player.Session.ID, @char.Direction, 0, (int)attack, type, spell.Number, eDmg);
                monster?.GetAttackedDelayed(@char.Player, (int)attack, type, TimeSpan.FromMilliseconds(500));
            }
        }

        [MessageHandler(typeof(CMagicAttackS9))]
        public void CMagicAttackS9(GSSession session, CMagicAttackS9 message) => CMagicAttack(session, new CMagicAttack { MagicNumber = message.MagicNumber, Target = message.Target });

        [MessageHandler(typeof(CMagicDurationS9))]
        public async Task CMagicDurationS9(GSSession session, CMagicDurationS9 message) => await CMagicDuration(session, new CMagicDuration
        {
            MagicNumber = message.MagicNumber,
            Target = message.Target,
            Dir = message.Dir,
            Dis = message.Dis,
            MagicKey = message.MagicKey,
            TargetPos = message.TargetPos,
            X = message.X,
            Y = message.Y,
        });
        [MessageHandler(typeof(CMagicDurationS16))]
        public async Task CMagicDurationS16(GSSession session, CMagicDurationS16 message) => await CMagicDuration(session, new CMagicDuration
        {
            MagicNumber = message.MagicNumber,
            Target = message.Target,
            Dir = message.Dir,
            Dis = message.Dis,
            MagicKey = message.MagicKey,
            TargetPos = message.TargetPos,
            X = (byte)message.X,
            Y = (byte)message.Y,
        });

        [MessageHandler(typeof(CMagicDuration))]
        public async Task CMagicDuration(GSSession session, CMagicDuration message)
        {
            var @char = session.Player.Character;

            if (!@char.Spells.SpellDictionary.ContainsKey(message.MagicNumber))
            {
                Logger.Error("Invalid Magic, user don't own this spell {0}", message.MagicNumber);
                return;
            }

            var magic = @char.Spells.SpellDictionary[message.MagicNumber];

            if (@char.Mana < magic.Mana || @char.Stamina < magic.BP)
                return;

            if ((magic.Number == Spell.Triple_Shot ||
                magic.Number == Spell.Penetration ||
                magic.Number == Spell.IceArrow ||
                magic.Number == Spell.MultiShot))
            {
                if (@char.Inventory.Arrows == null)
                    return;
            }

            @char.Mana -= magic.Mana;
            @char.Stamina -= magic.BP;

            object msgdef = null;
            msgdef = VersionSelector.CreateMessage<SMagicDuration>(magic.Number, (ushort)session.ID, message.X, message.Y, message.Dir);
            await session.SendAsync(msgdef);
            session.Player.SendV2Message(msgdef);

            var dir = (message.Dir & 0xF0) >> 4;
            var dis = (message.Dir & 0x0F);

            var dirs = new List<Point>
            {
                new Point(-1,-1),
                new Point(0, -1),
                new Point(1, -1),

                new Point(1, 0),
                new Point(1, 1),
                new Point(0, 1),

                new Point(-1, 1),
                new Point(-1, 0)
            };
            DamageType type = DamageType.Regular;
            int attack = 0;
            Point pos = new Point();
            Monster mom = null;
            Player plr;

            if (message.Target != 0 && message.Target != 0xffff)
            {
                if (message.Target < MonstersMng.MonsterStartIndex)
                {
                    plr = Program.server.Clients.First(x => x.ID == message.Target).Player;
                    attack = @char.SkillAttack(magic, plr.Character.Defense, out type);
                    pos = plr.Character.Position;
                    var eDmg = await @char.PentagramAttack(plr.Character);
                    await plr.Character.GetAttacked(@char.Player.ID, message.Dir, 0, attack, type, message.MagicNumber, eDmg);
                }
                else
                {
                    mom = MonstersMng.Instance.GetMonster(message.Target);
                    if (mom == null)
                        return;
                    attack = @char.SkillAttack(magic, mom.Defense, out type);
                    pos = mom.Position;
                    var eDmg = await @char.PentagramAttack(mom);
                    await mom.GetAttacked(@char.Player, attack, type, eDmg);
                }
            }

            if (@char.Spells.CheckCombo(message.MagicNumber))
            {
                attack += (@char.StrengthTotal + @char.AgilityTotal + @char.EnergyTotal) / 2;
                @char.Spells.AttackSend(Spell.Combo, message.Target, true);
            }

            switch (message.MagicNumber)
            {
                case Spell.DrainLife:
                    {
                        if (mom != null)
                        {
                            @char.Health += (@char.EnergyTotal / 15.0f) + (mom.Info.Level / 2.5f);
                        }
                        else
                        {
                            @char.Health += (@char.EnergyTotal / 23.0f) + (attack * 0.1f);
                        }
                        var mg = VersionSelector.CreateMessage<SMagicAttack>(message.MagicNumber, @char.Player.ID, message.Target);
                        @char.SendV2Message(mg);
                        session.SendAsync(mg).Wait();
                    }
                    break;
                case Spell.ChainLighting:
                    {
                        var mvpcopy = @char.MonstersVP.ToList();
                        var t1 = mvpcopy
                            .FirstOrDefault(
                            x => (MonstersMng
                            .Instance
                            .GetMonster(x)?
                            .Position
                            .Substract(pos)
                            .Length()??100) < 2);

                        var t2 = mvpcopy
                            .Except(new[] { t1 })
                            .FirstOrDefault(
                            x => (MonstersMng
                            .Instance
                            .GetMonster(x)?
                            .Position
                            .Substract(pos)
                            .Length() ?? 100) < 4);

                        var l = new List<ushort>() { message.Target };

                        if (t1 != 0)
                        {
                            l.Add(t1);
                            var mob = MonstersMng.Instance.GetMonster(t1);
                            var eDmg = await @char.PentagramAttack(mob);
                            await mob.GetAttacked(@char.Player, attack, type, eDmg);
                        }

                        if (t2 != 0)
                        {
                            l.Add(t2);
                            var mob = MonstersMng.Instance.GetMonster(t2);
                            var eDmg = await @char.PentagramAttack(mob);
                            await mob.GetAttacked(@char.Player, attack, type, eDmg);
                        }

                        var obj = new SChainMagic
                        {
                            Magic = ((ushort)message.MagicNumber),
                            UserIndex = @char.Player.ID,
                            Targets = l.ToArray(),
                        };
                        var mg = VersionSelector.CreateMessage<SMagicAttack>(message.MagicNumber, @char.Player.ID, message.Target);
                        @char.SendV2Message(mg);
                        session.SendAsync(mg).Wait();
                        session.SendAsync(obj).Wait();
                        session.Player.SendV2Message(obj);
                    }
                    break;
                case Spell.RagefulBlow:
                case Spell.RagefulBlow1:
                case Spell.RagefulBlow2:
                case Spell.RagefulBlow3:
                case Spell.RagefulBlow4:
                case Spell.RagefulBlow5:
                    {
                        var mp = new Point(message.X, message.Y);
                        var vp = @char.MonstersVP
                            .ToList() // clone for preveen collection changes
                            .Select(x => MonstersMng.Instance.GetMonster(x))
                            .Where(x => x.Position.Substract(mp).Length() <= 2.0 && x.Type != ObjectType.NPC);

                        foreach (var mob in vp)
                        {
                            attack = @char.SkillAttack(magic, mob.Defense, out type);
                            var eDmg = await @char.PentagramAttack(mob);
                            await mob.GetAttacked(@char.Player, attack, type, eDmg);
                        }
                    }
                    break;
                case Spell.TwistingSlash:
                case Spell.TwistingSlash1:
                case Spell.TwistingSlash2:
                case Spell.TwistingSlash3:
                case Spell.TwistingSlash4:
                case Spell.TwistingSlash5:
                    {
                        var vp = @char.MonstersVP
                            .ToList() // clone for preveen collection changes
                            .Select(x => MonstersMng.Instance.GetMonster(x))
                            .Where(x => x.Position.Substract(@char.Position).Length() <= 2.0 && x.Type != ObjectType.NPC);

                        foreach (var mob in vp)
                        {
                            attack = @char.SkillAttack(magic, mob.Defense, out type);
                            var eDmg = await @char.PentagramAttack(mob);
                            await mob.GetAttacked(@char.Player, attack, type, eDmg);
                        }
                    }
                    break;
                case Spell.Decay:
                    {
                        var mp = new Point(message.X, message.Y);
                        var vp = @char.MonstersVP
                            .ToList() // clone for preveen collection changes
                            .Select(x => MonstersMng.Instance.GetMonster(x))
                            .Where(x => x.Position.Substract(mp).Length() <= 2.0 && x.Type != ObjectType.NPC);
                        foreach (var mob in vp)
                        {
                            attack = @char.SkillAttack(magic, mob.Defense, out type);
                            var eDmg = await @char.PentagramAttack(mob);
                            await mob.GetAttacked(@char.Player, attack, type, eDmg);
                            mob.Spells.SetBuff(SkillStates.Poison, TimeSpan.FromSeconds(60), @char);
                        }
                    }
                    break;
                case Spell.IceStorm:
                case Spell.IceStorm1:
                case Spell.IceStorm2:
                case Spell.IceStorm3:
                case Spell.IceStorm4:
                case Spell.IceStorm5:
                    {
                        var mp = new Point(message.X, message.Y);
                        var vp = @char.MonstersVP
                            .ToList() // clone for preveen collection changes
                            .Select(x => MonstersMng.Instance.GetMonster(x))
                            .Where(x => x.Position.Substract(mp).Length() <= 2.0 && x.Type != ObjectType.NPC);
                        foreach (var mob in vp)
                        {
                            attack = @char.SkillAttack(magic, mob.Defense, out type);
                            var eDmg = await @char.PentagramAttack(mob);
                            await mob.GetAttacked(@char.Player, attack, type, eDmg);
                            mob.Spells.SetBuff(SkillStates.Ice, TimeSpan.FromSeconds(60), @char);
                        }
                    }
                    break;
                case Spell.Neil:
                case Spell.Sahamutt:
                    {
                        var mp = new Point(message.X, message.Y);
                        var vp = @char.MonstersVP
                            .ToList() // clone for preveen collection changes
                            .Select(x => MonstersMng.Instance.GetMonster(x))
                            .Where(x => x.Position.Substract(mp).Length() <= 2.0 && x.Type != ObjectType.NPC);
                        foreach (var mob in vp)
                        {
                            attack = @char.MagicAttack(magic, mob.Defense, out type);
                            mob.GetAttackedDelayed(@char.Player, attack, type, TimeSpan.FromMilliseconds(300));
                            //mob.Spells.SetBuff(SkillStates.f, TimeSpan.FromSeconds(60), @char);
                        }
                    }
                    break;
            }
        }

        [MessageHandler(typeof(CBeattack))]
        public async Task CBeattack(GSSession session, CBeattack message)
        {
            var spell = ResourceCache.Instance.GetSkills()[message.MagicNumber];

            var mobList = from id in message.Beattack
                          select MonstersMng.Instance.GetMonster(id.Number);

            var mobInRange = from mob in mobList
                             where mob.MapID == session.Player.Character.MapID && spell.Distance >= mob.Position.Substract(message.Position).LengthSquared()
                             select mob;

            foreach (var mob in mobInRange)
            {
                DamageType dmgType;
                var dmg = session.Player.Character.MagicAttack(spell, mob.Defense, out dmgType);
                var eDmg = await session.Player.Character.PentagramAttack(mob);
                await mob.GetAttacked(session.Player, dmg, dmgType, eDmg);
            }
        }

        [MessageHandler(typeof(CBeattackS9))]
        public async Task CBeattackS9(GSSession session, CBeattackS9 message) => await CBeattack(session, new CBeattack
        {
            wzMagicNumber = ((ushort)message.MagicNumber).ShufleEnding(),
            Beattack = message.Beattack.Take(message.Count).Select(x => new CBeattackDto { MagicKey = x.MagicKey, wzNumber = x.Number.ShufleEnding() }).ToArray(),
            Serial = message.Serial,
            X = message.X,
            Y = message.Y,
        });
    }
}


--file GameServices.cs
﻿using MU.DataBase;
using MU.Network;
using MU.Network.Event;
using MU.Network.Game;
using MU.Network.MuunSystem;
using MU.Network.QuestSystem;
using MU.Resources;
using MU.Resources.Game;
using MuEmu.Entity;
using MuEmu.Events.BloodCastle;
using MuEmu.Events.CastleSiege;
using MuEmu.Events.DevilSquare;
using MuEmu.Events.EventChips;
using MuEmu.Events.ImperialGuardian;
using MuEmu.Events.Kanturu;
using MuEmu.Monsters;
using MuEmu.Network.ConnectServer;
using MuEmu.Network.Data;
using MuEmu.Network.UBFSystem;
using MuEmu.Resources;
using MuEmu.Resources.Game;
using MuEmu.Resources.Map;
using MuEmu.Util;
using MySqlX.XDevAPI;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using WebZen.Handlers;
using WebZen.Network;
using WebZen.Util;

namespace MuEmu.Network.GameServices
{
    public partial class GameServices : MessageHandler
    {
        public static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(GameServices));
        private static readonly Dictionary<HackCheck, string> HackCheck = new Dictionary<HackCheck, string>
        {
            { (HackCheck)0x3600, "Trade must be encrypted"},
            { (HackCheck)0x0004, "NProtect must be open"},
            { (HackCheck)0x0005, "Minimize is not enable"},
            { (HackCheck)0xF100, "LogOut must be encrypted" },
            { (HackCheck)0xF300, "JoinMap must be encrypted" },
            { (HackCheck)0x1C00, "Teleport must be encrypted" },
            { (HackCheck)0x1900, "Magic must be encrypted" },
            { (HackCheck)0x1E00, "MagicContinue must be encrypted" },
            { (HackCheck)0x1600, "DieExp/EquipmentItem must be encrypted" },
            { (HackCheck)0x2900, "HelperItem must be encrypted" },
            { (HackCheck)0x0006, "Decrypted size < 0" },
            { (HackCheck)0x4A00, "StraightAttack must be encrypted" },
        };

        [MessageHandler(typeof(CCheckSum))]
        public void CCheckSum(GSSession session, CCheckSum message)
        {
            //session.Player.CheckSum.IsValid(message.Key);
            Logger
                .ForAccount(session)
                .Debug("Key {0:X4}", message.Key);
        }

        [MessageHandler(typeof(CClientMessage))]
        public void CClientMessage(GSSession session, CClientMessage message)
        {
            if(HackCheck.ContainsKey(message.Flag))
            {
                Logger
                .ForAccount(session)
                .Information("Client Hack Check {0}", HackCheck[message.Flag]);
                return;
            }
            Logger
                .ForAccount(session)
                .Information("Client Hack Check {0}", message.Flag);
        }

        [MessageHandler(typeof(CAction))]
        public void CAction(GSSession session, CAction message)
        {
            session.Player.Character.Direction = message.Dir;
            var ans = new SAction((ushort)session.ID, message.Dir, message.ActionNumber, message.Target);
            //session.SendAsync(ans).Wait();
            session.Player.SendV2Message(ans);
        } 

        [MessageHandler(typeof(CDataLoadOK))]
        public void CDataLoadOk(GSSession session)
        {
            session.Player.Character.DataLoaded = true;
        }

        [MessageHandler(typeof(CMove))]
        public static async Task CMove(GSSession session, CMove message)
        {
            var dirs = new List<Point>
            {
                new Point(-1,-1),
                new Point(0, -1),
                new Point(1, -1),

                new Point(1, 0),
                new Point(1, 1),
                new Point(0, 1),

                new Point(-1, 1),
                new Point(-1, 0)
            };

            var @char = session.Player.Character;
            var count = message.Path[0] & 0x0F;
            var Cpos = new Point(message.X, message.Y);

            var valid = true;
            byte ld = 0;

            for (int i = 1; i <= count; i++)
            {
                ld = (byte)((message.Path[(i + 1) / 2] >> (((i % 2) == 1) ? 4 : 0)) & 0x07);

                Cpos.Offset(dirs[ld]);
                var att = @char.Map.GetAttributes(Cpos);
                if (att.Where(y => y == MapAttributes.NoWalk || y == MapAttributes.Hide).Count() > 0)
                {
                    valid = false;
                    break;
                }
            }

            if (!valid)
            {
                var msgp = VersionSelector.CreateMessage<SPositionSet>((ushort)session.ID, @char.Position);
                await session.SendAsync(msgp);
                session.Player.SendV2Message(msgp);
                Logger
                    .ForAccount(session)
                    .Error("Invalid path");
                return;
            }

            @char.Position = Cpos;

            var msg = new SMove((ushort)session.ID, (byte)Cpos.X, (byte)Cpos.Y, ld);
            session.Player.SendV2Message(msg);
            session.Player.Character.TPosition = Cpos;
        }

        [MessageHandler(typeof(CMoveEng))]
        public async Task CMoveEng(GSSession session, CMoveEng message)
        {
            await CMove(session, new CMove { Path = message.Path, X = message.X, Y = message.Y });
        }

        [MessageHandler(typeof(CMove12Eng))]
        public async Task CMove12Eng(GSSession session, CMove12Eng message)
        {
            await CMove(session, new CMove { Path = message.Path, X = message.X, Y = message.Y });
        }

        [MessageHandler(typeof(CPositionSet))]
        public async Task CPositionSet(GSSession session, CPositionSet message)
        {
            var pos = message.Position;
            Logger.ForAccount(session).Debug("Position set Recv {0}", pos);
            var @char = session.Player.Character;
            var msg = VersionSelector.CreateMessage<SPositionSet>((ushort)session.ID, pos);
            @char.Position = pos;
            @char.TPosition = pos;
            await session.SendAsync(msg);
            @char.SendV2Message(msg);
        }

        [MessageHandler(typeof(CPositionSetS9))]
        public async Task CPositionSet(GSSession session, CPositionSetS9 message)
        {
            var pos = message.Position;
            //Logger.ForAccount(session).Debug("PositionS9 set Recv {0}", pos);
            var @char = session.Player.Character;
            var msg = new SPositionSetS9Eng((ushort)session.ID, pos);
            @char.Position = pos;
            @char.TPosition = pos;
            await session.SendAsync(msg);
            @char.SendV2Message(msg);
        }

        #region Chat MessageHandlers
        // 0xC1 0x00
        [MessageHandler(typeof(CChatNickname))]
        public async Task CChatNickname(GSSession session, CChatNickname message)
        {
            if (!Program.Handler.ProcessCommands(session, message.Message.MakeString()))
            {
                session.Player.SendV2Message(message);
                await session.SendAsync(message);
            }
        }

        // 0xC1 0x01
        [MessageHandler(typeof(CChatNumber))]
        public async Task CChatNumber(GSSession session, CChatNumber message)
        {
            message.Number = (ushort)session.ID;
            session.Player.SendV2Message(message);
            await session.SendAsync(message);
        }

        // 0xC1 0x02
        [MessageHandler(typeof(CChatWhisper))]
        public async Task CChatWhisper(GSSession session, CChatWhisper message)
        {
            var target = Program.server.Clients
                .Where(x => x.Player != null)
                .Where(x => x.Player.Character != null)
                .FirstOrDefault(x => x.Player.Character.Name.ToLower() == message.Id.ToLower());

            if (target == null)
            {
                await session.SendAsync(new SNotice(NoticeType.Blue, ServerMessages.GetMessage(Messages.Chat_Player_Offline, message.Id)));
                return;
            }

            await target.SendAsync(message);
        }
        #endregion

        [MessageHandler(typeof(CCloseWindow))]
        public static void CCloseWindow(GSSession session)
        {
            if (session.Player.Window == null)
                return;

            if (session.Player.Window.GetType() == typeof(Monster))
            {
                var mob = session.Player.Window as Monster;
                if (mob == null)
                    return;

                if (mob.Info.Monster == 229)
                    Marlon.RemRef();

                Logger.Debug("Player close window:NPC{0}", mob.Info.Name);
            } else if (session.Player.Window.GetType() == typeof(Character))
            {
                var @char = session.Player.Window as Character;
                Logger.Debug("Player close window:Character{0}", @char.Name);
            } else
            {
                Logger.Debug("Player close window:{0}", session.Player.Window.GetType());
            }
            session.Player.Window = null;
        }

        [MessageHandler(typeof(CClientClose))]
        public static async Task CClientClose(GSSession session, CClientClose message)
        {
            Logger
                .ForAccount(session)
                .Information(ServerMessages.GetMessage(Messages.Game_Close), message.Type);

            using (var db = new GameContext())
            {
                await session.Player.Save(db);
                await db.SaveChangesAsync();
            }

            for (int i = 1; i <= 5; i++)
            {
                SubSystem.Instance.AddDelayedMessage(session.Player, TimeSpan.FromSeconds(5 - i), new SNotice(NoticeType.Blue, ServerMessages.GetMessage(Messages.Game_Close_Message, i)));
            }

            SubSystem.Instance.AddDelayedMessage(session.Player, TimeSpan.FromSeconds(5), new SCloseMsg { Type = message.Type });

            Program.client.SendAsync(new SCRem { Server = (byte)Program.ServerCode, List = new CliRemDto[] { new CliRemDto { btName = session.Player.Character?.Name.GetBytes() ?? Array.Empty<byte>() } } });
            session.Player.Status = message.Type switch
            {
                ClientCloseType.SelectChar => LoginStatus.Logged,
                _ => LoginStatus.NotLogged
            };
        }

        [MessageHandler(typeof(CMoveItem))]
        public async Task CMoveItem(GSSession session, CMoveItem message)
        {
            var msg = VersionSelector.CreateMessage<SMoveItem>();
            msg.Set("ItemInfo", message.ItemInfo);
            if (session.Player.Character.Inventory.Move(message.sFlag, message.Source, message.tFlag, message.Dest))
            {
                msg.Set("Position", message.Dest);
                msg.Set("Result", (byte)message.tFlag);
            }
            else
            {
                msg.Set("Position", message.Source);
                msg.Set("Result", (byte)message.sFlag);
            }
            await session.SendAsync(msg);
        }

        [MessageHandler(typeof(CPointAdd))]
        public async Task CPointAdd(GSSession session, CPointAdd message)
        {
            var @char = session.Player.Character;
            var msg = new SPointAdd
            {
                Result = (byte)(0x10 | (byte)message.Type),
            };

            if (@char.LevelUpPoints == 0)
            {
                msg.Result = 0;
                await session.SendAsync(msg);
                return;
            }

            switch (message.Type)
            {
                case PointAdd.Strength:
                    if (@char.Strength + 1 <= short.MaxValue)
                    {
                        @char.LevelUpPoints--;
                        @char.Strength++;
                        msg.MaxStamina = (ushort)@char.MaxStamina;
                        msg.MaxShield = (ushort)@char.MaxShield;
                    } else
                    {
                        msg.Result = 0;
                    }
                    break;
                case PointAdd.Agility:
                    if (@char.Agility + 1 <= short.MaxValue)
                    {
                        @char.LevelUpPoints--;
                        @char.Agility++;
                        msg.MaxStamina = (ushort)@char.MaxStamina;
                        msg.MaxShield = (ushort)@char.MaxShield;
                    }
                    else
                    {
                        msg.Result = 0;
                    }
                    break;
                case PointAdd.Vitality:
                    if (@char.Vitality + 1 <= short.MaxValue)
                    {
                        @char.LevelUpPoints--;
                        @char.Vitality++;
                        msg.MaxLifeAndMana = (ushort)@char.MaxHealth;
                        msg.MaxStamina = (ushort)@char.MaxStamina;
                        msg.MaxShield = (ushort)@char.MaxShield;
                    }
                    else
                    {
                        msg.Result = 0;
                    }
                    break;
                case PointAdd.Energy:
                    if (@char.Energy + 1 <= short.MaxValue)
                    {
                        @char.LevelUpPoints--;
                        @char.Energy++;
                        msg.MaxLifeAndMana = (ushort)@char.MaxMana;
                        msg.MaxStamina = (ushort)@char.MaxStamina;
                        msg.MaxShield = (ushort)@char.MaxShield;
                    }
                    else
                    {
                        msg.Result = 0;
                    }
                    break;
                case PointAdd.Command:
                    if (@char.Command + 1 <= short.MaxValue)
                    {
                        @char.LevelUpPoints--;
                        @char.Command++;
                        msg.MaxStamina = (ushort)@char.MaxStamina;
                        msg.MaxShield = (ushort)@char.MaxShield;
                    }
                    else
                    {
                        msg.Result = 0;
                    }
                    break;
            }

            await session.SendAsync(msg);
        }

        // lacting
        [MessageHandler(typeof(CUseItem))]
        public async Task CUseItem(GSSession session, CUseItem message)
        {
            var @char = session.Player.Character;
            var inv = @char.Inventory;

            var Source = inv.Get(message.Source);

            Logger.Debug("CUseItem Source:{0} Target:{1} Type:{2} ItemSource:{3}", message.Source, message.Dest, message.Type, Source);

            if (Source.BasicInfo.Skill != Spell.None)
            {
                if (await @char.Spells.TryAdd(Source.BasicInfo.Skill))
                {
                    await inv.Delete(message.Source);
                }
                @char.HPorSDChanged(RefillInfo.Update);
                return;
            }

            switch (Source.Number)
            {
                case 14 * 512 + 0:// Apple
                case 14 * 512 + 1:// Small HP Potion
                case 14 * 512 + 2:// Medium HP Potion
                case 14 * 512 + 3:// Big HP Potion
                    var AddLife = (Source.SellPrice * 10) - (@char.Level * 2);
                    if (AddLife < 0)
                        AddLife = 0;

                    float AddLifeRate = ((Source.Number.Index + 1) * 10.0f) + (Source.Plus * 5.0f);
                    AddLife += (long)(@char.MaxHealth * AddLifeRate / 100.0f);
                    if (Source.Durability <= 1)
                        await inv.Delete(message.Source);
                    else
                        Source.Durability--;

                    @char.Health += AddLife;
                    @char.HuntingRecord.HealingUse(AddLife);
                    break;
                case 14 * 512 + 4:// Small MP Potion
                case 14 * 512 + 5:// Medium MP Potion
                case 14 * 512 + 6:// Big MP Potion
                    var AddMana = (Source.SellPrice * 10) - @char.Level;
                    if (AddMana < 0)
                        AddMana = 0;

                    float AddManaRate = ((Source.Number.Index - 3) * 10.0f) + (Source.Plus * 5.0f);
                    AddMana += (uint)(@char.MaxMana * AddManaRate / 100.0f);
                    if (Source.Durability == 1)
                        await inv.Delete(message.Source);
                    else
                        Source.Durability--;

                    @char.Mana += AddMana;
                    break;
                case 14 * 512 + 8: // Antidote
                    if (Source.Durability == 1)
                        await inv.Delete(message.Source);
                    else
                        Source.Durability--;
                    await @char.Spells.ClearBuffByEffect(SkillStates.Ice);
                    await @char.Spells.ClearBuffByEffect(SkillStates.Poison);
                    break;
                case 14 * 512 + 46: // Haloween Scroll
                    if (Source.Durability == 1)
                        await inv.Delete(message.Source);
                    else
                        Source.Durability--;

                    @char.Spells.SetBuff(SkillStates.HAttackSpeed, TimeSpan.FromMilliseconds(1800));
                    break;
                case 14 * 512 + 47: // Haloween Scroll
                    if (Source.Durability == 1)
                        await inv.Delete(message.Source);
                    else
                        Source.Durability--;

                    @char.Spells.SetBuff(SkillStates.HAttackPower, TimeSpan.FromMilliseconds(1800));
                    break;
                case 14 * 512 + 48: // Haloween Scroll
                    if (Source.Durability == 1)
                        await inv.Delete(message.Source);
                    else
                        Source.Durability--;

                    @char.Spells.SetBuff(SkillStates.HDefensePower, TimeSpan.FromMilliseconds(1800));
                    break;
                case 14 * 512 + 49: // Haloween Scroll
                    if (Source.Durability == 1)
                        await inv.Delete(message.Source);
                    else
                        Source.Durability--;

                    @char.Spells.SetBuff(SkillStates.HMaxLife, TimeSpan.FromMilliseconds(1800));
                    break;
                case 14 * 512 + 50: // Haloween Scroll
                    if (Source.Durability == 1)
                        await inv.Delete(message.Source);
                    else
                        Source.Durability--;

                    @char.Spells.SetBuff(SkillStates.HMaxMana, TimeSpan.FromMilliseconds(1800));
                    break;
                case 14 * 512 + 10: // Town Portal Scroll
                    if (Source.Durability == 1)
                        await inv.Delete(message.Source);
                    else
                        Source.Durability--;

                    if (@char.MapID == Maps.Davias)
                    {
                        await @char.WarpTo(22);
                    }
                    else if (@char.MapID == Maps.Noria)
                    {
                        await @char.WarpTo(27);
                    }
                    else if (@char.MapID == Maps.LostTower)
                    {
                        await @char.WarpTo(42);
                    }
                    else if (@char.MapID == Maps.Atlans)
                    {
                        await @char.WarpTo(49);
                    }
                    else if (@char.MapID == Maps.Tarkan)
                    {
                        await @char.WarpTo(57);
                    }
                    else if (@char.MapID == Maps.BloodCastle1)
                    {
                        await @char.WarpTo(22);
                    }
                    else if (@char.MapID == Maps.ChaosCastle1)
                    {
                        await @char.WarpTo(22);
                    }
                    else if (@char.MapID == Maps.Kalima1)
                    {
                        await @char.WarpTo(22);
                    }
                    else if (@char.MapID == Maps.Aida)
                    {
                        await @char.WarpTo(27);
                    }
                    else if (@char.MapID == Maps.Crywolf)
                    {
                        await @char.WarpTo(27);
                    }
                    else
                    {
                        await @char.WarpTo(17);
                    }
                    break;
                case 14 * 512 + 9: // Ale
                    if (Source.Durability <= 1)
                        await inv.Delete(message.Source);
                    else
                        Source.Durability--;
                    break;
                case 14 * 512 + 20: // Remedy Of Love
                    if (Source.Durability == 1)
                        await inv.Delete(message.Source);
                    else
                        Source.Durability--;

                    await session.SendAsync(new SItemUseSpecialTime { Number = 1, Time = 90 });
                    break;
                case 14 * 512 + 7: // Siege Potion
                    if (Source.Durability == 1)
                        await inv.Delete(message.Source);
                    else
                        Source.Durability--;

                    var SS = Source.Plus == 0 ? SkillStates.PotionBless : SkillStates.PotionSoul;
                    var time = TimeSpan.FromSeconds(Source.Plus == 0 ? 120 : 60);
                    @char.Spells.SetBuff(SS, time);
                    if (Source.Plus == 1)
                    {
                        await session.SendAsync(new SItemUseSpecialTime { Number = 2, Time = 60 });
                    }
                    break;
                case 14 * 512 + 63: // Fireworks
                    if (Source.Durability == 1)
                        await inv.Delete(message.Source);
                    else
                        Source.Durability--;

                    @char.SendV2Message(new SCommand(ServerCommandType.Fireworks, (byte)@char.Position.X, (byte)@char.Position.Y));
                    break;
                case 14 * 512 + 35:// Small SD Potion
                case 14 * 512 + 36:// Medium SD Potion
                case 14 * 512 + 37:// Big SD Potion
                    float addSDRate = @char.MaxShield * (25.0f + (Source.Number.Index - 35) * 10.0f) / 100.0f;

                    @char.Shield += addSDRate;
                    if (Source.Durability == 1)
                        await inv.Delete(message.Source);
                    else
                        Source.Durability--;
                    await session.SendAsync(new SEffect((ushort)session.ID, ClientEffect.RecoverShield));
                    break;
                case 14 * 512 + 13: //  Jewel of Bless
                    {
                        var Target = inv.Get(message.Dest);
                        if (Target.Plus >= 7)
                            break;

                        var source = inv.Get(message.Source);
                        var left = (byte)Math.Min(6 - Target.Plus, source.Durability);

                        Target.Plus += left;
                        source.Durability -= left;

                        if(source.Durability == 0)
                            await inv.Delete(message.Source);
                    }
                    break;
                case 14 * 512 + 14: //  Jewel of Soul
                    {
                        var Target = inv.Get(message.Dest);
                        if (Target.Plus >= 9)
                            break;

                        await inv.Delete(message.Source);
                        var soulRate = 50 + (Target.Luck ? 25 : 0);
                        if (Program.RandomProvider(100) < soulRate)
                        {
                            Target.Plus++;
                        }
                        else
                        {
                            if (Target.Plus > 7)
                                Target.Plus = 0;
                            else
                                Target.Plus--;
                        }
                    }
                    break;
                case 14 * 512 + 16: // Jewel of Life
                    {
                        var Target = inv.Get(message.Dest);
                        if (Target.Option28 >= 3)
                            break;

                        if (!Target.BasicInfo.Option)
                            break;

                        await inv.Delete(message.Source);
                        var lifeRate = 50 + (Target.Luck ? 25 : 0);
                        if (Program.RandomProvider(100) < lifeRate)
                        {
                            Target.Option28++;
                        }
                        else
                        {
                            Target.Option28--;
                        }

                    }
                    break;
                case 7210:// Jewel of Harmony
                    {
                        var Target = inv.Get(message.Dest);
                        if (Target.Harmony.Option != 0)
                            break;

                        var joh = ResourceCache.Instance.GetJOH();

                        Target.Harmony = new JewelOfHarmony();
                        Target.Harmony.Item = Target;
                        switch (Target.Harmony.Type)
                        {
                            case 1:
                                Target.Harmony.Option = (byte)Program.RandomProvider(joh.Weapon.Length + 1, 1);
                                break;
                            case 2:
                                Target.Harmony.Option = (byte)Program.RandomProvider(joh.Staff.Length + 1, 1);
                                break;
                            case 3:
                                Target.Harmony.Option = (byte)Program.RandomProvider(joh.Defense.Length + 1, 1);
                                break;
                            default:
                                return;
                        }

                        Logger.ForAccount(session).Information("Item {0} added JOH Option {1}", Target, Target.Harmony.EffectName);
                        Target.OnItemChange();
                        await inv.Delete(message.Source);
                    }
                    break;
                case 7211: // Lower Refining Stone
                case 7212: // Higher Refining Stone
                    inv.Get(message.Dest).Harmony.UseRefiningStone(Source);
                    break;
                case 13 * 512 + 66: //Invitation of the Santa Town's

                    break;
                case 14 * 512 + 29: // Symbol of Kundun
                    {
                        var Target = inv.Get(message.Dest);
                        if (Target.Number.Number != 7197 || Target.Plus != Source.Plus)
                            return;

                        if (Target.Durability + Source.Durability <= 5)
                        {
                            Target.Durability += Source.Durability;
                        } else
                        {
                            Source.Durability -= (byte)(5 - Target.Durability);
                        }
                        var LostMap = new Item(new ItemNumber(7196), new { Source.Plus });
                        await inv.Delete(message.Dest);
                        inv.Add(LostMap);
                    }
                    break;
            }
        }

        private static Item[] ExecuteBag(Player plr, Item item)
        {
            var itemBags = ResourceCache.Instance.GetItemBags();
            var bag = (from b in itemBags
                       where b.Number == item.Number && (b.Plus == item.Plus || b.Plus == 0xffff)
                       select b).FirstOrDefault();

            if (bag != null)
            {
                if (bag.LevelMin <= plr.Character.Level)
                {
                    return bag.GetReward();
                }
            }
            return null;
        }

        [MessageHandler(typeof(CItemThrow))]
        public static async Task CItemThrow(GSSession session, CItemThrow message)
        {
            var logger = Logger.ForAccount(session);
            var plr = session.Player;
            var inv = plr.Character.Inventory;
            var item = inv.Get(message.Source);
            if (item == null)
                return;
            DateTimeOffset date = DateTimeOffset.Now;

            var bag = ExecuteBag(plr, item);
            if (bag != null)
            {
                foreach (var reward in bag)
                    date = plr.Character.Map.AddItem(message.MapX, message.MapY, reward, plr.Character);

                var msg = new SCommand(ServerCommandType.Fireworks, (byte)plr.Character.Position.X, (byte)plr.Character.Position.X);
                await plr.Session.SendAsync(msg);
                plr.SendV2Message(msg);
                await inv.Delete(message.Source);
            }
            else
            {
                switch (item.Number.Number)
                {
                    case 7196://lost map
                        logger.Information("[Kalima] Try to Create Kalima Gate");
                        if (plr.Character.Map.IsEvent)
                        {
                            logger.Error("[Kalima] Failed to Summon Kalima Gate - Called in {0}", plr.Character.MapID);
                            break;
                        }
                        if (plr.Character.Map.GetAttributes(message.MapX, message.MapY).Contains(MapAttributes.Safe))
                        {
                            logger.Error("[Kalima] Failed to Summon Kalima Gate - Called in Saftey Area (Map:{0}, X:{1}, Y:{2})", plr.Character.MapID, message.MapX, message.MapY);
                            break;
                        }
                        if (plr.Character.KalimaGate != null)
                        {
                            logger.Error("[Kalima] Failed to Summon Kalima Gate - Already Have Gate (SummonIndex:{0})", plr.Character.KalimaGate.Index);
                            break;
                        }
                        var minLevel = new List<int> { 0, 40, 131, 181, 231, 281, 331, 380 };
                        if (minLevel[item.Plus] > plr.Character.Level)
                        {
                            logger.Error("[Kalima] Failed to Summon Kalima Gate - Min Level: {0}, Player Level: {1}", minLevel[item.Plus], plr.Character.Level);
                            break;
                        }
                        plr.Character.KalimaGate = MonstersMng.Instance.CreateMonster((ushort)(151 + item.Plus), ObjectType.NPC, plr.Character.MapID, new Point(message.MapX, message.MapY), 1);
                        plr.Character.KalimaGate.Caller = plr;
                        plr.Character.KalimaGate.Params = 5;
                        await inv.Delete(message.Source);

                        goto throwItem;
                }
                date = await item.Drop(message.MapX, message.MapY);
            }
        throwItem:
            await session.SendAsync(new SItemThrow { Source = message.Source, Result = 1 });

            logger.Information("Drop item {0} at {1},{2} in {3} deleted at {4}", item, message.MapX, message.MapY, plr.Character.MapID, date);
        }

        [MessageHandler(typeof(CItemGet))]
        public static async Task CItemGet(GSSession session, CItemGet message)
        {
            var @char = session.Player.Character;
            byte pos = 0xff;
            Item pickup;

            try
            {
                pickup = @char.Map.ItemPickUp(@char, message.Number);
            }
            catch(Exception ex)
            {
                var msgex = VersionSelector.CreateMessage<SItemGet>((byte)0xff, Array.Empty<byte>(), message.Number);
                session.SendAsync(msgex).Wait();
                session.Exception(ex);
                return;
            }

            if(pickup.IsZen)
            {
                if(session.Player.Character.Money == uint.MaxValue)
                {
                    var msgex = VersionSelector.CreateMessage<SItemGet>((byte)0xff, Array.Empty<byte>(), message.Number);
                    session.SendAsync(msgex).Wait();
                    return;
                }

                if (session.Player.Character.Money <= uint.MaxValue - pickup.BuyPrice)
                    session.Player.Character.Money += pickup.BuyPrice;
                else
                    session.Player.Character.Money = uint.MaxValue;
            }
            else
            {
                switch(Program.Season >= ServerSeason.Season16Kor?pickup.BasicInfo.Inventory: StorageID.Inventory)
                {
                    case StorageID.Inventory:
                        pos = @char.Inventory.Add(pickup);
                        //pickup = @char.Inventory.Get(pos);
                        var msg = VersionSelector.CreateMessage<SItemGet>(pos, pickup?.GetBytes() ?? Array.Empty<byte>(), message.Number);
                        await session.SendAsync(msg);
                        break;
                    case StorageID.EventInventory:
                        pos = @char.Inventory.AddEvent(pickup);
                        //pickup = @char.Inventory.GetEvent(pos);
                        await session.SendAsync(VersionSelector.CreateMessage<SEventItemGet>(pos, pickup?.GetBytes() ?? Array.Empty<byte>(), message.Number));
                        break;
                    case StorageID.MuunInventory:
                        pos = @char.Inventory.AddMuun(pickup);
                        //pickup = @char.Inventory.GetMuun(pos);
                        break;
                }
            }

            var msg2 = @char.Map.ItemGive(message.Number);
            _=session.SendAsync(msg2);
            session.Player.SendV2Message(msg2);
        }

        [MessageHandler(typeof(CEventEnterCount))]
        public async Task CEventEnterCount(GSSession session, CEventEnterCount message)
        {
            await session.SendAsync(new SEventEnterCount { Type = message.Type, Left = 10 });
        }

        [MessageHandler(typeof(CTalk))]
        public async Task CTalk(GSSession session, CTalk message)
        {
            var npcs = ResourceCache.Instance.GetNPCs();
            var ObjectIndex = message.Number.ShufleEnding();
            var obj = MonstersMng.Instance.GetMonster(ObjectIndex);
            var @char = session.Player.Character;

            if (obj == null)
                return;

            if (npcs.TryGetValue(obj.Info.Monster, out var npc))
            {
                session.Player.Window = obj;
                switch (npc.Class)
                {
                    case NPCAttributeType.ShopRuud:
                        if (session.Player.Character.PKLevel >= PKLevel.Warning2)
                        {
                            await session.SendAsync(new SChatTarget(ObjectIndex, "I don't sell to killers"));
                            break;
                        }

                        if (npc.Data == 0xffff)
                            break;

                        var baseClass = (byte)session.Player.Character.BaseClass;
                        baseClass >>= 4;
                        var shop = ResourceCache.Instance.GetShops()[(ushort)(npc.Data + baseClass)];

                        await session.SendAsync(new STalk { Result = NPCWindow.RuudShop });
                        await session.SendAsync(VersionSelector.CreateMessage<SShopItemList>((byte)0, shop.Storage.GetInventory()));
                        await session.SendAsync(new SMonsterSoulShop { Result = 1 });
                        await session.SendAsync(new SMonsterSoulAvailableShop { Amount = 1 });
                        break;
                    case NPCAttributeType.Shop:
                        if(session.Player.Character.PKLevel >= PKLevel.Warning2)
                        {
                            if(npc.NPC == 254)
                            {
                                var left = (session.Player.Character.PKTimeEnds - DateTime.Now);
                                _= session.SendAsync(new SChatTarget(ObjectIndex, $"You have {left.Hours} hour {left.Minutes} minutes left on the outlaw status.")); 
                            }
                            else{
                                await session.SendAsync(new SChatTarget(ObjectIndex, "I don't sell to killers"));
                            }
                            
                            break;
                        }

                        if (npc.Data == 0xffff)
                            break;
                        await session.SendAsync(new STalk { Result = NPCWindow.Shop });
                        await session.SendAsync(VersionSelector.CreateMessage<SShopItemList>((byte)0, npc.Shop.Storage.GetInventory()));
                        await session.SendAsync(new STax { Type = TaxType.Shop, Rate = 4 });
                        break;
                    case NPCAttributeType.Warehouse:
                        session.Player.Character.Inventory.Lock = true;
                        await session.SendAsync(new SNotice(NoticeType.Blue, ServerMessages.GetMessage(Messages.Game_Vault_active, session.Player.Account.ActiveVault + 1)));
                        await session.SendAsync(new STalk { Result = NPCWindow.Warehouse });
                        await session.SendAsync(VersionSelector.CreateMessage<SShopItemList>((byte)0, session.Player.Account.Vault.GetInventory()));
                        await session.SendAsync(new SWarehouseMoney(true, session.Player.Account.VaultMoney, session.Player.Character.Money));
                        break;
                    case NPCAttributeType.GuildMaster:
                        GuildManager.NPCTalk(session.Player, obj);
                        break;
                    case NPCAttributeType.EventChips:
                        EventChips.NPCTalk(session.Player);
                        break;
                    case NPCAttributeType.MessengerAngel:
                        Program.EventManager.GetEvent<BloodCastles>()
                            .MessengerAngelTalk(session.Player);
                        break;
                    case NPCAttributeType.KingAngel:
                        Program.EventManager.GetEvent<BloodCastles>()
                            .AngelKingTalk(session.Player);
                        break;
                    case NPCAttributeType.Kanturu:
                        Program.EventManager
                            .GetEvent<Kanturu>()
                            .NPCTalk(session.Player);
                        break;
                    case NPCAttributeType.DevilSquare:
                        Program.EventManager
                            .GetEvent<DevilSquares>()
                            .NPCTalk(session.Player);
                        break;
                    case NPCAttributeType.ServerDivision:
                        await session.SendAsync(new SCommand(ServerCommandType.ServerDivision));
                        break;
                    case NPCAttributeType.Window:
                        await session.SendAsync(new STalk { Result = (NPCWindow)npc.Data });

                        switch ((NPCWindow)npc.Data)
                        {
                            case NPCWindow.ChaosMachine:
                                session.Player.Character.Inventory.Lock = true;
                                break;
                            case NPCWindow.GateKeeper:
                                DuelSystem.NPCTalk(session.Player);
                                break;
                        }
                        break;
                    case NPCAttributeType.Talk:
                        if (npc.NPC == 257 && Program.Season < ServerSeason.Season9Eng)
                        {
                            CShadowBuff(session);
                            break;
                        }
                        await session.SendAsync(new SNPCDialog { Contribution = 0, NPC = npc.NPC });
                        break;
                    case NPCAttributeType.Buff:
                        @char.Spells.SetBuff((SkillStates)npc.Data, TimeSpan.FromSeconds(120));
                        break;
                    case NPCAttributeType.Quest:
                        var quest = @char.Quests.Find(obj.Info.Monster);

                        if (quest == null)
                        {
                            await session.SendAsync(new SChatTarget(ObjectIndex, ServerMessages.GetMessage(Messages.Game_NoQuestAvailable)));
                            return;
                        }

                        var details = quest.Details;
                        Logger.ForAccount(session)
                            .Information("Talk to QuestNPC: {0}, Found Quest:{1}, State:{2}", obj.Info.Name, details.Name, quest.State);
                        await session.SendAsync(new SMonsterKillS16 { 
                            QuestId = (byte)quest.Index, 
                            KillCount = quest
                            .GetKillCount()
                            .Select(x => new MonsterKillCountDto { Monster = x.Key, Count = x.Value })
                            .ToArray()
                        });
                        await session.SendAsync(new SSetQuest { Index = (byte)quest.Index, State = quest.StateByte });
                        break;
                    case NPCAttributeType.Gens:
                        @char.Gens.NPCTalk(npc.NPC);
                        break;
                    case NPCAttributeType.CastleSiege:
                        Program.EventManager
                            .GetEvent<CastleSiege>()
                            .NPCTalk(session.Player);
                        break;
                    case NPCAttributeType.CastleSiegeCrown:
                        Program.EventManager
                            .GetEvent<CastleSiege>()
                            .CrownTalk(session.Player);
                        break;
                    case NPCAttributeType.CastleSiegeCrownSwitch:
                        Program.EventManager
                            .GetEvent<CastleSiege>()
                            .CrownSwitchTalk(obj, session.Player);
                        break;
                    case NPCAttributeType.MossMerchant:
                        MossMerchant.Talk(session.Player);
                        break;
                }
            }
            else
            {
                Logger.ForAccount(session)
                    .Debug("Talk to unasigned NPC {0}", obj.Info.Monster);
                await session.SendAsync(new SChatTarget(ObjectIndex, ServerMessages.GetMessage(Messages.Game_DefaultNPCMessage)));
            }
        }

        [MessageHandler(typeof(CBuy))]
        public async Task CBuy(GSSession session, CBuy message)
        {
            var plr = session.Player;
            var @char = plr.Character;

            var bResult = new SBuy
            {
                Result = 0xff,
                ItemInfo = Array.Empty<byte>(),
            };

            if (plr.Window == null)
            {
                await session.SendAsync(bResult);
                throw new ArgumentException("Player isn't in buy/trade/box/Quest", nameof(session.Player.Window));
            }

            if (plr.Window.GetType() != typeof(Monster))
            {
                await session.SendAsync(bResult);
                throw new ArgumentException("Player isn't in buy", nameof(session.Player.Window));
            }

            var npcs = ResourceCache.Instance.GetNPCs();
            var obj = plr.Window as Monster;
            if (npcs.TryGetValue(obj.Info.Monster, out var npc))
            {
                if (npc.Class != NPCAttributeType.Shop)
                {
                    await session.SendAsync(bResult);
                    throw new ArgumentException("Player isn't in buy", nameof(session.Player.Window));
                }

                var item = npc.Shop.Storage.Items[message.Position].Clone() as Item;
                
                bResult.ItemInfo = item.GetBytes();

                session.SendAsync(new SNotice(NoticeType.Blue, $"Item: {item.BasicInfo.Name} Price: {item.BuyPrice}zen")).Wait();

                if (item.BuyPrice > @char.Money)
                {
                    await session.SendAsync(bResult);
                    return;
                }

                bResult.Result = @char.Inventory.Add(item);
                if (bResult.Result == 0xff)
                {
                    await session.SendAsync(bResult);
                    return;
                }

                @char.Money -= item.BuyPrice;

                Logger
                    .ForAccount(session)
                    .Information("Buy {0} for {1}", item.ToString(), item.BuyPrice);

                await session.SendAsync(bResult);
            }
        }

        [MessageHandler(typeof(CSell))]
        public async Task CSell(GSSession session, CSell message)
        {
            var plr = session.Player;
            var result = new SSell { Result = 0, Money = session.Player.Character.Money };

            if (plr.Window == null)
            {
                await session.SendAsync(result);
                throw new ArgumentException("Player isn't in buy/trade/box", nameof(session.Player.Window));
            }

            if (plr.Window.GetType() != typeof(Monster))
            {
                await session.SendAsync(result);
                throw new ArgumentException("Player isn't in buy", nameof(session.Player.Window));
            }

            var npcs = ResourceCache.Instance.GetNPCs();
            var obj = plr.Window as Monster;
            if (npcs.TryGetValue(obj.Info.Monster, out var npc))
            {
                if (npc.Class == NPCAttributeType.Shop)
                {
                    result.Result = 1;
                    var inve = plr.Character.Inventory;
                    var item = inve.Get(message.Position);

                    if(
                        item.ExcellentCount > 0 || 
                        item.Plus > 7 || 
                        item.Number.Number == 6159 || //Chaos
                        (item.Number >= 6174 && item.Number <= 6175) || //Compressed
                        (item.Number >= 6204 && item.Number <= 6209) || //Seed()
                        (item.Number >= 6288 && item.Number <= 6345) || item.WingType != 0
                        )
                    {
                        using (var db = new GameContext())
                        {
                            db.Sell.Add(new SellDto
                            {
                                CharacterId = plr.Character.Id,
                                Count = 1,
                                Date = DateTime.Now.AddDays(1),
                                Item = item.GetBytes(),
                                Price = (int)(item.SellPrice*1.1f)
                            });
                            db.SaveChanges();
                        }
                    }

                    plr.Character.Money += item.SellPrice;
                    result.Money = session.Player.Character.Money;
                    await inve.Delete(item, false);
                    await session.SendAsync(new SNotice(NoticeType.Blue, $"Item: {item.BasicInfo.Name} Price: {item.SellPrice}zen"));
                }
            }
            await session.SendAsync(result);
        }

        [MessageHandler(typeof(CWarp))]
        public async Task CWarp(GSSession session, CWarp message)
        {
            if (session.Player.Character.Duel != null)
                return;

            var gates = ResourceCache.Instance.GetGates();

            var gate = (from g in gates
                        where /*g.Value.GateType != GateType.Exit &&*/ g.Value.Move == message.MoveNumber
                        select g.Value).FirstOrDefault();

            var log = Logger.ForAccount(session);

            if (gate == null)
            {
                log.Error("Invalid Gate {0}", message.MoveNumber);

                await session.SendAsync(new SNotice(NoticeType.Blue, "You can't go there"));
                return;
            }

            log.Information("Warp request to {0}", gate.Name);
            var @char = session.Player.Character;

            if (gate.ReqLevel > @char.Level)
            {
                await session.SendAsync(new SNotice(NoticeType.Blue, ServerMessages.GetMessage(Messages.Game_Warp, gate.ReqLevel)));
                return;
            }

            var moneyRequ = gate.ReqZen * ((@char.PKLevel < PKLevel.Warning) ? 1u : 50u);

            if (moneyRequ > @char.Money)
            {
                await session.SendAsync(new SNotice(NoticeType.Blue, ServerMessages.GetMessage(Messages.Game_Warp, gate.ReqZen)));
                return;
            }

            @char.Money -= moneyRequ;
            await @char.WarpTo(gate.Number);
        }

        [MessageHandler(typeof(CJewelMix))]
        public void CJewelMix(GSSession session, CJewelMix message)
        {
            var @char = session.Player.Character;
            var result = @char.Inventory.FindAll(new ItemNumber(14, (ushort)(13 + message.JewelType)));
            var neededJewels = new int[][] {
                new int[] { 10,  500000 },
                new int[] { 20, 1000000 },
                new int[] { 30, 1500000 } };

            if (message.JewelMix > 2)
            {
                Logger.ForAccount(session)
                    .Error("JewelMix out of bounds: {0}", message.JewelMix);
                session.SendAsync(new SJewelMix(0)).Wait();
                return;
            }

            if (result.Count() < neededJewels[message.JewelMix][0])
            {
                Logger.ForAccount(session)
                    .Error("JewelMix Insuficient Jewel count: {0} < {1}", result.Count(), neededJewels[message.JewelMix][0]);
                session.SendAsync(new SJewelMix(0)).Wait();
                return;
            }

            if (@char.Money < neededJewels[message.JewelMix][1])
            {
                Logger.ForAccount(session)
                    .Error("JewelMix Insuficient Money: {0} < {1}", @char.Money, neededJewels[message.JewelMix][1]);
                session.SendAsync(new SJewelMix(8)).Wait();
                return;
            }

            foreach (var i in result.Take(neededJewels[message.JewelMix][0]))
            {
                @char.Inventory.Delete(i).Wait();
            }

            @char.Inventory.Add(new Item(new ItemNumber(12, (ushort)(30 + message.JewelType)), new { Plus = message.JewelMix }));
            @char.Inventory.SendInventory();
            session.SendAsync(new SJewelMix(1)).Wait();
        }

        [MessageHandler(typeof(CJewelUnMix))]
        public void CJewelUnMix(GSSession session, CJewelUnMix message)
        {
            var @char = session.Player.Character;
            var target = @char.Inventory.Get(message.JewelPos);
            var neededJewels = new int[][] {
                new int[] { 10,  500000 },
                new int[] { 20, 1000000 },
                new int[] { 30, 1500000 } };

            if (target == null)
            {
                Logger.ForAccount(session)
                    .Error("Item not found: {0}", message.JewelPos);
                session.SendAsync(new SJewelMix(4)).Wait();
                return;
            }

            if (target.Plus != message.JewelLevel)
            {
                Logger.ForAccount(session)
                    .Error("Item level no match: {0} != {1}", message.JewelLevel, target.Plus);
                session.SendAsync(new SJewelMix(3)).Wait();
                return;
            }

            if (@char.Money < 1000000)
            {
                Logger.ForAccount(session)
                    .Error("Insuficient money: {0} < 1000000", @char.Money);
                session.SendAsync(new SJewelMix(8)).Wait();
                return;
            }

            for (var i = 0; i < neededJewels[message.JewelLevel][0]; i++)
            {
                @char.Inventory.Add(new Item(new ItemNumber(14, (ushort)(13 + message.JewelType)), 0));
            }

            @char.Inventory.Delete(message.JewelPos).Wait();
            @char.Inventory.SendInventory();
            session.SendAsync(new SJewelMix(7)).Wait();
        }

        [MessageHandler(typeof(CChaosBoxItemMixButtonClick))]
        public async Task CChaosBoxItemMixButtonClick(GSSession session, CChaosBoxItemMixButtonClick message)
        {
            var @char = session.Player.Character;
            var cbMix = @char.Inventory.ChaosBox;

            var mixInfo = ResourceCache.Instance.GetChaosMixInfo();
            var mixMatched = mixInfo.FindMix(@char);

            Logger.Debug("Client aditional info {0},{1}", message.Type, message.Info);

            if (mixMatched == null)
            {
                Logger.ForAccount(session)
                    .Error("Invalid MIX");

                await session.SendAsync(new SChaosBoxItemMixButtonClick { Result = ChaosBoxMixResult.IncorrectItems, ItemInfo = Array.Empty<byte>() });
                return;
            }

            Logger.ForAccount(session)
                .Information("Mix found, match: {0}", mixMatched.Name);

            if (!@char.Inventory.TryAdd())
            {
                await session.SendAsync(new SNotice(NoticeType.Blue, ServerMessages.GetMessage(Messages.Game_ChaosBoxMixError)));
                await session.SendAsync(new SChaosBoxItemMixButtonClick { Result = ChaosBoxMixResult.TooManyItems, ItemInfo = Array.Empty<byte>() });
                return;
            }

            var result = mixMatched.Execute(@char, message);

            if (result != ChaosBoxMixResult.Success)
            {
                await session.SendAsync(VersionSelector.CreateMessage<SShopItemList>((byte)3, cbMix.GetInventory()));
            }

            await session.SendAsync(new SChaosBoxItemMixButtonClick { Result = result, ItemInfo = cbMix.Items.Values.FirstOrDefault()?.GetBytes() ?? Array.Empty<byte>() });
            Logger.ForAccount(session)
                .Information("Mix Result: {0} : {1}", mixMatched.Name, result);
        }

        [MessageHandler(typeof(CChaosBoxUseEnd))]
        public void CChaosBoxUseEnd(GSSession session)
        {
            session.Player.Character.Inventory.Lock = false;
        }

        [MessageHandler(typeof(CWarehouseUseEnd))]
        public void CWarehouseUseEnd(GSSession session)
        {
            session.Player.Character.Inventory.Lock = false;
        }

        [MessageHandler(typeof(CWarehouseMoney))]
        public async Task CWarehouseMoney(GSSession session, CWarehouseMoney message)
        {
            var r = false;
            if (message.Type == 0x00)
            {
                if (session.Player.Character.Money >= message.Money)
                {
                    session.Player.Account.VaultMoney += (int)message.Money;
                    session.Player.Character.Money -= message.Money;
                    r = true;
                }
            }
            else
            {
                if (session.Player.Account.VaultMoney >= message.Money)
                {
                    session.Player.Account.VaultMoney -= (int)message.Money;
                    session.Player.Character.Money += message.Money;
                    r = true;
                }
            }
            await session.SendAsync(new SWarehouseMoney(r, session.Player.Account.VaultMoney, session.Player.Character.Money));
        }

        [MessageHandler(typeof(CItemModify))]
        public async Task CItemModify(GSSession session, CItemModify message)
        {
            if (message.Position == 0xff)
            {
                session.Player.Character.Inventory
                    .MainInventory()
                    .ForEach(x => CItemModify(session, new CItemModify { Position = (byte)x.SlotId }));
                return;
            }

            var it = session.Player.Character.Inventory.Get(message.Position);
            var res = new SItemModify
            {
                Money = 0,
            };

            var cost = it.RepairPrice;

            if (cost <= 0 || cost > session.Player.Character.Money)
            {
                session.SendAsync(res).Wait();
                return;
            }

            await session.SendAsync(new SNotice(NoticeType.Blue, $"Item:{it.BasicInfo.Name} Repair:{it.RepairPrice}zen"));

            it.Durability = it.DurabilityBase;
            session.Player.Character.Money -= (uint)cost;
            res.Money = (int)session.Player.Character.Money;
            await session.SendAsync(res);
        }

        [MessageHandler(typeof(CTeleportS9))]
        public async Task CTeleportS9(GSSession session, CTeleportS9 message)
        {
            await CTeleport(session, new CTeleport { MoveNumber = message.MoveNumber, X = message.X, Y = message.Y });
        }

        [MessageHandler(typeof(CTeleport))]
        public async Task CTeleport(GSSession session, CTeleport message)
        {
            var log = Logger.ForAccount(session);
            var @char = session.Player.Character;

            var gates = ResourceCache.Instance.GetGates();

            if (message.MoveNumber != 0)
            {
                int target = message.MoveNumber;
                Gate gate = null;

                if (!gates.TryGetValue(target, out gate))
                {
                    log.Error("Invalid source gate {0}", message.MoveNumber);
                    await @char.WarpTo(@char.MapID, @char.Position, @char.Direction);
                    return;
                }

                if (gate.GateType == GateType.Entrance)
                {
                    target = gate.Target;
                    gate = null;
                    gates.TryGetValue(target, out gate);
                }

                if (gate == null)
                {
                    log.Error("Invalid source gate {0}", message.MoveNumber);
                    await @char.WarpTo(@char.MapID, @char.Position, @char.Direction);
                    return;
                }

                var ev = Program.EventManager.GetEvent<ImperialGuardian>();
                if (gate.Map == ev.Map)
                {
                    await ev.UsePortal(@char, (ushort)target);
                }
                else
                {
                    log.Information("Warp request to {1}:{0}", target, gate.Map);
                    await @char.WarpTo(target);
                }
            }
            else
            {
                var spell = ResourceCache.Instance.GetSkills()[Spell.Teleport];

                if (spell.Mana < @char.Mana && spell.BP < @char.Stamina)
                {
                    var msg = VersionSelector.CreateMessage<SMagicAttack>(Spell.Teleport, (ushort)session.ID, (ushort)session.ID);

                    await session.SendAsync(msg);
                    @char.SendV2Message(msg);

                    @char.Mana -= spell.Mana;
                    @char.Stamina -= spell.BP;

                    @char.PlayersVP.Clear();
                    @char.MonstersVP.Clear();
                    @char.ItemsVP.Clear();
                    @char.TeleportTo(new Point(message.X, message.Y));
                }


                //await @char.WarpTo(@char.MapID, @char.Position, @char.Direction);
                //@char.TeleportTo(@char.Position);
            }
        }

        #region Duel MessageHandlers
        [MessageHandler(typeof(CDuelRequest))]
        public void CDuelRequest(GSSession session, CDuelRequest message)
        {
            var targetId = message.wzNumber.ShufleEnding();
            var target = Program.server.Clients.FirstOrDefault(x => x.ID == targetId);

            if (session.Player.Character.Duel != null)
            {
                session.SendAsync(new SDuelAnsDuelInvite(DuelResults.AlreadyDuelling, 0, "")).Wait();
                return;
            }
            if (target.Player.Character.Duel != null)
            {
                session.SendAsync(new SDuelAnsDuelInvite(DuelResults.AlreadyDuelling1, 0, "")).Wait();
                return;
            }

            if (!DuelSystem.CreateDuel(session.Player, target.Player))
            {
                session.SendAsync(new SDuelAnsDuelInvite(DuelResults.DuelMax, 0, "")).Wait();
                return;
            }
            target.SendAsync(new SDuelAnswerReq((ushort)session.ID, session.Player.Character.Name)).Wait();
            //session.SendAsync(new SDuelAnsDuelInvite(DuelResults.NoError, 0, "")).Wait();
        }

        [MessageHandler(typeof(CDuelAnswer))]
        public void CDuelAnswer(GSSession session, CDuelAnswer message)
        {
            if (message.DuelOK == 0)
            {
                session.SendAsync(new SDuelAnsDuelInvite(DuelResults.RefuseInvitated, (ushort)session.ID, session.Player.Character.Name)).Wait();
                return;
            }

            session.Player.Character.Duel.Join();
        }

        [MessageHandler(typeof(CDuelLeave))]
        public void CDuelLeave(GSSession session)
        {
            try
            {
                session.Player.Character.Duel.Leave(session.Player);
            } catch (Exception)
            {
                session.SendAsync(new SDuelAnsExit(DuelResults.Failed)).Wait();
            }
        }

        [MessageHandler(typeof(CDuelJoinRoom))]
        public void CDuelJoinRoom(GSSession session, CDuelJoinRoom message)
        {
            var msg = new SDuelRoomJoin();
            msg.Results = DuelSystem.TryJoinRoom(session.Player, message.Room);
            session.SendAsync(msg).Wait();
        }

        [MessageHandler(typeof(CDuelLeaveRoom))]
        public void CDuelLeaveRoom(GSSession session, CDuelLeaveRoom message)
        {
            var msg = new SDuelRoomLeave();
            msg.Results = DuelSystem.LeaveRoom(session.Player, message.Room);
            session.SendAsync(msg).Wait();
        }
        #endregion

        #region MasterSystem
        [MessageHandler(typeof(CMasterSkill))]
        public async Task CMasterSkill(GSSession session, CMasterSkill message)
        {
            var si = ResourceCache.Instance.GetSkills()[message.MasterSkill];
            var @char = session.Player.Character;

            var canUse = si.Classes.Where(x => (x&(HeroClass)(0xF0)) == @char.BaseClass && x <= @char.Class).Any();
            if(!canUse)
            {
                return;
            }

            var skill = MasterLevel.MasterSkillTree
                .Trees
                .Where(x => x.ID == session.Player.Character.Class)
                .SelectMany(y => y.Skill)
                .Where(x => (Spell)x.MagicNumber == message.MasterSkill)
                .FirstOrDefault();

            if(skill.ReqMinPoint > @char.MasterLevel.Points)
            {
                return;
            }

            @char.MasterLevel.Points = (ushort)(@char.MasterLevel.Points-skill.ReqMinPoint);

            var baseSpell = @char
                .Spells
                .SpellList
                .Where(x => x.Number == (Spell)skill.ParentSkill1)
                .FirstOrDefault();

            var spell = @char.Spells.SpellList.Where(x => x.Number == message.MasterSkill).FirstOrDefault();

            if(skill.ParentSkill1 != 0)
            {
                if (baseSpell == null) {
                    Logger.Error("Don't have previus condition to use skill");
                    return;
                }

                //@char.Spells.Remove(baseSpell);
                @char.Spells.SendList();
            }

            if (spell == null)
            {
                if(!await @char.Spells.TryAdd(message.MasterSkill))
                {
                    throw new Exception("Invalid master skill");
                }

                spell = @char.Spells.SpellList.Where(x => x.Number == message.MasterSkill).First();
            }
            else
            {
                spell.Level++;
                @char.Spells.SetEffect(spell);
            }

            var curLevel = spell?.Level ?? 1;

            await session.SendAsync(new SMasterLevelSkillS9ENG
            {
                Result = 1,
                MasterLevelPoint = @char.MasterLevel.Points,
                MasterSkillUIIndex = (byte)skill.Index,
                dwMasterSkillIndex = (int)message.MasterSkill,
                dwMasterSkillLevel = curLevel,
                fMasterSkillCurValue = spell.MLSValue,
                fMasterSkillNextValue = skill.GetValue((short)(curLevel + 1)),
            });

            session.Player.Character.CalcStats();
        }

        #endregion

        [MessageHandler(typeof(CInventory))]
        public async Task CInventory(GSSession session)
        {
            session.Player.Character.Inventory.SendInventory();
            session.Player.Character.Inventory.SendJewelsInfo();
        }

        [MessageHandler(typeof(CTradeRequest))]
        public async Task CTradeRequest(GSSession session, CTradeRequest message)
        {
            var target = Program.server.Clients.FirstOrDefault(x=> x.ID == message.Number);
            var log = Logger.ForAccount(session);

            if (target == null || 
                target.ID == session.ID || 
                session.Player.Status != LoginStatus.Playing ||
                target.Player.Status != LoginStatus.Playing || 
                target.Player.Character.Shop.Open ||
                session.Player.Character.Shop.Open ||
                session.Player.Character.Map.IsEvent ||
                target.Player.Window != null ||
                session.Player.Window != null )
                return;

            await target.SendAsync(new STradeRequest { Id = session.Player.Character.Name });
            session.Player.Window = target;
            target.Player.Window = session;
        }

        [MessageHandler(typeof(CTradeResponce))]
        public async Task CTradeResponce(GSSession session, CTradeResponce message)
        {
            var tgt = session.Player.Window as GSSession;

            if (message.Result == 0)
            {
                session.Player.Window = null;
                tgt.Player.Window = null;
            }else
            {
                session.Player.Character.Inventory.TradeOpen = true;
                tgt.Player.Character.Inventory.TradeOpen = true;
            }

            await session.SendAsync(new STradeResponce { Result = message.Result, szId = tgt.Player.Character.Name.GetBytes(), Level = tgt.Player.Character.Level });
            await tgt.SendAsync(new STradeResponce { Result = message.Result, szId = session.Player.Character.Name.GetBytes(), Level = session.Player.Character.Level });
        }

        [MessageHandler(typeof(CTradeMoney))]
        public async Task CTradeMoney(GSSession session, CTradeMoney message)
        {
            var session2 = (session.Player.Window as GSSession);
            Logger.ForAccount(session).Information("[TRADE] Money set:{0}", message.Money);
            var @char = session.Player.Character;
            var @char2 = session2.Player.Character;
            if (message.Money > @char.Money)
            {
                return;
            }

            var modmoney = message.Money - @char.Inventory.TradeBox.Money;

            @char.Money -= modmoney;
            @char.Inventory.TradeBox.Money += modmoney;
            @char2.Inventory.TradeOk = false;
            await session.SendAsync(new STradeMoney { Result = 1 });
            await session2.SendAsync(new STradeOtherMoney { Money = message.Money });
            await session.SendAsync(new CTradeButtonOk { Flag = 0 });
            await session2.SendAsync(new CTradeButtonOk { Flag = 0 });
        }

        [MessageHandler(typeof(CTradeButtonOk))]
        public async Task CTradeButtonOk(GSSession session, CTradeButtonOk message)
        {
            var session2 = session.Player.Window as GSSession;
            var char1 = session.Player.Character;
            var char2 = session2.Player.Character;
            char1.Inventory.TradeOk = message.Flag == 1;
            await session2.SendAsync(message);

            if (!char1.Inventory.TradeOk || !char2.Inventory.TradeOk)
                return;

            char1.Inventory.TradeOk = false;
            char2.Inventory.TradeOk = false;

            var result = char1.Inventory.TryAdd(char2.Inventory.TradeBox.Items.Values);
            result &= char2.Inventory.TryAdd(char1.Inventory.TradeBox.Items.Values);

            char1.Player.Window = null;
            char2.Player.Window = null;

            if (!result)
            {
                var notice = new SNotice(NoticeType.Blue, ServerMessages.GetMessage(Messages.Game_ChaosBoxMixError));
                await session.SendAsync(notice);
                await session2.SendAsync(notice);

                if (char1.Inventory.TradeBox.Items.Count != 0)
                    char1.Inventory.TradeRollBack();

                if (char2.Inventory.TradeBox.Items.Count != 0)
                    char2.Inventory.TradeRollBack();

                char1.Inventory.SendInventory();
                char2.Inventory.SendInventory();

                var msg = new STradeResult { Result = TradeResult.InventoryFull };
                await session.SendAsync(msg);
                await session2.SendAsync(msg);
                return;
            }

            char1.Inventory.TradeOpen = false;
            char2.Inventory.TradeOpen = false;

            foreach (var it in char2.Inventory.TradeBox.Items.Values)
            {
                char1.Inventory.Add(it);
                if (it.IsPentagramItem || it.IsPentagramJewel)
                    char2.Inventory.TransferPentagram(it, char1.Inventory);
            }

            foreach (var it in char1.Inventory.TradeBox.Items.Values)
            {
                char2.Inventory.Add(it);
                if (it.IsPentagramItem || it.IsPentagramJewel)
                    char1.Inventory.TransferPentagram(it, char2.Inventory);
            }

            char1.Money += char2.Inventory.TradeBox.Money;
            char2.Money += char1.Inventory.TradeBox.Money;
            char1.Inventory.TradeBox.Clear();
            char2.Inventory.TradeBox.Clear();
            char1.Inventory.SendInventory();
            char2.Inventory.SendInventory();

            var msg2 = new STradeResult { Result = TradeResult.Ok };
            await session.SendAsync(msg2);
            await session2.SendAsync(msg2);
        }

        [MessageHandler(typeof(CTradeButtonCancel))]
        public async Task CTradeButtonCancel(GSSession session)
        {
            var session2 = session.Player.Window as GSSession;
            var char1 = session.Player.Character;
            var char2 = session2.Player.Character;

            session.Player.Window = null;
            session2.Player.Window = null;

            char1.Inventory.TradeOk = false;
            char2.Inventory.TradeOk = false;

            if (char1.Inventory.TradeBox.Items.Count != 0)
                char1.Inventory.TradeRollBack();

            if (char2.Inventory.TradeBox.Items.Count != 0)
                char2.Inventory.TradeRollBack();

            char1.Inventory.SendInventory();
            char2.Inventory.SendInventory();

            var msg = new STradeResult { Result = TradeResult.Error };
            await session.SendAsync(msg);
            await session2.SendAsync(msg);
        }

        [MessageHandler(typeof(CFriendAdd))]
        public void CFriendAdd(GSSession session, CFriendAdd message)
        {
            session.Player.Character.Friends
                .AddFriend(message.Name);
        }

        [MessageHandler(typeof(CWaitFriendAddReq))]
        public void CWaitFriendAddReq(GSSession session, CWaitFriendAddReq message)
        {
            session.Player.Character.Friends
                .AcceptFriend(message.Name, message.Result);
        }

        [MessageHandler(typeof(CUsePopUpType))]
        public async Task CUsePopUpType(GSSession session)
        {
            Logger.Information("Req PopUp Type");
            await session.SendAsync(new SUBFPopUpType { Type = 0 });
        }

        [MessageHandler(typeof(CMemberPosInfoStart))]
        public void CMemberPosInfoStart(GSSession session)
        {
            session.Player.Character.Map.SendMinimapInfo(session.Player.Character);
        }

        [MessageHandler(typeof(CMemberPosInfoStop))]
        public void CMemberPosInfoStop(GSSession session)
        {
        }

        [MessageHandler(typeof(CNPCJulia))]
        public void CNPCJulia(GSSession session)
        {
            if(session.Player.Character.MapID == Maps.LorenMarket)
            {
                session.Player.Character.WarpTo(17).Wait();
            }else
            {
                session.Player.Character.WarpTo(333).Wait();
            }
        }

        [MessageHandler(typeof(CMUBotData))]
        public void CMUBotData(GSSession session, CMUBotData message)
        {
            var muhelper = session.Player.Character.MuHelper;
            muhelper.Configuration = message;

            Logger.Debug(message.ToString());
            //message.Data[0x01]: 0x08: Jewel/Gem, 0x40: Zen, 0x10: Set Item, 0x20: Excellent Item, 0x80: Add Extra Item
            //message.Data[0x02]: 0x01-0x08: hunting Range, 0x10-0x80: Optaining Range
            //message.Data[0x04-0x05]: Basic Skill
            //message.Data[0x06-0x07]: Activation Skill
            //message.Data[0x08-0x09]: Delay Time
            //message.Data[0x0A-0x0B]: Activation Skill 2
            //message.Data[0x0C-0x0D]: Delay Time 2
            //message.Data[0x10-0x11]: Buff 1
            //message.Data[0x12-0x13]: Buff 2
            //message.Data[0x14-0x15]: Buff 3
            //message.Data[0x17]: 0x01-0x0A: 100% AutoPotion
            //message.Data[0x18]: 0x01-0x0A: 100% DrainLife
            //message.Data[0x19]: 0x08:Long Distance-C, 0x10:Original Position, 0x01:Enable AutoPotion, 0x04: Enable DrainLife, 0x20: Combo Enabled
            //message.Data[0x1A]: 0x08: Delay Enable, 0x10: Con, 0x04: Buff Duration
            //message.Data[0x1B]: 0x01: Delay Enable 2, 0x02: Con 2, 0x20: Repair, 0x80: Pick Selected items, 0x40: Pick all near items
            //message.Data[0x1C]: 0x40:Use Regular Attack Area, 0x20:Use skill closely, 0x04: Auto accept friend, 0x08: AutoAccept Guild, 0x10: Use elite potion
            //message.Data[0x1D-0x40]
            //message.Data[0x41]: Extra Item 1
            //message.Data[0x51]: Extra Item 2
            //message.Data[0x61]: Extra Item 3
            //message.Data[0x71]: Extra Item 4
            //message.Data[0x81]: Extra Item 5
            //message.Data[0x91]: Extra Item 6
            //message.Data[0xA1]: Extra Item 7
            //message.Data[0xB1]: Extra Item 8
            //message.Data[0xC1]: Extra Item 9
            //message.Data[0xD1]: Extra Item 10
            //message.Data[0xF1]: Extra Item 11
            /*using (var fp = File.Open($"mubot_{session.Player.Account.Nickname}_{DateTime.Now.Ticks}.txt", FileMode.OpenOrCreate))
            {
                fp.Write(message.Data, 0, message.Data.Length);
            }*/
        }

        [MessageHandler(typeof(CMuHelperState))]
        public void CMuHelperState(GSSession session, CMuHelperState message)
        {
            session.Player.Character.MuHelper.Enable(message.State == 0);
        }

        [MessageHandler(typeof(CQuestExp))]
        public void CQuestExp(GSSession session)
        {
            var npc = session.Player.Window as Monster;

            var list = session.Player.Character.Quests.EXPListNPC(npc.Info.Monster);
            _ = session.SendAsync(new SQuestSwitchListNPC
            {
                NPC = npc.Info.Monster,
                QuestList = list.Select(x => (uint)x).ToArray()
            });
        }

        [MessageHandler(typeof(CShadowBuff))]
        public void CShadowBuff(GSSession session)
        {
            var @char = session.Player.Character;
            @char.Spells.SetBuff(SkillStates.ShadowPhantom, TimeSpan.FromSeconds(120));
        }

        [MessageHandler(typeof(CGremoryCaseOpen))]
        public async Task CGremoryCaseOpen(GSSession session)
        {
            session.Player.Character.GremoryCase.SendList();
            await session.SendAsync(new SGremoryCaseOpen { Result = 0 });
        }

        [MessageHandler(typeof(CGremoryCaseOpenS16))]
        public async Task CGremoryCaseOpenS16(GSSession session, CGremoryCaseOpenS16 message)
        {
            session.Player.Character.GremoryCase.SendList();
            await session.SendAsync(new SGremoryCaseOpenS16 { Result = 3 });
        }

        [MessageHandler(typeof(CGremoryCaseUseItem))]
        public async Task CGremoryCaseUseItem(GSSession session, CGremoryCaseUseItem message)
        {
            var @char = session.Player.Character;
            Item item = @char.GremoryCase.GetItem(message.Inventory, message.Serial);
            if(item == null)
            {
                await session.SendAsync(new SGremoryCaseUseItem {
                    Result = SGremoryCaseUseItem.GCResult.DatabaseError
                });
                return;
            }
            byte pos = 0xff;
            switch ((item.BasicInfo.Inventory)
)
            {
                case StorageID.EventInventory:
                    pos = @char.Inventory.AddEvent(item);
                    @char.Inventory.SendEventInventory();
                    break;
                case StorageID.MuunInventory:
                    pos = @char.Inventory.AddMuun(item);
                    @char.Inventory.SendMuunInventory();
                    break;
                case StorageID.PersonalShop:
                    break;
                case StorageID.Inventory:
                default:
                    pos = @char.Inventory.Add(item);
                    @char.Inventory.SendInventory();
                    break;
            }
            await session.SendAsync(new SGremoryCaseUseItem
            {
                Result = pos==0xff ? SGremoryCaseUseItem.GCResult.NotEnoughtSpace : SGremoryCaseUseItem.GCResult.Success,
                Inventory = message.Inventory,
                Item = item.Number.Number,
                Serial = (uint)item.Serial,
                Slot = message.Slot,
            });
            var msg = VersionSelector.CreateMessage<SGremoryCaseDelete>();
            msg.Set("StorageType", message.Inventory);
            msg.Set("ItemNumber", (ushort)message.Item);
            msg.Set("ItemGUID", message.Serial);
            msg.Set("Slot", message.Slot);
            await session.SendAsync(msg);
            
            @char.GremoryCase.RemoveItem(message.Serial);
        }

        [MessageHandler(typeof(CAcheronEnterReq))]
        public async Task CAcheronEnterReq(GSSession session)
        {
            var it = session
                .Player
                .Character
                .Inventory
                .FindAllItems(ItemNumber.FromTypeIndex(13, 146))
                .FirstOrDefault();

            if(it== null)
            {
                await session.SendAsync(new SNeedSpiritMap());
                return;
            }

            await session
                .Player
                .Character
                .Inventory
                .Delete(it);

            await session
                .Player
                .Character
                .WarpTo(417);
        }

        [MessageHandler(typeof(CRefineJewelReq))]
        public async Task CRefineJewelReq(GSSession session, CRefineJewelReq message)
        {
            var plr = session.Player;
            var @char = plr.Character;
            var cbMix = @char.Inventory.ChaosBox;
            var mixInfos = ResourceCache.Instance.GetChaosMixInfo();
            var mixMatched = mixInfos.FindMix(@char);

            Logger.ForAccount(session)
                .Information("Mix Type {0}", message.Type);

            if(mixMatched == null)
            {
                Logger.ForAccount(session)
                    .Error("Invalid MIX");
                await session.SendAsync(new SChaosBoxItemMixButtonClick { Result = ChaosBoxMixResult.Fail, ItemInfo = Array.Empty<byte>() });
                return;
            }

            var element = cbMix.Items.Values.First(x => (x.IsPentagramItem || x.IsPentagramJewel) && x.PentagramaMainAttribute != Element.None).PentagramaMainAttribute;
            Logger.ForAccount(session)
                .Information("Mix found, match: {0} {1}", mixMatched.Name, element);

            var result = mixMatched.Execute(@char);

            if (result != ChaosBoxMixResult.Success)
            {
                await session.SendAsync(VersionSelector.CreateMessage<SShopItemList>((byte)3, cbMix.GetInventory()));
            }
            else
            {
                var it = cbMix.Items.Values.First();
                it.PentagramaMainAttribute = element;
                it.BonusSocket |= 0x10;

                switch (message.Type)
                {
                    case 3:
                        it.Slots = new SocketOption[1] { SocketOption.SocketWater };
                        break;
                }
            }

            switch (result)
            {
                case ChaosBoxMixResult.Fail:
                    result = ChaosBoxMixResult.PentagramaRefineFail;
                    break;
                case ChaosBoxMixResult.InsufficientMoney:
                    result = ChaosBoxMixResult.PentagramaInsufficientMoney;
                    break;
                case ChaosBoxMixResult.LackingItems:
                    result = ChaosBoxMixResult.PentagramaLackingItems;
                    break;
            }

            Logger.ForAccount(session)
                .Information("Mix Result: {0} : {1}", mixMatched.Name, result);
            await session.SendAsync(new SChaosBoxItemMixButtonClick { Result = result, ItemInfo = cbMix.Items.Values.FirstOrDefault()?.GetBytes() ?? Array.Empty<byte>() });
        }
    
        [MessageHandler(typeof(CPentagramaJewelIn))]
        public async Task CPentagramaJewelIn(GSSession session, CPentagramaJewelIn message)
        {
            var plr = session.Player;
            var @char = plr.Character;
            var inv = @char.Inventory;

            var pItem = inv.Get((byte)message.PentagramPos);
            var pJewel = inv.Get((byte)message.JewelPos);
            var jAtt = pJewel.PentagramaMainAttribute;
            var iAtt = pItem.PentagramaMainAttribute;

            if (!pItem.IsPentagramItem || !pJewel.IsPentagramJewel || jAtt != iAtt)
            {
                await session.SendAsync(new SPentagramJewelIn { Result = 0 });
                return;
            }

            var slot = (pJewel.Number.Index - 221) / 10;

            if (pItem.Slots.Length <= slot || pItem.Slots[slot] != SocketOption.EmptySocket)
                return;

            pItem.Slots[slot] = (SocketOption)session.Player.Character.Inventory.AddPentagramJewel(pItem, pJewel, slot);

            var msg = new SPentagramJewelIn
            {
                Result = 1,
                Info = new PentagramJewelDto
                {
                    MainAttribute = pJewel.BonusSocket,
                    ItemIndex = pJewel.Number.Index,
                    ItemType = (byte)pJewel.Number.Type,
                    JewelIndex = 0,
                    JewelPos = 0,
                    Level = pJewel.Plus,
                    Rank1Level = 0xf,
                    Rank1OptionNum = 0xf,
                    Rank2Level = 0xf,
                    Rank2OptionNum = 0xf,
                    Rank3Level = 0xf,
                    Rank3OptionNum = 0xf,
                    Rank4Level = 0xf,
                    Rank4OptionNum = 0xf,
                    Rank5Level = 0xf,
                    Rank5OptionNum = 0xf,
                }
            };

            var n = 1;
            foreach(var a in pJewel.Slots)
            {
                msg.Info.Set($"Rank{n}OptionNum", (byte)((byte)a & 0x0F));
                msg.Info.Set($"Rank{n}Level", (byte)(((byte)a & 0xF0)>>4));
            }
            await session.SendAsync(msg);
            pItem.OnItemChange();

            await session.SendAsync(new SPentagramJewelInOut
            {
                Result = 1,
            });
        }

        [MessageHandler(typeof(CPetInfo))]
        public async Task CPetInfo(GSSession session, CPetInfo message)
        {
            Item item;

            switch(message.InvenType)
            {
                case 0:// Inventory
                    item = session.Player.Character.Inventory.Get(message.nPos);
                    break;
                case 1:// Warehouse
                    item = session.Player.Account.Vault.Get(message.nPos);
                    break;
                case 2:// Trade
                    item = session.Player.Character.Inventory.TradeBox.Get(message.nPos);
                    break;
                case 3:// Target Trade
                    item = (session.Player.Window as GSSession).Player.Character.Inventory.TradeBox.Get(message.nPos);
                    break;
                case 4:// Chaos
                    item = session.Player.Character.Inventory.ChaosBox.Get(message.nPos);
                    break;
                case 5:// Personal Shop
                    item = session.Player.Character.Inventory.PersonalShop.Get(message.nPos);
                    break;
                default:
                    return;
            }

            if (item.PetLevel == 0)
                item.PetLevel = 1;

            var responce = new SPetInfo
            {
                InvenType = message.InvenType,
                nPos = message.nPos,
                PetType = message.PetType,
                Dur = item.Durability,
                Exp = (int)item.PetEXP,
                Level = item.PetLevel,
            };

            await session.SendAsync(responce);
        }

        [MessageHandler(typeof(CPetCommand))]
        public async Task CPetCommand(GSSession session, CPetCommand message)
        {
            if (session.Player?.Character != null)
            {
                session.Player.Character.PetTarget = message.Number;
                session.Player.Character.PetMode = message.Command;
            }

            Logger.ForAccount(session).Information("Pet mode changed to {0}", message.Command);
            await session.SendAsync(message);
        }

        [MessageHandler(typeof(CInventoryEquipament))]
        public void CInventoryEquipament(GSSession session, CInventoryEquipament message)
        {
            var item = session.Player.Character.Inventory.Get(message.ItemPos);
            if(item.IsMount)
            {
                message.Type = session.Player.Character.ApplyMount(item, message.Type);
            }
            else
            {
                return;
            }

            var itemBytes = item.GetBytes();
            itemBytes[1] = (byte)(message.ItemPos << 4);
            itemBytes[1] |= item.SmallPlus;

            _ = session.SendAsync(message);
            _ = session.SendAsync(new SEquipamentChange
            {
                Element = session.Player.Character.Inventory.Get(Equipament.Pentagrama)?.PentagramaMainAttribute??Element.None,
                ItemInfo = itemBytes,
                wzNumber = ((ushort)session.ID).ShufleEnding()
            });
        }
        [MessageHandler(typeof(CSXInfo))]
        public async Task CSXInfo(GSSession session)
        {
            var @char = session.Player.Character;
            var inv = @char.Inventory;
            await session.SendAsync(new SXElementalData
            {
                AbsorbHP = inv.PentagramAbsorbHP,
                AbsorbShield = inv.PentagramAbsorbShield,
                AddAttackDamage = inv.PentagramAddAttackDamage,
                AddDefense = inv.PentagramAddDefense,
                PVMAbsorbDamage = inv.PentagramAbsorbDamagePVM,
                PVMAttackSuccessRate = inv.PentagramAttackSuccessRatePVM,
                PVPAbsorbDamage = inv.PentagramAbsorbDamagePVP,
                PVPAttackSuccessRate = inv.PentagramAttackSuccessRatePVP,
                Bind = inv.PentagramBind,
                BleedingDamage = inv.PentagramBleedingDamage,
                Blind = inv.PentagramBlind,
                CriticalDamageRate = inv.PentagramCriticalDamageRate,
                Paralyzing = inv.PentagramParalyzing,
                Punish = inv.PentagramPunish,
                PVMDamageMax = inv.PentagramDamageMaxPVM,
                PVMDamageMin = inv.PentagramDamageMinPVM,
                PVMDefense = inv.PentagramDefensePVM,
                PVMDefenseSuccessRate = inv.PentagramDefenseSuccessRatePVM,
                PVMIncreaseDamage = inv.PentagramIncreaseDamagePVM,
                PVPDamageMax = inv.PentagramDamageMaxPVP,
                PVPDamageMin = inv.PentagramDamageMinPVP,
                PVPDefense = inv.PentagramDefensePVM,
                PVPDefenseSuccessRate = inv.PentagramDefenseSuccessRatePVM,
                PVPIncreaseDamage = inv.PentagramIncreaseDamagePVM,
            });
            await session.SendAsync(new SXCharacterInfo
            {
                CriticalDamageRate = inv.CriticalRate,
                ExcellentDamageRate = inv.ExcellentRate,
                Defense = @char.Defense,
                Dex = @char.Agility,
                Vit = @char.Vitality,
                AddDex = @char.AgilityAdd,
                AddStr = @char.StrengthAdd,
                AddVit = @char.VitalityAdd,
                AddEnergy = @char.EnergyAdd,
                AddLeadership = @char.CommandAdd,
                Energy = @char.Energy,
                Leadership = @char.Command,
                Str = @char.Strength,
                fMonsterDieGetHP_info = inv.IncreaseLifeRate,
                fMonsterDieGetMana_info = inv.IncreaseManaRate,
                fWingDamageAbsorb_info = inv.WingDmgAbsorb,
                fWingDamageIncRate_info = inv.WingDmgIncrease,
                DamageReflect = (byte)(inv.Reflect*100.0f),
                SDRecovery = @char.Spells.IncreaseAutoSDRegeneration + inv.IncreaseSDRecovery,
                MoneyAmountDropRate = (ushort)(inv.DropZen*100.0f),
                CriticalDamage = @char.CriticalDamage,
                ExcellentDamage = @char.ExcellentDamage,
                fTripleDamageRationInfo = 0,
                AbsorbLife = 0,
                AbsorbSD = 0,
                SDAttack = 0,
                SDAttack1 = 0,
                BlockRate = 0,
                BPConsumptionRate = 0,
                BPRecovery = 0,
                DamageReduction = 0,
                DefensiveFullHPRestoreRate = 0,
                DefensiveFullMPRestoreRate = 0,
                DoubleDamageRate = 0,
                fMonsterDieGetSD_info = 0,
                FullDamageReflectRate = 0,
                HPRecovery = 0,
                IgnoreDefenseRate = 0,
                IgnoreShieldGaugeRate = 0,
                MPConsumptionRate = 0,
                MPRecovery = 0,
                OffensiveFullSDRestoreRate = 0,
                ParryRate = 0,
                ResistStunRate = 0,
                ShieldDamageReduction = 0,
                SkillDamageBonus = 0,
                StunRate = 0,
                AGUsageRate = 0,
                TripleDamageRate = 0,
                unk3a = 1,
                unk37 = 2,
                unk38 = 3,
                unk39 = 4,
            });
        }

        [MessageHandler(typeof(CFavoritesList))]
        public async Task CFavoritesList(GSSession session, CFavoritesList message)
        {
            using (var db = new GameContext())
            {
                var tmp = new int[5] { -1, -1, -1, -1, -1 };
                message.Region.CopyTo(tmp, 0);
                var fav = db.Favorites.FirstOrDefault(x => x.CharacterId == session.Player.Character.Id);
                bool newRow = false;
                if (fav == null)
                {
                    fav = new FavoritesDto
                    {
                        CharacterId = session.Player.Character.Id,
                    };
                    newRow = true;
                }

                fav.Fav01 = tmp[0];
                fav.Fav02 = tmp[1];
                fav.Fav03 = tmp[2];
                fav.Fav04 = tmp[3];
                fav.Fav05 = tmp[4];

                if (newRow)
                    db.Favorites.Add(fav);
                else
                    db.Favorites.Update(fav);

                await db.SaveChangesAsync();
            }
        }

        [MessageHandler(typeof(COpenBox))]
        public async Task COpenBox(GSSession session, COpenBox message)
        {
            Item it = null;
            var result = new SOpenBox { Result = OBResult.UnableToUse };
            switch(message.type)
            {
                case 0x00:
                    it = session.Player.Character.Inventory.Get(message.Slot);
                    result.Result = OBResult.OKInvent;
                    break;
                case 0x15:
                    it = session.Player.Character.Inventory.GetEvent(message.Slot);
                    result.Result = OBResult.OKEvent;
                    break;
                default:
                    break;
            }

            if(it==null)
            {
                result.Result = OBResult.UnableToUse;
                goto SendResult;
            }

            if(!session.Player.Character.Inventory.TryAdd(new Size(4, 4)))
            {
                result.Result = OBResult.FullInventory;
                goto SendResult;
            }

            var plr = session.Player;
            var bag = ExecuteBag(plr, it);
            if (bag != null)
            {
                var reward = bag.First();
                switch(message.type)
                {
                    case 0x00:
                        await plr.Character.Inventory.Delete(it);
                        break;
                    case 0x15:
                        plr.Character.Inventory.DeleteEvent(message.Slot);
                        plr.Character.Inventory.SendEventInventory();
                        break;
                }
                result.Result = OBResult.OKInvent;
                result.Slot = reward.Number.Number;

                if (!reward.IsZen)
                {
                    if(
                        (reward.Number >= 6868 && reward.Number <= 7005) || 
                        (reward.Number >= 7065 && reward.Number <= 7120) ||
                        (reward.Number >= 7136 && reward.Number <= 7159) ||
                        (reward.Number >= 8192 && reward.Number <= 8695)
                        )
                    {
                        plr.Character.Inventory.AddMuun(reward);
                        plr.Character.Inventory.SendMuunInventory();
                    }
                    else
                    {
                        plr.Character.Inventory.Add(reward);
                    }
                }
                else
                    plr.Character.Money += reward.BuyPrice;

                plr.Character.Inventory.SendInventory();

                var msg = new SCommand(ServerCommandType.Fireworks, (byte)plr.Character.Position.X, (byte)plr.Character.Position.X);
                await plr.Session.SendAsync(msg);
                plr.SendV2Message(msg);
            }else
            {
                result.Result = OBResult.UnableToUse;
            }

        SendResult:
            await session.SendAsync(result);
        }

        [MessageHandler(typeof(CItemSplit))]
        public async Task CItemSplit(GSSession session, CItemSplit message)
        {
            var msg = new SItemSplit();
            Item it = null;

            switch(message.Type)
            {
                case 0:
                    it = session.Player.Character.Inventory.Get(message.Slot);
                    break;
                case 1:
                    it = session.Player.Character.Inventory.GetEvent(message.Slot);
                    break;
                default:
                    await session.SendAsync(msg);
                    return;
            }

            if(it == null || it.Durability <= message.Amount)
            {
                await session.SendAsync(msg);
                return;
            }

            if(!session.Player.Character.Inventory.TryAdd(it.BasicInfo.Size))
            {
                msg.Result = 6;
                await session.SendAsync(msg);
                return;
            }

            it.Durability -= message.Amount;
            session.Player.Character.Inventory.Add(new Item(it.Number, new { Durability = message.Amount, it.Plus }));
            session.Player.Character.Inventory.SendInventory();
        }

        [MessageHandler(typeof(CHuntingRecordRequest))]
        public async Task CHuntingRecordRequest(GSSession session, CHuntingRecordRequest message)
        {
            var target = Program.server.Clients.First(x => x.ID == message.index);
            var hrDay = new SHuntingRecordDay();
            var tHR = target.Player.Character.HuntingRecord;

            var list = tHR.GetRecordList((Maps)message.Map);
            var today = list.SingleOrDefault(x => x.Value.DateTime.Date == DateTime.Now.Date);

            if (tHR.Hunting.Map == message.Map)
            {
                var tod = tHR.Hunting;
                hrDay.Id = (byte)today.Key;
                hrDay.Duration = tod.Duration;
                hrDay.KilledCount = tod.KilledMonsters;
                hrDay.Damage = tod.AttackPVM;
                hrDay.ElementalDamage = tod.ElementalAttackPVM;
                hrDay.Experience = tod.Experience.ShufleEnding();
                hrDay.Level = tod.Level;
                hrDay.SetDT(tod.DateTime);
            }

            await session.SendAsync(hrDay);
            var hrList = list.Select(x => new HuntingRecordListDto
            {
                Damage = x.Value.AttackPVM,
                Duration = (uint)x.Value.Duration,
                ElementalDamage = x.Value.ElementalAttackPVM,
                Experience = (ulong)(x.Value.Experience).ShufleEnding(),
                Healing = (uint)x.Value.HealingUse,
                KilledCount = (uint)x.Value.KilledMonsters,
                Level = x.Value.Level,
                Id = (uint)(x.Key),
                Year = (uint)x.Value.DateTime.Year,
                Month = (byte)x.Value.DateTime.Month,
                Day = (byte)x.Value.DateTime.Day,
            });

            await session.SendAsync(new SHuntingRecordList
            {
                List = hrList.ToArray(),
            });
        }

        [MessageHandler(typeof(CHuntingRecordClose))]
        public void CHuntingRecordClose(GSSession session)
        {
            session.Player.Character?.HuntingRecord.Save();
        }

        [MessageHandler(typeof(CHuntingRecordVisibility))]
        public void CHuntingRecordVisibility(GSSession session, CHuntingRecordVisibility message)
        {
            if(session.Player.Character != null)
                session.Player.Character.HuntingRecord.Visibility = message.Visible == 1;
        }

        [MessageHandler(typeof(CMossMerchantOpenBox))]
        public async Task CMossMerchantOpenBox(GSSession session, CMossMerchantOpenBox message)
        {
            var @char = session.Player.Character;
            if(!@char.Inventory.TryAdd(new Size(2, 4)))
            {
                await session.SendAsync(new SChaosBoxItemMixButtonClick { Result = ChaosBoxMixResult.TooManyItems, ItemInfo = Array.Empty<byte>() });
                return;
            }
            switch (message.Section)
            {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    if (@char.Money < 1000000)
                    {
                        Logger.Error("MossMerchantOpenBox 1000000zen > {0}zen", @char.Money);
                        return;
                    }
                    @char.Money -= 1000000;
                    break;
                case 5://Jewel of Bless
                case 8:
                case 9:
                    {
                        var jewelList = @char.Inventory.FindAllItems(7181);
                        if(!jewelList.Any())
                        {
                            Logger.Error("MossMerchantOpenBox needs 1JOB");
                            return;
                        }

                        var jewel = jewelList.First();
                        if(jewel.Durability > 1)
                        {
                            jewel.Durability--;
                        }
                        else
                        {
                            @char.Inventory.Delete(jewel);
                        }
                    }
                    break;
                case 6:// Jewel of Soul
                    {
                        var jewelList = @char.Inventory.FindAllItems(7182);
                        if (!jewelList.Any())
                        {
                            Logger.Error("MossMerchantOpenBox needs 1JOS");
                            return;
                        }
                        var jewel = jewelList.First();
                        if (jewel.Durability > 1)
                        {
                            jewel.Durability--;
                        }
                        else
                        {
                            @char.Inventory.Delete(jewel);
                        }
                    }
                    break;
                case 7:// Miracle Coin
                    {
                        var miracleCoinList = @char.Inventory.FindAllItems(7581);
                        if (!miracleCoinList.Any())
                        {
                            Logger.Error("MossMerchantOpenBox needs 1MC");
                            return;
                        }
                        var jewel = miracleCoinList.First();
                        if (jewel.Durability > 1)
                        {
                            jewel.Durability--;
                        }
                        else
                        {
                            @char.Inventory.Delete(jewel);
                        }
                    }
                    break;
                case 10://  Miracle Coinx3 && Jewel of Blessx10
                    {
                        var miracleCoinList = @char.Inventory.FindAllItems(7581);
                        var jewelList = @char.Inventory.FindAllItems(7181);
                        if (!jewelList.Any() || jewelList.Sum(x => x.Durability) < 10)
                        {
                            Logger.Error("MossMerchantOpenBox needs 10JOB");
                            return;
                        }
                        if (!miracleCoinList.Any() || miracleCoinList.Sum(x => x.Durability) < 3)
                        {
                            Logger.Error("MossMerchantOpenBox needs 3MC");
                            return;
                        }
                    }
                    break;
            }
            var reward = MossMerchant.Gamble(session.Player, message.Section);
            @char.Inventory.Add(reward);
            @char.Inventory.SendInventory();
            await session.SendAsync(new SMossMerchantOpenBox { ItemInfo = reward.GetBytes() });
        }

        [MessageHandler(typeof(CCancelItemSale))]
        public async Task CCancelItemSale(GSSession session)
        {
            using(var db = new GameContext())
            {
                var list = from s in db.Sell
                           where s.CharacterId == session.Player.Character.Id
                           select s;
                var outputList = new List<CancelItemSaleInfoDto>();

                byte index = 0;
                foreach(var it in list)
                {
                    if(it.Date < DateTime.Now)
                    {
                        db.Sell.Remove(it);
                    }
                    else
                    {
                        outputList.Add(new CancelItemSaleInfoDto
                        {
                            ExpireSec = (uint)(it.Date - DateTime.Now).TotalSeconds,
                            IndexCode = index++,
                            ItemCount = 1,
                            ItemInfo = it.Item,
                            RequireMoney = it.Price,
                        });
                    }
                }

                db.SaveChanges();
                await session.SendAsync(new SCancelItemSaleListS16
                {
                    //Result = 0,
                    ItemList = outputList.Take(5).ToArray()
                });
            }
        }

        [MessageHandler(typeof(CCancelItemSaleItem))]
        public async Task CCancelItemSaleItem(GSSession session, CCancelItemSaleItem message)
        {
            using(var db = new GameContext())
            {
                var list = (from s in db.Sell
                           where s.CharacterId == session.Player.Character.Id
                           select s).ToList();

                var item = list.Take(5).ElementAt(message.IndexCode);
                if (session.Player.Character.Money >= item.Price)
                {
                    if(session.Player.Character.Inventory.Add(new Item(item.Item)) == 0xff)
                    {
                        await session.SendAsync(new SCancelItemSaleResult { Result = 2 });
                        return;
                    }
                    session.Player.Character.Money -= (uint)item.Price;
                    db.Sell.Remove(item);
                    db.SaveChanges();
                    session.Player.Character.Inventory.SendInventory();
                    await CCancelItemSale(session);
                    await session.SendAsync(new SCancelItemSaleResult { Result = 0 });
                }
                else
                {
                    await session.SendAsync(new SCancelItemSaleResult { Result = 1 });
                }
            }
        }

        [MessageHandler(typeof(CChangeSkin))]
        public async Task CChangeSkin(GSSession session, CChangeSkin message)
        {
            session.Player.Character.Change = true;
            session.Player.Character.Transformation = message.Skin == 0;

            SubSystem.SelfUpdate(session.Player.Character);
            SubSystem.PlayerPlrViewport(session.Player.Character.Map, session.Player.Character);
        }

        [MessageHandler(typeof(CRuudBuy))]
        public async Task CRuudBuy(GSSession session, CRuudBuy message)
        {
            var plr = session.Player;
            var @char = plr.Character;

            var bResult = new SRuudBuy { Result = 255 };

            if (plr.Window == null)
            {
                await session.SendAsync(bResult);
                throw new ArgumentException("Player isn't in buy/trade/box/Quest", nameof(session.Player.Window));
            }

            if (plr.Window.GetType() != typeof(Monster))
            {
                await session.SendAsync(bResult);
                throw new ArgumentException("Player isn't in buy", nameof(session.Player.Window));
            }

            var npcs = ResourceCache.Instance.GetNPCs();
            var ruud = npcs.First(x => x.Value.Class == NPCAttributeType.ShopRuud).Value;
            var baseClass = (byte)session.Player.Character.BaseClass;
            baseClass >>= 4;
            var shop = ResourceCache.Instance.GetShops()[(ushort)(ruud.Data + baseClass)];
            var it = shop.Storage.Get(message.Slot).Clone() as Item;

            if(it.BasicInfo.Ruud > @char.Ruud)
            {
                bResult.Result = 252;
                await session.SendAsync(bResult);
                return;
            }

            var result = @char.Inventory.Add(it);
            if(result == 0xff)
            {
                bResult.Result = 251;
                await session.SendAsync(bResult);
                return;
            }

            @char.Ruud -= (uint)it.BasicInfo.Ruud;
            await session.SendAsync(new SBuy { Result = result, ItemInfo = it.GetBytes() });
        }
    }
}


--file MuunServices.cs
﻿using MU.Network.MuunSystem;
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using WebZen.Handlers;
using System.Linq;
using MuEmu.Util;

namespace MuEmu.Network.GameServices
{
    public partial class GameServices
    {
        [MessageHandler(typeof(CMuunItemRideSelect))]
        public async Task CMuunRideReq(GSSession session, CMuunItemRideSelect message)
        {
            await session.SendAsync(new SMuunRideVP { ViewPort = new MuunRideVPDto[] { new MuunRideVPDto(session.Player.ID, 0xffff) } });
        }

        [MessageHandler(typeof(CMuunItemGet))]
        public async Task CMuunItemGet(GSSession session, CMuunItemGet message)
        {
            var @char = session.Player.Character;
            Item pickup;

            try
            {
                pickup = @char.Map.ItemPickUp(@char, message.Number);
            }
            catch (Exception ex)
            {
                session.Exception(ex);
                return;
            }

            var pos = @char.Inventory.AddMuun(pickup);

            var msg = new SMuunItemGet { Item = pickup.GetBytes(), Result = pos, };
            await session.SendAsync(msg);
        }

    }
}


--file PartyServices.cs
﻿using MU.Network.Game;
using MU.Resources;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WebZen.Handlers;

namespace MuEmu.Network.GameServices
{
    public partial class GameServices : MessageHandler
    {
        [MessageHandler(typeof(CPartyRequest))]
        public async Task CPartyRequest(GSSession session, CPartyRequest message)
        {
            var trg = Program.server.Clients.FirstOrDefault(x => x.ID == message.Number);
            if (trg == null)
            {
                await session.SendAsync(new SPartyResult(PartyResults.PlayerOffline));
                return;
            }

            if (trg.Player.Character.Party != null)
            {
                await session.SendAsync(new SPartyResult(PartyResults.InAnotherParty));
                return;
            }

            var party = session.Player.Character.Party;

            if ((party != null && party.Master != session.Player) || session.Player.Window != null || trg.Player.Window != null)
            {
                await session.SendAsync(new SPartyResult(PartyResults.Fail));
                return;
            }

            if (Math.Abs(session.Player.Character.Level - trg.Player.Character.Level) > PartyManager.MaxLevelDiff)
            {
                await session.SendAsync(new SPartyResult(PartyResults.RestrictedLevel));
                return;
            }

            message.Number = (ushort)session.ID;
            await trg.SendAsync(message);
        }

        [MessageHandler(typeof(CPartyRequestResult))]
        public async Task CPartyRequestResult(GSSession session, CPartyRequestResult message)
        {
            var trg = Program.server.Clients.FirstOrDefault(x => x.ID == message.Number);
            if (trg == null)
            {
                await session.SendAsync(new SPartyResult(PartyResults.Fail));
                return;
            }
            PartyManager.CreateLink(trg.Player, session.Player);
        }

        [MessageHandler(typeof(CPartyList))]
        public async Task CPartyList(GSSession session)
        {
            var party = session.Player.Character.Party;
            PartyManager.SendAll(party);
        }

        [MessageHandler(typeof(CPartyDelUser))]
        public void CPartyDelUser(GSSession session, CPartyDelUser message)
        {
            var party = session.Player.Character.Party;
            if (party == null)
            {
                return;
            }

            var memb = party.Members.ElementAtOrDefault(message.Index);
            if (memb == null)
            {
                return;
            }

            if (memb != party.Master && memb != session.Player)
            {
                return;
            }

            PartyManager.Remove(memb);
        }

        [MessageHandler(typeof(CPartyMRegister))]
        public async Task CPartyMRegister(GSSession session, CPartyMRegister message)
        {
            var result = new SPartyMRegister();

            var plr = session.Player;
            var @char = plr.Character;
            if (@char.Party != null)
            {
                if (@char.Party.Master != plr)
                {
                    result.Result = -3;
                    await session.SendAsync(result);
                    return;
                }
            }

            if (PartyManager.ExistsMatching(plr))
            {
                result.Result = -2;
                await session.SendAsync(result);
                return;
            }

            PartyManager.CreateMatching(
                plr,
                message.Text,
                message.NeedPassword ? message.Password : "",
                message.AutAccept,
                message.MinLevel,
                message.MaxLevel,
                message.EnergyElf
                );

            await session.SendAsync(result);
        }

        [MessageHandler(typeof(CPartyMSearch))]
        public async Task CPartyMSearch(GSSession session, CPartyMSearch message)
        {
            var msg = new SPartyMSearch();
            msg.Page = message.Page;
            msg.Result = 0;

            var matchings = PartyManager.GetMatchings();

            msg.MaxPage = (uint)Math.Ceiling(matchings.Count / 6.0f);
            var matchingPage = matchings.Skip((int)((message.Page - 1) * 6)).Take(6);
            msg.List = matchingPage.Select(x => new PartyMSearchDto
            {
                MaxLevel = x.MaxLevel,
                MinLevel = x.MinLevel,
                Text = x.Text,
                Password = !string.IsNullOrEmpty(x.Password),
                Members = x.Player.Character.Party?.Members.Select(y => new PartyMSearchMemberDto
                {
                    Name = y.Character.Name,
                    Level = y.Character.Level,
                    Race = (ushort)y.Character.Class
                }).ToArray() ?? new PartyMSearchMemberDto[] { new PartyMSearchMemberDto { Name = x.Player.Character.Name, Level = x.Player.Character.Level } },
                Count = (byte)(x.Player.Character.Party?.Members.Count() ?? 1)
            }).ToArray();

            msg.Count = (uint)matchingPage.Count();
            await session.SendAsync(msg);
        }

        [MessageHandler(typeof(CPartyMJoin))]
        public async Task CPartyMJoin(GSSession session, CPartyMJoin message)
        {
            var msg = new SPartyMJoin();

            if (PartyManager.ExistsMatching(session.Player))
            {
                msg.Result = -4;
                goto sendmsg;
            }

            if (session.Player.Character.Party != null)
            {
                msg.Result = -6;
                goto sendmsg;
            }

            var matchings = PartyManager.GetMatchings();
            PartyMatching matching = null;
            if (message.Random)
            {
                var pool = matchings.Where(x => x.CanJoin(session.Player.Character));
                if (pool.Any())
                {
                    var matchNum = Program.RandomProvider(pool.Count());
                    matching = pool.ElementAtOrDefault(matchNum);
                }
                if (matching == null)
                {
                    msg.Result = -3;
                    goto sendmsg;
                }
            }
            else
            {
                matching = matchings.FirstOrDefault(x => x.Player.Character.Name == message.Leader);
                if (matching == null)
                {
                    msg.Result = -2;
                    goto sendmsg;
                }
            }

            msg.Result = matching.TryJoin(session.Player, message.Password);
            msg.Text = matching.Text;
            msg.Gens = 0;
            msg.Name = matching.Player.Character.Name;
            msg.UsePassword = !string.IsNullOrEmpty(matching.Password);

        sendmsg:
            await session.SendAsync(msg);
        }

        [MessageHandler(typeof(CPartyMJoinList))]
        public async Task CPartyMJoinList(GSSession session)
        {
            var matching = PartyManager.GetMatchings().First(x => x.Player == session.Player);
            var msg = new SPartyMJoinList();

            msg.List = matching.Waiting.Select(x => new PartyMJoinListDto
            {
                Name = x.Character.Name,
                Level = x.Character.Level,
                Data = 0,
                Race = (byte)x.Character.BaseClass
            }).ToArray();
            msg.Count = msg.List.Count();

            await session.SendAsync(msg);
        }
        [MessageHandler(typeof(CPartyMAccept))]
        public async Task CPartyMAccept(GSSession session, CPartyMAccept message)
        {
            var matching = PartyManager.GetMatchings().First(x => x.Player == session.Player);
            var applicant = matching.Waiting.First(x => x.Character.Name == message.Applicant);
            matching.Waiting.Remove(applicant);

            if (message.Accept)
            {
                PartyManager.CreateLink(matching.Player, applicant);
            }
            else
            {

            }
            await session.SendAsync(new SPartyMJoinNotify());
        }

        [MessageHandler(typeof(CPartyMCancel))]
        public async Task CPartyMCancel(GSSession session, CPartyMCancel message)
        {
            var msg = new SPartyMCancel();
            msg.Result = PartyManager.CancelMatching(session.Player);
            msg.Type = message.Type;
            await session.SendAsync(msg);
        }
    }
}


--file PersonalShopServices.cs
﻿using MU.Network.Game;
using MU.Network;
using MU.Resources;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WebZen.Handlers;
using MuEmu.Util;
using Google.Protobuf.Collections;

namespace MuEmu.Network.GameServices
{
    public partial class GameServices : MessageHandler
    {
        [MessageHandler(typeof(CPShopSetItemPrice))]
        public async Task CPShopSetItemPrice(GSSession session, CPShopSetItemPrice message)
        {
            var @char = session.Player.Character;
            if (@char.Level < 6)
            {
                await session.SendAsync(new SPShopSetItemPrice(PShopResult.LevelTooLow, message.Position));
                return;
            }

            if (message.Price == 0)
            {
                await session.SendAsync(new SPShopSetItemPrice(PShopResult.InvalidPrice, message.Position));
                return;
            }

            var item = @char.Inventory.Get(message.Position);

            if (item == null)
            {
                await session.SendAsync(new SPShopSetItemPrice(PShopResult.InvalidItem, message.Position));
                return;
            }

            item.PShopValueZ = message.Price;
            item.PShopValueB = message.JewelOfBlessPrice;
            item.PShopValueS = message.JewelOfSoulPrice;
            item.PShopValueC = message.JewelOfChaosPrice;

            Logger.ForAccount(session).Information("Update price for {0}, {1}Zen, {2}Bless, {3}Soul, {4}Chaos", item, item.PShopValueZ, item.PShopValueB, item.PShopValueS, item.PShopValueC);
            await session.SendAsync(new SPShopSetItemPrice(PShopResult.Success, message.Position));
        }

        [MessageHandler(typeof(CPShopRequestOpen))]
        public async Task CPShopRequestOpen(GSSession session, CPShopRequestOpen message)
        {
            var @char = session.Player.Character;
            var log = Logger.ForAccount(session);

            if (@char.Map.IsEvent)
            {
                log.Error("Try to open PShop on Event map");
                await session.SendAsync(new SPShopRequestOpen(PShopResult.Disabled));
                return;
            }

            if (@char.Level < 6)
            {
                log.Error("Character Level Too Low ");
                await session.SendAsync(new SPShopRequestOpen(PShopResult.LevelTooLow));
                return;
            }

            if (!@char.Shop.Open)
            {
                log.Information("PShop:{0} Open", message.Name);
                @char.Shop.Name = message.Name;
                @char.Shop.Open = true;
                await session.SendAsync(new SPShopRequestOpen(PShopResult.Success));
                return;
            }

            await session.SendAsync(new SPShopRequestOpen(PShopResult.Disabled));
        }

        [MessageHandler(typeof(CPShopRequestClose))]
        public async Task CPShopRequestClose(GSSession session)
        {
            var @char = session.Player.Character;
            var log = Logger.ForAccount(session);

            if (@char == null)
                return;

            if (!@char.Shop.Open)
            {
                log.Error("PShop isn't open");
            }
            else
            {
                @char.Shop.Open = false;
                log.Error("PShop {0} Closed", @char.Shop.Name);
            }
            var msg = new SPShopRequestClose(PShopResult.Success, (ushort)session.ID);
            await session.SendAsync(msg);
            @char.SendV2Message(msg);
        }

        [MessageHandler(typeof(CPShopRequestList))]
        public async Task CPShopRequestList(GSSession session, CPShopRequestList message)
        {
            var seller = Program.server.Clients.FirstOrDefault(x => x.ID == message.Number);

            if (seller == null)
            {
                await session.SendAsync(new SPShopRequestList(PShopResult.InvalidPosition));
                return;
            }

            if (seller == session)
            {
                await session.SendAsync(new SPShopRequestList(PShopResult.Disabled));
                return;
            }

            await session.SendAsync(new SPShopAlterVault { type = 0 });
            var msg = VersionSelector.CreateMessage<SPShopRequestList>(PShopResult.Success, message.Number, seller.Player.Character.Name, seller.Player.Character.Shop.Name, seller.Player.Character.Shop.Items);
            await session.SendAsync(msg);
            session.Player.Window = seller;
            return;
        }

        [MessageHandler(typeof(CPShopCloseDeal))]
        public async Task CPShopCloseDeal(GSSession session, CPShopCloseDeal message)
        {
            var log = Logger.ForAccount(session);
            var seller = session.Player.Window as GSSession;
            session.Player.Window = null;
            if (seller != null)
            {
                log.Information("Close deal with {0}", seller.Player.Character);
            }
            else
            {
                log.Information("Close deal with {0}", message.Name);
            }
        }

        [MessageHandler(typeof(CPShopRequestBuy))]
        public async Task CPShopRequestBuy(GSSession session, CPShopRequestBuy message)
        {
            var seller = Program.server.Clients.FirstOrDefault(x => x.ID == message.Number);

            if (seller == null)
            {
                await session.SendAsync(new SPShopRequestBuy(PShopResult.InvalidPosition));
                return;
            }

            if (seller == session)
            {
                await session.SendAsync(new SPShopRequestBuy(PShopResult.Disabled));
                return;
            }

            var @char = seller.Player.Character;
            if (!@char.Shop.Open)
            {
                await session.SendAsync(new SPShopRequestBuy(PShopResult.Disabled));
                return;
            }

            var item = @char.Inventory.PersonalShop.Get(message.Position);

            if (item == null)
            {
                await session.SendAsync(new SPShopRequestBuy(PShopResult.InvalidItem));
                return;
            }

            if (item.PShopValueZ > session.Player.Character.Money)
            {
                await session.SendAsync(new SPShopRequestBuy(PShopResult.LackOfZen));
                return;
            }

            if (@char.Money + item.PShopValueZ > uint.MaxValue)
            {
                await session.SendAsync(new SPShopRequestBuy(PShopResult.ExceedingZen));
                return;
            }

            var Bless = session.Player.Character.Inventory.FindAllItems(7181);
            var BlessC = session.Player.Character.Inventory.FindAllItems(6174);
            var Bless10Pack = BlessC.Where(x => x.Plus == 0);
            var Bless20Pack = BlessC.Where(x => x.Plus == 1);
            var Bless30Pack = BlessC.Where(x => x.Plus == 2);
            var Soul = session.Player.Character.Inventory.FindAllItems(7182);
            var SoulC = session.Player.Character.Inventory.FindAllItems(6175);
            var Soul10Pack = SoulC.Where(x => x.Plus == 0);
            var Soul20Pack = SoulC.Where(x => x.Plus == 1);
            var Soul30Pack = SoulC.Where(x => x.Plus == 2);
            var Chaos = session.Player.Character.Inventory.FindAllItems(6159);
            var ChaosC = session.Player.Character.Inventory.FindAllItems(6285);
            var Chaos10Pack = ChaosC.Where(x => x.Plus == 0);
            var Chaos20Pack = ChaosC.Where(x => x.Plus == 1);
            var Chaos30Pack = ChaosC.Where(x => x.Plus == 2);

            if (item.PShopValueB > Bless.Count() + Bless30Pack.Count() * 30 + Bless20Pack.Count() * 20 + Bless10Pack.Count() * 10)
            {
                await session.SendAsync(new SPShopRequestBuy(PShopResult.LackOfBless));
                return;
            }

            if (item.PShopValueS > Soul.Count() + Soul30Pack.Count() * 30 + Soul20Pack.Count() * 20 + Soul10Pack.Count() * 10)
            {
                await session.SendAsync(new SPShopRequestBuy(PShopResult.LackOfSoul));
                return;
            }

            if (item.PShopValueC > Chaos.Count() + Chaos30Pack.Count() * 30 + Chaos20Pack.Count() * 20 + Chaos10Pack.Count() * 10)
            {
                await session.SendAsync(new SPShopRequestBuy(PShopResult.LackOfChaos));
                return;
            }

            int jewel = item.PShopValueB;
            var pickB30 = Math.Min(jewel / 30, Bless30Pack.Count());
            jewel -= pickB30 * 30;
            var pickB20 = Math.Min(jewel / 20, Bless20Pack.Count());
            jewel -= pickB20 * 20;
            var pickB10 = Math.Min(jewel / 10, Bless10Pack.Count());
            jewel -= pickB10 * 10;
            var pickB1 = jewel;

            jewel = item.PShopValueS;
            var pickS30 = Math.Min(jewel / 30, Soul30Pack.Count());
            jewel -= pickS30 * 30;
            var pickS20 = Math.Min(jewel / 20, Soul20Pack.Count());
            jewel -= pickS20 * 20;
            var pickS10 = Math.Min(jewel / 10, Soul10Pack.Count());
            jewel -= pickS10 * 10;
            var pickS1 = jewel;

            jewel = item.PShopValueC;
            var pickC30 = Math.Min(jewel / 30, Chaos30Pack.Count());
            jewel -= pickC30 * 30;
            var pickC20 = Math.Min(jewel / 20, Chaos20Pack.Count());
            jewel -= pickC20 * 20;
            var pickC10 = Math.Min(jewel / 10, Chaos10Pack.Count());
            jewel -= pickC10 * 10;
            var pickC1 = jewel;

            var transfer = Bless30Pack.Take(pickB30).ToList();
            transfer.AddRange(Bless20Pack.Take(pickB20));
            transfer.AddRange(Bless10Pack.Take(pickB10));
            transfer.AddRange(Bless.Take(pickB1));

            transfer.AddRange(Soul30Pack.Take(pickS30));
            transfer.AddRange(Soul20Pack.Take(pickS20));
            transfer.AddRange(Soul10Pack.Take(pickS10));
            transfer.AddRange(Soul.Take(pickS1));

            transfer.AddRange(Chaos30Pack.Take(pickC30));
            transfer.AddRange(Chaos20Pack.Take(pickC20));
            transfer.AddRange(Chaos10Pack.Take(pickC10));
            transfer.AddRange(Chaos.Take(pickC1));

            if (!@char.Inventory.TryAdd(transfer))
            {
                await session.SendAsync(new SPShopRequestBuy(PShopResult.SellerInventoryFull));
                return;
            }

            if (!session.Player.Character.Inventory.TryAdd(new[] { item }))
            {
                await session.SendAsync(new SPShopRequestBuy(PShopResult.InvalidPosition));
                return;
            }

            session.Player.Character.Inventory.Remove(transfer);
            @char.Inventory.Add(transfer);

            await @char.Inventory.Remove(message.Position, true);
            var res = session.Player.Character.Inventory.Add(item);

            session.Player.Character.Money -= item.PShopValueZ;
            @char.Money += item.PShopValueZ;

            await session.SendAsync(new SPShopRequestBuy(PShopResult.Success, message.Number, item.GetBytes(), res));
            await @char.Player.Session.SendAsync(new SPShopRequestSold(PShopResult.Success, message.Position, session.Player.Character.Name));

            if (@char.Inventory.PersonalShop.Items.Count == 0)
            {
                await CPShopRequestClose(@char.Player.Session);
            }
        }

        [MessageHandler(typeof(CPShopSearchItem))]
        public async Task CPShopSearchItem(GSSession session, CPShopSearchItem message)
        {
            IEnumerable<PShop> shopList;

            shopList = from cl in Program.server.Clients
                       where
                       cl.Player != null &&
                       cl.Player.Status == LoginStatus.Playing &&
                       cl.Player.Character.Shop.Open == true &&
                       (cl.Player.Character.MapID == Maps.Lorencia || cl.Player.Character.MapID == Maps.Davias || cl.Player.Character.MapID == Maps.Noria || cl.Player.Character.MapID == Maps.Elbeland || cl.Player.Character.MapID == Maps.LorenMarket)
                       select cl.Player.Character.Shop;

            if (message.sSearchItem != -1)
            {
                shopList = from cl in shopList
                           where
                           cl.Chararacter.Inventory.PersonalShop.Items.Values.Count(x => x.Number.Number == (ushort)message.sSearchItem) != 0
                           select cl;
            }

            shopList = shopList.Skip(message.iLastCount).Take(50);
            var msg = new SPShopSearchItem
            {
                iPShopCnt = shopList.Count(),
                btContinueFlag = (byte)(shopList.Count() == 50 ? 1 : 0),
                List = shopList.Select(x => new SPShopSearchItemDto
                {
                    Number = x.Chararacter.Player.ID,
                    szName = x.Chararacter.Name,
                    szPShopText = x.Name,
                }).ToArray()
            };
            await session.SendAsync(msg);
        }

        [MessageHandler(typeof(CPShopSearch))]
        public async Task CPShopRequestListS16Kor(GSSession session, CPShopSearch message)
        {
            var shopList = from cl in Program.server.Clients
                       where
                       cl.Player != null &&
                       cl.Player.Status == LoginStatus.Playing &&
                       cl.Player.Character.Shop.Open == true &&
                       (cl.Player.Character.MapID == Maps.Lorencia || cl.Player.Character.MapID == Maps.Davias || cl.Player.Character.MapID == Maps.Noria || cl.Player.Character.MapID == Maps.Elbeland || cl.Player.Character.MapID == Maps.LorenMarket)
                       select cl.Player.Character.Shop;

            /*if (message.Number != -1)
            {
                shopList = from cl in shopList
                           where
                           cl.Chararacter.Inventory.PersonalShop.Items.Values.Count(x => x.Number.Number == (ushort)message.sSearchItem) != 0
                           select cl;
            }*/

            Logger.Debug(nameof(CPShopRequestListS16Kor));
            await session.SendAsync(new SPShopSearch
            {
                Count = (uint)shopList.Count(),
                Number = message.Number,
                List = shopList.Select(x => new SPShopSearchDto
                {
                    Seller = x.Chararacter.Name,
                    Description = x.Name,
                }).ToArray()
            });
        }

        [MessageHandler(typeof(CPShopItemSearch2))]
        public async Task CPShopItemSearch(GSSession session, CPShopItemSearch2 message)
        {
            var shopList = from cl in Program.server.Clients
                           where
                           cl.Player != null &&
                           cl.Player.Status == LoginStatus.Playing &&
                           cl.Player.Character.Shop.Open == true &&
                           (cl.Player.Character.MapID == Maps.Lorencia || cl.Player.Character.MapID == Maps.Davias || cl.Player.Character.MapID == Maps.Noria || cl.Player.Character.MapID == Maps.Elbeland || cl.Player.Character.MapID == Maps.LorenMarket)
                           select cl.Player.Character.Shop;

            var list = shopList.SelectMany(x =>
            {
                var seller = x.Chararacter.Name;
                var description = x.Name;
                return x.Items.Select(y => new SPShopItemSearchDto
                {
                    Seller = seller,
                    ItemInfo = y.Item,
                    JOBless = y.BlessValue,
                    JOSoul = y.SoulValue,
                    Zen = y.Price,
                    Slot = y.Pos,
                });
            });

            if(message.Number != 0xffffffff)
            {
                list = list.Where(x => (new Item(x.ItemInfo)).Number == message.Number);
            }else if(message.Name.Length > 0)
            {
                list = list.Where(x => (new Item(x.ItemInfo)).BasicInfo.Name.ToLower().Contains(message.Name.ToLower()));
            }
            Logger.Debug(nameof(CPShopItemSearch));
            await session.SendAsync(new SPShopItemSearch
            {
                Count = (uint)list.Count(),
                Number = message.Number,
                List = list.ToArray()
            });
        }

        [MessageHandler(typeof(CPShopItemSearch))]
        public async Task CPShopItemSearch(GSSession session, CPShopItemSearch message)
        {
            Logger.Debug(nameof(CPShopItemSearch));
            await CPShopItemSearch(session, new CPShopItemSearch2 { Item = 0xffff, Name = "", Number = message.Number });
        }

        [MessageHandler(typeof(CPShopRequestList2S16Kor))]
        public async Task CPShopRequestList2S16Kor(GSSession session, CPShopRequestList2S16Kor message)
        {
            var shop = session.Player.Character.Shop;
            Logger.Debug(nameof(CPShopRequestList2S16Kor));
            var psInventory = session.Player.Character.Inventory.PersonalShop;
            var Bundles = psInventory.Items.Values.GroupBy(x => Math.Floor((x.SlotId - (int)psInventory.IndexTranslate) / 5.0f));

            var output = new SPShopSellList
            {
                Result = 1,
                Description = shop.Name,
                state = (byte)(shop.Open ? 1 : 0),
                Number = message.Number,
                List = Bundles.Select(x =>
                {
                    var y = x.First();
                    var bundle = x.Count() > 1;
                    return new SPShopItemSellListDto
                    {
                        JOBless = y.PShopValueB,
                        JOSoul = y.PShopValueS,
                        ItemInfo = y.GetBytes(),
                        Zen = y.PShopValueZ,
                        Slot = (byte)x.Key,
                        Bundle = (byte)(bundle ? 2 : 1),
                    };
                 }).ToArray()
            };
            await session.SendAsync(output);
        }

        [MessageHandler(typeof(CPShopSetItemPriceS16Kor))]
        public async Task CPShopSetItemPriceS16Kor(GSSession session, CPShopSetItemPriceS16Kor message)
        {
            var shop = session.Player.Character.Shop;

            var items = message.Items.Select(x => session.Player.Character.Inventory.Get((byte)x)).ToList();
            if (items.Count != 0)
            {
                var i = 0;
                foreach (var item in items)
                {
                    session.Player.Character.Inventory.Remove(item, true);
                    session.Player.Character.Inventory.PersonalShop.Add((byte)(StorageID.PersonalShop + message.Slot * 5 + i), item);
                    i++;
                }
            }
            else
            {
                items = Enumerable
                    .Range(message.Slot * 5, 5)
                    .Select(x => session.Player.Character.Inventory.PersonalShop.Get((byte)(StorageID.PersonalShop + x)))
                    .Where(x => x != null)
                    .ToList();
            }
            foreach (var item in items)
            {
                item.PShopValueB = (ushort)message.JewelOfBlessPrice;
                item.PShopValueS = (ushort)message.JewelOfSoulPrice;
                item.PShopValueZ = message.Price;
            }
            var start = items.First();
            Logger.Debug(nameof(CPShopSetItemPriceS16Kor));
            await session.SendAsync(new SPShopSetItemPriceS16Kor
            {
                ItemInfo = start.GetBytes(),
                Number = 1,
                Bundle = (byte)(items.Count > 1?2:1),
                JOBless = message.JewelOfBlessPrice,
                JOSoul = message.JewelOfSoulPrice,
                Result = message.Changed,
                Slot = message.Slot,
                Zen = message.Price,
            });
        }

        [MessageHandler(typeof(CPShopChangeStateS16Kor))]
        public async Task CPShopChangeStateS16Kor(GSSession session, CPShopChangeStateS16Kor message)
        {
            var shop = session.Player.Character.Shop;
            shop.Open = message.State == 0? false : (message.State == 1?true: shop.Open);
            shop.Name = message.Description;
            Logger.Debug(nameof(CPShopChangeStateS16Kor));
            await session.SendAsync(new SPShopChangeStateS16Kor
            {
                Number = message.Number,
                Result = 1,
                State = (byte)(shop.Open ? 1 : 0)
            });
        }

        [MessageHandler(typeof(CPShopItemViewS16Kor))]
        public async Task CPShopItemViewS16Kor(GSSession session, CPShopItemViewS16Kor message)
        {
            var shop = session.Player.Character.Shop;
            var psInventory = session.Player.Character.Inventory.PersonalShop;
            var Bundles = psInventory.Items.Values.GroupBy(x => Math.Floor((x.SlotId - (int)psInventory.IndexTranslate) / 5.0f));

            Logger.Debug(nameof(CPShopItemViewS16Kor));
            var info = Bundles.FirstOrDefault(x => x.Key == message.Slot);
            if (info == null)
                throw new InvalidOperationException("message.Slot Invalid");

            var start = info.First();
            await session.SendAsync(new SPShopItemViewS16Kor
            {
                Result = 1,
                Slot = message.Slot,
                JOBless = start.PShopValueB,
                JOSoul = start.PShopValueS,
                Zen = start.PShopValueZ,
                Items = info.Select(y => new ItemViewS16Dto { ItemInfo = y.GetBytes() }).ToArray()
            });
        }

        [MessageHandler(typeof(CPShopCancelItemSaleS16Kor))]
        public async Task CPShopCancelItemSaleS16Kor(GSSession session, CPShopCancelItemSaleS16Kor message)
        {
            var psInventory = session.Player.Character.Inventory.PersonalShop;
            var Bundles = psInventory.Items.Values.GroupBy(x => Math.Floor((x.SlotId - (int)psInventory.IndexTranslate) / 5.0f));

            var slot = Bundles.First(x => x.Key == message.Slot);
            foreach (var item in slot)
                session.Player.Character.GremoryCase.AddItem(item, DateTime.Today.AddDays(30), GremoryStorage.Character, GremorySource.Event);

            foreach (var item in slot)
                psInventory.Remove((byte)item.SlotId);

            await session.SendAsync(new SPShopCancelItemSaleS16Kor
            {
                Data = message.Number,
                Result = 1,
                Slot = message.Slot,
            });
        }
    }
}


--file GensServices.cs
﻿using MU.Network.GensSystem;
using MU.Resources;
using MuEmu.Entity;
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using WebZen.Handlers;

namespace MuEmu.Network
{
    public class GensServices : MessageHandler
    {
        [MessageHandler(typeof(CRequestJoin))]
        public async Task RequestJoin(GSSession session, CRequestJoin message)
        {
            var @char = session.Player.Character;
            if(@char.Gens.Influence != GensType.None)
            {
                await session.SendAsync(new SRegMember(1, message.Influence));
                return;
            }
            if(@char.Level < 50)
            {
                await session.SendAsync(new SRegMember(3, message.Influence));
                return;
            }
            if(@char.Party != null)
            {
                await session.SendAsync(new SRegMember(6, message.Influence));
                return;
            }

            @char.Gens.Join(message.Influence);
            await session.SendAsync(new SRegMember(0, message.Influence));
        }
        [MessageHandler(typeof(CRequestLeave))]
        public async Task RequestLeave(GSSession session)
        {
            var @char = session.Player.Character;
            if (@char.Guild != null && @char.Guild.Master.Player == session.Player)
            {
                await session.SendAsync(new SGensLeaveResult(2, (ushort)session.ID));
                return;
            }
            if (@char.Gens.Influence == GensType.None)
            {
                await session.SendAsync(new SGensLeaveResult(1, (ushort)session.ID));
                return;
            }
            if (@char.Party != null)
            {
                await session.SendAsync(new SGensLeaveResult(4, (ushort)session.ID));
                return;
            }

            @char.Gens.Leave();
            await session.SendAsync(new SGensLeaveResult(1, (ushort)session.ID));
        }

        [MessageHandler(typeof(CRequestReward))]
        public async Task RequestReward(GSSession session, CRequestReward message)
        {
            var result = new SGensReward { ItemType = 3 };
            var @char = session.Player.Character;

            
            if(!@char.Inventory.TryAdd())
            {
                await session.SendAsync(result);
                return;
            }

            result.ItemType = 0;

            await session.SendAsync(result);
        }

        [MessageHandler(typeof(CRequestMemberInfo))]
        public void RequestMemberInfo(GSSession session)
        {
            var gens = session.Player.Gens;
            using(var db = new GameContext())
            {
                var info = db.Gens.Find(session.Player.Character.Id);
                gens?.UpdateInfo(info);
                gens?.SendMemberInfo();
            }
        }
    }
}


--file GlobalServices.cs
﻿using MU.Network.Global;
using System;
using System.Collections.Generic;
using System.Text;
using WebZen.Handlers;

namespace MuEmu.Network
{
    public class GlobalServices : MessageHandler
    {
        [MessageHandler(typeof(CLiveClient))]
        public void LiveClient(GSSession session, CLiveClient message)
        { }
    }
}


--file GSSession.cs
﻿using System;
using System.Collections.Generic;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using System.Security.Cryptography;
using WebZen.Network;

namespace MuEmu.Network
{
    public class GSSession : WZClient
    {
        public Player Player { get; set; }
        public ushort PreviousCode { get; set; }
        public byte[] Key => _rijndael.Key;
        public byte TryLoginCount { get; set; }

        public GSSession(WZServer server, Socket socket, AsyncCallback onRecv)
            : base(server, socket, onRecv)
        { }

        public async Task SendAsync(object message)
        {
            if (Closed)
                return;

            await Send(_server.Encode(message, ref _outSerial, this));
        }
    }

    public class GSSessionFactory : ISessionFactory
    {
        public WZClient Create(WZServer server, Socket socket, AsyncCallback onRecv)
        {
            return new GSSession(server, socket, onRecv);
        }
    }
}


--file GuildServices.cs
﻿using MU.Network.Game;
using MU.Network.Guild;
using MU.Resources;
using MuEmu.Events.CastleSiege;
using MuEmu.Resources;
using MuEmu.Util;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WebZen.Handlers;
using WebZen.Util;

namespace MuEmu.Network
{
    public class GuildServices : MessageHandler
    {
        public static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(GuildServices));

        // 0xC1 0x55
        [MessageHandler(typeof(CGuildInfoSave))]
        public void CGuildInfoSave(GSSession session, CGuildInfoSave message)
        {
            Logger.ForAccount(session).Debug("Create Guild: {0}:{1}", message.Name, message.Type);
            GuildManager.CreateGuild(session.Player, message.Name, message.Mark, message.Type);
        }

        // 0xC1 0x66
        [MessageHandler(typeof(CGuildReqViewport))]
        public void CGuildReqViewport(GSSession session, CGuildReqViewport message)
        {
            var log = Logger.ForAccount(session);
            var guild = GuildManager.Get(message.Guild);

            if (guild == null)
            {
                log.Error("Try to get an invalid Guild {0}", message.Guild);
                return;
            }

            var msg = new SGuildAnsViewport
            {
                GuildName = guild.Name,
                UnionName = guild.Union.FirstOrDefault()?.Name ?? "",
                btGuildType = 0,
                GuildNumber = guild.Index,
                Mark = guild.Mark,
            };

            _=session.SendAsync(msg);
        }

        // 0xC1 0x52
        [MessageHandler(typeof(CGuildListAll))]
        public void CGuildListAll(GSSession session)
        {
            GuildManager.SendList(session.Player);
        }

        // 0xC1 0x50
        [MessageHandler(typeof(CGuildRequest))]
        public async Task CGuildRequest(GSSession session, CGuildRequest message)
        {
            var log = Logger.ForAccount(session);
            var target = Program.server.Clients.FirstOrDefault(x => x.ID == message.Number);

            if(target == null)
            {
                await session.SendAsync(new SGuildResult(GuildResult.PlayerOffline));
                return;
            }

            if(target.Player.Window != null)
            {
                await session.SendAsync(new SGuildResult(GuildResult.InTransaction));
                return;
            }

            if(session.Player.Character.Level < 6)
            {
                await session.SendAsync(new SGuildResult(GuildResult.InsuficientLevel));
                return;
            }

            if(session.Player.Character.Guild != null)
            {
                await session.SendAsync(new SGuildResult(GuildResult.HaveGuild));
                return;
            }

            if(target.Player.Character.Guild.Master.Player != target.Player)
            {
                await session.SendAsync(new SGuildResult(GuildResult.NotGuildMaster));
                return;
            }

            if(!target.Player.Character.Guild.CanAdd())
            {
                await session.SendAsync(new SGuildResult(GuildResult.CannotAcceptMoreMembers));
                return;
            }

            message.Number = (ushort)session.ID;
            await target.SendAsync(message);
        }

        // 0xC1 0x51
        [MessageHandler(typeof(CGuildRequestAnswer))]
        public async Task CGuildRequestAnswer(GSSession session, CGuildRequestAnswer message)
        {
            var source = Program.server.Clients.FirstOrDefault(x => x.ID == message.Number);

            if(source == null)
            {
                await session.SendAsync(new SGuildResult(GuildResult.CannotAcceptMoreMembers));
                return;
            }

            if(message.Result == 1)
            {
                session.Player.Character.Guild.Add(source.Player, GuildStatus.Member);
            }else
            {
                await source.SendAsync(new SGuildResult(GuildResult.Fail));
                return;
            }
        }

        // 0xC1 0xE1
        [MessageHandler(typeof(CGuildSetStatus))]
        public async Task CGuildSetStatus(GSSession session, CGuildSetStatus message)
        {
            var log = Logger.ForAccount(session);
            var guild = session.Player.Character.Guild;
            if(guild == null)
            {
                await session.SendAsync(new SGuildSetStatus(message.Type, GuildResult.NotExist, message.Name));
                return;
            }

            if(guild.Master.Player != session.Player)
            {
                await session.SendAsync(new SGuildSetStatus(message.Type, GuildResult.NotExistPermission, message.Name));
                return;
            }

            var memb = guild.Find(message.Name);
            if(memb == null)
            {
                return;
            }

            if(memb.Name == session.Player.Character.Name)
            {
                await session.SendAsync(new SGuildSetStatus(message.Type, GuildResult.NotExistPermission, message.Name));
                return;
            }

            if(message.Type == 1 || message.Type == 2)
            {
                if(message.Status == GuildStatus.Assistant && guild.Assistant == null)
                {
                    log.Information("Status for {0} changed to {1}", message.Name, message.Status);
                    memb.UpdateRank(message.Status);
                    await session.SendAsync(new SGuildSetStatus(message.Type, GuildResult.Success, message.Name));
                }
                else if(message.Status == GuildStatus.BattleMaster)
                {
                    var bm = guild.BattleMasters;
                    var bmmax = session.Player.Character.Level / 200 + 1;

                    if(bm.Count() < bmmax)
                    {
                        log.Information("Status for {0} changed to {1}", message.Name, message.Status);
                        memb.UpdateRank(message.Status);
                        await session.SendAsync(new SGuildSetStatus(message.Type, GuildResult.Success, message.Name));
                    }
                }
            }else if(message.Type == 3)
            {
                memb.UpdateRank(message.Status);
                await session.SendAsync(new SGuildSetStatus(message.Type, GuildResult.Success, message.Name));
            }
        }

        // 0xC1 0xE3
        [MessageHandler(typeof(CGuildRemoveUser))]
        public async Task CGuildRemoveUser(GSSession session, CGuildRemoveUser message)
        {
            var log = Logger.ForAccount(session);
            var guild = session.Player.Character.Guild;
            if (guild == null)
            {
                await session.SendAsync(new SGuildRemoveUser(GuildResult.NotExist));
                return;
            }

            if (guild.Master.Player != session.Player)
            {
                await session.SendAsync(new SGuildRemoveUser(GuildResult.NotExistPermission));
                return;
            }

            var memb = guild.Find(message.Name);
            if (memb == null)
            {
                return;
            }

            if (memb.Name == session.Player.Character.Name)
            {
                await session.SendAsync(new SGuildRemoveUser(GuildResult.NotExistPermission));
                return;
            }

            guild.Remove(memb);
            await session.SendAsync(new SGuildRemoveUser(GuildResult.Success));
        }


        // 0xC1 E5
        [MessageHandler(typeof(CRelationShipJoinBreakOff))]
        public async Task CRelationShipJoinBreakOff(GSSession session, CRelationShipJoinBreakOff message)
        {
            var siege = Program.EventManager.GetEvent<CastleSiege>();

            if (siege.State >= SiegeStates.Notify && siege.State <= SiegeStates.StartSiege)
            {
                //MsgOutput(aIndex, Lang.GetText(0, 197));
                await session.SendAsync(new SNotice(NoticeType.Blue, ServerMessages.GetMessage(Messages.Guild_RelationShipCantChange)));
                return;
            }

            Character src, dst;

            src = session.Player.Character;
            if(message.TargetUserIndex == 0)
            {
                dst = GuildManager.Instance.Guilds.FirstOrDefault(x => x.Value.Name == message.Guild).Value.Master?.Player?.Character??null;
            }
            else
            {
                dst = Program.server.Clients.FirstOrDefault(x => x.ID == message.TargetUserIndex)?.Player?.Character ?? null;
            }

            if(dst == null)
            {
                await session.SendAsync(new SGuildResult(GuildResult.PlayerOffline));
                return;
            }

            if (src.Guild == null || dst.Guild == null)
            {
                await session.SendAsync(new SGuildResult(GuildResult.HaveGuild));
                return;
            }

            if (src.Guild.Master.Player != src.Player || dst.Guild.Master.Player != dst.Player)
            {
                await session.SendAsync(new SGuildResult(GuildResult.NotGuildMaster));
                return;
            }

            if (src.Player.Window != null || dst.Player.Window != null)
            {
                await session.SendAsync(new SGuildResult(GuildResult.InTransaction));
                return;
            }

            var errmsg = new SRelationShipJoinBreakOff
            {
                RequestType = message.RequestType,
                Result = 0,
                RelationShipType = message.RelationShipType,
                wzTargetUserIndex = message.wzTargetUserIndex,
            };

            switch (message.RequestType)
            {
                case GuildUnionRequestType.Join:
                    switch(message.RelationShipType)
                    {
                        case GuildRelationShipType.Union:
                            break;
                        case GuildRelationShipType.Rivals:
                            break;
                    }
                    break;
                case GuildUnionRequestType.BreakOff:
                    switch (message.RelationShipType)
                    {
                        case GuildRelationShipType.Union:
                            break;
                        case GuildRelationShipType.Rivals:
                            break;
                    }
                    break;
            }

            message.wzTargetUserIndex = ((ushort)session.ID).ShufleEnding();
            await dst.Player.Session.SendAsync(message);
        }

        // 0xC1 E6
        [MessageHandler(typeof(SRelationShipJoinBreakOff))]
        public async Task SRelationShipJoinBreakOff(GSSession session, SRelationShipJoinBreakOff message)
        {
            var src = session.Player.Character;
            Character dst = null;

            if (message.wzTargetUserIndex.ShufleEnding() != session.Player.ID)
                dst = Program.server.Clients.First(x => x.ID == message.wzTargetUserIndex.ShufleEnding()).Player.Character;
            else if (message.RelationShipType == GuildRelationShipType.Union)
                dst = src.Guild.Union.First().Master.Player?.Character ?? null;
            else if(message.RelationShipType == GuildRelationShipType.Rivals)
                dst = src.Guild.Rival.First().Master.Player?.Character ?? null;

            if (message.Result == 1)
            {
                if (dst != null)
                    src.Guild.ChangeRelation(dst.Guild, message.RequestType, message.RelationShipType);
                else if (message.RelationShipType == GuildRelationShipType.Union)
                    src.Guild.ChangeRelation(src.Guild.Union.First(), message.RequestType, message.RelationShipType);
                else if (message.RelationShipType == GuildRelationShipType.Rivals)
                    src.Guild.ChangeRelation(src.Guild.Rival.First(), message.RequestType, message.RelationShipType);

                message.wzTargetUserIndex = dst.Player.ID.ShufleEnding();
                _= src.Player.Session.SendAsync(message);

                if (dst != null)
                {
                    message.wzTargetUserIndex = src.Player.ID.ShufleEnding();
                    _ = dst.Player.Session.SendAsync(message);
                    CGuildReqViewport(dst.Player.Session, new MU.Network.Guild.CGuildReqViewport { Guild = dst.Guild.Index });
                    CGuildReqViewport(dst.Player.Session, new MU.Network.Guild.CGuildReqViewport { Guild = src.Guild.Index });
                }
                CGuildReqViewport(src.Player.Session, new MU.Network.Guild.CGuildReqViewport { Guild = dst.Guild.Index });
                CGuildReqViewport(src.Player.Session, new MU.Network.Guild.CGuildReqViewport { Guild = src.Guild.Index });

                Logger.Information("Relation Changed, {0} now have {1} to {2} as {3}",
                    dst.Guild.Name,
                    message.RequestType,
                    src.Guild.Name,
                    message.RelationShipType);
            }
            else
            {
                message.wzTargetUserIndex = src.Player.ID.ShufleEnding();
                await dst.Player.Session.SendAsync(message);
            }
        }

        // 0xC1 E9
        [MessageHandler(typeof(CUnionList))]
        public async Task CUnionList(GSSession session)
        {
            var guild = session.Player.Character.Guild;
            var list = guild.Union.Select((x,i) => new UnionListDto
            {
                GuildName = x.Name,
                Mark = x.Mark,
                MemberNum = (byte)x.Members.Count
            }).ToArray();
            await session.SendAsync(new SUnionList
            {
                List = list,
                Count = (byte)list.Count(),
                Result = 1,
                RivalMemberNum = 0,
                UnionMemberNum = 0,
            });
        }

        [MessageHandler(typeof(CGuildMatchingList))]
        public async Task GuildMatchingList(GSSession session, CGuildMatchingList message)
        {
            await GuildMatchingListSearch(session, new CGuildMatchingListSearch { Page = message.Page, Text = null });
        }
        [MessageHandler(typeof(CGuildMatchingListSearch))]
        public async Task GuildMatchingListSearch(GSSession session, CGuildMatchingListSearch message)
        {
            var result = new SGuildMatchingList();
            var maxPage = 0;

            result.List = GuildManager.GuildMatchingList(session.Player.Character, message.Page, message.Text, out maxPage)
                .ToArray();
            result.Count = result.List.Length;
            result.CurrentPage = message.Page;
            result.MaxPage = maxPage;

            await session.SendAsync(result);
        }
        [MessageHandler(typeof(CGuildMatchingRegister))]
        public async Task GuildMatchingRegister(GSSession session, CGuildMatchingRegister message)
        {
            var result = 0u;
            if(session.Player.Character.Guild.Master.Name != session.Player.Character.Name)
            {
                result = 1;
            }
            else
            {
                await GuildManager.GuildMatchingRegister(session.Player.Character, message.Text, message.InterestType, message.LevelRange, message.Class);
            }

            await session.SendAsync(new SGuildMatchingRegister { Result = result });
        }
        [MessageHandler(typeof(CGuildMatchingRegisterCancel))]
        public async Task GuildMatchingRegisterCancel(GSSession session)
        {
            await GuildManager.GuildMatchingRegisterCancel(session.Player.Character);
            await session.SendAsync(new SGuildMatchingRegisterCancel { Result = 0 });
        }
        [MessageHandler(typeof(CGuildMatchingJoin))]
        public async Task GuildMatchingJoin(GSSession session, CGuildMatchingJoin message)
        {
            int result = await GuildManager.GuildMatchingJoin(session.Player.Character, message.GuildID);
            await session.SendAsync(new SGuildMatchingJoin { Result = result });
        }
        [MessageHandler(typeof(CGuildMatchingJoinAccept))]
        public async Task GuildMatchingJoinAccept(GSSession session, CGuildMatchingJoinAccept message)
        {
            int result = await GuildManager.GuildMatchingJoin(session.Player.Character, message.Type, message.Name);
            await session.SendAsync(new SGuildMatchingAccept { Name = message.Name, Type = message.Type, Result = result });

            var tgtSession = Program.server.Clients.FirstOrDefault(x => x.Player.Character.Name == message.Name);

            if(tgtSession != null)
            {
                await tgtSession.SendAsync(new SGuildMatchingNotify
                {
                    Result = 1
                });
            }
        }
        [MessageHandler(typeof(CGuildMatchingJoinList))]
        public async Task GuildMatchingJoinList(GSSession session)
        {
            try
            {
                var list = await GuildManager.GuildMatchingJoinList(session.Player.Character);
                await session.SendAsync(new SGuildMatchingJoinList
                {
                    Result = 0,
                    List = list.ToArray(),
                    Count = list.Count(),
                });
            }catch(Exception ex)
            {
                session.Exception(ex);
                await session.SendAsync(new SGuildMatchingJoinList
                {
                    Result = 1,
                    List = Array.Empty<GuildMatchingJoinListDto>(),
                    Count = 0,
                });
            }
        }
        [MessageHandler(typeof(CGuildMatchingJoinInfo))]
        public async Task GuildMatchingJoinInfo(GSSession session)
        {
            var result = new SGuildMatchingJoinInfo();
            try
            {
                string gName = "";
                string gMaster = "";
                result.Result = GuildManager.GuildMatchingJoinInfo(session.Player.Character, out gName, out gMaster);
                result.MasterName = gMaster;
                result.GuildName = gName;
            }
            catch (Exception ex)
            {
                result.Result = 1;
            }

            await session.SendAsync(result);
        }
        [MessageHandler(typeof(CGuildMatchingJoinCancel))]
        public async Task GuildMatchingJoinCancel(GSSession session)
        {
            int result = await GuildManager.GuildMatchingJoin(session.Player.Character);
            await session.SendAsync(new SGuildMatchingJoin { Result = result });
        }
    }
}


--file MapServerManager.cs
﻿using MU.Network.Auth;
using MU.Resources;
using MuEmu.Entity;
using MuEmu.Resources;
using MuEmu.Resources.XML;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using WebZen.Util;

namespace MuEmu.Network
{
    internal class MapServerManager
    {
        public static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(MapServerManager));

        private MapServerDto mapServerDto;
        private static MapServerManager _instance;

        private MapServerManager(string file)
        {
            mapServerDto = ResourceLoader.XmlLoader<MapServerDto>(file);
        }

        private MSGameServerDto _CantGo(MSGroupDto dto, ushort PreviousGS, Maps map)
        {
            var GS = dto.GameServers
                .Where(x => x.Maps.Any(y => y.ID == map && y.MoveAbleOption) 
                || (x.Default == 1 && !x.Maps.Any(y => y.ID == map)))
                .ToList();

            var pGS = GS.FirstOrDefault(x => x.Code == PreviousGS);
            if (pGS != null)
                return pGS;

            return GS[Program.RandomProvider(GS.Count)];
        }

        private MSGameServerDto _CheckMapServerMove(GSSession session, Maps map)
        {
            var group = mapServerDto.Groups
                .Where(x => x.GameServers.Any(y => y.Code == Program.ServerCode))
                .First();

            var GS = group.GameServers.Where(y => y.Code == Program.ServerCode).First();

            var data = GS.Maps?.FirstOrDefault(x => x.ID == map)??null;

            if(data == null)
            {
                switch(GS.Default)
                {
                    case 0:
                        return _CantGo(group, session.PreviousCode, map);
                    case 1:
                        return GS;
                }
            }
            
            if(data.MoveAbleOption)
                return GS;

            return _CantGo(group, session.PreviousCode, map);            
        }

        public static void Initialize(string file)
        {
            if (_instance != null)
                throw new InvalidOperationException();

            _instance = new MapServerManager(file);
        }

        public static bool CheckMapServerMove(GSSession session, Maps map)
        {
            var NextGS = _instance._CheckMapServerMove(session, map);
            if (NextGS.Code != Program.ServerCode)
            {
                Logger.Information("Map {2} disabled, Moving to other server, [{0}]{3}->[{1}]{4}:{5}", 
                    Program.ServerCode, 
                    NextGS.Code, 
                    map,
                    Program.server.IPAddress,
                    NextGS.IP,
                    NextGS.Port);
                uint[] Auth = {
                    (uint)Program.RandomProvider(int.MaxValue),
                    (uint)Program.RandomProvider(int.MaxValue),
                    (uint)Program.RandomProvider(int.MaxValue),
                    (uint)Program.RandomProvider(int.MaxValue),
                };
                using (var db = new GameContext())
                {
                    var token = $"{Auth[0]:X8}{Auth[1]:X8}{Auth[2]:X8}{Auth[3]:X8}";
                    var acc = db.Accounts.Find(session.Player.Account.ID);
                    acc.AuthToken = token;
                    db.Accounts.Update(acc);
                    db.SaveChanges();
                }
                session.SendAsync(new SServerMove
                {
                    IpAddress = NextGS.IP.GetBytes(),
                    ServerCode = NextGS.Code,
                    ServerPort = NextGS.Port,
                    AuthCode1 = Auth[0],
                    AuthCode2 = Auth[1],
                    AuthCode3 = Auth[2],
                    AuthCode4 = Auth[3],
                }).Wait();
                //session.Disconnect();
                return false;
            }

            return true;
        }
    }
}


--file PCPShopServices.cs
﻿using MU.Network.Game;
using MU.Network.PCPShop;
using MU.Resources;
using MuEmu.Resources;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WebZen.Handlers;

namespace MuEmu.Network
{
    public class PCPShopServices : MessageHandler
    {
        [MessageHandler(typeof(CPCPShopItems))]

        public async Task CPCPShopItems(GSSession session, CPCPShopItems message)
        {
            var its = ResourceCache.Instance.GetPCPointShop().Items;
            var array = from it in ResourceCache.Instance.GetPCPointShop().Items
                        select new PCPShopItemDto
                        {
                            Dur = it.Value.Durability,
                            Exc = it.Value.OptionExe,
                            Index = (byte)it.Value.Number.Index,
                            Opts = (byte)(it.Value.Option28 + (it.Value.Luck?4:0) + it.Value.Plus*8 + (it.Value.Skill ? 128 : 0)),
                            Position = it.Key,
                            Type16 = (byte)((int)it.Value.Number.Type*16),
                            NewOpt1 = it.Value.Slots.Length >= 1 ? it.Value.Slots[0] : SocketOption.None,
                            NewOpt2 = it.Value.Slots.Length >= 2 ? it.Value.Slots[1] : SocketOption.None,
                            NewOpt3 = it.Value.Slots.Length >= 3 ? it.Value.Slots[2] : SocketOption.None,
                            NewOpt4 = it.Value.Slots.Length >= 4 ? it.Value.Slots[3] : SocketOption.None,
                            NewOpt5 = it.Value.Slots.Length >= 5 ? it.Value.Slots[4] : SocketOption.None,
                            unk1 = 0,
                            unk2 = 0,
                        };

            await session.SendAsync(new SPCPShopInfo());
            await session.SendAsync(new SPCPShopItems(array.ToArray()));
        }

        [MessageHandler(typeof(CPCPShopBuy))]
        public async Task CPCPShopBuy(GSSession session, CPCPShopBuy message)
        {
            var PCPS = ResourceCache.Instance.GetPCPointShop();

            var Item = PCPS.Get(message.Position);

            var bResult = new SBuy
            {
                Result = 0xff,
                ItemInfo = Array.Empty<byte>(),
            };

            if(Item.BuyPrice <= session.Player.Character.PCPoints)
            {
                bResult.ItemInfo = Item.GetBytes();
                bResult.Result = session.Player.Character.Inventory.Add(Item);
            }

            await session.SendAsync(bResult);
        }
    }
}


--file QuestSystemServices.cs
﻿using MuEmu.Resources;
using MuEmu.Resources.XML;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using System.Linq;
using WebZen.Handlers;
using MU.Network.QuestSystem;
using MU.Resources;
using MU.Network.Game;
using MuEmu.Monsters;

namespace MuEmu.Network
{
    public class QuestSystemServices : MessageHandler
    {
        private static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(QuestSystemServices));

        [MessageHandler(typeof(CSetQuestState))]
        public async Task CSetQuestState(GSSession session, CSetQuestState message)
        {
            var quests = session.Player.Character.Quests;
            var result = quests.SetState(message.Index);
            var serverState = quests.GetByIndex(message.Index).StateByte;

            await session.SendAsync(new SSetQuestState(message.Index, result, serverState));
        }

        [MessageHandler(typeof(CQuestEXP))]
        public async Task CQuestEXP(GSSession session, CQuestEXP message)
        {
            var @char = session.Player.Character;
            await @char.Quests.QuestEXPInfo(message.Index);
        }

        [MessageHandler(typeof(CQuestEXPProgress))]
        public async Task CQuestEXPProgress(GSSession session, CQuestEXPProgress message)
        {
            var @char = session.Player.Character;
            @char.Quests.QuestEXPSetProgress(message.Index, message.Result);
           await @char.Quests.QuestEXPInfo(message.Index);
        }

        [MessageHandler(typeof(CQuestEXPComplete))]
        public async Task CQuestEXPComplete(GSSession session, CQuestEXPComplete message)
        {
            var @char = session.Player.Character;
            await @char.Quests.QuestEXPCompleted(message.Index);
        }


        [MessageHandler(typeof(CNewQuestInfo))]
        public async Task CNewQuestInfo(GSSession session, CNewQuestInfo message)
        {
            if (message.dwQuestInfoIndexID == 0)
            {
                return;
            }
            var @char = session.Player.Character;
            var quest2 = ResourceLoader.XmlLoader<QuestEXPDto>("./Data/QuestEXP.xml");

            QuestInfoIndex info = message.dwQuestInfoIndexID;// @char.Quests.GetEpisodeByIndex();

            var result = quest2
                .QuestList
                .FirstOrDefault(x => x.QuestInfo.Any(y => y.Episode == info.Episode))?
                .QuestInfo
                .FirstOrDefault(x => x.Episode == info.Episode) ?? null;

            if (result == null)
            {
                await session.SendAsync(new SQuestEXP { Result = 1 });
                return;
            }
            var state = result
                .QuestState
                .Where(x => x.State == info.Switch && (x.Class == @char.BaseClass || x.Class == HeroClass.End))
                .FirstOrDefault();

            if (state == null)
            {
                await session.SendAsync(new SQuestEXP { Result = 1 });
                return;
            }

            byte rewardCount = 0;
            var ask = new AskInfoDto[5];
            var reward = new RewardInfoDto[5];

            for (var i = 0; i < 5; i++)
            {
                ask[i] = new AskInfoDto();
                reward[i] = new RewardInfoDto();
            }

            if (state.RewardEXP > 0)
            {
                reward[rewardCount].Type = RewardType.Exp;
                reward[rewardCount].Value = state.RewardEXP;
                rewardCount++;
            }

            if (state.RewardGENS > 0)
            {
                reward[rewardCount].Type = RewardType.Point;
                reward[rewardCount].Value = state.RewardGENS;
                rewardCount++;
            }

            if (state.RewardZEN > 0)
            {
                reward[rewardCount].Type = RewardType.Zen;
                reward[rewardCount].Value = state.RewardZEN;
                rewardCount++;
            }

            byte askCount = 0;
            switch (state.Type)
            {
                case AskType.Tutorial:
                    ask[askCount].Type = state.Type;
                    break;
                case AskType.Item:
                    foreach (var it in state.Item)
                    {
                        var item = new Item(ItemNumber.FromTypeIndex(it.Type, it.Index), Options: new { Plus = it.Level });

                        var list = @char.Inventory.FindAllItems(ItemNumber.FromTypeIndex(it.Type, it.Index))
                        .Where(x => x.Plus == it.Level && it.Skill == x.Skill && it.Option == x.Option28 && it.Excellent == x.OptionExe);

                        ask[askCount].Type = state.Type;
                        ask[askCount].ItemInfo = item.GetBytes();
                        ask[askCount].CurrentValue = (uint)list.Count();
                        ask[askCount].Value = it.Count;
                        askCount++;
                    }
                    break;
                case AskType.Monster:
                    var infoM = @char.Quests.GetEpisode<QuestInfoMonster>((int)info.Episode, info.Switch);
                    infoM.Type = state.Type;
                    foreach (var it in state.Monster)
                    {
                        ask[askCount].Type = state.Type;
                        ask[askCount].Index = it.Index;
                        ask[askCount].CurrentValue = infoM.Current;
                        ask[askCount].Value = it.Count;
                        infoM.MonsterClass = it.Index;
                        askCount++;
                    }
                    break;
            }
            await session.SendAsync(new SSendQuestEXPInfo
            {
                dwQuestInfoIndexID = QuestInfoIndex.FromEpisodeSwitch(info.Episode, info.Switch),
                AskCnt = askCount,
                RandRewardCnt = 0,
                RewardCnt = rewardCount,
                Asks = ask,
                Rewards = reward,
            });
        }

        [MessageHandler(typeof(CQuestEXPProgressList))]
        public async Task CQuestEXPProgressList(GSSession session)
        {
            await session.SendAsync(new SQuestEXPProgressList
            {
                QuestInfoIndexID = session.Player.Character.Quests.QuestEXPProgressList()
            });
        }

        [MessageHandler(typeof(CQuestEXPEventItemEPList))]
        public async Task CQuestEXPEventItemEPList(GSSession session)
        {
            var @char = session.Player.Character;
            if(@char.BaseClass == HeroClass.DarkLord || @char.BaseClass == HeroClass.MagicGladiator || @char.BaseClass == HeroClass.RageFighter)
            {
                return;
            }
            var rings = session.Player.Character.Inventory.FindAllItems(ItemNumber.FromTypeIndex(13, 20)).Where(x => x.Plus == 1 || x.Plus == 2);
            if (@char.Level >= 80 || rings.Any())
            {
                return;
            }

            var qs = @char.Quests.GetEpisodeState(1);

            if(qs < 3)
            {
                var q = @char.Quests.GetEpisode<QuestInfoIndex>(1,0);
                await session.SendAsync(new SQuestSwitchListEvent
                {
                    QuestList = new uint[] { q.Index },
                });
            }
        }

        [MessageHandler(typeof(CQuestNPCTalk))]
        public async Task CQuestNPCTalk(GSSession session, CQuestNPCTalk message)
        {
            var npc = session.Player.Window as Monster;
            var list = session.Player.Character.Quests
                .EXPListNPC(npc.Info.Monster)
                .Select(x => new QuestNPCTalkDto { QuestInfoIndex = x, State = x.Switch==0? QuestState.Clear : x.Switch == 65535 ? QuestState.Complete : QuestState.Reg })
                .ToList();

            //list.Add(new QuestNPCTalkDto { QuestInfoIndex = QuestInfoIndex.FromEpisodeSwitch(1, 1), State = QuestState.Clear });
            //list.Add(new QuestNPCTalkDto { QuestInfoIndex = QuestInfoIndex.FromEpisodeSwitch(2, 1), State = QuestState.Clear });
            list.Add(new QuestNPCTalkDto { QuestInfoIndex = QuestInfoIndex.FromEpisodeSwitch(0, 0), State = QuestState.Clear });

            await session.SendAsync(new SQuestNPCTalk
            {
                QuestList = list.ToArray()
            });
        }

        [MessageHandler(typeof(CQuestNPCAccept))]
        public async Task CQuestNPCAccept(GSSession session, CQuestNPCAccept message)
        {
            var @char = session.Player.Character;
            @char.Quests.QuestEXPSetProgress(message.QuestInfoIndex, 1);
            await session.SendAsync(new SQuestNPCAccept { QuestInfoIndex = message.QuestInfoIndex, Result = 0 });
        }

        [MessageHandler(typeof(CCentMove))]
        public async Task CentMove(GSSession session)
        {
            await session.Player.Character.WarpTo(537);
        }

        [MessageHandler(typeof(CCentTestStart))]
        public async Task CentTestStart(GSSession session)
        {
            var @char = session.Player.Character;
            var party = @char.Party;

            var q6 = @char.Quests.GetByIndex(6);
            if (q6 == null || q6.State != QuestState.Complete || @char.MapID != Maps.LabyrinthEntrance)
            {
                return;
            }

            var instance = Quest4th.GetInfo(session.Player);
            instance.State = 1;

            if (party != null)
            {
                var inPlace = party.Members
                    .Where(x => x.Character.MapID == Maps.LabyrinthEntrance)
                    .Where(x => (x.Character.Quests.GetByIndex(6)?.State??QuestState.Clear) == QuestState.Complete)
                    .ToList();

                inPlace.ForEach(x => _=x.Character.WarpTo(540));
            }
            else
            {
                await @char.WarpTo(540);
            }
        }

        [MessageHandler(typeof(CCentBattleStart))]
        public async Task CentBattleStart(GSSession session)
        {
            var instance = Quest4th.GetInfo(session.Player);
            var q = session.Player.Character.Quests.Find(766);
            switch (q.Index)
            {
                case 7:
                    instance.State = 2;
                    break;
                case 8:
                    instance.State = 5;
                    break;
                case 9:
                    instance.State = 8;
                    break;
            }
            
        }
    }
}


--file WZGameServer.cs
﻿using System;
using System.Collections.Generic;
using System.Net;
using System.Text;
using WebZen.Network;
using WebZen.Handlers;
using WebZen.Util;
using System.Threading.Tasks;
using System.Linq;
using MuEmu.Entity;
using Serilog;
using Serilog.Core;
using MuEmu.Monsters;
using MU.Resources;
using MU.Network.Auth;
using MuEmu.Network.ConnectServer;
using MU.Network;

namespace MuEmu.Network
{
    internal class WZServerEventArgs : EventArgs
    {
        public GSSession session { get; set; }
    }
    internal class WZGameServer : WZServer
    {
        public string ClientVersion { get; set; }
        public string ClientSerial { get; set; }
        public IEnumerable<GSSession> Clients => _clients.Values.Select(x => x as GSSession);


        /// <summary>
        /// Sender as Server, WZServerEventArgs with GSSession
        /// </summary>
        public event EventHandler<WZServerEventArgs> Connect;
        /// <summary>
        /// Sender as Server, WZServerEventArgs with GSSession
        /// </summary>
        public event EventHandler<WZServerEventArgs> Disconnect;

        public WZGameServer(IPEndPoint address, MessageHandler[] handler, MessageFactory[] factories, bool useRijndael)
        {
            Initialize(address, handler, new GSSessionFactory(), factories, useRijndael);
        }

        protected override void OnConnect(WZClient session)
        {
            var Session = session as GSSession;

            Session.Player = new Player(Session);

            var msg = VersionSelector.CreateMessage<SJoinResult>((byte)1, Session.ID, ClientVersion);
            _ = Session.SendAsync(msg);

            Connect?.Invoke(this, new WZServerEventArgs { session = Session });
        }

        public override void OnDisconnect(WZClient session)
        {
            var Session = session as GSSession;
            if (Session.Player != null)
            {
                if (Session.Player.Character != null)
                {
                    Program.client
                        .SendAsync(new SCRem
                        {
                            Server = (byte)Program.ServerCode,
                            List = new CliRemDto[] {
                                new CliRemDto {
                                    btName = Session.Player.Character.Name.GetBytes()
                                }
                            }
                        });

                    PartyManager.CancelMatching(Session.Player);
                }
                Session.Player.Status = LoginStatus.NotLogged;

                using (var db = new GameContext())
                {
                    if (Session.Player.Account != null)
                    {
                        var acc = (from a in db.Accounts
                                   where a.AccountId == Session.Player.Account.ID
                                   select a).First();

                        acc.IsConnected = false;

                        db.Accounts.Update(acc);
                        db.SaveChanges();
                        Logger.ForAccount(Session).Information("Disconnecting...");
                    }
                }
                if(Session.Player != null)
                    Session.Player.Account = null;
            }
            //db.SaveChanges();

            Session.Player = null;
            base.OnDisconnect(session);
            Disconnect?.Invoke(this, new WZServerEventArgs { session = Session });
        }

        public async Task SendAll(object message)
        {
            foreach(var cl in _clients.Values.Select(x => x as GSSession).Where(x => x.Player.Status == LoginStatus.Playing))
                await cl.SendAsync(message);
        }
    }
}


--file .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


--file MuEmu.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("MuEmu")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("0.1.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("0.1.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("MuEmu")]
[assembly: System.Reflection.AssemblyTitleAttribute("MuEmu")]
[assembly: System.Reflection.AssemblyVersionAttribute("0.1.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file .NETCoreApp,Version=v3.1.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v3.1", FrameworkDisplayName = ".NET Core 3.1")]


--file MuEmu.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("MuEmu")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("0.1.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("0.1.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("MuEmu")]
[assembly: System.Reflection.AssemblyTitleAttribute("MuEmu")]
[assembly: System.Reflection.AssemblyVersionAttribute("0.1.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


--file MuEmu.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("MuEmu")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("0.1.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("0.1.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("MuEmu")]
[assembly: System.Reflection.AssemblyTitleAttribute("MuEmu")]
[assembly: System.Reflection.AssemblyVersionAttribute("0.1.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file Party.cs
﻿using MuEmu.Network.Data;
using MU.Network.Game;
using MuEmu.Util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using MU.Resources;
using MU.Network;

namespace MuEmu
{
    internal class PartyMatching
    {
        public Player Player { get; set; }
        public string Text { get; set; }
        public string Password { get; set; }
        public bool AutAccept { get; set; }
        public ushort MinLevel { get; set; }
        public ushort MaxLevel { get; set; }
        public bool EnergyElf { get; set; }
        public List<Player> Waiting { get; set; } = new List<Player>();

        public bool CanJoin(Character @char)
        {
            if (@char.Level < MinLevel || @char.Level > MaxLevel)
                return false;

            if (Player.Character.Party != null && Player.Character.Party.Count >= 5)
                return false;

            return true;
        }

        internal int TryJoin(Player plr, string password)
        {
            if (Password != password)
                return -1;

            if (AutAccept)
            {
                PartyManager.CreateLink(Player, plr);
            }
            else
            {
                Waiting.Add(plr);
                _ = Player.Session.SendAsync(new SPartyMJoinNotify());
            }

            return 0;
        }
    }
    public class PartyManager
    {
        private static PartyManager _instance;
        private List<Party> _parties = new List<Party>();
        private List<PartyMatching> _partyMatchings = new List<PartyMatching>();
        public static ushort MaxLevelDiff { get; private set; }

        public static void Initialzie(ushort maxLevelDiff)
        {
            if(_instance == null)
                _instance = new PartyManager();

            MaxLevelDiff = maxLevelDiff;
        }

        public static PartyResults CreateLink(Player master, Player member)
        {
            if(Math.Abs(master.Character.Level - member.Character.Level) > MaxLevelDiff)
            {
                return PartyResults.RestrictedLevel;
            }

            if(member.Character.Party != null)
            {
                return PartyResults.InAnotherParty;
            }

            var party = master.Character.Party;

            if (party == null)
            {
                party = new Party(master, member);
                _instance._parties.Add(party);
                SendAll(party);
                return PartyResults.Success;
            }

            if(party.Count == 5)
            {
                return PartyResults.Fail;
            }

            party.Add(member);
            SendAll(party);
            return PartyResults.Success;
        }

        public static void SendAll(Party party)
        {
            if (party == null)
                return;

            var members = party.Members.Select(x => x.Session);
            var basetype = Program.Season switch
            {
                ServerSeason.Season9Eng => typeof(PartyS9Dto),
                ServerSeason.Season16Kor => typeof(PartyS16Dto),
                _ => typeof(PartyDto),
            };

            var list = party.List(basetype);
            var msg = VersionSelector.CreateMessage<SPartyList>(list);
            members.SendAsync(msg);
        }

        public static void Remove(Player plr)
        {
            var party = plr.Character.Party;
            if (party == null)
                return;

            party.Remove(plr);
            if(party.Count == 1)
            {
                party.Close();
                _instance._parties.Remove(party);
                return;
            }

            SendAll(party);
        }

        internal static void CreateMatching(Player plr, string text, string password, bool autAccept, ushort minLevel, ushort maxLevel, bool energyElf)
        {
            _instance._partyMatchings.Add(new PartyMatching
            {
                AutAccept = autAccept,
                EnergyElf = energyElf,
                MaxLevel = maxLevel,
                MinLevel = minLevel,
                Password = password,
                Player = plr,
                Text = text
            });
        }

        internal static bool ExistsMatching(Player plr)
        {
            return _instance._partyMatchings.Any(x => x.Player == plr);
        }

        internal static List<PartyMatching> GetMatchings()
        {
            return _instance._partyMatchings;
        }

        internal static int CancelMatching(Player player)
        {
            try
            {
                if (!_instance._partyMatchings.Any(x => x.Player == player))
                {
                    var matching = _instance._partyMatchings.First(x => x.Waiting.Any(y => y == player));
                    matching.Waiting.Remove(player);
                    _=matching.Player.Session.SendAsync(new SPartyMJoinNotify());
                }
                else
                {
                    var matching = _instance._partyMatchings.First(x => x.Player == player);
                    _instance._partyMatchings.Remove(matching);
                }
                return 0;
            }catch(Exception)
            {
                return -1;
            }
        }
    }

    public class Party
    {
        List<Player> _members;

        public ushort MaxLevel => _members.Max(x => x.Character.Level);

        public Player Master => _members.First();
        public int Count => _members.Count();

        public IEnumerable<Player> Members => _members;

        internal Party(Player plr, Player memb)
        {
            _members = new List<Player>
            {
                plr,
                memb,
            };

            plr.Character.Party = this;
            memb.Character.Party = this;

            LifeUpdate();
        }

        internal bool Any(Player plr)
        {
            return _members.Any(x => x == plr);
        }

        internal bool Add(Player plr)
        {
            if (_members.Count == 5)
                return false;

            _members.Add(plr);
            LifeUpdate();
            return true;
        }

        internal bool Remove(Player plr)
        {
            if (!Any(plr))
                return false;

            _members.Remove(plr);
            plr.Character.Party = null;
            plr.Session.SendAsync(new SPartyDelUser()).Wait();
            LifeUpdate();

            return true;
        }

        internal void Close()
        {
            var del = new SPartyDelUser();
            foreach (var memb in Members)
            {
                memb.Session.SendAsync(del).Wait();
                memb.Character.Party = null;
            }

            _members.Clear();
        }

        public IEnumerable<IPartyDto> List(Type baseType)
        {
            byte i = 0;
            foreach(var m in _members)
            {
                var @char = m.Character;
                var obj = Activator.CreateInstance(baseType) as IPartyDto;
                obj.Set(i++,
                    @char.Name,
                    @char.MapID,
                    (byte)@char.Position.X,
                    (byte)@char.Position.Y,
                    (int)@char.Health,
                    (int)@char.MaxHealth,
                    (int)@char.Mana,
                    (int)@char.MaxMana,
                    Program.ServerCode + 1,
                    0);
                yield return obj;
            }
        }

        public async void LifeUpdate()
        {
            var msg = new SPartyLifeAll();

                msg.PartyLives = _members.Select(x => new SPartyLife
                {
                    Name = x.Character.Name,
                    Life = (byte)((float)x.Character.Health / (float)x.Character.MaxHealth * 255.0f),
                    Mana = (byte)((float)x.Character.Mana / (float)x.Character.MaxMana * 255.0f),
                }).ToArray();

            await _members
                .Select(x => x.Session)
                .SendAsync(msg);
        }

        public async void ExpDivision(ushort TargetID, float EXP, Player killer, ushort dmg)
        {
            EXP *= _members.Count * 0.01f + 1.0f;
            var totalLevel = _members.Sum(x => x.Character.Level);

            foreach(var plr in _members)
            {
                var subEXP = (long)(EXP * plr.Character.Level / totalLevel);
                plr.Character.Experience += subEXP;
                await plr.Session.SendAsync(new SKillPlayer(TargetID, (ushort)subEXP, killer == plr ? dmg : (ushort)0));
            }
        }
    }
}


--file PathFinding.cs
﻿using MU.Resources;
using MuEmu.Resources.Map;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;

namespace MuEmu
{
    public class PathFinding
    {
        private Point _start;
        private Point _end;
        private List<Tile> _tiles = new List<Tile>();
        private MapInfo _map;
        private MapAttributes[] _cantWalkOn;
        private Tile _subtile;
        public PathFinding(Point start, Point end, MapInfo map, MapAttributes[] cantWalkOn = null)
        {
            _start = start;
            _end = end;
            _map = map;
            _cantWalkOn = cantWalkOn;
            if (_cantWalkOn == null)
                _cantWalkOn = new MapAttributes[] { MapAttributes.Hide, MapAttributes.NoWalk };
        }

        public bool FindPath()
        {
            var tile = new Tile(_start);
            _subtile = SubTile(tile);
            return _subtile != null;
        }

        private Tile SubTile(Tile tile)
        {
            tile.Closed = true;

            for(var y = Math.Max(tile.Position.Y - 1, 0); y <= Math.Min(tile.Position.Y + 1, 255); y++)
            {
                for (var x = Math.Max(tile.Position.X - 1, 0); x <= Math.Min(tile.Position.X + 1, 255); x++)
                {
                    if (_map.ContainsAny(x, y, _cantWalkOn))
                        continue;
                    if (x == tile.Position.X && y == tile.Position.Y)
                        continue;

                    var H = (Math.Abs(_end.X - x) + Math.Abs(_end.Y - y)) * 10;
                    var stile = new Tile(new Point(x,y), tile, H);

                    if (stile.F == Tile.MaxF)
                        return null;

                    if (H == 0)
                        return stile;

                    var exist = _tiles.Any(f => f.Position.X == x && f.Position.Y == y);
                    if(!exist)
                    {
                        _tiles.Add(stile);
                    }
                }
            }

            foreach(var otile in _tiles.Where(x => !x.Closed).ToList())
            {
                var rtile = SubTile(otile);
                if (rtile != null)
                    return rtile;
            }

            return null;
        }

        public List<Point> GetPath()
        {
            var rList = new List<Point>();
            var endTile = _subtile;

            do
            {
                rList.Add(endTile.Position);
                var next = endTile.Parent;
                endTile = next;
            } while (endTile != null);
            rList.Reverse();

            return rList;
        }
    }

    class Tile
    {
        public const int MaxF = 100; //25555
        public int H { get; private set; }
        public int G { get; private set; }
        public int F => Math.Min(G + H, MaxF);
        public Point Position { get; private set; }
        public Tile Parent { get; private set; }
        public bool Closed { get; set; }
        public Tile(Point pt, Tile parent = null, int h = 0)
        {
            Position = pt;
            H = h;
            Parent = parent;

            if(parent != null)
                G = parent.G + ((pt.Y == parent.Position.Y || pt.X == parent.Position.X) ? 10 : 14);
        }
    }
}


--file Pentagrama.cs
﻿using MU.Resources;
using MU.Resources.XML;
using MuEmu.Monsters;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu
{
    public class Pentagrama
    {
        private static ILogger _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(Pentagrama));
        private static Pentagrama _instance;
        private Dictionary<Element, int> _rates = new Dictionary<Element, int>()
        {
            { Element.Fire, 2000 },
            { Element.Water, 4000 },
            { Element.Earth, 6000 },
            { Element.Wind, 8000 },
            { Element.Dark, 10000 },
        };
        // Element vs Element
        private Dictionary<Element, Dictionary<Element, float>> _elementDmgTable =
            new Dictionary<Element, Dictionary<Element, float>>
        {
            { Element.Fire, new Dictionary<Element, float>
                {
                    { Element.None, 1.2f }, { Element.Fire, 1.0f }, {Element.Water, 0.8f}, {Element.Earth, 0.9f }, {Element.Wind, 1.1f }, {Element.Dark, 1.2f }
                }
            },
            { Element.Water, new Dictionary<Element, float>
                {
                    { Element.None, 1.2f }, { Element.Fire, 1.2f }, {Element.Water, 1.0f}, {Element.Earth, 0.8f }, {Element.Wind, 0.9f }, {Element.Dark, 1.1f }
                }
            },
            { Element.Earth, new Dictionary<Element, float>
                {
                    { Element.None, 1.2f }, { Element.Fire, 1.1f }, {Element.Water, 1.2f}, {Element.Earth, 1.0f }, {Element.Wind, 0.8f }, {Element.Dark, 0.9f }
                }
            },
            { Element.Wind, new Dictionary<Element, float>
                {
                    { Element.None, 1.2f }, { Element.Fire, 0.9f }, {Element.Water, 1.1f}, {Element.Earth, 1.2f }, {Element.Wind, 1.0f }, {Element.Dark, 0.8f }
                }
            },
            { Element.Dark, new Dictionary<Element, float>
                {
                    { Element.None, 1.2f }, { Element.Fire, 0.8f }, {Element.Water, 0.9f}, {Element.Earth, 1.1f }, {Element.Wind, 1.2f }, {Element.Dark, 1.0f }
                }
            }
        };
        private PentagramaDto _Info;

        private Pentagrama()
        {
            _Info = Resources.ResourceLoader.XmlLoader<PentagramaDto>("./Data/PentagramaItems.xml");
            _logger.Information("Initialized");
            foreach(var mob in _Info.Monsters)
            {
                ushort rated = 0;
                foreach(var it in mob.Items)
                {
                    rated += it.Rate;
                    it.Rate = rated;
                }
            }

            var _openRateMax = 0;
            foreach(var socket in _Info.Sockets)
            {
                _openRateMax += socket.OpenRate;
                socket.OpenRate = _openRateMax;
                var rated = 0;
                foreach (var rate in socket.Rates)
                {
                    rated += rate.Set;
                    rate.Set = rated;
                }
            }
        }

        public static void Initialize()
        {
            if (_instance != null)
                throw new InvalidOperationException();

            _instance = new Pentagrama();
        }

        public static Element GetElement()
        {
            var rand = Program.RandomProvider(10000);

            foreach (var e in _instance._rates)
            {
                if (e.Value > rand)
                    return e.Key;
            }

            return Element.None;
        }

        public static int GetSockets()
        {
            var top = _instance._Info.Sockets.Max(x => x.OpenRate);
            var result = _instance._Info
                .Sockets
                .Where(x => x.OpenRate >= Program.RandomProvider(top))
                .FirstOrDefault();

            if (result == null)
                return -1;

            top = result.Rates.Max(x => x.Set);
            var result2 = result.Rates
                .Where(x => x.Set >= Program.RandomProvider(top))
                .FirstOrDefault();

            if(result2 == null)
            {
                return -1;
            }

            if(result2.Slot2 != 100 && result2.Slot2 <= Program.RandomProvider(100))
            {
                return 1;
            }

            if (result2.Slot3 != 100 && result2.Slot3 <= Program.RandomProvider(100))
            {
                return 2;
            }

            if (result2.Slot4 != 100 && result2.Slot4 <= Program.RandomProvider(100))
            {
                return 3;
            }

            if (result2.Slot5 != 100 && result2.Slot5 <= Program.RandomProvider(100))
            {
                return 4;
            }

            return 5;
        }

        public static Item Drop(Monster mob)
        {
            var result = _instance.
                _Info
                .Monsters
                .Where(x => x.Number == mob.Info.Monster)
                .FirstOrDefault();

            if (result == null)
                return null;

            if (Program.RandomProvider(100) > result.Rate)
                return null;

            var top = result.Items.Max(x => x.Rate);

            var itResult = result
                .Items
                .Where(x => x.Rate >= Program.RandomProvider(top))
                .Select(x => new Item(x.Number))
                .FirstOrDefault();

            if (itResult == null)
                return null;

            itResult.PentagramaMainAttribute = GetElement();
            var sockets = GetSockets();
            if (sockets >0)
            {
                itResult.Slots = new SocketOption[sockets];
                for (var i = 0; i < sockets; i++)
                {
                    itResult.Slots[i] = SocketOption.EmptySocket;
                }
            }
            _logger.Information("Item drop {0}", itResult);
            return itResult;
        }

        public static float GetElementalFactor(Element source, Element target)
        {
            if (source == Element.None)
                return 0f;

            return _instance._elementDmgTable[source][target];
        }
    }
}


--file Player.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using MuEmu.Network;
using MuEmu.Security;
using MU.DataBase;
using System.Threading.Tasks;
using MuEmu.Entity;
using MU.Resources;
using MuEmu.Monsters;
using MuEmu.Network.GameServices;

namespace MuEmu
{
    public class Player
    {
        private LoginStatus _loginStatus;
        /// <summary>
        /// Session ID or Connection ID
        /// </summary>
        public ushort ID => (ushort)Session.ID;
        public Account Account { get; set; }

        public Character Character { get; set; }

        /// <summary>
        /// Connection Status on GS, NotLogged - Logged - Playing
        /// </summary>
        public LoginStatus Status { get => _loginStatus; set
            {
                if (_loginStatus == value)
                    return;
                _loginStatus = value;
                OnStatusChange?.Invoke(this, new EventArgs());
            }
        }

        public GameCheckSum CheckSum { get; set; }

        /// <summary>
        /// Connection pipeline
        /// </summary>
        public GSSession Session { get; set; }

        public object Window { get; set; }
        public object Killer { get; internal set; }
        public Gens Gens { get; internal set; }

        public Player(GSSession session)
        {
            Session = session;
            Status = LoginStatus.NotLogged;
            OnStatusChange += Player_OnStatusChange;
        }

        private void Player_OnStatusChange(object sender, EventArgs e)
        {
            var plr = sender as Player;
            switch(_loginStatus)
            {
                case LoginStatus.NotLogged:
                case LoginStatus.Logged:
                    GameServices.CCloseWindow(Session);
                    var @char = plr.Character;

                    using (var db = new GameContext())
                    {
                        if(plr.Account != null) plr.Account.Save(db).Wait();
                        if (@char != null)
                        {
                            @char.Save(db).Wait();
                            @char.Dispose();
                        }
                        db.SaveChanges();
                    }

                    plr.Character = null;
                    break;
            }
        }

        public void SetAccount(AccountDto acc)
        {
            Account = new Account(this, acc);
            CheckSum = new GameCheckSum(this);
            Status = LoginStatus.Logged;
        }

        /// <summary>
        ///  Send message to all player in this player View Port
        /// </summary>
        /// <param name="message">Any WZContract message</param>
        /// <param name="exclude">Player excluded</param>
        /// <returns></returns>
        public void SendV2Message(object message, Player exclude = null)
        {
            if (Status != LoginStatus.Playing)
                return;

            Character.SendV2Message(message, exclude);
        }

        public async Task Save(GameContext db)
        {
            if (Account != null) await Account.Save(db);
            if(Character != null) await Character.Save(db);
            await db.SaveChangesAsync();
        }

        /// <summary>
        /// Sender Player
        /// </summary>
        public event EventHandler OnStatusChange;

        public override string ToString()
        {
            return $"{Account?.ID??0}{Account?.Nickname??""}:{Character?.Name??""}";
        }
    }
}


--file Program.cs
﻿using BlubLib.Serialization;
using MuEmu.Resources;
using Serilog;
using Serilog.Formatting.Json;
using System;
using System.IO;
using System.Net;
using WebZen.Handlers;
using WebZen.Network;
using WebZen.Serialization;
using MuEmu.Resources.XML;
using MuEmu.Monsters;
using WebZen.Util;
using MuEmu.Events.LuckyCoins;
using MuEmu.Events.EventChips;
using MuEmu.Events.BloodCastle;
using System.Threading.Tasks;
using MuEmu.Entity;
using System.Linq;
using MuEmu.Events.DevilSquare;
using MuEmu.Events;
using MuEmu.Util;
using MuEmu.Events.Kanturu;
using MuEmu.Events.ChaosCastle;
using MuEmu.Resources.BMD;
using Serilog.Sinks.File;
using MuEmu.Resources.Game;
using Serilog.Core;
using MuEmu.Events.Crywolf;
using MuEmu.Events.ImperialGuardian;
using MuEmu.Events.DoubleGoer;
using MuEmu.Network;
using MU.Network.CashShop;
using MU.Network.Auth;
using MU.Network.Global;
using MU.Network.Game;
using MU.Network.Event;
using MU.Network.Guild;
using MU.Network.AntiHack;
using MU.Network.PCPShop;
using MU.Network.GensSystem;
using MU.Network.QuestSystem;
using MU.Network;
using MU.Resources;
using MU.Resources.Game;
using MU.Resources.BMD;
using MuEmu.Network.ConnectServer;
using System.Collections.Generic;
using Newtonsoft.Json;
using System.Text.RegularExpressions;
using System.Threading;
using MuEmu.Events.MoonRabbit;
using MuEmu.Game;
using MuEmu.Events.WhiteWizard;
using MuEmu.Network.GameServices;
using MuEmu.Events.Event_Egg;
using MuEmu.Events.Minigames;
using MuEmu.Events.CastleSiege;
using MuEmu.Events.Raklion;
using MuEmu.Events.AcheronGuardian;
using Serilog.Events;
using static System.Net.Mime.MediaTypeNames;

namespace MuEmu
{
    class Program
    {
        private static Random s_rand = new Random();

        public static CommandHandler<GSSession> Handler { get; } = new CommandHandler<GSSession>();
        public static WZGameServer server;
        public static CSClient client;
        public static string ConnectionString { get; set; }
        public static bool AutoRegistre { get; set; }
        public static ushort ServerCode { get; set; }
        public static int ServerGroup => ServerCode / 20;
        //public static float Experience { get; set; }
        public static ExpManagement Experience { get; } = new ExpManagement();
        public static float Zen { get; set; }
        public static int DropRate { get; set; }
        public static ServerSeason Season { get; set; }
        public static string Name { get; set; }
        public static IEnumerable<MU.Network.Auth.ServerDto> ServerList { get; internal set; }

        public static EventManagement EventManager;
        public static GlobalEvents GlobalEventsManager;
        public static GoldenInvasion GoldenInvasionManager;

        public static ServerInfoDto XMLConfiguration;

        private static bool NewEncode(ServerSeason season) => season switch
        {
            ServerSeason.Season6Kor => false,
            ServerSeason.Season9Eng => true,
            ServerSeason.Season12Eng => true,
            ServerSeason.Season16Kor => true,
            ServerSeason.Season17Kor => true,
            ServerSeason.Season17Kor75 => true,
            _ => throw new NotImplementedException()
        };

        static void Main(string[] args)
        {
            Predicate<GSSession> MustNotBeLoggedIn = session => session.Player.Status == LoginStatus.NotLogged;
            Predicate<GSSession> MustBeLoggedIn = session => (session.Player?.Status??LoginStatus.NotLogged) == LoginStatus.Logged;
            Predicate<GSSession> MustBePlaying = session => session.Player.Status == LoginStatus.Playing;
            Predicate<GSSession> MustBeLoggedOrPlaying = session => session.Player.Status == LoginStatus.Logged || session.Player.Status == LoginStatus.Playing;
            Predicate<GSSession> MustBeGameMaster = session => (session.Player.Character.CtlCode&ControlCode.GameMaster) != 0;
            Predicate<GSSession> MustBeInTrade = session => session.Player.Window is GSSession;

            string output = "{Timestamp: HH:mm:ss} [{Level} {SourceContext}][{AID}:{AUser}] {Message}{NewLine}{Exception}";

            AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;

            Log.Logger = new LoggerConfiguration()
                .Destructure.ByTransforming<IPEndPoint>(endPoint => endPoint.ToString())
                .Destructure.ByTransforming<EndPoint>(endPoint => endPoint.ToString())
                .WriteTo.Map(
                le => new Tuple<DateTime, LogEventLevel>(new DateTime(le.Timestamp.Year, le.Timestamp.Month, le.Timestamp.Day), le.Level),
                (key,log) => log.File($"Logs/{key.Item1:yyyy-MM}/{key.Item2}GameServer_.txt", rollingInterval: RollingInterval.Day), sinkMapCountLimit: 1)
                .WriteTo.Console(outputTemplate: output)
                .MinimumLevel.Debug()
                .CreateLogger();

            ServerMessages.Initialize();
            ServerMessages.LoadMessages("./Data/Lang/ServerMessages(es).xml");

            if (!File.Exists("./Server.xml"))
            {
                Log.Logger.Error(ServerMessages.GetMessage(Messages.Server_Cfg));
                ResourceLoader.XmlSaver("./Server.xml", new ServerInfoDto());
                Task.Delay(10000);
                return;
            }

            var xml = ResourceLoader.XmlLoader<ServerInfoDto>("./Server.xml");
            XMLConfiguration = xml;
            ServerMessages.LoadMessages($"{xml.Files.DataRoot}Lang/ServerMessages({xml.Lang}).xml");

            Name = xml.Name;
            Console.Title = ServerMessages.GetMessage(Messages.Server_Title, xml.Code, xml.Name, xml.Client.Version, xml.Client.Serial, xml.Database.DataBase, xml.Season);

            ConnectionString = $"Server={xml.Database.DBIp};port=3306;Database={xml.Database.DataBase};user={xml.Database.BDUser};password={xml.Database.DBPassword};Convert Zero Datetime=True;";

            GameContext.ConnectionString = ConnectionString;
            SimpleModulus.LoadDecryptionKey(xml.Files.DataRoot + "Dec1.dat");
            SimpleModulus.LoadEncryptionKey(xml.Files.DataRoot + "Enc2.dat");
            
            var ip = new IPEndPoint(IPAddress.Parse(xml.Connection.IP), xml.Connection.Port);
            var csIP = new IPEndPoint(IPAddress.Parse(xml.Connection.ConnectServerIP), 44405);
            AutoRegistre = xml.AutoRegister;
            ServerCode = (ushort)xml.Code;
            Experience.BaseExpRate = xml.GamePlay.Experience / 100.0f;
            Experience.GoldChannel = xml.GamePlay.GoldExperience / 100.0f;
            Zen = xml.GamePlay.Zen;
            DropRate = xml.GamePlay.DropRate;
            Season = xml.Season;

            VersionSelector.Initialize(xml.Season);

            var mh = new MessageHandler[] {
                new FilteredMessageHandler<GSSession>()
                    .AddHandler(new AuthServices())
                    .AddHandler(new GlobalServices())
                    .AddHandler(new GameServices())
                    .AddHandler(new CashShopServices())
                    .AddHandler(new EventServices())
                    .AddHandler(new QuestSystemServices())
                    .AddHandler(new GuildServices())
                    .AddHandler(new AntiHackServices())
                    .AddHandler(new PCPShopServices())
                    .AddHandler(new GensServices())
                    .RegisterRule<CIDAndPass>(MustNotBeLoggedIn)
                    .RegisterRule<CCharacterList>(MustBeLoggedIn)
                    .RegisterRule<CCharacterMapJoin>(MustBeLoggedIn)
                    .RegisterRule<CCharacterMapJoin2>(MustBeLoggedIn)
                    .RegisterRule<CCloseWindow>(MustBePlaying)
                    .RegisterRule<CDataLoadOK>(MustBePlaying)
                    .RegisterRule<CAction>(MustBePlaying)
                    .RegisterRule<CWarehouseMoney>(MustBePlaying)
                    .RegisterRule<CTradeResponce>(MustBeInTrade)
                    .RegisterRule<CAcheronEnterReq>(MustBePlaying)
                    .RegisterRule<CAcheronEventEnter>(MustBePlaying)
                    .RegisterRule<CAttack>(MustBePlaying)
                    .RegisterRule<CAttackS5E2>(MustBePlaying)
                    .RegisterRule<CBeattack>(MustBePlaying)
                    .RegisterRule<CBeattackS9>(MustBePlaying)
                    .RegisterRule<CBloodCastleMove>(MustBePlaying)
                    .RegisterRule<CBuy>(MustBePlaying)
                    .RegisterRule<CCashInventoryItem>(MustBePlaying)
                    .RegisterRule<CCashItemBuy>(MustBePlaying)
                    .RegisterRule<CCashOpen>(MustBePlaying)
                    .RegisterRule<CCashPoints>(MustBePlaying)
                    .RegisterRule<CChaosBoxItemMixButtonClick>(MustBePlaying)
                    .RegisterRule<CChaosBoxItemMixButtonClickS5>(MustBePlaying)
                    .RegisterRule<CChaosBoxUseEnd>(MustBePlaying)
                    .RegisterRule<CChaosCastleMove>(MustBePlaying)
                    .RegisterRule<CCharacterCreate>(MustBeLoggedIn)
                    .RegisterRule<CCharacterDelete>(MustBeLoggedIn)
                    .RegisterRule<CChatNickname>(MustBePlaying)
                    .RegisterRule<CChatNumber>(MustBePlaying)
                    .RegisterRule<CChatWhisper>(MustBePlaying)
                    .RegisterRule<CCheckSum>(MustBePlaying)
                    .RegisterRule<CClientClose>(MustBeLoggedOrPlaying)
                    .RegisterRule<CCloseWindow>(MustBePlaying)
                    .RegisterRule<CCrywolfBenefit>(MustBePlaying)
                    .RegisterRule<CCrywolfContract>(MustBePlaying)
                    .RegisterRule<CCrywolfState>(MustBePlaying)
                    .RegisterRule<CDataLoadOK>(MustBePlaying)
                    .RegisterRule<CDevilSquareMove>(MustBePlaying)
                    .RegisterRule<CDuelAnswer>(MustBePlaying)
                    .RegisterRule<CDuelJoinRoom>(MustBePlaying)
                    .RegisterRule<CDuelLeave>(MustBePlaying)
                    .RegisterRule<CDuelLeaveRoom>(MustBePlaying)
                    .RegisterRule<CDuelRequest>(MustBePlaying)
                    .RegisterRule<CEventEnterCount>(MustBePlaying)
                    .RegisterRule<CEventItemGet>(MustBePlaying)
                    .RegisterRule<CEventItemThrow>(MustBePlaying)
                    .RegisterRule<CEventRemainTime>(MustBePlaying)
                    .RegisterRule<CFavoritesList>(MustBePlaying)
                    .RegisterRule<CFriendAdd>(MustBePlaying)
                    .RegisterRule<CFriendAddReq>(MustBePlaying)
                    .RegisterRule<CGremoryCaseOpen>(MustBePlaying)
                    .RegisterRule<CGuildInfoSave>(MustBePlaying)
                    .RegisterRule<CGuildListAll>(MustBePlaying)
                    .RegisterRule<CGuildRemoveUser>(MustBePlaying)
                    .RegisterRule<CGuildRequest>(MustBePlaying)
                    .RegisterRule<CGuildRequestAnswer>(MustBePlaying)
                    .RegisterRule<CGuildReqViewport>(MustBePlaying)
                    .RegisterRule<CGuildSetStatus>(MustBePlaying)
                    .RegisterRule<CImperialGuardianEnter>(MustBePlaying)
                    .RegisterRule<CInventory>(MustBePlaying)
                    .RegisterRule<CInventoryEquipament>(MustBePlaying)
                    .RegisterRule<CItemGet>(MustBePlaying)
                    .RegisterRule<CItemModify>(MustBePlaying)
                    .RegisterRule<CItemSplit>(MustBePlaying)
                    .RegisterRule<CItemThrow>(MustBePlaying)
                    .RegisterRule<CJewelMix>(MustBePlaying)
                    .RegisterRule<CJewelUnMix>(MustBePlaying)
                    .RegisterRule<CKanturuEnterBossMap>(MustBePlaying)
                    .RegisterRule<CKanturuStateInfo>(MustBePlaying)
                    .RegisterRule<CLuckyCoinsCount>(MustBePlaying)
                    .RegisterRule<CLuckyCoinsRegistre>(MustBePlaying)
                    .RegisterRule<CMagicAttack>(MustBePlaying)
                    .RegisterRule<CMagicAttackS9>(MustBePlaying)
                    .RegisterRule<CMagicDuration>(MustBePlaying)
                    .RegisterRule<CMagicDurationS16>(MustBePlaying)
                    .RegisterRule<CMagicDurationS9>(MustBePlaying)
                    .RegisterRule<CMasterSkill>(MustBePlaying)
                    .RegisterRule<CMemberPosInfoStart>(MustBePlaying)
                    .RegisterRule<CMemberPosInfoStop>(MustBePlaying)
                    .RegisterRule<CMove>(MustBePlaying)
                    .RegisterRule<CMove12Eng>(MustBePlaying)
                    .RegisterRule<CMoveEng>(MustBePlaying)
                    .RegisterRule<CMoveItem>(MustBePlaying)
                    .RegisterRule<CMUBotData>(MustBePlaying)
                    .RegisterRule<CMuHelperState>(MustBePlaying)
                    .RegisterRule<CEventInventoryOpenS16>(MustBePlaying)
                    .RegisterRule<CNewQuest>(MustBePlaying)
                    .RegisterRule<CNewQuestInfo>(MustBePlaying)
                    .RegisterRule<CNPCJulia>(MustBePlaying)
                    .RegisterRule<COpenBox>(MustBePlaying)
                    .RegisterRule<CPartyDelUser>(MustBePlaying)
                    .RegisterRule<CPartyLeaderChange>(MustBePlaying)
                    .RegisterRule<CPartyList>(MustBePlaying)
                    .RegisterRule<CPartyMAccept>(MustBePlaying)
                    .RegisterRule<CPartyMCancel>(MustBePlaying)
                    .RegisterRule<CPartyMJoin>(MustBePlaying)
                    .RegisterRule<CPartyMJoinData>(MustBePlaying)
                    .RegisterRule<CPartyMJoinList>(MustBePlaying)
                    .RegisterRule<CPartyMRegister>(MustBePlaying)
                    .RegisterRule<CPartyMSearch>(MustBePlaying)
                    .RegisterRule<CPartyRequest>(MustBePlaying)
                    .RegisterRule<CPartyRequestResult>(MustBePlaying)
                    .RegisterRule<CPCPShopBuy>(MustBePlaying)
                    .RegisterRule<CPCPShopItems>(MustBePlaying)
                    .RegisterRule<CPentagramaJewelIn>(MustBePlaying)
                    .RegisterRule<CPetCommand>(MustBePlaying)
                    .RegisterRule<CPetInfo>(MustBePlaying)
                    .RegisterRule<CPointAdd>(MustBePlaying)
                    .RegisterRule<CPositionSet>(MustBePlaying)
                    .RegisterRule<CPositionSetS9>(MustBePlaying)
                    .RegisterRule<CPShopCloseDeal>(MustBePlaying)
                    .RegisterRule<CPShopRequestBuy>(MustBePlaying)
                    .RegisterRule<CPShopRequestClose>(MustBePlaying)
                    .RegisterRule<CPShopRequestList>(MustBePlaying)
                    .RegisterRule<CPShopRequestOpen>(MustBePlaying)
                    .RegisterRule<CPShopSearchItem>(MustBePlaying)
                    .RegisterRule<CPShopSetItemPrice>(MustBePlaying)
                    
                    .RegisterRule<CQuestEXPComplete>(MustBePlaying)
                    .RegisterRule<CQuestEXPEventItemEPList>(MustBePlaying)
                    .RegisterRule<CQuestEXPProgress>(MustBePlaying)
                    .RegisterRule<CQuestEXPProgressList>(MustBePlaying)
                    .RegisterRule<CQuestNPCAccept>(MustBePlaying)
                    .RegisterRule<CQuestNPCTalk>(MustBePlaying)
                    .RegisterRule<CRefineJewelReq>(MustBePlaying)
                    .RegisterRule<CRegistryReq>(MustBePlaying)
                    .RegisterRule<CRelationShipJoinBreakOff>(MustBePlaying)
                    .RegisterRule<CRequestJoin>(MustBePlaying)
                    .RegisterRule<CRequestLeave>(MustBePlaying)
                    .RegisterRule<CRequestMemberInfo>(MustBePlaying)
                    .RegisterRule<CRequestReward>(MustBePlaying)
                    .RegisterRule<CSell>(MustBePlaying)
                    .RegisterRule<CServerList>(MustBeLoggedOrPlaying)
                    .RegisterRule<CServerMove>(MustNotBeLoggedIn)
                    .RegisterRule<CSetQuestState>(MustBePlaying)
                    .RegisterRule<CShadowBuff>(MustBePlaying)
                    .RegisterRule<CSkillKey>(MustBePlaying)
                    .RegisterRule<CSXInfo>(MustBePlaying)
                    .RegisterRule<CTalk>(MustBePlaying)
                    .RegisterRule<CTeleport>(MustBePlaying)
                    .RegisterRule<CTeleportS9>(MustBePlaying)
                    .RegisterRule<CTradeButtonCancel>(MustBeInTrade)
                    .RegisterRule<CTradeButtonOk>(MustBeInTrade)
                    .RegisterRule<CTradeMoney>(MustBeInTrade)
                    .RegisterRule<CTradeRequest>(MustBePlaying)
                    .RegisterRule<CUnionList>(MustBePlaying)
                    .RegisterRule<CUseItem>(MustBePlaying)
                    .RegisterRule<CWaitFriendAddReq>(MustBePlaying)
                    .RegisterRule<CWarehouseMoney>(MustBePlaying)
                    .RegisterRule<CWarehouseUseEnd>(MustBePlaying)
                    .RegisterRule<CWarp>(MustBePlaying)
            };
            var mf = new MessageFactory[]
            {
                new AuthMessageFactory(Season),
                new GlobalMessageFactory(Season),
                new GameMessageFactory(Season),
                new CashShopMessageFactory(Season),
                new EventMessageFactory(Season),
                new QuestSystemMessageFactory(Season),
                new GuildMessageFactory(Season),
                new AntiHackMessageFactory(),
                new PCPShopMessageFactory(Season),
                new GensMessageFactory(Season),
            };
            server = new WZGameServer(ip, mh, mf, NewEncode(Season));
            server.IPPublic = xml.Connection.IPPublic;
            server.ClientVersion = xml.Client.Version;
            server.ClientSerial = xml.Client.Serial;
            server.Connect += Server_Connect;

            var cmh = new MessageHandler[]
            {
                new FilteredMessageHandler<CSClient>()
                .AddHandler(new CSServices())
            };

            var cmf = new MessageFactory[]
            {
                new CSMessageFactory()
            };

            try
            {
                Log.Information(ServerMessages.GetMessage(Messages.Server_Disconnecting_Accounts));
                using (var db = new GameContext())
                {
                    var accs = from acc in db.Accounts
                               where acc.IsConnected && acc.ServerCode == xml.Code
                               select acc;

                    foreach (var acc in accs)
                        acc.IsConnected = false;

                    db.Accounts.UpdateRange(accs);
                    db.SaveChanges();
                }

                ResourceCache.Initialize(xml.Files.DataRoot);
                MasterLevel.Initialize();
                GuildManager.Initialize();
                PartyManager.Initialzie(xml.GamePlay.MaxPartyLevelDifference);
                DuelSystem.Initialize();
                CashShop.Initialize(xml.Client.CashShopVersion.Split(".").Select(x => ushort.Parse(x)).ToArray());
                Pentagrama.Initialize();
                // Event Config
                EventConfig(xml);
                MonstersMng.Initialize();
                MonstersMng.Instance.LoadMonster(xml.Files.DataRoot + xml.Files.Monsters);
                MonsterIA.Initialize(xml.Files.DataRoot + "Monsters/");
                EventInitialize();

                MapServerManager.Initialize(xml.Files.DataRoot + xml.Files.MapServer);
                MonstersMng.Instance.LoadSetBase(xml.Files.DataRoot + xml.Files.MonsterSetBase);
                SubSystem.Initialize();
                Marlon.Initialize();
                SubSystem.CSSystem(csIP, cmh, cmf, (byte)xml.Show, xml.Connection.APIKey);
                Log.Information(ServerMessages.GetMessage(Messages.Server_Ready));
            }
            catch(MySql.Data.MySqlClient.MySqlException ex)
            {
                Log.Error(ServerMessages.GetMessage(Messages.Server_MySQL_Error));
                Log.Error(ex.Message);
                Task.Delay(15000);
            }
            catch (Exception ex)
            {
                Log.Error(ex, ServerMessages.GetMessage(Messages.Server_Error));
            }

            Handler
                .AddCommand(new Command<GSSession>("help", Help, help:"Use help <cmd> for get help on any command"))
                .AddCommand(new Command<GSSession>("pck", PacketCreate, autority: MustBeGameMaster, help:"Index Packet<byte>"))
                .AddCommand(new Command<GSSession>("exit", Close, autority: MustBeGameMaster, help: "Close game server"))
                .AddCommand(new Command<GSSession>("quit", Close, autority: MustBeGameMaster, help: "Close game server"))
                .AddCommand(new Command<GSSession>("stop", Close, autority: MustBeGameMaster, help: "Close game server"))
                .AddCommand(new Command<GSSession>("reload", autority:MustBeGameMaster, help: "Reload GameServer section")
                    .AddCommand(new Command<GSSession>("shops", (object a, CommandEventArgs b) => ResourceCache.Instance.ReloadShops(), help:"Reload shop List"))
                    .AddCommand(new Command<GSSession>("gates", (object a, CommandEventArgs b) => ResourceCache.Instance.ReloadGates(), help:"Reload gate list"))
                    .AddCommand(new Command<GSSession>("itembags", (object a, CommandEventArgs b) => ResourceCache.Instance.ReloadItembags(), help: "Reload Item Bag list"))
                    )
                .AddCommand(new Command<GSSession>("create", autority: MustBeGameMaster, help:"Create client side files")
                    .AddCommand(new Command<GSSession>("movereq", DumpMoveReq, null, "Create MoveRequest file for client")))
                .AddCommand(new Command<GSSession>("decrypt", DumpFile, null, "Aply Decrypt to file"))
                .AddCommand(new Command<GSSession>("db", autority: MustBeGameMaster, help:"Generate db changes, use help")
                    .AddCommand(new Command<GSSession>("migrate", Migrate, help:"delete DB and create it again"))
                    .AddCommand(new Command<GSSession>("create", Create, help:"Create DB"))
                    .AddCommand(new Command<GSSession>("delete", Delete, help:"Delete DB")))
                .AddCommand(new Command<GSSession>("!", (object a, CommandEventArgs b) => GlobalAnoucement(b.Argument).Wait(), MustBeGameMaster).SetPartial())
                .AddCommand(new Command<GSSession>("/").SetPartial()
                    .AddCommand(new Command<GSSession>("p", PostCommand))//Post
                    .AddCommand(new Command<GSSession>("add").SetPartial()
                        .AddCommand(new Command<GSSession>("str", Character.AddStr))
                        .AddCommand(new Command<GSSession>("agi", Character.AddAgi))
                        .AddCommand(new Command<GSSession>("vit", Character.AddVit))
                        .AddCommand(new Command<GSSession>("ene", Character.AddEne))
                        .AddCommand(new Command<GSSession>("cmd", Character.AddCmd)))
                    .AddCommand(new Command<GSSession>("set", autority:MustBeGameMaster)
                        .AddCommand(new Command<GSSession>("hp", (object a, CommandEventArgs b) => ((GSSession)a).Player.Character.Health = float.Parse(b.Argument)))
                        .AddCommand(new Command<GSSession>("zen", UpdateZen))
                        .AddCommand(new Command<GSSession>("exp", (object a, CommandEventArgs b) => ((GSSession)a).Player.Character.Experience = uint.Parse(b.Argument))))
                    .AddCommand(new Command<GSSession>("levelup", LevelUp, MustBeGameMaster, "Level up current character, use: '/levelup 100' add 100 levels to current character"))
                    .AddCommand(new Command<GSSession>("reset", Character.Reset, null, "Resets current Character"))
                    .AddCommand(new Command<GSSession>("drop", CreateItem, MustBeGameMaster, "Create item <Number>")))
                //.AddCommand(new Command<GSSession>("~").SetPartial())
                /*.AddCommand(new Command<GSSession>("]").SetPartial())*/;

            while (true)
            {
                var input = Console.ReadLine();
                if (input == null)
                    break;

                Handler.ProcessCommands(null, input);
            }
        }

        private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            Log.Error("UnhandledException", (e.ExceptionObject as Exception));
        }

        private static void PacketCreate(object sender, CommandEventArgs e)
        {
            var args = e.Argument.Split(" ");
            var index = int.Parse(args[0]);
            var length = args[1].Length / 2;
            var array = new byte[length];
            for (var i = 0; i < length; i++)
            {
                array[i] = byte.Parse(args[1].Substring(i*2, 2), System.Globalization.NumberStyles.HexNumber);
            }

            var session = server.Clients.First(x => x.ID == index);
            _=session.Send(array);
        }

        private static void Server_Connect(object sender, WZServerEventArgs e)
        {
            if (NewEncode(Season))
            {
                Log.Information("Sending PSK");
                _ = e.session.SendAsync(new SAHPreSharedKey { Key = e.session.Key });
            }
        }

        private static void UpdateZen(object sender, CommandEventArgs e)
        {
            var session = sender as GSSession;
            session.Player.Character.Money = uint.Parse(e.Argument);
        }
        private static void CreateItem(object sender, CommandEventArgs e)
        {
            var session = sender as GSSession;
            var @char = session.Player.Character;
            if (session == null)
                return;

            var map = session.Player.Character.Map;
            try
            {
                var item = new Item(ushort.Parse(e.Argument));
                item.NewOptionRand();
                map.AddItem(@char.Position.X, @char.Position.Y, item);
            }catch(Exception ex)
            {
                session.Exception(ex);
            }
        }

        private static void EventConfig(ServerInfoDto xml)
        {
            GlobalEventsManager = new GlobalEvents();
            GoldenInvasionManager = new GoldenInvasion();

            if (xml.Events == null)
                return;

            foreach(var e in xml.Events)
            {
                var ev = new GlobalEvent(GlobalEventsManager)
                { 
                    Active = e.active, 
                    Rate = e.rate,
                    Duration = TimeSpan.FromSeconds(e.duration),
                    Start = DateTime.Parse(e.start),
                    RepeatType = e.repeat,
                    ExpAdd = e.experienceAdd
                };

                foreach (var c in e.Conditions)
                    ev.AddRange(new Item((ItemNumber)c.item, Options: new { Plus = c.itemLevel }), c.mobMinLevel, c.mobMaxLevel, c.map);

                if(ev.Active)
                    GlobalEventsManager.AddEvent(e.name, ev);
            }
        }

        public static int RandomProvider(int Max, int Min = 0)
        {
            return s_rand.Next(Min, Max);
        }

        private static void MakeXOR(byte[] data, int offset, int length)
        {
            var xor = new byte[] { 0xFC, 0xCF, 0xAB };
            for(var i = 0; i < data.Length- offset; i++)
            {
                data[i+ offset] ^= xor[(i % length) % xor.Length];
            }
        }

        private static void DumpFile(object sender, CommandEventArgs e)
        {
            var file = e.Argument.Split(" ");
            byte[] data;
            var chunck = int.Parse(file[1]);
            using (var fs = new FileStream(file[0], FileMode.Open))
            {
                data = new byte[fs.Length];
                fs.Read(data, 0, data.Length);
            }
            using(var fs = new FileStream(file[0] + "d", FileMode.Create))
            {
                fs.Seek(4, SeekOrigin.Begin);
                MakeXOR(data, 4, chunck);
                fs.Write(data, 0,data.Length);
            }

            Log.Information(file[0]+" -> "+ file[0] + "d P:"+ chunck);
        }

        private static void DumpMoveReq(object sender, CommandEventArgs e)
        {
            var gates = ResourceCache.Instance.GetGates();
            var moves = gates
                .Where(x => x.Value.Move != -1)
                .OrderBy(x => x.Value.Move)
                .Select(x => x.Value);

            using(var fs = new FileStream("./MoveReq.bmd", FileMode.Create))
            using (var fs2 = new FileStream("./MoveReq_eng.bmd", FileMode.Create))
            {
                var num = BitConverter.GetBytes(moves.Count());
                fs.Write(num, 0, 4);
                fs2.Write(num, 0, 4);

                var data = new byte[0xFA0];
                var data2 = new byte[0xFA0];
                using (var ms = new MemoryStream(data))
                using(var ms2 = new MemoryStream(data2))
                {
                    foreach (var mov in moves)
                    {
                        var bmdData = new MoveReqBMD
                        {
                            Gate = mov.Number,
                            Level = mov.ReqLevel,
                            MoveNumber = mov.Move,
                            Zen = mov.ReqZen,
                            ClientName = mov.Name,
                            ServerName = mov.Name,
                        };
                        Serializer.Serialize(ms, bmdData);
                        Serializer.Serialize(ms2, new MoveReqBMDS9Eng
                        {
                            Gate = mov.Number,
                            Level = mov.ReqLevel,
                            MoveNumber = mov.Move,
                            Zen = mov.ReqZen,
                            ClientName = mov.Name,
                            ServerName = mov.Name,
                        });
                        Log.Information("{0}\t{1}\t\t{2}\t{3}\t{4}", mov.Move, mov.Name, mov.ReqLevel, mov.ReqZen, mov.Number);
                    }
                }

                MakeXOR(data, 0, 80);
                MakeXOR(data2, 0, 84);
                fs.Write(data, 0, data.Length);
                fs2.Write(data2, 0, data2.Length);
            }

            Log.Information("MoveReq.bmd Created");

            using (var fs = new FileStream("./Gate.bmd", FileMode.Create))
            {
                var num = BitConverter.GetBytes(moves.Count());
                //fs.Write(num, 0, 4);

                var data = new byte[7168];
                using (var ms = new MemoryStream(data))
                {
                    foreach (var mov in moves)
                    {
                        var bmdData = new GateBMD
                        {
                            Flag = mov.GateType,
                            Map = (byte)mov.Map,
                            Dir = mov.Dir,
                            Level = mov.ReqLevel,
                            X1 = (byte)mov.Door.Left,
                            Y1 = (byte)mov.Door.Top,
                            X2 = (byte)mov.Door.Right,
                            Y2 = (byte)mov.Door.Bottom,
                            GateNumber = (ushort)mov.Number,
                            BZLevel = 400,
                            BZone = 1,
                        };
                        Serializer.Serialize(ms, bmdData);
                    }
                }

                MakeXOR(data, 0, 14);
                fs.Write(data, 0, data.Length);
            }
            Log.Information("Gate.bmd Created");
        }

        static void EventInitialize()
        {
            EventManager = new EventManagement();
            EventManager
                .AddEvent(Events.Events.BloodCastle, new BloodCastles())
                .AddEvent(Events.Events.DevilSquared, new DevilSquares())
                .AddEvent(Events.Events.Kanturu, new Kanturu())
                .AddEvent(Events.Events.ChaosCastle, new ChaosCastles())
                .AddEvent(Events.Events.Crywolf, new Crywolf())
                .AddEvent(Events.Events.ImperialGuardian, new ImperialGuardian())
                .AddEvent(Events.Events.MoonRabbit, new MoonRabbit())
                .AddEvent(Events.Events.WhiteWizard, new WhiteWizard())
                .AddEvent(Events.Events.EventEgg, new EventEgg())
                .AddEvent(Events.Events.MuRummy, new MuRummy(Program.XMLConfiguration.Files.MGMuRummy))
                .AddEvent(Events.Events.CastleSiege, new CastleSiege())
                .AddEvent(Events.Events.Raklion, new BattleOfSelupan())
                .AddEvent(Events.Events.AcheronGuardian, new AcheronGuardian())
                //.AddEvent(Events.Events.DoubleGoer, new DoubleGoer())
                .AddEvent(Events.Events.MineSweeper, new MineSweeper(Program.XMLConfiguration.Files.MGFindBombs))
                .AddEvent(Events.Events.JeweldryBingo, new JeweldryBingo(Program.XMLConfiguration.Files.MGJewelBingo))
                .AddEvent(Events.Events.BallsAndCows, new BallsAndCows(Program.XMLConfiguration.Files.MGBallsAndCows))
                ;
            LuckyCoins.Initialize();
            EventChips.Initialize();
        }

        public static async Task GlobalAnoucement(string text)
        {
            await server.SendAll(new SNotice(NoticeType.Gold, text));
            Log.Information(ServerMessages.GetMessage(Messages.Server_GlobalAnnouncement, text));
        }

        public static async Task MapAnoucement(Maps map, string text)
        {
            await ResourceCache.Instance
                .GetMaps()[map]
                .SendAsync(new SNotice(NoticeType.Gold, text));
            Log.Information(ServerMessages.GetMessage(Messages.Server_MapAnnouncement) + text, map);
        }

        public static async Task NoEventMapSendAsync(object message)
        {
            await server
                .Clients
                .Where(x => x.Player.Status == LoginStatus.Playing && !x.Player.Character.Map.IsEvent)
                .SendAsync(message);
        }
        public static async Task NoEventMapAnoucement(string text)
        {
            await NoEventMapSendAsync(new SNotice(NoticeType.Gold, text));
            Log.Information(ServerMessages.GetMessage(Messages.Server_NoEventMapAnnouncement, text));
        }

        public static async void PostCommand(object a, CommandEventArgs b)
        {
            var session = a as GSSession;
            await server.SendAll(new SChatNickName(session.Player.Character.Name, $"~# {b.Argument}"));
        }

        public static void Help(object a, CommandEventArgs b)
        {
            string output = "";
            if (string.IsNullOrWhiteSpace(b.Argument))
            {
                var list = Handler.GetCommandList().Select(x => x.FullName());
                output = "Command List:\n\t"+string.Join("\n\t", list);
            }
            else
            {
                var cmd = Handler.FindCommand(a as GSSession, b.Argument);
                if (cmd != null)
                    output = cmd.Help();
                else
                    output = "Invalid Command";
            }

            if(a==null)
            {
                Log.Information(output);
            }else
            {
                var session = a as GSSession;
                var outputs = output.Split("\n\t");
                foreach(var o in outputs)
                {
                    session.SendAsync(new SNotice(NoticeType.Blue, o)).Wait();
                }
            }
        }

        public static void Close(object a, EventArgs b)
        {
            if (a != null)
                return;

            GlobalAnoucement(ServerMessages.GetMessage(Messages.Server_Close)).Wait();

            Task.Delay(30000);

            Environment.Exit(0);
        }

        public static void Create(object a, EventArgs b)
        {
            if (a != null)
                return;

            Log.Information("Creating DB");
            using (var db = new GameContext())
                db.Database.EnsureCreated();
            Log.Information("Created DB");
        }

        public static void Migrate(object a, EventArgs b)
        {
            if (a != null)
                return;

            using (var db = new GameContext())
            {
                Log.Information("Dropping DB");
                db.Database.EnsureDeleted();
                Log.Information("Creating DB");
                db.Database.EnsureCreated();
                Log.Information("Created DB");
            }
        }

        public static void Delete(object a, EventArgs b)
        {
            if (a != null)
                return;

            Log.Information("Dropping DB");
            using (var db = new GameContext())
                db.Database.EnsureDeleted();
            Log.Information("Dropped DB");
        }
        public static void LevelUp(object a, CommandEventArgs b)
        {
            var session = a as GSSession;

            if(!string.IsNullOrWhiteSpace(b.Argument))
            {
                var lvls = uint.Parse(b.Argument);
                while(lvls-- > 0)
                {
                    session.Player.Character.Experience = session.Player.Character.NextExperience;
                }
            }else
            {
                session.Player.Character.Experience = session.Player.Character.NextExperience;
            }
        }
    }
}


--file Quests.cs
﻿using MU.DataBase;
using MuEmu.Data;
using MuEmu.Entity;
using MuEmu.Monsters;
using MuEmu.Network.Data;
using MU.Network.Game;
using MU.Network.QuestSystem;
using MuEmu.Resources;
using MuEmu.Resources.XML;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MU.Resources;
using MuEmu.Util;

namespace MuEmu
{
    public class QuestInfoIndex
    {
        public AskType Type { get; set; }
        public uint Index { get; set; }
        public uint Episode { get => (Index >> 0x10); set => Index = Switch + value << 0x10; }
        public uint Switch { get => (Index & 0xFFFF); set => Index = (Episode << 0x10) + value; }

        public static implicit operator QuestInfoIndex(uint id)
        {
            return new QuestInfoIndex { Index = id };
        }

        public static implicit operator uint(QuestInfoIndex info)
        {
            return info.Index;
        }

        public static QuestInfoIndex FromEpisodeSwitch(uint Ep, uint Sw)
        {
            return new QuestInfoIndex { Episode = Ep, Switch = Sw };
        }

        public override string ToString()
        {
            return $"EP{Episode}-{Switch}";
        }
    }
    public class QuestInfoMonster : QuestInfoIndex
    {
        public ushort MonsterClass { get; set; }
        public uint Current { get; set; }
        public uint Value { get; set; }
    }
    internal struct QuestKCInfo
    {
        public uint Number
        {
            get => (uint)((Quest << 24) | (Monster << 8) | Count);
            set
            {
                Quest = (value & 0xff000000) >> 24;
                Monster = (ushort)((value & 0x00ffff00) >> 8);
                Count = (byte)(value & 0xff);
            }
        }
        
        public uint Quest { get; set; }
        public ushort Monster { get; set; }
        public byte Count { get; set; }
    }
    public class Quests
    {
        private static Random _rand = new Random();
        private List<Quest> _quests;
        private Dictionary<int, QuestInfoIndex> _episodes = new Dictionary<int, QuestInfoIndex>();
        private QuestEXPDto _questEXP;
        private QuestInfoIndex _currentQuest;
        private ushort _currentNpc;

        internal static ILogger _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(Quests));
        internal List<QuestKCInfo> _questMonsterKillCount = new List<QuestKCInfo>();

        public byte[] QuestStates { get; set; }
        public Player Player { get; set; }
        public Quests(Character @char, CharacterDto characterDto)
        {
            if(_questEXP == null)
            {
                string file = Program.XMLConfiguration.Files.DataRoot+Program.XMLConfiguration.Files.QuestWorld+$"Quest_{Program.Season}.xml";
                try
                {
                    _questEXP = ResourceLoader.XmlLoader<QuestEXPDto>(file);
                }catch(Exception)
                {
                    _questEXP = new QuestEXPDto()
                    {
                        QuestList = Array.Empty<QuestNPCDto>()
                    };
                    ResourceLoader.XmlSaver(file, _questEXP);
                }
            }
            QuestStates =  new byte[20];
            _quests = new List<Quest>();
            Array.Fill<byte>(QuestStates, 0xff);

            Player = @char.Player;
            foreach(var q in characterDto.Quests)
            {
                var nq = new Quest
                {
                    Manager = this,
                    Index = q.Quest,
                    State = (QuestState)q.State,
                    _dbId = q.QuestId,
                };

                nq._needSave = false;
                _quests.Add(nq);
                _questMonsterKillCount = q.Details
                    .Split(";")
                    .Where(x => !string.IsNullOrEmpty(x))
                    .Select(x => new QuestKCInfo() { Number = uint.Parse(x) })
                    .ToList();

                _logger
                    .ForAccount(Player.Session)
                    .Information("Quest Found:{0} State:{1}", nq.Details.Name, nq.State);
            }

            foreach(var q in characterDto.QuestEX)
            {
                var qIndex = QuestInfoIndex.FromEpisodeSwitch((uint)q.Quest, (uint)q.State);
                _episodes.Add(q.Quest, qIndex);
                _logger
                    .ForAccount(Player.Session)
                    .Information("Quest Found:{0}", qIndex);
            }
        }

        internal uint GetEpisodeState(uint episode)
        {
            if (_episodes.TryGetValue((int)episode, out QuestInfoIndex value))
            {
                return value.Switch;
            }

            return 0;
        }
        internal void SetEpisodeState(uint episode, uint _switch)
        {
            if(_episodes.TryGetValue((int)episode, out QuestInfoIndex value))
            {
                value.Switch = _switch;
                return;
            }

            _episodes.Add((int)episode, QuestInfoIndex.FromEpisodeSwitch(episode, _switch));
        }

        public async void SendList()
        {
            var standarQuest = _quests.Where(x => x.Standar).ToArray();
            await Player.Session.SendAsync(new SQuestInfo { Count = (byte)standarQuest.Length, State = QuestStates });
            //var customQuest = _quests.Where(x => !x.Standar).ToArray();
            await Player.Session.SendAsync(new SNQWorldLoad());
            await Player.Session.SendAsync(new SNewQuestInfo { 
                QuestList = _episodes.Values.Select(x => x.Index).ToArray() });
            await Player.Session.SendAsync(new SNQWorldList { Quest = new SNQWorldListDto { QuestIndex = 1, TagetNumber = 1, QuestState = 0 } });
        }

        public IEnumerable<QuestInfoIndex> EXPListNPC(ushort npc)
        {
            var session = Player.Session;
            var list = _questEXP.QuestList.FirstOrDefault(x => x.Index == npc)?.QuestInfo??null;
            _currentNpc = npc;

            var quest = Array.Empty<QuestInfoIndex>();
            if(list != null)
            {
                quest = (from l in list
                        where 
                        l.MinLevel <= Player.Character.Level && 
                        l.MaxLevel >= Player.Character.Level &&
                        (l.ReqEpisode == 0 || _episodes.ContainsKey((int)l.ReqEpisode))
                         select QuestInfoIndex.FromEpisodeSwitch(l.Episode, 0)).ToArray();

                foreach(var q in quest)
                {
                    if(_episodes.ContainsKey((int)q.Episode))
                    {
                        q.Switch = _episodes[(int)q.Episode].Switch;
                    }
                }
            }
            return quest;
        }

        private QuestNPCStateDto GetQuestEXPStateInfo(uint Episode, uint state)
        {
            var npcQuestList = (from q in _questEXP.QuestList
                                where q.Index == _currentNpc
                                select q.QuestInfo).FirstOrDefault();

            var quest = (from q in npcQuestList
                         where q.Episode == Episode
                         select q).FirstOrDefault();

            var nextState = (from q in quest.QuestState
                             where q.State == state
                             select q).FirstOrDefault();

            return nextState;
        }

        public async Task QuestEXPInfo(QuestInfoIndex info)
        {
            var session = Player.Session;
            var @char = Player.Character;

            try
            {
                if (!_episodes.ContainsKey((int)info.Episode))
                    _episodes.Add((int)info.Episode, info);

                var state = _episodes[(int)info.Episode].Switch;
                byte rewardCount = 0;

                var nextState = GetQuestEXPStateInfo(info.Episode, state);

                var ask = new AskInfoDto[5];
                var reward = new RewardInfoDto[5];
                for (var i = 0; i < 5; i++)
                {
                    ask[i] = new AskInfoDto();
                    reward[i] = new RewardInfoDto();
                }

                if (nextState.RewardEXP > 0)
                {
                    reward[rewardCount].Type = RewardType.Exp;
                    reward[rewardCount].Value = nextState.RewardEXP;
                    rewardCount++;
                }

                if (nextState.RewardGENS > 0)
                {
                    reward[rewardCount].Type = RewardType.Point;
                    reward[rewardCount].Value = nextState.RewardGENS;
                    rewardCount++;
                }

                if (nextState.RewardZEN > 0)
                {
                    reward[rewardCount].Type = RewardType.Zen;
                    reward[rewardCount].Value = nextState.RewardZEN;
                    rewardCount++;
                }

                byte askCount = 0;
                switch (nextState.Type)
                {
                    case AskType.Tutorial:
                        ask[askCount].Type = nextState.Type;
                        break;
                    case AskType.Item:
                        foreach (var it in nextState.Item)
                        {
                            var item = new Item(ItemNumber.FromTypeIndex(it.Type, it.Index), Options: new { Plus = it.Level });

                            var list = @char.Inventory.FindAllItems(ItemNumber.FromTypeIndex(it.Type, it.Index))
                            .Where(x => x.Plus == it.Level && it.Skill == x.Skill && it.Option == x.Option28 && it.Excellent == x.OptionExe);

                            ask[askCount].Type = nextState.Type;
                            ask[askCount].ItemInfo = item.GetBytes();
                            ask[askCount].CurrentValue = (uint)list.Count();
                            ask[askCount].Value = it.Count;
                            askCount++;
                        }
                        break;
                    case AskType.Monster:
                        var infoM = @char.Quests.GetEpisode<QuestInfoMonster>((int)info.Episode, state);
                        infoM.Type = nextState.Type;
                        foreach (var it in nextState.Monster)
                        {
                            ask[askCount].Type = nextState.Type;
                            ask[askCount].Index = it.Index;
                            ask[askCount].CurrentValue = infoM.Current;
                            ask[askCount].Value = it.Count;
                            infoM.MonsterClass = it.Index;
                            askCount++;
                        }
                        break;
                }
                if (rewardCount > 0 || askCount > 0)
                {
                    await session.SendAsync(new SSendQuestEXPProgressAsk
                    {
                        dwQuestInfoIndexID = QuestInfoIndex.FromEpisodeSwitch(info.Episode, state),
                        AskCnt = askCount,
                        RandRewardCnt = 0,
                        RewardCnt = rewardCount,
                        Asks = ask,
                        Rewards = reward,
                    });
                }
                else
                {
                    await session.SendAsync(new SSendQuestEXPProgress
                    {
                        dwQuestInfoIndexID = QuestInfoIndex.FromEpisodeSwitch(info.Episode, state),
                        /*AskCnt = 0,
                        RandRewardCnt = 0,
                        RewardCnt = 0,*/
                    });
                }
            }
            catch(Exception ex)
            {
                _logger.Error(ex, "QuestInfo");
                await session.SendAsync(new SQuestEXP { Result = 1 });
            }
        }

        public void QuestEXPSetProgress(QuestInfoIndex info, int result)
        {
            var state = GetEpisodeState(info.Episode);
            var nextState = GetQuestEXPStateInfo(info.Episode, state);
            var select = (ushort)nextState.Get("Select" + result);
            SetEpisodeState(info.Episode, select);
            _logger.ForAccount(Player.Session).Information("Update state EP{0} {1}->{2}", info.Episode, state, select);
        }

        public async Task QuestEXPCompleted(QuestInfoIndex info)
        {
            var session = Player.Session;
            var @char = Player.Character;

            var ss = GetEpisodeState(info.Episode);
            var state = GetQuestEXPStateInfo(info.Episode, ss);
            SetEpisodeState(info.Episode, state.Select1);

            if (state.Item != null && state.Item.Length > 0)
            {
                foreach (var it in state.Item)
                {
                    var list = @char.Inventory.FindAllItems(ItemNumber.FromTypeIndex(it.Type, it.Index))
                        .Where(x => x.Plus == it.Level && it.Skill == x.Skill && it.Option == x.Option28 && it.Excellent == x.OptionExe);

                    if (list.Count() < it.Count)
                    {
                        await session.SendAsync(new SQuestEXP { Result = 1 });
                        return;
                    }
                }
            }

            @char.Money += state.RewardZEN;
            @char.Experience += state.RewardEXP;
            await session.SendAsync(new SKillPlayerEXT(ushort.MaxValue, (int)state.RewardEXP, 0));
            @char.Gens.Contribution += (int)state.RewardGENS;

            var rewardItemOut = "";
            if (state.RewardItem != null)
            {
                foreach (var it in state.RewardItem)
                {
                    var item = new Item(ItemNumber.FromTypeIndex(it.Type, it.Index), Options: new { Plus = it.Level });
                    @char.Inventory.Add(item);
                    rewardItemOut += item.ToString() + "\n";
                }
            }

            _logger
                .Information($"[{info}] Quest completed! Reward List:\n\t\tZEN:{state.RewardZEN}\n\t\tEXP:{state.RewardEXP}\n\t\tGENS:{state.RewardGENS}\n\t\tItems:{rewardItemOut}\n");
            await session.SendAsync(new SSendQuestEXPComplete
            {
                dwQuestInfoIndexID = QuestInfoIndex.FromEpisodeSwitch(info.Episode, state.Select1),
                Result = 1,
            });
        }

        public uint[] QuestEXPProgressList()
        {
            return _episodes.Select(x => x.Value.Index).ToArray();
        }

        public void OnMonsterDie(Monster monster)
        {
            var runningQuests = _quests.Where(x => x.State == QuestState.Reg);

            foreach(var q in runningQuests)
            {
                foreach(var sq in q.Details.Sub.Where(x => x.Allowed.Contains(Player.Character.Class)))
                {

                    if(sq.Monster != 0 && sq.Drop == 0)
                    {
                        if (sq.Monster != monster.Info.Monster)
                            continue;

                        var key = (sq.Monster | (uint)(q.Index << 16));
                        var id = _questMonsterKillCount.FindIndex(x => x.Quest == q.Index && x.Monster == sq.Monster);
                        var info = (id == -1) ? new QuestKCInfo { Monster = sq.Monster, Quest = (uint)q.Index } : _questMonsterKillCount[id];

                        if(info.Count < sq.Count)
                        info.Count++;

                        if (id == -1)
                        {
                            id = _questMonsterKillCount.Count;
                            _questMonsterKillCount.Add(info);
                        }

                        _questMonsterKillCount[id] = info;

                        Player
                            .Session
                            .SendAsync(new SNotice(NoticeType.Blue, $"{monster.Info.Name}: {info.Count}/{sq.Count}"))
                            .Wait();

                        continue;
                    }

                    if (sq.MonsterMin > monster.Level ||
                        sq.MonsterMax < monster.Level)
                        continue;

                    if(sq.Drop > _rand.Next(100))
                    {
                        Item dropItem = null;
                        foreach(var it in sq.Requeriment)
                        {
                            var cantDrop = Player.Character.Inventory.FindAll(it.Number).Count() == it.Durability;
                            if (cantDrop)
                                continue;

                            dropItem = new Item(it.Number, new { it.Plus });
                            break;
                        }

                        if(dropItem != null)
                            Player.Character.Map.AddItem(monster.Position.X, monster.Position.Y, dropItem);
                    }
                }
            }

            foreach(var episode in _episodes.Values)
            {
                if (episode.Type != AskType.Monster)
                    continue;

                var mons = episode as QuestInfoMonster;
                if(mons.MonsterClass == monster.Info.Monster)
                {
                    mons.Current++;
                }
            }
        }

        internal T GetEpisode<T>(int episode, uint _switch)
            where T: class
        {
            if(_episodes.ContainsKey(episode))
            {
                if(_episodes[episode] is T)
                    return (T)(object)_episodes[episode];
            }

            var newObject = (QuestInfoIndex)Activator.CreateInstance(typeof(T));
            newObject.Index = QuestInfoIndex.FromEpisodeSwitch((uint)episode, _switch);

            if(_episodes.ContainsKey(episode))
            {
                _episodes[episode] = newObject;
            }
            else
            {
                _episodes.Add(episode, newObject);
            }

            return (T)(object)newObject;
        }

        internal QuestInfoIndex GetLastEpisode()
        {
            return _episodes.Last().Value;
        }

        public Quest GetByIndex(int Index)
        {
            return _quests.Where(x => x.Index == Index).FirstOrDefault();
        }

        public Quest Find(ushort npc)
        {
            var NPCQuests = from q in ResourceCache.Instance.GetQuests().Values
                            where q.NPC == npc
                            select q;

            var listed = from q in _quests
                        where NPCQuests.Any(x => x.Index == q.Index)
                        select q;

            var running = listed.Where(x => x.State != QuestState.Complete).FirstOrDefault();
            if (running != null)
            {
                return running;
            }

            var newQ = (from q in NPCQuests
                       where !listed.Any(x => x.Index == q.Index) && q.CanRun(Player.Character)
                       select q).FirstOrDefault();

            if (newQ != null)
            {
                var newQuest = new Quest
                {
                    Index = newQ.Index,
                    Manager = this,
                };

                newQuest.State = QuestState.Unreg;

                _quests.Add(newQuest);
                return newQuest;
            }

            return listed.FirstOrDefault();
        }

        public bool IsClear(int Index)
        {
            if (Index == -1)
                return true;

            var q = GetByIndex(Index);
            if (q == null)
                return false;
            return (q.State == QuestState.Complete || q.State == QuestState.Clear);
        }

        public byte SetState(int Index)
        {
            return GetByIndex(Index)?.NextStep() ?? 0xff;
        }

        internal IEnumerable<QuestKCInfo> GetKillCount(int Index)
        {
            return from q in _questMonsterKillCount
            where q.Quest == Index
            select q;
        }

        public async Task Save(GameContext db)
        {
            foreach (var q in _quests)
                await q.Save(db);

            foreach(var q in _episodes)
            {
                var entity = db.QuestsEX.SingleOrDefault(x => x.CharacterId == Player.Character.Id && x.Quest == q.Key);
                if (entity == null)
                    entity = new QuestEXDto();

                entity.Quest = q.Key;
                entity.State = (int)q.Value.Switch;
                entity.CharacterId = Player.Character.Id;
                if (entity.QuestId == 0)
                    db.QuestsEX.Add(entity);
                else
                    db.QuestsEX.Update(entity);
            }
        }
    }
    public class Quest
    {
        private int _index;
        private int _questByte;
        private byte _killCount;

        internal int _dbId;
        internal bool _needSave;

        public byte StateByte => Manager.QuestStates[_questByte];
        public QuestState State
        {
            get => (QuestState)((StateByte >> Shift) & 0x03);
            set
            {
                var curState = StateByte;
                var curMask = (byte)(~(0x03 << Shift));

                curState &= curMask;
                curState |= (byte)(((byte)value) << Shift);
                Manager.QuestStates[_questByte] = curState;
                _needSave = true;
            }
        }

        public bool Standar { get; set; }
        public int Index { get => _index;
            set
            {
                _index = value;
                _questByte = _index / 4;
                Shift = (_index % 4) * 2;
                Details = Resources.ResourceCache.Instance.GetQuests()[_index];
            }
        }
        public int Shift { get; private set; }
        public QuestInfo Details { get; private set; }
        public Quests Manager { get; set; }
        public Character Character => Manager.Player.Character;

        public uint Cost => (uint)Details.Conditions.Sum(x => x.Cost);

        internal byte NextStep()
        {
            byte result = 0xff;
            switch(State)
            {
                case QuestState.Unreg:
                case QuestState.Clear:
                    result = canRun();

                    if (result != 0)
                        return result;

                    Character.Money -= Cost;
                    State = QuestState.Reg;
                    return 0;
                case QuestState.Reg:
                    result = canClear();

                    if (result != 0)
                        return result;

                    State = QuestState.Complete;
                    return 0;
                default:
                    return 0xff;
            }
        }

        internal byte Clear(SubQuest sq)
        {
            var session = Character.Player.Session;

            byte RewardArg = 0;

            switch (sq.CompensationType)
            {
                case QuestCompensation.Changeup:
                    Character.LevelUpPoints += sq.Amount;
                    Character.Changeup = true;
                    RewardArg = Character.ClientClass;

                    _ = session.SendAsync(new SSendQuestPrize((ushort)session.ID, QuestCompensation.Statup, sq.Amount));
                    break;
                case QuestCompensation.Statup:
                case QuestCompensation.Plusstat:
                    Character.LevelUpPoints += sq.Amount;
                    RewardArg = sq.Amount;
                    break;
                case QuestCompensation.Comboskill:
                    RewardArg = 0;
                    break;
                case QuestCompensation.Master:
                    Character.LevelUpPoints += sq.Amount;

                    if (!Character.Changeup && !(Character.Class == HeroClass.MagicGladiator || Character.Class == HeroClass.DarkLord))
                    {
                        return 1;
                    }
                    Character.MasterClass = true;
                    RewardArg = Character.ClientClass;
                    _ = session.SendAsync(new SSendQuestPrize((ushort)session.ID, QuestCompensation.Statup, sq.Amount));
                    break;
                case QuestCompensation.AllStatsUp:
                    Character.Strength += sq.Amount;
                    Character.Agility += sq.Amount;
                    Character.Vitality += sq.Amount;
                    Character.Energy += sq.Amount;
                    if(Character.BaseClass == HeroClass.DarkLord) Character.Command += sq.Amount;
                    break;
                case QuestCompensation.Majestic:
                    Character.LevelUpPoints += sq.Amount;

                    if (!Character.MasterClass)
                    {
                        return 1;
                    }
                    Character.MajesticClass = true;
                    RewardArg = (byte)(Character.ClientClass|14);
                    _ = session.SendAsync(new SSendQuestPrize((ushort)session.ID, QuestCompensation.Statup, sq.Amount));
                    break;
            }

            _ = session.SendAsync(new SSendQuestPrize((ushort)session.ID, sq.CompensationType, RewardArg));

            return 0;
        }

        internal byte canClear(bool clear = true)
        {
            var inv = Character.Inventory;
            var list = new List<Item>();
            var total = 0;
            var mobFinish = true;
            foreach(var sq in Details.Sub.Where(x => x.Allowed.Contains(Character.Class)))
            {
                if (sq.Monster != 0)
                {
                    var kcInfo = Manager.GetKillCount(Index).FirstOrDefault(x => x.Monster == sq.Monster);
                    mobFinish &= sq.Count <= kcInfo.Count;
                }
                else
                {
                    foreach (var req in sq.Requeriment)
                    {
                        var Items = (from it in inv.FindAllItems(req.Number)
                                    where it.Plus == req.Plus
                                    select it)
                                    .Take(sq.Count);

                        list.AddRange(Items);
                        total += sq.Count;
                    }
                }
            }
            var result = mobFinish && total == list.Count;
            if(result && clear)
            {
                list.ForEach(x => _=inv.Delete((byte)x.SlotId));
                Details.Sub.Where(x => x.Allowed.Contains(Character.Class)).ToList().ForEach( x => Clear(x));
            }

            return (byte)(result?0:1);
        }

        private byte canRun()
        {
            var sub = Details.Sub.Find(x => x.Allowed.Any(y => y == Character.Class));

            if (sub == null)
                return 0;

            return (byte)(Details.Conditions.FindAll(x => x.Index == sub.Index || x.Index == -1)
                .LastOrDefault(x => !x.CanRun(Character))?.Message ?? 0);
        }

        internal async Task Save(GameContext db)
        {
            if (!_needSave)
                return;
            _needSave = false;

            var details = string.Join(";",Manager._questMonsterKillCount
                .Where(x => x.Quest == Index)
                .Select(x => x.Number.ToString()));

            var dto =
                    new MU.DataBase.QuestDto
                    {
                        QuestId = _dbId,
                        Quest = Index,
                        State = (byte)State,
                        Details = details,
                        CharacterId = Manager.Player.Character.Id,
                    };

            var msg = _dbId == 0 ? "Added" : "Updated";
            Quests._logger
                    .ForAccount(Manager.Player.Session)
                    .Information("Quest:{0} {1} State:{2}", Details.Name, msg, State);

            if (_dbId == 0)
                db.Quests.Add(dto);
            else
                db.Quests.Update(dto);

            await db.SaveChangesAsync();

            _dbId = dto.QuestId;
        }

        internal IDictionary<ushort, byte> GetKillCount()
        {
            return Manager._questMonsterKillCount
                .Where(x => x.Quest == Index)
                .ToDictionary(x => x.Monster, y => y.Count);
        }
    }

    internal class Quest4thInfo
    {
        private byte state;
        private List<Monster> monsters = new List<Monster>();
        private DateTime end;
        private Monster centNPC;

        public Player Master { get; set; }
        public List<Player> Members => Master.Character.Party?.Members.ToList() ?? new List<Player> { Master };
        public byte State { get => state;
            set
            {
                state = value;
                onSetState();
            }
        }

        public Quest4thInfo()
        {
            centNPC = MonstersMng.Instance.CreateMonster(766, 
                ObjectType.NPC, 
                Maps.NewQuest,
                new System.Drawing.Point(147, 29),
                1);

            centNPC.Active = false;
            centNPC.Params = this;
        }

        internal IEnumerable<Monster> GetMonsters()
        {
            var copy = monsters.ToList();
            copy.Add(centNPC);
            return copy;
        }

        private void onSetState()
        {
            monsters.ForEach(x => x.Active = false);
            centNPC.Active = false;

            var masterQuest = Master.Character?.Quests.Find(766)??null;
            Log.Logger.Debug("Quest state changed to {0}, main quest index {1}", state, masterQuest?.Index??0);
            switch (state)
            {
                case 0: // Created State
                    break;
                case 10: // Talk End
                case 7: // Talk
                case 4: // Talk
                case 1: // Firts Talk
                    centNPC.Active = true;
                    break;
                case 8: // Set Reg
                case 5: // Set Reg
                case 2: // Set Reg
                    if (questPartyNextStep(766, new QuestState[] { QuestState.Clear, QuestState.Unreg }))
                        State++;
                    else
                        State--;
                    break;
                case 9: // Final Cent Battle
                    monsters.ForEach(x => x.Active = true);
                    break;
                case 6: // Summon Monsters
                case 3: // Cent Test Battle
                    var SubQuests = masterQuest.Details.Sub.Where(x => x.Allowed.Contains(Master.Character.Class)).ToList();
                    foreach (var sub in SubQuests)
                    {
                        for (var i = 0; i < sub.Count; i++)
                        {
                            monsters.Add(MonstersMng.Instance.CreateMonster(
                                sub.Monster,
                                ObjectType.Monster,
                                Maps.NewQuest,
                                new System.Drawing.Point(147, 29),
                                1));
                        }
                    }
                    monsters.ForEach(x => x.Die += X_Die);
                    if(state == 6)
                    {
                        _ = Members.SendAsync(new SQuestSurvivalTime
                        {
                            Increase = 0,
                            Time = 1 * 60 * 1000,
                            Type = QSType.QuestSurvivalTime,
                        });

                        end = DateTime.Now.AddMinutes(1);
                    }
                    break;
            }
            monsters.ForEach(x => x.Params = this);
        }

        private bool questPartyNextStep(ushort npc, QuestState[] states)
        {
            var masterQuest = Members.First().Character.Quests.Find(npc);
            bool result = true;
            foreach (var member in Members)
            {
                var q = member.Character.Quests.Find(npc);
                if (q.Index > masterQuest.Index || (q.Index == masterQuest.Index && q.State == QuestState.Complete))
                    continue;

                if (q.Index < masterQuest.Index)
                    return false;

                if (states.Contains(q.State))
                    result &= q.NextStep() == 0;
            }

            return result;
        }

        private void X_Die(object sender, EventArgs e)
        {
            var mob = sender as Monster;
            var instance = mob.Params as Quest4thInfo;
            var quests = instance.Master.Character.Quests;
            var masterQuest = quests.Find(766);

            if (masterQuest.Index != 8)
            {
                instance.State++;
            }
        }

        public void Update()
        {
            if (state == 6 && end <= DateTime.Now)
            {
                var q = Master.Character.Quests.Find(766);
                if (q.canClear(false) == 0)
                {
                    State++;
                }
                else
                {
                    State = 4;
                }
            }
        }

        public void Dispose()
        {
            centNPC.Params = null;
            MonstersMng.Instance.DeleteMonster(centNPC);
            centNPC = null;
            monsters.ForEach(x => MonstersMng.Instance.DeleteMonster(x));
            monsters.Clear();
        }
    }
    internal static class Quest4th
    {
        private static Dictionary<Player, Quest4thInfo> _info = new Dictionary<Player, Quest4thInfo>();

        public static Quest4thInfo GetInfo(Player plr)
        {
            var master = plr.Character.Party?.Master ?? plr;

            if (!_info.ContainsKey(master))
            {
                _info.Add(master, new Quest4thInfo { Master = master });
                master.OnStatusChange += Master_OnStatusChange;
            }
            return _info[master];
        }

        private static void Master_OnStatusChange(object sender, EventArgs e)
        {
            RemoveInstance(sender as Player);
        }

        internal static void RemoveInstance(Player plr)
        {
            if (!_info.ContainsKey(plr))
                return;

            var instance = _info[plr];
            instance.State = 0;
            instance.Dispose();
            _info.Remove(plr);
        }

        internal static void Update()
        {
            _info.Values.ToList().ForEach(x => x.Update());
        }
    }
}


--file Bag.cs
﻿using MuEmu.Resources.XML;
using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu.Resources
{
    public class Bag : BagDto
    {
        public Bag(BagDto basea)
        {
            Extensions.AnonymousMap(this, basea);
        }

        public Item[] GetReward()
        {
            var result = new List<Item>();
            for(var i = 0; i < DropItemCount; i++)
            {
                if (DropItemRate < Program.RandomProvider(100))
                    continue;

                var tmp = Item[Program.RandomProvider(Item.Length-1)];
                byte OptionExe = 0;
                var exCoun = Program.RandomProvider(tmp.MaxExcellent, tmp.MinExcellent);
                for (var j = 0; j < exCoun; j++)
                {
                    var addOption = (byte)Math.Pow(2, Program.RandomProvider(5));
                    OptionExe |= addOption;
                }
                var Option28 = (byte)Program.RandomProvider(tmp.MaxOption, tmp.MinOption);
                var Plus = (byte)Program.RandomProvider(tmp.MaxLevel, tmp.MinLevel);
                var Luck = Program.RandomProvider(tmp.Luck ? 1:0)!=0 ? true : false;
                var Skill = Program.RandomProvider(tmp.Skill ? 1:0)!=0 ? true : false;
                result.Add(new Item(tmp.Number, Options: new { Plus, Option28, OptionExe, Luck, Skill }));
            }

            if (DropZenRate <= Program.RandomProvider(100) || result.Count == 0)
                result.Add(MuEmu.Item.Zen((uint)Program.RandomProvider(MaxZen, MinZen)));

            return result.ToArray();
        }
    }
}


--file CharacterInfo.cs
﻿using MU.Resources;
using MuEmu.Resources.Game;
using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu.Resources
{
    public class CharacterInfo
    {
        public HeroClass Class { get; set; }
        public Maps Map { get; set; }
        public ushort Level { get; set; }
        public StatsInfo Stats { get; set; }
        public AttriInfo Attributes { get; set; }
        public Dictionary<ushort, Item> Equipament { get; set; }
        public Spell[] Spells { get; set; }
    }
}


--file MapInfo.cs
﻿using MuEmu.Monsters;
using MU.Network.Game;
using MuEmu.Util;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Reflection.Metadata.Ecma335;
using System.Text;
using System.Threading.Tasks;
using WebZen.Util;
using MU.Resources;
using MuEmu.Network.Data;

namespace MuEmu.Resources.Map
{
    public enum ItemMapState : byte
    {
        Creating,
        Created,
        Deleting,
        Deleted,
    }

    public class ItemInMap
    {
        public ushort Index { get; set; }
        public ItemMapState State { get; set; }
        public Point Position { get; set; }
        public Item Item { get; set; }
        public DateTimeOffset validTime { get; set; }

        public Character Character { get; set; }
        public DateTimeOffset OwnedTime { get; set; }
    };
    public class MapInfo
    {
        private List<MapAttributes[]> _shadowLayer = new List<MapAttributes[]>();
        private DateTime _nextWeater;
        private List<ushort> _reuseAddress;

        internal Item ItemPickUp(Character @char, ushort number)
        {
            if(!Items.ContainsKey(number) || Items[number].State != ItemMapState.Created)
            {
                throw new Exception("This item don't exists.");
            }

            var item = Items[number];

            if (
                item.Item.Number != ItemNumber.Zen && 
                item.Character != null && 
                item.Character != @char && 
                item.OwnedTime > DateTimeOffset.Now
                )
            {
                throw new Exception("This item does not belong to you");
            }
            return item.Item;
        }

        private MapAttributes[] Layer { get; }
        private List<Point> SafePoints { get; set; }
        private IEnumerable<Monster> NPC => Monsters.Where(x => x.Type == ObjectType.NPC);
        public int Width { get; }
        public int Height { get; }
        public List<Monster> Monsters { get; }
        public List<Character> Players { get; }
        public Dictionary<ushort, ItemInMap> Items { get; }
        public int Map { get; }
        public bool IsEvent { get; }
        public byte Weather { get; set; }
        public bool DragonInvasion { get; set; }
        public Rectangle SafeArea { get; private set; }
        public Point GetRespawn()
        {
            if (SafePoints == null)
            {
                SafePoints = new List<Point>();
                for (var y = SafeArea.Y; y < SafeArea.Bottom; y++)
                {
                    for (var x = SafeArea.X; x < SafeArea.Right; x++)
                    {
                        var cell = Layer[x + y * 256];
                        if ((cell & (MapAttributes.NoWalk | MapAttributes.Hide)) == 0)
                        {
                            SafePoints.Add(new Point(x, y));
                        }
                    }
                }
            }
            if (SafePoints.Any())
            {
                var rand = Program.RandomProvider(SafePoints.Count());
                var id = SafePoints[rand];
                return id;
            }
            else
            {
                var p = ResourceCache.Instance.GetGates().Values
                    .First(x => x.Map == (Maps)Map)
                    .Door.Location;

                SafePoints.Add(p);
            }

            return new Point();
        }
        internal ushort GetAddress()
        {
            if(_reuseAddress.Any())
            {
                var reuse = _reuseAddress[0];
                _reuseAddress.RemoveAt(0);
                return reuse;
            }

            return (ushort)Items.Count;
        }

        /// <summary>
        /// On Player warps into the map (Sender as Player)
        /// </summary>
        public event EventHandler PlayerJoins;
        /// <summary>
        /// On Player leave the map (Sender as Player)
        /// </summary>
        public event EventHandler PlayerLeaves;

        /// <summary>
        /// On Monster added to map Invoke event with sender as monster
        /// </summary>
        public event EventHandler MonsterAdd;
        
        public MapInfo(int map, string attFile)
        {
            Maps[] disabled = new Maps[]
            {
                Maps.BloodCastle1,
                Maps.BloodCastle2,
                Maps.BloodCastle3,
                Maps.BloodCastle4,
                Maps.BloodCastle5,
                Maps.BloodCastle6,
                Maps.BloodCastle7,
                Maps.BloodCastle8,
                Maps.DevilSquare,
                Maps.DevilSquare2,
                Maps.ChaosCastle1,
                Maps.ChaosCastle2,
                Maps.ChaosCastle3,
                Maps.ChaosCastle4,
                Maps.ChaosCastle5,
                Maps.ChaosCastle6,
                Maps.ChaosCastle7,
            };

            IsEvent = disabled.Any(x => (int)x == map);

            using (var fr = File.OpenRead(attFile))
            {
                var length = fr.Length;
                var type = fr.ReadByte();
                Width = fr.ReadByte();
                Height = fr.ReadByte();
                length -= fr.Position;

                var tmp = new byte[length];
                fr.Read(tmp, 0, tmp.Length);
                Layer = tmp.Select(x => (MapAttributes)x).ToArray();

                Map = map;
            }

            Weather = 0x30;
            _nextWeater = DateTime.Now.AddMilliseconds(Program.RandomProvider(10000) + 10000);

            Monsters = new List<Monster>();
            Players = new List<Character>();
            Items = new Dictionary<ushort, ItemInMap>();
            _reuseAddress = new List<ushort>();
            switch((Maps)Map)
            {
                case Maps.Lorencia:
                    SafeArea = new Rectangle(130, 116, 21, 21);
                    break;
                case Maps.Dugeon:
                    SafeArea = new Rectangle(106, 236, 6, 7);
                    break;
                case Maps.Davias:
                    SafeArea = new Rectangle(197, 35, 21, 15);
                    break;
                case Maps.Noria:
                    SafeArea = new Rectangle(174, 101, 13, 24);
                    break;
                case Maps.LostTower:
                    SafeArea = new Rectangle(201, 70, 12, 11);
                    break;
                case Maps.Atlans:
                    SafeArea = new Rectangle(14, 11, 13, 12);
                    break;
                case Maps.Tarkan:
                    SafeArea = new Rectangle(187, 54, 16, 15);
                    break;
                case Maps.Aida:
                    SafeArea = new Rectangle(82, 8, 5, 6);
                    break;
                //case Maps.Barracks:
                //    SafeArea = new Rectangle(30, 75, 33, 78);
                //    break;
                case Maps.Elbeland:
                    SafeArea = new Rectangle(50, 220, 6, 6);
                    break;
                case Maps.SilentSwamp:
                    SafeArea = new Rectangle(135, 105, 10, 10);
                    break;
                case Maps.Raklion:
                    SafeArea = new Rectangle(220, 210, 13, 2);
                    break;
                case Maps.Vulcan:
                    SafeArea = new Rectangle(110, 120, 15, 15);
                    break;
                case Maps.Kantru1:
                    SafeArea = new Rectangle(124, 123, 3, 2);
                    break;
                case Maps.Kantru2:
                    SafeArea = new Rectangle(162, 16, 1, 1);
                    break;
                default:
                    SafeArea = new Rectangle(0, 0, 255, 255);
                    break;
            }
        }

        private MapAttributes GetByte(int X, int Y)
        {
            if (Y * 256 + X > Layer.Length)
                return MapAttributes.Unknow;

            return Layer[Y * 256 + X];
        }
        private void SetByte(int X, int Y, MapAttributes val)
        {
            Layer[Y * 256 + X] = val;
        }

        public bool ContainsAny(int X, int Y, MapAttributes[] attrs)
        {
            var info = GetByte(X, Y);
            MapAttributes @byte = 0;
            foreach(var att in attrs)
                @byte |= att;

            return (info & @byte) != 0;
        }

        public MapAttributes[] GetAttributes(int X, int Y)
        {
            var info = GetByte(X, Y);
            var in_ = (MapAttributes[])Enum.GetValues(typeof(MapAttributes));
            return in_.Where(x => (x & info) != 0).ToArray();
        }

        public MapAttributes[] GetAttributes(Point pt)
        {
            return GetAttributes(pt.X, pt.Y);
        }

        public void SetAttribute(int X, int Y, MapAttributes att)
        {
            SetByte(X, Y, (GetByte(X, Y) | att));
        }

        public void ClearAttribute(int X, int Y, MapAttributes att)
        {
            SetByte(X, Y, (GetByte(X, Y) & (~att)));
        }

        public void AddPlayer(Character @char)
        {
            SendMinimapInfo(@char);
            SendWeather(@char);
            var pos = @char.Position;
            SetAttribute(pos.X, pos.Y, MapAttributes.Stand);
            Players.Add(@char);
            PlayerJoins?.Invoke(@char.Player, new EventArgs());
        }

        public async void SendMinimapInfo(Character @char)
        {
            byte i = 0;
            var npcs = ResourceCache.Instance.GetNPCs();
            var gates = ResourceCache.Instance.GetGates();
            var mapGates = gates
                .Where(x => x.Value.Map == (Maps)Map && x.Value.GateType == GateType.Entrance)
                .Select(x => x.Value);

            foreach (var npc in NPC)
            {
                var icon = MiniMapTag.Shield;
                if(npcs.TryGetValue(npc.Info.Monster, out var npcInfo))
                {
                    icon = npcInfo.Icon;
                }
                await @char.Player.Session.SendAsync(new SMiniMapNPC(npc.Position, i++, icon, 0, npc.Info.Name));
            }
            foreach (var gate in mapGates)
            {
                var target = gates[gate.Target].Map;
                await @char.Player.Session.SendAsync(new SMiniMapNPC(gate.Door, i++, MiniMapTag.Shield, 0, target));
            }
        }

        internal void DeleteItem(ItemInMap it)
        {
            it.State = ItemMapState.Deleted;
            _reuseAddress.Add(it.Index);
        }

        public void SendWeather(Character @char)
        {
            SubSystem.Instance.AddDelayedMessage(@char.Player, TimeSpan.FromSeconds(1), new SWeather(Weather));
            SubSystem.Instance.AddDelayedMessage(@char.Player, TimeSpan.FromSeconds(1), new SEventState(MapEvents.GoldenInvasion, DragonInvasion));
        }

        public void AddMonster(Monster mons)
        {
            var pos = mons.Position;
            SetAttribute(pos.X, pos.Y, MapAttributes.Stand);
            lock(Monsters)
                Monsters.Add(mons);

            MonsterAdd?.Invoke(mons, new EventArgs());
        }

        public DateTimeOffset AddItem(int X, int Y, Item item, Character character = null)
        {
            if (item == null)
                return DateTimeOffset.Now;
            item.Character?.Inventory.Remove(item);
            item.Character = null;
            item.Account = null;
            item.SlotId = 0;
            item.Storage = 0;

            var valid = DateTimeOffset.Now.AddSeconds(120);
            var own = DateTimeOffset.Now.AddSeconds(60);

            ItemInMap it = new ItemInMap {
                Index = GetAddress(),
                Item = item,
                State = ItemMapState.Creating,
                Position = new Point(X, Y),
                validTime = valid,
                Character = character,
                OwnedTime = own,
            };

            lock (Items)
            {
                if (Items.ContainsKey(it.Index))
                {
                    Items[it.Index] = it;
                }
                else
                {
                    Items.Add(it.Index, it);
                }
            }

            return valid;
        }
        
        public void DelPlayer(Character @char)
        {
            var pos = @char.Position;
            ClearAttribute(pos.X, pos.Y, MapAttributes.Stand);
            Players.Remove(@char);
            PlayerLeaves?.Invoke(@char.Player, new EventArgs());
        }
        public void DelMonster(Monster mons)
        {
            var pos = mons.Position;
            ClearAttribute(pos.X, pos.Y, MapAttributes.Stand);
            lock(Monsters)
                Monsters.Remove(mons);
            
        }

        public void PositionChanged(Point prev, Point current)
        {
            ClearAttribute(prev.X, prev.Y, MapAttributes.Stand);
            SetAttribute(current.X, current.Y, MapAttributes.Stand);
        }

        public async Task AddAttribute(MapAttributes att, Rectangle area)
        {
            await AddAttribute(att, new Rectangle[] { area });
        }

        public async Task AddAttribute(MapAttributes att, Rectangle[] areas)
        {
            var result = new List<MapRectDto>();
            foreach (var area in areas)
            {
                for (int y = area.Top; y < area.Bottom; y++)
                    for (int x = area.Left; x < area.Right; x++)
                        SetAttribute(x, y, att);

                result.Add(new MapRectDto
                {
                    StartX = (byte)area.Left,
                    StartY = (byte)area.Top,
                    EndX = (byte)area.Right,
                    EndY = (byte)area.Bottom
                });
            }

            await SendAsync(new SSetMapAttribute(0, att, 1, result.ToArray()));
        }

        public async Task RemoveAttribute(MapAttributes att, Rectangle area)
        {
            await RemoveAttribute(att, new Rectangle[] { area });
        }

        public async Task RemoveAttribute(MapAttributes att, Rectangle[] areas)
        {
            var result = new List<MapRectDto>();
            foreach (var area in areas)
            {
                for (int y = area.Top; y < area.Bottom; y++)
                    for (int x = area.Left; x < area.Right; x++)
                    {
                        ClearAttribute(x, y, att);
                    }

                result.Add(new MapRectDto
                {
                    StartX = (byte)area.Left,
                    StartY = (byte)area.Top,
                    EndX = (byte)area.Right,
                    EndY = (byte)area.Bottom
                });
            }

            await SendAsync(new SSetMapAttribute(0, att, 1, result.ToArray()));
        }

        public async Task SendAsync(object message)
        {
            foreach(var @char in Players)
                await @char.Player.Session.SendAsync(message);
        }

        public void Push()
        {
            _shadowLayer.Add(Layer.ToArray());
        }

        public void Pop()
        {
            var last = _shadowLayer.PopBack();
            Array.Copy(last, Layer, Layer.Length);
        }

        public async Task WeatherUpdate()
        {
            if (DateTime.Now < _nextWeater)
                return;

            _nextWeater = DateTime.Now.AddMilliseconds(Program.RandomProvider(10000) + 10000);

            Weather = (byte)(Program.RandomProvider(3) << 4 | Program.RandomProvider(10));
            await SendAsync(new SWeather(Weather));
        }

        internal SViewPortItemDestroy ItemGive(ushort number)
        {
            Items[number].State = ItemMapState.Deleted;
            _reuseAddress.Add(number);
            return new SViewPortItemDestroy { ViewPort = new VPDestroyDto[] { new VPDestroyDto(number) } };
        }
    }
}


--file ResourceCache.cs
﻿using BlubLib.Caching;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MuEmu.Resources.Map;
using MuEmu.Resources.Game;
using MU.Resources;
using MU.Resources.Game;
using MuEmu.Data;

namespace MuEmu.Resources
{
    public class ResourceCache
    {
        private static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(ResourceCache));

        public static ResourceCache Instance { get; private set; }
        private ResourceLoader _loader;
        private MemoryCache _cache;

        private ResourceCache(string root)
        {
            _loader = new ResourceLoader(root);
            _cache = new MemoryCache();
        }

        public static void Initialize(string root)
        {
            if (Instance != null)
                throw new Exception(ServerMessages.GetMessage(Messages.RCache_Initialized));

            Instance = new ResourceCache(root);

            Instance.GetItems();
            Instance.GetSkills();
            Instance.GetMaps();
            Instance.GetDefChar();
            Instance.GetShops();
            Instance.GetNPCs();
            Instance.GetJOH();
            Instance.GetGates();
            Instance.GetQuests();
            Instance.GetChaosMixInfo();
            Instance.GetItemBags();
            Instance.GetPCPointShop();
        }

        public IDictionary<ushort, ItemInfo> GetItems()
        {
            var cache = _cache.Get<IDictionary<ushort, ItemInfo>>("Items");
            if(cache == null)
            {
                Logger.Information(ServerMessages.GetMessage(Messages.RCache_Loading_Items));
                cache = _loader.LoadItems().ToDictionary(x => x.Number);
                _cache.Set("Items", cache);
            }

            return cache;
        }

        public IDictionary<Spell, SpellInfo> GetSkills()
        {
            var cache = _cache.Get<IDictionary<Spell, SpellInfo>>("Spells");
            if (cache == null)
            {
                Logger.Information(ServerMessages.GetMessage(Messages.RCache_Loading_Spells));
                cache = _loader.LoadSkills().ToDictionary(x => x.Number);
                _cache.Set("Spells", cache);
            }

            return cache;
        }

        public IDictionary<Maps, MapInfo> GetMaps()
        {
            var cache = _cache.Get<IDictionary<Maps, MapInfo>>("Maps");
            if (cache == null)
            {
                Logger.Information(ServerMessages.GetMessage(Messages.RCache_Loading_Maps));
                cache = _loader.LoadMaps().ToDictionary(x => (Maps)x.Map);
                _cache.Set("Maps", cache);
            }

            return cache;
        }

        public IDictionary<HeroClass, CharacterInfo> GetDefChar()
        {
            var cache = _cache.Get<IDictionary<HeroClass, CharacterInfo>>("DefClass");
            if (cache == null)
            {
                Logger.Information(ServerMessages.GetMessage(Messages.RCache_Loading_DefClass));
                cache = _loader.LoadDefCharacter().ToDictionary(x => x.Class);
                _cache.Set("DefClass", cache);
            }

            return cache;
        }

        public IDictionary<ushort, ShopInfo> GetShops()
        {
            var cache = _cache.Get<IDictionary<ushort, ShopInfo>>("Shops");
            if (cache == null)
            {
                Logger.Information(ServerMessages.GetMessage(Messages.RCache_Loading_Shops));
                cache = _loader.LoadShops().ToDictionary(x => x.Shop);
                _cache.Set("Shops", cache);
            }

            return cache;
        }

        public IDictionary<ushort, NPCInfo> GetNPCs()
        {
            var cache = _cache.Get<IDictionary<ushort, NPCInfo>>("NPCs");
            if (cache == null)
            {
                Logger.Information(ServerMessages.GetMessage(Messages.RCache_Loading_NPCs));
                cache = _loader.LoadNPCs().ToDictionary(x => x.NPC);
                _cache.Set("NPCs", cache);
            }

            return cache;
        }

        public JOHDto GetJOH()
        {
            var cache = _cache.Get<JOHDto>("JOH");
            if (cache == null)
            {
                Logger.Information(ServerMessages.GetMessage(Messages.RCache_Loading_JoHs));
                cache = _loader.LoadJOH();//.ToDictionary(x => (byte)(x.Type << 4 | x.Index));
                _cache.Set("JOH", cache);
            }

            return cache;
        }

        public IDictionary<int, Gate> GetGates()
        {
            var cache = _cache.Get<IDictionary<int, Gate>>("Gates");
            if (cache == null)
            {
                Logger.Information(ServerMessages.GetMessage(Messages.RCache_Loading_Gates));
                cache = _loader.LoadGates().ToDictionary(x => x.Number);
                _cache.Set("Gates", cache);
            }

            return cache;
        }

        public IDictionary<int, QuestInfo> GetQuests()
        {
            var cache = _cache.Get<IDictionary<int, QuestInfo>>("Quests");
            if (cache == null)
            {
                Logger.Information(ServerMessages.GetMessage(Messages.RCache_Loading_Quests));
                cache = _loader.LoadQuests().ToDictionary(x => x.Index);
                _cache.Set("Quests", cache);
            }

            return cache;
        }

        public ChaosMixInfo GetChaosMixInfo()
        {
            var cache = _cache.Get<ChaosMixInfo>("ChaosMix");
            if (cache == null)
            {
                Logger.Information(ServerMessages.GetMessage(Messages.RCache_Loading_ChaosMixs));
                cache = _loader.LoadChaosBox();
                _cache.Set("ChaosMix", cache);
            }

            return cache;
        }

        public IEnumerable<Bag> GetItemBags()
        {
            var cache = _cache.Get<IEnumerable<Bag>>("ItemBags");
            if (cache == null)
            {
                Logger.Information(ServerMessages.GetMessage(Messages.RCache_Loading_ItemBags));
                cache = _loader.LoadItembags();
                cache.ToList();
                _cache.Set("ItemBags", cache);
            }

            return cache;
        }

        public Storage GetPCPointShop()
        {
            var cache = _cache.Get<Storage>("PCPoint");
            if (cache == null)
            {
                Logger.Information(ServerMessages.GetMessage(Messages.RCache_Loading_Shops));
                cache = _loader.LoadPCPointShop();
                _cache.Set("PCPoint", cache);
            }

            return cache;
            
        }

        public void ReloadShops()
        {
            _cache.Remove("Shops");
            GetShops();
        }

        public void ReloadGates()
        {
            _cache.Remove("Gates");
            GetGates();
        }

        public void ReloadChaosMix()
        {
            _cache.Remove("ChaosMix");
            GetChaosMixInfo();
        }

        internal void ReloadItembags()
        {
            _cache.Remove("ItemBags");
            GetItemBags();
        }
    }
}


--file ResourceLoader.cs
﻿using Google.Protobuf.WellKnownTypes;
using MU.Resources;
using MU.Resources.Game;
using MU.Resources.XML;
using MuEmu.Data;
using MuEmu.Resources.Game;
using MuEmu.Resources.Map;
using MuEmu.Resources.XML;
using MuEmu.Util;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml.Serialization;

namespace MuEmu.Resources
{
    public class ResourceLoader
    {
        private static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(ResourceLoader));
        private string _root;

        public ResourceLoader(string root)
        {
            _root = root;
        }

        public static T XmlLoader<T>(string file)
        {
            var s = new XmlSerializer(typeof(T));
            using (var ts = File.OpenText(file))
                return (T)s.Deserialize(ts);
        }

        public static void XmlSaver<T>(string file, T xml)
        {
            var s = new XmlSerializer(typeof(T));
            using (var ts = File.OpenWrite(file))
                s.Serialize(ts, xml);
        }

        private IEnumerable<ItemInfo> LoadItemsXML()
        {
            var result = new List<ItemInfo>();
            var dir = Path.Combine(_root, "Items.xml");            
            var xml = XmlLoader<ItemDbDto>(dir);

            foreach (var i in xml.items)
            {
                var Size = i.Size.Split(",").Select(x => int.Parse(x)).ToArray();
                var Dmg = i.Dmg.Split("-").Select(x => int.Parse(x)).ToArray();
                var tmp = new ItemInfo
                {
                    Number = i.Number,
                    Size = new Size(Size[0], Size[1]),
                    Option = bool.Parse(i.Option),
                    Drop = bool.Parse(i.Drop),
                    Damage = new Point(Dmg[0], Dmg[1]),
                    Speed = i.Speed,
                    Str = i.NeededStr,
                    Agi = i.NeededAgi,
                    Vit = i.NeededVit,
                    Ene = i.NeededEne,
                    Cmd = i.NeededCmd,
                    Level = i.Level,
                    Def = i.Defense,
                    DefRate = i.DefenseRate,
                    Attributes = i.Attributes.Split(",").Where(x => !string.IsNullOrEmpty(x)).Select(x => System.Enum.Parse<AttributeType>(x)).ToList(),
                    Zen = i.Zen,
                    Ruud = i.Ruud,
                    Classes = i.ReqClass.Split(",").Where(x => !string.IsNullOrEmpty(x)).Select(x => System.Enum.Parse<HeroClass>(x)).ToList(),
                    Skill = System.Enum.Parse<Spell>(i.Skill),
                    Durability = i.Durability,
                    MagicDur = i.MagicDur,
                    MagicPower = i.MagicPower,
                    Name = i.Name,
                    ReqLevel = i.NeededLevel,
                    MaxStack = i.MaxStack,
                    OnMaxStack = i.OnMaxStack,
                    IsMount = bool.Parse(i.IsMount),
                    Skin = i.Skin,
                    Inventory = System.Enum.Parse<StorageID>(i.Inventory),
                };

                result.Add(tmp);
            }

            return result;
        }
        public IEnumerable<ItemInfo> LoadItems()
        {
            try
            {
                return LoadItemsXML();
            }
            catch (FileNotFoundException)
            {
                var result = new List<ItemInfo>();
                if(File.Exists(Path.Combine(_root, "ItemS16.txt")))
                {
                    var loaderS16 = new LoadWZSectionTXT<ItemBMDS16GroupBasic>();
                    var info = loaderS16.Load(File.ReadAllText(Path.Combine(_root, "ItemS16.txt")));
                    result = info.Select(x => Extensions.AnonymousMap(new ItemInfo(), x)).ToList();
                }
                else
                using (var tr = File.OpenText(Path.Combine(_root, "Item.txt")))
                {
                    var ItemRegex = new Regex(@"([0-9]+)\s*\n+(?s)(.*?)\nend");
                    var Item0Regex = new Regex(@"([0-9]+)\s+([\-0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+" + "\"" + @"(.+)" + "\"" + @"\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)");
                    var Item6Regex = new Regex(@"([0-9]+)\s+([\-0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+" + "\"" + @"(.+)" + "\"" + @"\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)");
                    var Item12Regex = new Regex(@"([0-9]+)\s+([\-0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+" + "\"" + @"(.+)" + "\"" + @"\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)");
                    var Item13Regex = new Regex(@"([0-9]+)\s+([\-0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+" + "\"" + @"(.+)" + "\"" + @"\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)");
                    var Item14Regex = new Regex(@"([0-9]+)\s+([\-0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+" + "\"" + @"(.+)" + "\"" + @"\s+([0-9]+)\s+([0-9]+)");
                    var Item15Regex = new Regex(@"([0-9]+)\s+([\-0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+" + "\"" + @"(.+)" + "\"" + @"\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)");
                    foreach (Match m in ItemRegex.Matches(tr.ReadToEnd()))
                    {
                        var type = (ItemType)byte.Parse(m.Groups[1].Value);
                        switch(type)
                        {
                            case ItemType.Sword:
                            case ItemType.Axe:
                            case ItemType.Scepter:
                            case ItemType.Spear:
                            case ItemType.BowOrCrossbow:
                            case ItemType.Staff:
                                foreach (Match sm in Item0Regex.Matches(m.Groups[2].Value))
                                {
                                    var c = new List<HeroClass>();
                                    if (byte.Parse(sm.Groups[24].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[24].Value) - 1));
                                    if (byte.Parse(sm.Groups[25].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[25].Value) - 1 + 0x10));
                                    if (byte.Parse(sm.Groups[26].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[26].Value) - 1 + 0x20));
                                    if (byte.Parse(sm.Groups[27].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[27].Value) - 1 + 0x30));
                                    if (byte.Parse(sm.Groups[28].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[28].Value) - 1 + 0x40));
                                    if (byte.Parse(sm.Groups[29].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[29].Value) - 1 + 0x50));

                                    result.Add(new ItemInfo
                                    {
                                        Number = new ItemNumber(type, ushort.Parse(sm.Groups[1].Value)),
                                        Skill = (Spell)ushort.Parse(sm.Groups[3].Value),
                                        Size = new Size(byte.Parse(sm.Groups[4].Value), byte.Parse(sm.Groups[5].Value)),
                                        Option = byte.Parse(sm.Groups[7].Value) != 0,
                                        Drop = byte.Parse(sm.Groups[8].Value) != 0,
                                        Name = sm.Groups[9].Value,
                                        Level = ushort.Parse(sm.Groups[10].Value),
                                        Damage = new Point(ushort.Parse(sm.Groups[11].Value), ushort.Parse(sm.Groups[12].Value)),
                                        Speed = ushort.Parse(sm.Groups[13].Value),
                                        Durability = byte.Parse(sm.Groups[14].Value),
                                        MagicDur = byte.Parse(sm.Groups[15].Value),
                                        MagicPower = byte.Parse(sm.Groups[16].Value),
                                        ReqLevel = ushort.Parse(sm.Groups[17].Value),
                                        Str = ushort.Parse(sm.Groups[18].Value),
                                        Agi = ushort.Parse(sm.Groups[19].Value),
                                        Ene = ushort.Parse(sm.Groups[20].Value),
                                        Vit = ushort.Parse(sm.Groups[21].Value),
                                        Cmd = ushort.Parse(sm.Groups[22].Value),
                                        Classes = c
                                    });
                                }
                                break;
                            case ItemType.Shield:
                            case ItemType.Helm:
                            case ItemType.Armor:
                            case ItemType.Pant:
                            case ItemType.Gloves:
                            case ItemType.Boots:
                                foreach (Match sm in Item6Regex.Matches(m.Groups[2].Value))
                                {
                                    var c = new List<HeroClass>();
                                    if (byte.Parse(sm.Groups[21].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[21].Value) - 1));
                                    if (byte.Parse(sm.Groups[22].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[22].Value) - 1 + 0x10));
                                    if (byte.Parse(sm.Groups[23].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[23].Value) - 1 + 0x20));
                                    if (byte.Parse(sm.Groups[24].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[24].Value) - 1 + 0x30));
                                    if (byte.Parse(sm.Groups[25].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[25].Value) - 1 + 0x40));
                                    if (byte.Parse(sm.Groups[26].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[26].Value) - 1 + 0x50));

                                    var item = new ItemInfo
                                    {
                                        Number = new ItemNumber(type, ushort.Parse(sm.Groups[1].Value)),
                                        Size = new Size(byte.Parse(sm.Groups[4].Value), byte.Parse(sm.Groups[5].Value)),
                                        Option = byte.Parse(sm.Groups[7].Value) != 0,
                                        Drop = byte.Parse(sm.Groups[8].Value) != 0,
                                        Name = sm.Groups[9].Value,
                                        Level = ushort.Parse(sm.Groups[10].Value),
                                        Def = ushort.Parse(sm.Groups[11].Value),
                                        DefRate = ushort.Parse(sm.Groups[12].Value),
                                        Durability = byte.Parse(sm.Groups[13].Value),
                                        ReqLevel = ushort.Parse(sm.Groups[14].Value),
                                        Str = ushort.Parse(sm.Groups[15].Value),
                                        Agi = ushort.Parse(sm.Groups[16].Value),
                                        Vit = ushort.Parse(sm.Groups[17].Value),
                                        Ene = ushort.Parse(sm.Groups[18].Value),
                                        Cmd = ushort.Parse(sm.Groups[19].Value),
                                        Classes = c
                                    };
                                    result.Add(item);
                                }
                                    break;
                            case ItemType.Wing_Orb_Seed:
                                foreach (Match sm in Item12Regex.Matches(m.Groups[2].Value))
                                {
                                    var c = new List<HeroClass>();
                                    if (byte.Parse(sm.Groups[19].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[19].Value) - 1));
                                    if (byte.Parse(sm.Groups[20].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[20].Value) - 1 + 0x10));
                                    if (byte.Parse(sm.Groups[21].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[21].Value) - 1 + 0x20));
                                    if (byte.Parse(sm.Groups[22].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[22].Value) - 1 + 0x30));
                                    if (byte.Parse(sm.Groups[23].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[23].Value) - 1 + 0x40));
                                    if (byte.Parse(sm.Groups[24].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[24].Value) - 1 + 0x50));

                                    result.Add(new ItemInfo
                                    {
                                        Number = new ItemNumber(type, ushort.Parse(sm.Groups[1].Value)),
                                        Size = new Size(byte.Parse(sm.Groups[4].Value), byte.Parse(sm.Groups[5].Value)),
                                        Option = byte.Parse(sm.Groups[7].Value) != 0,
                                        Drop = byte.Parse(sm.Groups[8].Value) != 0,
                                        Name = sm.Groups[9].Value,
                                        Level = ushort.Parse(sm.Groups[10].Value),
                                        Def = ushort.Parse(sm.Groups[11].Value),
                                        Durability = byte.Parse(sm.Groups[12].Value),
                                        ReqLevel = ushort.Parse(sm.Groups[13].Value),
                                        Ene = ushort.Parse(sm.Groups[14].Value),
                                        Str = ushort.Parse(sm.Groups[15].Value),
                                        Agi = ushort.Parse(sm.Groups[16].Value),
                                        Cmd = ushort.Parse(sm.Groups[17].Value),
                                        Zen = int.Parse(sm.Groups[18].Value),
                                        Classes = c
                                    });
                                }
                                break;
                            case ItemType.Missellaneo:
                                foreach (Match sm in Item13Regex.Matches(m.Groups[2].Value))
                                {
                                    var c = new List<HeroClass>();
                                    if (byte.Parse(sm.Groups[20].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[20].Value) - 1 + 0x00));
                                    if (byte.Parse(sm.Groups[21].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[21].Value) - 1 + 0x10));
                                    if (byte.Parse(sm.Groups[22].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[22].Value) - 1 + 0x20));
                                    if (byte.Parse(sm.Groups[23].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[23].Value) - 1 + 0x30));
                                    if (byte.Parse(sm.Groups[24].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[24].Value) - 1 + 0x40));
                                    if (byte.Parse(sm.Groups[25].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[25].Value) - 1 + 0x50));

                                    var a = new List<AttributeType>();
                                    for(var i=0; i < 7; i++)
                                    {
                                        if (byte.Parse(sm.Groups[12 + i].Value) != 0)
                                            a.Add((AttributeType)i);
                                    }

                                    result.Add(new ItemInfo
                                    {
                                        Number = new ItemNumber(type, ushort.Parse(sm.Groups[1].Value)),
                                        Size = new Size(byte.Parse(sm.Groups[4].Value), byte.Parse(sm.Groups[5].Value)),
                                        Option = byte.Parse(sm.Groups[7].Value) != 0,
                                        Drop = byte.Parse(sm.Groups[8].Value) != 0,
                                        Name = sm.Groups[9].Value,
                                        Level = ushort.Parse(sm.Groups[10].Value),
                                        Durability = byte.Parse(sm.Groups[11].Value),
                                        Attributes = a,
                                        Classes = c
                                    });
                                }
                                break;
                            case ItemType.Potion:
                                foreach (Match sm in Item14Regex.Matches(m.Groups[2].Value))
                                {
                                    result.Add(new ItemInfo
                                    {
                                        Number = new ItemNumber(type, ushort.Parse(sm.Groups[1].Value)),
                                        Size = new Size(byte.Parse(sm.Groups[4].Value), byte.Parse(sm.Groups[5].Value)),
                                        Option = byte.Parse(sm.Groups[7].Value) != 0,
                                        Drop = byte.Parse(sm.Groups[8].Value) != 0,
                                        Name = sm.Groups[9].Value,
                                        Zen = int.Parse(sm.Groups[10].Value),
                                        Level = ushort.Parse(sm.Groups[11].Value),
                                        Classes = new List<HeroClass>(),
                                    });
                                }
                                break;
                            case ItemType.Scroll:
                                foreach (Match sm in Item15Regex.Matches(m.Groups[2].Value))
                                {
                                    var c = new List<HeroClass>();
                                    if (byte.Parse(sm.Groups[14].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[14].Value) - 1));
                                    if (byte.Parse(sm.Groups[15].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[15].Value) - 1 + 0x10));
                                    if (byte.Parse(sm.Groups[16].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[16].Value) - 1 + 0x20));
                                    if (byte.Parse(sm.Groups[17].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[17].Value) - 1 + 0x30));
                                    if (byte.Parse(sm.Groups[18].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[18].Value) - 1 + 0x40));
                                    if (byte.Parse(sm.Groups[19].Value) > 0)
                                        c.Add((HeroClass)(byte.Parse(sm.Groups[19].Value) - 1 + 0x50));

                                    Spell spell = Spell.None;
                                    var index = ushort.Parse(sm.Groups[1].Value);

                                    if (index <= 15)
                                    {
                                        spell = (Spell)(index + 1);
                                    }else if(index <= 18)
                                    {
                                        spell = (Spell)(index + 22);
                                    }
                                    else if (index <= 24)
                                    {
                                        spell = (Spell)(index + 195);
                                    }

                                    var itin = new ItemInfo
                                    {
                                        Number = new ItemNumber(type, index),
                                        Size = new Size(byte.Parse(sm.Groups[4].Value), byte.Parse(sm.Groups[5].Value)),
                                        Option = byte.Parse(sm.Groups[7].Value) != 0,
                                        Drop = byte.Parse(sm.Groups[8].Value) != 0,
                                        Name = sm.Groups[9].Value,
                                        Level = ushort.Parse(sm.Groups[10].Value),
                                        ReqLevel = ushort.Parse(sm.Groups[11].Value),
                                        Ene = ushort.Parse(sm.Groups[12].Value),
                                        Zen = int.Parse(sm.Groups[13].Value),
                                        Classes = c,
                                        Skill = spell
                                    };

                                    result.Add(itin);
                                }
                                break;
                        }
                    }
                }

                var xml = new ItemDbDto();
                xml.items = result.Select(x => new ItemDto
                {
                    Durability = x.Durability,
                    Dmg = $"{x.Damage.X}-{x.Damage.Y}",
                    Drop = x.Drop.ToString(),
                    Level = x.Level,
                    Defense = x.Def,
                    DefenseRate = x.DefRate,
                    MagicDur = x.MagicDur,
                    MagicPower = x.MagicPower,
                    Name = x.Name,
                    NeededAgi = x.Agi,
                    NeededCmd = x.Cmd,
                    NeededEne = x.Ene,
                    NeededLevel = x.ReqLevel,
                    NeededStr = x.Str,
                    NeededVit = x.Vit,
                    Number = x.Number,
                    Option = x.Option.ToString(),
                    ReqClass = string.Join(",", x.Classes),
                    Attributes = string.Join(",", x?.Attributes??new List<AttributeType>()),
                    Size = $"{x.Size.Width},{x.Size.Height}",
                    Skill = x.Skill.ToString(),
                    Speed = x.Speed,
                    Zen = x.Zen,
                    Ruud = x.Ruud,
                }).ToArray();

                XmlSaver(Path.Combine(_root, "Items.xml"), xml);
                return result;
            }           
        }

        public IEnumerable<SpellInfo> LoadSkills()
        {
            var result = new List<SpellInfo>();
            SpellDbDto xml;
            try
            {
                xml = XmlLoader<SpellDbDto>(Path.Combine(_root, "Skills.xml"));
            }catch(FileNotFoundException)
            {
                using (var tr = File.OpenText(Path.Combine(_root, "Skill.txt")))
                {
                    var SkillRegex = new Regex(@"([0-9]+)\s+" + "\"" + @"(.+)" + "\"" + @"\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+(-?[0-9]+)\s+(-?[0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)");
                    foreach(Match m in SkillRegex.Matches(tr.ReadToEnd()))
                    {
                        var c = new List<HeroClass>();
                        if (byte.Parse(m.Groups[19].Value) > 0) //DW
                            c.Add((HeroClass)(byte.Parse(m.Groups[19].Value) - 1));
                        if (byte.Parse(m.Groups[20].Value) > 0) //DK
                            c.Add((HeroClass)(byte.Parse(m.Groups[20].Value) - 1 + 0x10));
                        if (byte.Parse(m.Groups[21].Value) > 0) //ELF
                            c.Add((HeroClass)(byte.Parse(m.Groups[21].Value) - 1 + 0x20));
                        if (byte.Parse(m.Groups[22].Value) > 0) //MG
                            c.Add((HeroClass)(byte.Parse(m.Groups[22].Value) - 1 + 0x30));
                        if (byte.Parse(m.Groups[23].Value) > 0) //DL
                            c.Add((HeroClass)(byte.Parse(m.Groups[23].Value) - 1 + 0x40));
                        if (byte.Parse(m.Groups[24].Value) > 0) //SUM
                            c.Add((HeroClass)(byte.Parse(m.Groups[24].Value) - 1 + 0x50));
                        if (byte.Parse(m.Groups[25].Value) > 0) //MONK
                            c.Add((HeroClass)(byte.Parse(m.Groups[25].Value) - 1 + 0x60));

                        var Dmg = ushort.Parse(m.Groups[4].Value);

                        var status = new List<int>
                        {
                            int.Parse(m.Groups[16].Value),
                            int.Parse(m.Groups[17].Value),
                            int.Parse(m.Groups[18].Value),
                        };

                        try
                        {
                            var tmp = new SpellInfo
                            {
                                Number = System.Enum.Parse<Spell>(m.Groups[1].Value, true),
                                Name = m.Groups[2].Value,
                                ReqLevel = ushort.Parse(m.Groups[3].Value),
                                Damage = new Point(Dmg, Dmg * 2),


                                Mana = ushort.Parse(m.Groups[5].Value),
                                BP = ushort.Parse(m.Groups[6].Value),
                                Distance = byte.Parse(m.Groups[7].Value),
                                Delay = uint.Parse(m.Groups[8].Value),
                                Energy = ushort.Parse(m.Groups[9].Value),
                                Command = ushort.Parse(m.Groups[10].Value),
                                Attribute = sbyte.Parse(m.Groups[11].Value),
                                Type = short.Parse(m.Groups[12].Value),
                                UseType = byte.Parse(m.Groups[13].Value),
                                Brand = int.Parse(m.Groups[14].Value),
                                KillCount = int.Parse(m.Groups[15].Value),
                                Status = status,
                                Classes = c,
                                Rank = int.Parse(m.Groups[26].Value),
                                Group = int.Parse(m.Groups[27].Value),
                                MasterP = int.Parse(m.Groups[28].Value),
                                AG = int.Parse(m.Groups[29].Value),
                                SD = int.Parse(m.Groups[30].Value),
                                Duration = int.Parse(m.Groups[31].Value),
                                Str = ushort.Parse(m.Groups[32].Value),
                                Agility = ushort.Parse(m.Groups[33].Value),
                                Icon = ushort.Parse(m.Groups[34].Value),
                                UseType2 = byte.Parse(m.Groups[35].Value),
                                Item = ushort.Parse(m.Groups[36].Value),
                                IsDamage = byte.Parse(m.Groups[37].Value),
                            };
                            result.Add(tmp);
                        } catch (Exception ex)
                        {
                            Logger.Error("", ex);
                        }
                    }
                    xml = new SpellDbDto();
                    xml.skills = result.Select(x => new SkillDto
                    {
                        AG = x.AG,
                        Agility = x.Agility,
                        Attribute = x.Attribute,
                        BP = x.BP,
                        Brand = x.Brand,
                        Command = x.Command,
                        Delay = x.Delay,
                        Distance = x.Distance,
                        Duration = x.Duration,
                        Group = x.Group,
                        Icon = x.Icon,
                        IsDamage = x.IsDamage,
                        Item = x.Item,
                        KillCount = x.KillCount,
                        MasterP = x.MasterP,
                        Rank = x.Rank,
                        ReqLevel = x.ReqLevel,
                        SD = x.SD,
                        Status = string.Join(",", x.Status),
                        Str = x.Str,
                        Type = x.Type,
                        UseType = x.UseType,
                        UseType2 = x.UseType2,
                        Classes = string.Join(",", x.Classes),
                        Dmg = $"{x.Damage.X}-{x.Damage.Y}",
                        Energy = x.Energy,
                        Mana = x.Mana,
                        Name = x.Name,
                        Number = (ushort)x.Number,
                    }).ToArray();

                    XmlSaver(Path.Combine(_root, "Skills.xml"), xml);
                    return result;
                }
            }

            foreach (var i in xml.skills)
            {
                //Logger.Debug("Spell {0} {1}", (Spell)i.Number, i.Number);
                var Dmg = i.Dmg.Split("-").Select(x => int.Parse(x)).ToArray();


                var classList = i.Classes
                    .Split(",")
                    .Where(x => !string.IsNullOrWhiteSpace(x))
                    .Select(x => (HeroClass)System.Enum.Parse(typeof(HeroClass), x))
                    .ToList();

                var tmp = new SpellInfo
                {
                    Number = (Spell)i.Number,
                    Name = i.Name,
                    AG = i.AG,
                    Agility = i.Agility,
                    Attribute = i.Attribute,
                    BP = i.BP,
                    Brand = i.Brand,
                    Command = i.Command,
                    Delay = i.Delay,
                    Distance = i.Distance,
                    Duration = i.Duration,
                    Group = i.Group,
                    Icon = i.Icon,
                    IsDamage = i.IsDamage,
                    Item = i.Item,
                    KillCount = i.KillCount,
                    MasterP = i.MasterP,
                    Rank = i.Rank,
                    ReqLevel = i.ReqLevel,
                    SD = i.SD,
                    Status = i.Status.Split(",").Select(x => int.Parse(x)).ToList(),
                    Str = i.Str,
                    Type = i.Type,
                    UseType = i.UseType,
                    UseType2 = i.UseType2,
                    Mana = i.Mana,
                    Energy = i.Energy,
                    Damage = new Point(Dmg[0], Dmg[1]),
                    Classes = classList
                };

                result.Add(tmp);
            }

            return result;
        }

        public IEnumerable<MapInfo> LoadMaps()
        {
            var xml = XmlLoader<MapsDbDto>(Path.Combine(_root, "Maps.xml"));
            foreach(var m in xml.maps)
            {
                yield return new MapInfo(m.Map, m.AttributteFile);
            }
        }

        public IEnumerable<CharacterInfo> LoadDefCharacter()
        {
            var xml = XmlLoader<CharactersInfoDto>(Path.Combine(_root, "Characters.xml"));
            foreach(var @char in xml.Character)
            {
                var eq = new Dictionary<ushort, Item>();
                if(@char.Equipament != null)
                foreach(var e in @char.Equipament)
                {
                    eq.Add((ushort)e.Slot, new Item(new ItemNumber((byte)e.Type, (ushort)e.Index), new { Plus = (byte)e.Level }));
                }

                yield return new CharacterInfo
                {
                    Level = (ushort)@char.Level,
                    Class = (HeroClass)System.Enum.Parse(typeof(HeroClass), @char.BaseClass),
                    Map = (Maps)System.Enum.Parse(typeof(Maps), @char.Map),
                    Spells = @char.Skill?.Select(x => (Spell)x).ToArray()??Array.Empty<Spell>(),
                    Stats = new StatsInfo
                    {
                        Str = @char.Stats.Str,
                        Agi = @char.Stats.Agi,
                        Vit = @char.Stats.Vit,
                        Ene = @char.Stats.Ene,
                        Cmd = @char.Stats.Cmd,
                    },
                    Attributes = new AttriInfo
                    {
                        Life = @char.Attributes.Life,
                        Mana = @char.Attributes.Mana,
                        LevelLife = @char.Attributes.LevelLife,
                        LevelMana = @char.Attributes.LevelMana,
                        EnergyToMana = @char.Attributes.EnergyToMana,
                        VitalityToLife = @char.Attributes.VitalityToLife,
                        StrToBP = @char.Attributes.StrToBP,
                        AgiToBP = @char.Attributes.AgiToBP,
                        EneToBP = @char.Attributes.EneToBP,
                        VitToBP = @char.Attributes.VitToBP,
                        CmdToBP = @char.Attributes.CmdToBP,
                    },
                    Equipament = eq
                };
            }
        }

        public IEnumerable<ShopInfo> LoadShops()
        {
            var xml = XmlLoader<ShopListDto>(Path.Combine(_root, "ShopList.xml"));
            foreach(var shop in xml.Shops)
            {
                var result = new ShopInfo
                {
                    Shop = shop.Shop,
                    Storage = new Storage(Storage.ShopSize),
                };

                var loader = new LoadWZTXT<ShopInfoDto>();
                var file = loader.Load(Path.Combine(_root, shop.ItemList));
                var itemList = file.Item.Select(
                    x => new Item(
                        new ItemNumber(x.Type, x.Index),
                        Options:
                        new {
                            x.Plus,
                            x.Durability,
                            x.Skill,
                            x.Luck,
                            Option28 = x.Option,
                            OptionExe = x.Excellent })).ToList();

                try
                {
                    itemList.ForEach(x => result.Storage.Add(x));
                }
                catch (Exception e)
                {
                    Logger.Error(e.Message);
                }

                yield return result;
            }
        }

        public IEnumerable<NPCInfo> LoadNPCs()
        {
            var xml = XmlLoader<NPCAttributesDto>(Path.Combine(_root, "NPCs.xml"));
            foreach(var npc in xml.NPCs)
            {
                var type = (NPCAttributeType)System.Enum.Parse(typeof(NPCAttributeType), npc.Type);
                NPCInfo info = new NPCInfo
                {
                    NPC = npc.NPC,
                    Data = 0xffff,
                    Class = type,
                    Icon = npc.Icon,
                };
                switch (type)
                {
                    case NPCAttributeType.ShopRuud:
                    case NPCAttributeType.Shop:
                        var shops = ResourceCache.Instance.GetShops();
                        var shopNum = ushort.Parse(npc.Data);

                        if (shops.ContainsKey(shopNum))
                            info.Data = shopNum;
                        break;
                    case NPCAttributeType.Quest:
                    case NPCAttributeType.Warehouse:
                    case NPCAttributeType.MessengerAngel:
                    case NPCAttributeType.KingAngel:
                    case NPCAttributeType.EventChips:
                    case NPCAttributeType.GuildMaster:
                        break;
                    case NPCAttributeType.Window:
                        info.Data = byte.Parse(npc.Data);
                        break;
                    case NPCAttributeType.Buff:
                        info.Data = ushort.Parse(npc.Data);
                        break;
                }
                yield return info;
            }
        }

        public JOHDto LoadJOH()
        {
            var loader = new LoadWZTXT<JOHDto>();
            var file = loader.Load(Path.Combine(_root, "JewelOfHarmonyOption.txt"));
            return file;
        }

        public IEnumerable<Gate> LoadGates()
        {
            WarpDto xml;
            try
            {
                xml = XmlLoader<WarpDto>(Path.Combine(_root, "Warps.xml"));
            }catch(FileNotFoundException)
            {
                xml = new WarpDto();
                var gates = new List<GateDto>();
                using (var tr = File.OpenText(Path.Combine(_root, "MoveGate.txt")))
                {
                    var GateRegex = new Regex(@"([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)");
                    foreach(Match m in GateRegex.Matches(tr.ReadToEnd()))
                    {
                        gates.Add(new GateDto
                        {
                            Number = int.Parse(m.Groups[1].Value),
                            GateType = m.Groups[2].Value,
                            Map = ((Maps)byte.Parse(m.Groups[3].Value)).ToString(),
                            X1 = byte.Parse(m.Groups[4].Value),
                            Y1 = byte.Parse(m.Groups[5].Value),
                            X2 = byte.Parse(m.Groups[6].Value),
                            Y2 = byte.Parse(m.Groups[7].Value),
                            Target = int.Parse(m.Groups[8].Value),
                            Dir = byte.Parse(m.Groups[9].Value),
                            ReqLevel = ushort.Parse(m.Groups[10].Value),
                        });
                    }
                }

                using (var tr = File.OpenText(Path.Combine(_root, "MoveReq.txt")))
                {
                    var MoveRegex = new Regex(@"([0-9]+)\s+" + "\"" + @"(.+)" + "\"" + @"\s+" + "\"" + @"(.+)" + "\"" + @"\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)");
                    foreach (Match m in MoveRegex.Matches(tr.ReadToEnd()))
                    {
                        var igate = int.Parse(m.Groups[6].Value);
                        var gate = gates.Where(x => x.Number == igate).FirstOrDefault();
                        if (gate == null)
                            continue;
                        gate.ReqZen = ushort.Parse(m.Groups[4].Value);
                        gate.Move = int.Parse(m.Groups[1].Value);
                        gate.Name = m.Groups[2].Value;
                    }
                }

                xml.Gates = gates.ToArray();

                XmlSaver(Path.Combine(_root, "Warps.xml"), xml);
            }
            foreach (var g in xml.Gates)
            {
                yield return new Gate
                {
                    GateType = System.Enum.Parse<GateType>(g.GateType),
                    Map = System.Enum.Parse<Maps>(g.Map),
                    Number = g.Number,
                    ReqLevel = g.ReqLevel,
                    Target = g.Target,
                    Move = g.Move,
                    Name = g.Name,
                    Dir = g.Dir,
                    Door = new Rectangle(g.X1, g.Y1, g.X2 - g.X1, g.Y2 - g.Y1),
                    ReqZen = g.ReqZen,
                };
            }
        }

        public IEnumerable<QuestInfo> LoadQuests()
        {
            var xml = XmlLoader<QuestsDto>(Path.Combine(_root, "Quests.xml"));
            foreach (var q in xml.Quest)
            {
                var tmp = new QuestInfo
                {
                    Name = q.Name,
                    Type = q.Type,
                    Index = q.Index,
                    NPC = q.NPC,
                    Sub = new List<SubQuest>(),
                    Conditions = new List<RunConditions>(),
                };

                foreach (var sq in q.Details)
                {
                    var stmp = new SubQuest
                    {
                        Index = sq.Index,
                        Allowed = sq.Classes.Split(",").Select(x => System.Enum.Parse<HeroClass>(x)).ToArray(),
                        Messages = new Dictionary<QuestState, ushort>(),
                        CompensationType = System.Enum.Parse<QuestCompensation>(sq.Reward.Type),
                        Amount = sq.Reward.SubType,
                        Requeriment = new List<Item>()
                    };
                    if (sq.NeededItem != null)
                    {
                        foreach (var it in sq.NeededItem)
                        {
                            stmp.Requeriment.Add(new Item(ItemNumber.FromTypeIndex((byte)it.Type, (ushort)it.Index), new { Plus = (byte)it.Level, Durability = (byte)it.Count }));
                            var mon = it.Monster.Split("-").Where(x => !string.IsNullOrEmpty(x)).Select(x => ushort.Parse(x));
                            stmp.MonsterMin = mon.FirstOrDefault();
                            stmp.MonsterMax = mon.LastOrDefault();
                            stmp.Count = it.Count;
                            stmp.Drop = (ushort)it.Drop;
                        }
                    }

                    if (sq.NeededMonster != null)
                    {
                        stmp.Monster = sq.NeededMonster.Type;
                        stmp.Count = sq.NeededMonster.Count;
                    }

                    stmp.Messages.Add(QuestState.Unreg, sq.Message.BeforeReg);
                    stmp.Messages.Add(QuestState.Reg, sq.Message.AfterReg);
                    stmp.Messages.Add(QuestState.Complete, sq.Message.CompleteQuest);
                    stmp.Messages.Add(QuestState.Clear, sq.Message.ClearQuest);

                    tmp.Sub.Add(stmp);
                }

                foreach (var c in q.Conditions)
                {
                    var ctmp = new RunConditions
                    {
                        Index = c.Index,
                        NeededQuestIndex = c.NeededQuest,
                        Cost = c.Cost,
                        MaxLevel = c.MaxLevel,
                        Message = c.Message,
                        MinLevel = c.MinLevel,
                        NeedStr = c.NeedStr,
                    };

                    tmp.Conditions.Add(ctmp);
                }

                Logger.Information("Quest: {0} OK! Linked to NPC:{1}", tmp.Name, tmp.NPC);
                yield return tmp;
            }
        }

        public ChaosMixInfo LoadChaosBox()
        {
            var cbmix = new ChaosMixInfo
            {
                AdditionalJewels = new List<JewelInfo>(),
                Mixes = new List<MixInfo>()
            };
            var xml = XmlLoader<ChaosMixDto>(Path.Combine(_root, "ChaosBox.xml"));
            foreach(var j in xml.Jewels)
            {
                cbmix.AdditionalJewels.Add(new JewelInfo
                {
                    ItemNumber = ItemNumber.FromTypeIndex((byte)j.Type, (ushort)j.Index),
                    Success = j.Success
                });
            }
            foreach(var m in xml.Mixes)
            {
                var mix = new MixInfo
                {
                    Name = m.Name,
                    BaseCost = m.Value,
                    GeneralSuccess = m.Success,
                    NPC = m.NPC,
                    Ingredients = new List<IngredientInfo>(),
                    ResultSuccess = new List<IngredientInfo>(),
                };
                mix.Ingredients.AddRange(
                    m.Ingredients.Select(x => new IngredientInfo
                    {
                        IID = x.IID,
                        Count = x.Count,
                        ItemNumber = ItemNumber.FromTypeIndex((byte)x.Type, (ushort)x.Index),
                        Level = x.Level.Split("-").Select(y => int.Parse(y)).ToArray(),
                        Luck = x.Luck,
                        Option = x.Option,
                        Excellent = x.Excellent,
                        Harmony = x.Harmony,
                        SetOption = x.SetOption,
                        Socket = x.Socket,
                        Skill = x.Skill,
                        Success = x.Success,
                    }
                    ));
                mix.ResultSuccess.AddRange(
                    m.RewardSuccess.Select(x => new IngredientInfo
                    {
                        IID = x.IID,
                        Count = x.Count,
                        ItemNumber = ItemNumber.FromTypeIndex((byte)x.Type, (ushort)x.Index),
                        Level = x.Level.Split("-").Select(y => int.Parse(y)).ToArray(),
                        Luck = x.Luck,
                        Option = x.Option,
                        Excellent = x.Excellent,
                        Harmony = x.Harmony,
                        SetOption = x.SetOption,
                        Socket = x.Socket,
                        Skill = x.Skill,
                        Success = x.Success,
                    }
                    ));
                mix.ResultFail = new IngredientInfo
                    {
                        IID = m.RewardFail.IID,
                        Count = m.RewardFail.Count,
                        ItemNumber = ItemNumber.FromTypeIndex((byte)m.RewardFail.Type, (ushort)m.RewardFail.Index),
                        Level = m.RewardFail.Level.Split("-").Select(y => int.Parse(y)).ToArray(),
                        Luck = m.RewardFail.Luck,
                        Option = m.RewardFail.Option,
                        Excellent = m.RewardFail.Excellent,
                        Harmony = m.RewardFail.Harmony,
                        SetOption = m.RewardFail.SetOption,
                        Socket = m.RewardFail.Socket,
                        Skill = m.RewardFail.Skill,
                        Success = m.RewardFail.Success,
                    };
                cbmix.Mixes.Add(mix);
            }

            return cbmix;
        }

        public IEnumerable<Bag> LoadItembags()
        {
            var xml = XmlLoader<ItemBagsDto>(Path.Combine(_root, "ItemBags/ItemBags.xml"));
            var helper = new LoadWZTXT<DSItemBagDto>();
            var helper2 = new LoadWZTXT<WZItemBagDto>();
            DSItemBagDto baseb = null;
            WZItemBagDto basec = null;
            foreach (var x in xml.ItemBags)
            {
                if(Path.GetExtension(x.Bag) == ".txt")
                {
                    var oldFile = Path.Combine(_root, "ItemBags/" + x.Bag);
                    var newFile = Path.ChangeExtension(oldFile, ".xml");
                    if(File.Exists(newFile))
                    {
                        var basex = XmlLoader<BagDto>(newFile);
                        yield return new Bag(basex);
                        continue;
                    }
                    try
                    {
                        baseb = helper.Load(oldFile);
                    }
                    catch (Exception) { }
                    try
                    {
                        if(baseb.Section1 == null)
                            basec = helper2.Load(oldFile);
                    }
                    catch (Exception) { }
                    BagDto basea = null;
                    if (baseb.Section1 != null)
                    {
                        Logger.Information($"Converting {oldFile} from www.darksideofmu.com file type to XML File Type");
                        try
                        {
                            basea = new BagDto
                            {
                                DropItemCount = 1,
                                DropItemRate = (ushort)Math.Min(baseb.Section1[0].ItemDropRate, (short)100),
                                DropZenRate = (ushort)(100 - baseb.Section1[0].ItemDropRate),
                                LevelMin = 1,
                                MaxZen = baseb.Section1[0].DropZen,
                                MinZen = baseb.Section1[0].DropZen,
                                Number = ItemNumber.FromTypeIndex(baseb.Section1[0].BoxType, baseb.Section1[0].BoxIndex),
                                Monster = x.Monster,
                                Plus = baseb.Section1[0].BoxLevel,
                                Item = baseb.Section2.Select(y => new ItemInBagDto
                                {
                                    Luck = y.Luck == 1,
                                    MaxExcellent = y.maxExOpt,
                                    MaxLevel = y.maxLvl,
                                    MaxOption = y.maxZ28,
                                    MinExcellent = 0,
                                    MinLevel = 0,
                                    MinOption = 0,
                                    Number = ItemNumber.FromTypeIndex(y.Type, y.Index),
                                    Skill = y.Skill == 1,
                                }).ToArray(),
                            };
                        } catch (Exception ex)
                        {
                            Logger.Error("DSFile to XML Error:", ex);
                            continue;
                        }
                    }else
                    {
                        Logger.Information($"Converting {oldFile} from GS 1.00.18 file type to XML File Type");
                        //basec.BagDtos
                        basea = new BagDto
                        {
                            DropItemCount = 1,
                            DropItemRate = 50,
                            DropZenRate = 50,
                            LevelMin = x.LevelMin,
                            MaxZen = 100000,
                            MinZen = 10000,
                            Number = x.Item,
                            Monster = x.Monster,
                            Plus = x.Plus,
                            Item = basec.BagDtos.Select(y => new ItemInBagDto
                            {
                                Luck = y.Luck == 1,
                                MaxExcellent = 0,
                                MaxLevel = y.Lvl,
                                MaxOption = y.Option,
                                MinExcellent = 0,
                                MinLevel = 0,
                                MinOption = 0,
                                Number = ItemNumber.FromTypeIndex(y.Type, y.Index),
                                Skill = y.Skill == 1,
                            }).ToArray(),
                        };
                    }
                    XmlSaver(newFile, basea);
                    yield return new Bag(basea);
                }
                else
                {
                    var basea = XmlLoader<BagDto>(Path.Combine(_root, "ItemBags/" + x.Bag));
                    yield return new Bag(basea);
                }
            }
        }

        public Storage LoadPCPointShop()
        {
            var xml = XmlLoader<PCPointShopDto>(Path.Combine(_root, "PCPointShop.xml"));
            var sto = new Storage(Storage.ShopSize);

            foreach(var x in xml.Items)
            {
                var it = new Item((ItemNumber)x.Number, Options: new { x.Plus, x.Luck, x.Skill, x.Option28, x.Durability, x.OptionExe, x.BuyPrice });
                sto.Add(it);
            }

            return sto;
        }
    }
}


--file ServerMessages.cs
﻿using MU.Resources;
using MuEmu.Resources.XML;
using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu.Resources
{
    public class ServerMessages
    {
        private static ServerMessages s_instance;
        private Dictionary<Messages, string> _messages = new Dictionary<Messages, string>();

        public static void Initialize()
        {
            s_instance = new ServerMessages();
        }
        public static void LoadMessages(string file)
        {
            var xml = ResourceLoader.XmlLoader<ServerMessagesDto>(file);

            s_instance._messages.Clear();
            foreach(var row in xml.Messages)
            {
                s_instance._messages.Add(Enum.Parse<Messages>(row.ID), row.Message);
            }
        }
        public static string GetMessage(Messages message, params object[] values)
        {
            if (!s_instance._messages.ContainsKey(message))
                return "{"+message+"}";

            var res = s_instance._messages[message];

            for (var i = 0; i < values.Length; i++)
            {
                res = res.Replace("{"+i+"}", values[i]?.ToString()??"");
            }

            return res;
        }
    }
}


--file GameCheckSum.cs
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu.Security
{
    public class GameCheckSum
    {
        private const int MAX_CHECKSUM_KEY = 1024;
        private int _Index { get; set; }
        public static uint[] Table { get; set; }
        public Player Player { set; get; }
        public DateTime Time { get; set; }

        public static void LoadChecksum(string exePath)
        {

        }

        public GameCheckSum(Player player)
        {
            Player = player;
        }

        public ushort GetKey()
        {
            var rand = new Random();
            _Index = rand.Next(MAX_CHECKSUM_KEY);
            Time = DateTime.Now;

            var wRandom = rand.Next(64);
            var wAcc = ((_Index & 0x3F0) * 64) | (wRandom * 16) | (_Index & 0x0F);
            return (ushort)(wAcc ^ 0xB479);
        }

        public bool IsValid(ushort key)
        {
            return Table[_Index] == key;
        }
    }
}


--file Spells.cs
﻿using MU.DataBase;
using MU.Resources;
using MuEmu.Data;
using MuEmu.Entity;
using MuEmu.Monsters;
using MU.Network.Game;
using MuEmu.Resources;
using MuEmu.Util;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MuEmu.Resources.XML;
using MU.Network;

namespace MuEmu
{
    public class SpellMagicInfo : SpellInfo
    {
        private short _level;

        public bool Changed { get; set; }
        public short Level { get => _level; set
            {
                _level = value;
                MLSValue = MLInfo?.GetValue(_level) ?? 0;
                Changed = true;
            }
        }
        public SkillTreeDto MLInfo { get; set; }
        public bool IsMLSkill => MLInfo != null;
        public float MLSValue { get; set; }
        public static SpellMagicInfo FromSpellInfo(HeroClass Class, SpellInfo si, short level = 1)
        {
            var res = new SpellMagicInfo();
            Extensions.AnonymousMap(res, si);
            res.MLInfo = MasterLevel.MasterSkillTree.Trees.Where(x => x.ID == Class)
                .SelectMany(x => x.Skill)
                .Where(x => (Spell)x.MagicNumber == si.Number)
                .Select(x => x)
                .FirstOrDefault();
            res.Level = level;
            res.Changed = false;

            return res;
        }
    }
    public class Spells
    {
        private static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(Spells));
        private Dictionary<Spell, SpellMagicInfo> _spellList;
        private List<Buff> _buffs;
        private List<Spell> _newSpell = new List<Spell>();
        private List<Spell> _delSpell = new List<Spell>();
        private List<Spell> _combo = new List<Spell>();
        private DateTime _comboTimer;

        // MasterLevel and other skills effect
        public float PvMAttackSuccessRate { get; private set; }
        public float PvPDefenceSuccessRate { get; private set; }
        public float AdvancedAttackSuccessRate { get; private set; }
        public float AdvancedDefenseSuccessRate { get; private set; }
        public float RepairLevel1 { get; private set; }
        public float RepairLevel2 { get; private set; }
        public float RepairLevel3 { get; private set; }
        public float PoisonResistance { get; private set; }
        public float LightningResistance { get; private set; }
        public float IceResistance { get; private set; }
        public float IncreaseAutoHPRegeneration { get; private set; }
        public float IncreaseAutoMPRegeneration { get; private set; }
        public float IncreaseAutoSDRegeneration { get; private set; }
        public float IncreaseAutoBPRegeneration { get; private set; }
        public float IncreaseZen { get; private set; }
        public float IncreaseDefense { get; private set; }
        public float IncreaseDefenseSuccessRate { get; private set; }
        public float IncreaseMaxHP { get; private set; }
        public float IncreaseMaxMP { get; private set; }
        public float IncreaseMaxAG { get; private set; }
        public float IncreaseMaxSD { get; private set; }
        public float IncreaseAgility { get; private set; }
        public float IncreaseStrength { get; private set; }
        public float IncreaseManaReduction { get; private set; }
        public float MonsterAttackLifeIncrease { get; private set; }
        public float MonsterAttackSDIncrease { get; private set; }
        public float IncreaseExperience { get; private set; }
        public float WingsDefensePowUp { get; private set; }
        public float WingsAttackPowUp { get; private set; }

        public Monster Monster { get; }
        public Player Player { get; }
        public Character Character { get; }

        public Spells(Monster monster)
        {
            Monster = monster;
            _spellList = new Dictionary<Spell, SpellMagicInfo>();
            _buffs = new List<Buff>();
        }

        public Spells(Character @char, CharacterDto character)
        {
            _spellList = new Dictionary<Spell, SpellMagicInfo>();
            Player = @char.Player;
            Character = @char;
            _buffs = new List<Buff>();


            var spells = ResourceCache.Instance.GetSkills();

            foreach (var skill in Character.BaseInfo.Spells)
            {
                var spell = SpellMagicInfo.FromSpellInfo(Character.Class, spells[skill]);
                _spellList.Add(skill, spell);
                Logger
                    .ForAccount(Player.Session)
                    .Information("Class Skill Added: {0}", spell.Name);
            }

            foreach (var skill in character.Spells)
            {
                var spell = SpellMagicInfo.FromSpellInfo(Character.Class, spells[(Spell)skill.Magic], skill.Level);
                _spellList.Add((Spell)skill.Magic, spell);
                SetEffect(spell);
                Logger
                    .ForAccount(Player.Session)
                    .Information("Learned {0} Skill Added", spell.Name);
            }
        }

        private void Add(Spell skill)
        {
            var spells = ResourceCache.Instance.GetSkills();

            if (!_spellList.ContainsKey(skill))
            {
                var info = SpellMagicInfo.FromSpellInfo(Character.Class, spells[skill]);
                _spellList.Add(skill, info);
                _newSpell.Add(skill);
                SetEffect(info);
            }
        }

        public async Task<bool> TryAdd(Spell skill)
        {
            var spells = ResourceCache.Instance.GetSkills();
            var spell = spells
                .Where(x => x.Key == skill)
                .Select(x => x.Value)
                .FirstOrDefault();

            if (spell == null)
            {
                Logger.Error($"Can't find skill {skill}");
                return false;
            }

            if (spell.ReqLevel > Character.Level)
            {
                await Player.Session.SendAsync(new SNotice(NoticeType.Blue, $"You need reach Lv. {spell.ReqLevel}"));
                return false;
            }

            if (spell.Str > Character.Strength)
            {
                await Player.Session.SendAsync(new SNotice(NoticeType.Blue, $"You need {spell.Str} of Strength"));
                return false;
            }

            if (spell.Agility > Character.Agility)
            {
                await Player.Session.SendAsync(new SNotice(NoticeType.Blue, $"You need {spell.Agility} of Agility"));
                return false;
            }

            if (spell.Energy > Character.Energy)
            {
                await Player.Session.SendAsync(new SNotice(NoticeType.Blue, $"You need {spell.Energy} of Energy"));
                return false;
            }

            var classList = spell.Classes.Select(x => new { BaseClass = (HeroClass)(((byte)x) & 0xF0), Class = (byte)x });
            var canUse = classList
                .Where(x => x.BaseClass == Character.BaseClass && x.Class <= (byte)Character.Class)
                .Any();

            if (!canUse)
            {
                await Player.Session.SendAsync(new SNotice(NoticeType.Blue, $"Only {string.Join(", ", spell.Classes)} can use this skill"));
                return false;
            }

            if (_spellList.ContainsKey(skill))
            {
                return false;
            }

            var pos = _spellList.Count;

            Add(skill);

            if (Player.Status == LoginStatus.Playing)
            {
                await Player.Session.SendAsync(VersionSelector.CreateMessage<SSpells>((byte)0, new MuEmu.Network.Data.SpellDto
                {
                    Index = (byte)pos,
                    Spell = (ushort)skill,
                }));
                await Player.Session.SendAsync(new SNotice(NoticeType.Blue, $"You have learned: {spell.Name}"));
            }

            return true;
        }

        public void Remove(Spell skill)
        {
            _spellList.Remove(skill);
            _delSpell.Add(skill);
        }

        public void Remove(SpellInfo skill)
        {
            Remove(skill.Number);
        }

        public List<SpellMagicInfo> SpellList => _spellList.Select(x => x.Value).ToList();
        public IDictionary<Spell, SpellMagicInfo> SpellDictionary => _spellList;

        public IEnumerable<Buff> BuffList => _buffs;

        public bool BufActive(SkillStates effect)
        {
            return _buffs.Any(x => x.State == effect);
        }

        public async void SendList()
        {
            var list = _spellList
                .Where(x => !x.Value.IsMLSkill)
                .Select((x, i) => new MuEmu.Network.Data.SpellDto {
                    Index = (byte)i,
                    Spell = (ushort)x.Key
                })
                .ToArray();
            var list2 = _spellList
                .Where(x => x.Value.IsMLSkill)
                .Select((x, i) => new MasterSkillInfoDto
                {
                    MasterSkillLevel = (byte)x.Value.Level,
                    MasterSkillUIIndex = (byte)x.Value.MLInfo.Index,
                    MasterSkillCurValue = x.Value.MLSValue,
                    MasterSkillNextValue = x.Value.MLInfo.GetValue((short)(x.Value.Level + 1)),
                })
                .ToArray();

            await Player.Session.SendAsync(new SMasterLevelSkillListS9ENG { Skills = list2 });
            await Player.Session.SendAsync(VersionSelector.CreateMessage<SSpells>((byte)0, list));
        }

        private byte SkillType(Spell spell) => spell switch
        {
            Spell.Uppercut => 0,
            Spell.Cyclone => 0,
            Spell.Lunge => 0,
            //Spell.Cutting => 0,
            //Spell.Hacking => 0,
            Spell.TwistingSlash => 1,
            Spell.RagefulBlow => 1,
            Spell.DeathStab => 1,
            _ => 0xff,
        };

        public bool CheckCombo(Spell spell)
        {
            var t = SkillType(spell);
            var comboEnabled = Character.Quests.IsClear(3);
            if (!comboEnabled || t == 0xff || (t == 1 && (_combo.Count == 0 || _comboTimer<DateTime.Now)))
            {
                _combo.Clear();
                return false;
            }
            if(t == 0 || !_combo.Contains(spell))
            {
                if (t == 0)
                    _combo.Clear();

                _combo.Add(spell);
                _comboTimer=DateTime.Now.AddSeconds(3);
                if (_combo.Count == 3)
                {
                    _combo.Clear();
                    return true;
                }
            }
            return false;
        }

        internal void ItemSkillAdd(Spell skill)
        {
            if (_spellList.ContainsKey(skill))
                return;

            var pos = _spellList.Count;
            var spells = ResourceCache.Instance.GetSkills();
            _spellList.Add(skill, SpellMagicInfo.FromSpellInfo(Character.Class, spells[skill]));

            if (Player.Status == LoginStatus.Playing)
            {
                var msg = VersionSelector.CreateMessage<SSpells>((byte)0, new MuEmu.Network.Data.SpellDto
                {
                    Index = (byte)pos,
                    Spell = (ushort)skill,
                });
                Player.Session.SendAsync(msg).Wait();
            }
        }

        internal void ItemSkillDel(Spell skill)
        {
            _spellList.Remove(skill);
            SendList();
        }
        public async void SetBuff(SkillStates effect, TimeSpan time, Monster source)
        {
            if (_buffs.Any(x => x.State == effect))
                return;



            var buff = new Buff { State = effect, EndAt = DateTimeOffset.Now.Add(time), Source = null };
            var @char = Player?.Character ?? null;

            var sPeriodicEffect = new SPeriodicEffectS12Eng
            {
                effect = (ushort)effect,
                time = (uint)(buff.EndAt - DateTimeOffset.Now).TotalSeconds,
                value = 0,
                state = 2,
                wEffectValue = 0,
                group = 0,
                ItemInfo = Array.Empty<byte>()
            };
            switch (effect)
            {
                case SkillStates.ShadowPhantom:
                    if (@char == null)
                        break;
                    buff.AttackAdd = @char.Level / 3 + 45;
                    buff.DefenseAdd = @char.Level / 3 + 50;
                    break;
                case SkillStates.HAttackPower:
                    buff.AttackAdd = 25;
                    sPeriodicEffect.value = (ushort)buff.AttackAdd;
                    break;
                case SkillStates.HAttackSpeed:
                    break;
                case SkillStates.HDefensePower:
                    buff.DefenseAdd = 100;
                    sPeriodicEffect.value = (ushort)buff.DefenseAdd;
                    break;
                case SkillStates.HMaxLife:
                    buff.LifeAdd = 500;
                    sPeriodicEffect.value = (ushort)buff.LifeAdd;
                    break;
                case SkillStates.HMaxMana:
                    buff.ManaAdd = 500;
                    sPeriodicEffect.value = (ushort)buff.ManaAdd;
                    break;
                case SkillStates.Poison:
                    buff.PoisonDamage = 12 + source.Attack / 10;
                    sPeriodicEffect.value = (ushort)buff.PoisonDamage;
                    break;
                case SkillStates.SkillDamageDeflection:
                    buff.DamageDeflection = (30 + (source.Attack / 42)) / 100.0f;
                    sPeriodicEffect.value = (ushort)buff.DamageDeflection;
                    break;
            }

            _buffs.Add(buff);
            if (Monster != null)
            {
                var m2 = new SViewSkillState(1, Monster.Index, (byte)effect);

                if (Monster.Info.ViewRange <= 0)
                {
                    await Monster.Map.SendAsync(m2);
                }
                else
                {
                    await Monster.ViewPort.Select(x => x.Session).SendAsync(m2);
                }
                return;
            }
            var sViewSkillState = new SViewSkillState(1, (ushort)Player.Session.ID, (byte)effect);

            await Player.Session.SendAsync(sPeriodicEffect);
            await Player.Session.SendAsync(sViewSkillState);
            Player.SendV2Message(sPeriodicEffect);
            Player.SendV2Message(sViewSkillState);
        }
        public async void SetBuff(SkillStates effect, TimeSpan time, Character source = null)
        {
            Buff buff;
            buff = _buffs.FirstOrDefault(x => x.State == effect);

            if (buff != null)
                _buffs.Remove(buff);

            buff = new Buff { State = effect, EndAt = DateTimeOffset.Now.Add(time), Source = source };
            var @char = Player?.Character??null;

            var sPeriodicEffect = new SPeriodicEffectS12Eng
            {
                effect = (ushort)effect,
                time = (uint)(buff.EndAt - DateTimeOffset.Now).TotalSeconds,
                value = 0,
                state = 0,
                wEffectValue = 10,
                group = 1,
                ItemInfo = Array.Empty<byte>()
            };
            switch (effect)
            {
                case SkillStates.ShadowPhantom:
                    if (@char == null)
                        break;
                    buff.AttackAdd = @char.Level / 3 + 45;
                    buff.DefenseAdd = @char.Level / 3 + 50;
                    break;
                case SkillStates.SoulBarrier:
                    buff.DefenseAddRate = 10 + source.AgilityTotal / 50 + source.EnergyTotal / 200;
                    break;
                case SkillStates.Defense:
                    buff.DefenseAdd = source.EnergyTotal / 8;
                    break;
                case SkillStates.Attack:
                    buff.AttackAdd = source.EnergyTotal / 7;
                    break;
                case SkillStates.SwellLife:
                    buff.LifeAdd = 12 + source.EnergyTotal / 10 + source.VitalityTotal / 100;
                    Character.MaxHealth += buff.LifeAdd;
                    break;
                case SkillStates.HAttackPower:
                    buff.AttackAdd = 25;
                    break;
                case SkillStates.HAttackSpeed:
                    break;
                case SkillStates.HDefensePower:
                    buff.DefenseAdd = 100;
                    break;
                case SkillStates.HMaxLife:
                    buff.LifeAdd = 500;
                    break;
                case SkillStates.HMaxMana:
                    buff.ManaAdd = 500;
                    break;
                case SkillStates.Poison:
                    buff.PoisonDamage = 12 + (source?.EnergyTotal??0) / 10;
                    break;
                case SkillStates.SkillDamageDeflection:
                    buff.DamageDeflection = (30 + (source.EnergyTotal / 42))/100.0f;
                    break;
            }

            _buffs.Add(buff);
            if(Monster != null)
            {
                var m2 = new SViewSkillState(1, Monster.Index, (byte)effect);

                if(Monster.Info.ViewRange <= 0)
                {
                    await Monster.Map.SendAsync(m2);
                }
                else
                {
                    await Monster.ViewPort.Select(x => x.Session).SendAsync(m2);
                }
                return;
            }
            var sViewSkillState = new SViewSkillState(1, (ushort)Player.Session.ID, (byte)effect);

            await Player.Session.SendAsync(sPeriodicEffect);
            await Player.Session.SendAsync(sViewSkillState);
            Player.SendV2Message(sPeriodicEffect);
            Player.SendV2Message(sViewSkillState);

            //Player.Session.Send(new byte[] { 0xC1, 0x24, 0x2D, 0x0A, 0x03, 0x00, 0x00, 0x00, 0x00, 0x68, 0xB9, 0x00, 0x44, 0x07, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00 }).Wait();
        }

        public async Task ClearBuffByEffect(SkillStates effect)
        {
            var rem = _buffs.Where(x => x.State == effect);
            _buffs = _buffs.Except(rem).ToList();
            await DelBuff(rem.First());
        }

        public async void ClearBuffTimeOut()
        {
            var b = _buffs.Where(x => x.EndAt > DateTimeOffset.Now);
            var rem = _buffs.Except(b);
            _buffs = b.ToList();

            try
            {
                foreach (var r in rem)
                    await DelBuff(r);
            }catch(Exception)
            {
                _buffs.Clear();
                return;
            }

            var poison = _buffs.FirstOrDefault(x => x.State == SkillStates.Poison);
            try
            {
                if (poison != null)
                {
                    Player?.Character.GetAttacked(poison.Source?.Player.ID ?? 0xffff, 0x00, 0x00, poison.PoisonDamage, DamageType.Poison, Spell.Poison, 0).Wait();
                    Monster?.GetAttacked(poison.Source.Player, poison.PoisonDamage + (int)(Monster.Life * 0.03f), DamageType.Poison, 0).Wait();
                }
            }catch(Exception)
            { }
        }

        public async void ClearAll()
        {
            try
            {
                foreach (var r in _buffs)
                    await DelBuff(r);
            }
            catch (Exception)
            { }
            _buffs.Clear();
        }

        public async Task DelBuff(Buff effect)
        {
            if(Monster != null)
            {
                var m2 = new SViewSkillState(0, Monster.Index, (byte)effect.State);

                await Monster.ViewPort.Select(x => x.Session).SendAsync(m2);
                return;
            }

            var m = new SViewSkillState(0, (ushort)Player.Session.ID, (byte)effect.State);

            switch(effect.State)
            {
                case SkillStates.SwellLife:
                    Character.MaxHealth -= effect.LifeAdd;
                    break;
            }

            await Player.Session.SendAsync(new SPeriodicEffectS12Eng
            {
                effect = (ushort)effect.State,
                time = 0,
                value = 0,
                state = 1,
                wEffectValue = 10,
                group = 1,
                ItemInfo = Array.Empty<byte>()
            });
            await Player.Session.SendAsync(m);
            Player.SendV2Message(m);
        }

        public async void AttackSend(Spell spell, ushort Target, bool Success)
        {
            Target &= 0x7FFF;
            Target = Success ? (ushort)(Target | 0x8000) : Target;

            var message = VersionSelector.CreateMessage<SMagicAttack>(spell, (Player?.ID??Monster.Index), Target);

            if (Monster == null)
            {
                await Player
                    .Session
                    .SendAsync(message);

                Player.SendV2Message(message);
            }
            else
            {
                _=Monster.ViewPort.Select(x => x?.Session).SendAsync(message);
            }
        }

        public SkillStates[] ViewSkillStates => _buffs.Select(x => x.State).ToArray();

        internal void SetEffect(SpellMagicInfo skill)
        {
            if (!skill.IsMLSkill)
                return;

            if (string.IsNullOrWhiteSpace(skill.MLInfo.Property))
                return;

            this.Set(skill.MLInfo.Property, skill.MLSValue);
        }

        public async Task Save(GameContext db)
        {
            var changed = _spellList.Where(x => x.Value.Changed).Select(x => x.Value);
            if (!_newSpell.Any() && !_delSpell.Any() && !changed.Any())
                return;

            _delSpell.ForEach(x => _newSpell.Remove(x));

            await db.Spells.AddRangeAsync(_newSpell.Select(x => new SpellDto
            {
                CharacterId = Character.Id,
                Level = 1,
                Magic = (short)x,
            }));

            var del = _delSpell.Select(x => (short)x);
            var toDel = db.Spells.Where(x => x.CharacterId == Character.Id && del.Contains(x.Magic));
            db.Spells.RemoveRange(toDel);

            var array = changed.Select(x => (short)x.Number);
            var toUpdate = db.Spells.Where(x => x.CharacterId == Character.Id && array.Contains(x.Magic)).ToList();
            foreach(var dto in toUpdate)
            {
                var newDto = changed.First(x => x.Number == (Spell)dto.Magic);
                dto.Level = newDto.Level;
            }
            db.Spells.UpdateRange(toUpdate);

            _newSpell.Clear();
            _delSpell.Clear();
        }
    }
}


--file Storage.cs
﻿using MU.Resources;
using MuEmu.Entity;
using MuEmu.Network.Data;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;

namespace MuEmu
{
    public class Storage
    {
        public const int WarehouseSize = 8 * 15;
        public const int ShopSize = 8 * 15;
        public const int TradeSize = 8 * 5;
        public const int ChaosBoxSize = 8 * 5;
        public const int InventorySize = 8 * 8;

        private Dictionary<byte, Item> _items;
        private RectangleF _bounds;
        private List<RectangleF> _map;

        public bool NeedSave { get; set; }
        public StorageID IndexTranslate { get; private set; }
        public StorageID StorageID { get; set; }
        public int EndIndex { get; private set; }
        public int Size { get; private set; }
        public uint Money { get; set; }
        public Dictionary<byte, Item> Items => _items;

        public const int Expansion = 4 * 8;

        public Storage(int size, StorageID startIndex = StorageID.Equipament)
        {
            Size = size;
            _items = new Dictionary<byte, Item>();
            _bounds = new RectangleF(new Point(0, 0), new SizeF(8, Size / 8));
            _map = new List<RectangleF>();
            IndexTranslate = startIndex;
            StorageID = startIndex;
            EndIndex = (int)startIndex + size;
        }

        public bool NoMapped { get; internal set; }

        public byte Add(Item it, byte offset = 0)
        {
            if (it.BasicInfo.MaxStack != 0)
            {
                var firts = (from r in _items.Values.Where(x => x.Number == it.Number)
                             where r.Plus == it.Plus && r.Durability < it.BasicInfo.MaxStack
                             select r).FirstOrDefault();
                if (firts != null)
                {
                    if(firts.Overlap(it) == null)
                        return 0xfd;
                }
            }
            for (var i = offset; i < Size; i++)
            {
                var itemRect = new RectangleF(new Point(i % 8, i / 8), it.BasicInfo.Size);
                itemRect.Width -= 0.1f;
                itemRect.Height -= 0.1f;
                if (itemRect.Right >= _bounds.Right || itemRect.Bottom >= _bounds.Bottom)
                    continue;

                if (NoIntersects(i, it.BasicInfo.Size).Width == 0)
                {
                    _add(i, it);
                    NeedSave = true;
                    it.SlotId = (int)IndexTranslate + i;
                    it.Storage = StorageID;
                    return (byte)it.SlotId;
                }
            }

            return 0xff;
        }

        private RectangleF NoIntersects(byte offset, Size freeSpace)
        {
            if (NoMapped)
                return _items.ContainsKey(offset)? _bounds : default(RectangleF);

            var itemRect = new RectangleF(new Point(offset % 8, offset / 8), freeSpace);
            itemRect.Width -= 0.1f;
            itemRect.Height -= 0.1f;

            if (itemRect.Right >= _bounds.Right || itemRect.Bottom >= _bounds.Bottom)
                return _bounds;

            return _map.FirstOrDefault(x => x.IntersectsWith(itemRect));
        }

        public bool TryAdd(Size freeSpace, byte offset = 0)
        {
            for (var i = offset; i < Size; i++)
            {
                var itemRect = new RectangleF(new Point(i % 8, i / 8), freeSpace);
                itemRect.Width -= 0.1f;
                itemRect.Height -= 0.1f;
                if (itemRect.Right >= _bounds.Right || itemRect.Bottom >= _bounds.Bottom)
                    continue;

                if (_map.Where(x => x.IntersectsWith(itemRect)).Count() == 0)
                {
                    return true;
                }
            }

            return false;
        }

        public bool TryAdd(Size[] sizes, byte offset = 0)
        {
            var mapCopy = _map.ToList();

            var ret = true;
            foreach (var freeSpace in sizes)
            {
                var result = false;
                for (var i = offset; i < Size; i++)
                {
                    var itemRect = new RectangleF(new Point(i % 8, i / 8), freeSpace);
                    itemRect.Width -= 0.1f;
                    itemRect.Height -= 0.1f;
                    if (itemRect.Right >= _bounds.Right || itemRect.Bottom >= _bounds.Bottom)
                        continue;

                    if (mapCopy.Where(x => x.IntersectsWith(itemRect)).Count() == 0)
                    {
                        mapCopy.Add(new RectangleF(new Point(i % 8, i / 8), freeSpace));
                        result = true;
                    }
                }
                ret &= result;
            }
            return ret;
        }

        private void _add(byte pos, Item it)
        {
            _items.Add(pos, it);
            if(!NoMapped)
                _map.Add(new RectangleF(new Point(pos % 8, pos / 8), it.BasicInfo.Size));
        }

        public void Add(byte pos, Item it)
        {
            var org = pos;
            pos -= (byte)IndexTranslate;

            if (_items.ContainsKey(pos))
            {
                if(_items[pos].Overlap(it) == null)
                    return;
            }

            if (pos >= Size)
                throw new Exception($"({org})[{IndexTranslate}] Out of range: {pos}/{Size}");

            it.SlotId = pos + (byte)IndexTranslate;

            var intersects = NoIntersects(pos, it.BasicInfo.Size);

            if (intersects.Width != 0)
                throw new Exception($"({org})[{IndexTranslate}] Space isn't free: ({Get((byte)(intersects.Y*8 + intersects.X + (float)IndexTranslate))})");

            it.Storage = StorageID;
            _items.Add(pos, it);

            if(!NoMapped)
                _map.Add(new RectangleF(new Point(pos % 8, pos / 8), it.BasicInfo.Size));
            NeedSave = true;
        }

        public Item Get(byte pos)
        {
            pos -= (byte)IndexTranslate;
            if(_items.ContainsKey(pos))
                return _items[pos];

            return null;
        }

        public void Remove(byte pos)
        {
            pos -= (byte)IndexTranslate;
            _items.Remove(pos);

            if (!NoMapped)
            {
                var pos2 = new Point(pos % 8, pos / 8);
                var rect = _map.First(x => x.Location == pos2);
                _map.Remove(rect);
            }
        }

        public void Remove(Item it)
        {
            if (!_items.Any(x => x.Value == it))
                return;

            var info = _items.First(x => x.Value == it);
            Remove((byte)(IndexTranslate+info.Key));
        }

        public void Clear()
        {
            _items.Clear();
            _map.Clear();
        }

        public IEnumerable<KeyValuePair<byte, byte[]>> GetInventory()
        {
            return _items
                .Select(x => new KeyValuePair<byte, byte[]>((byte)(x.Key + IndexTranslate), x.Value.GetBytes()));
        }

        public bool CanContain(byte address)
        {
            return address >= (byte)IndexTranslate && address < EndIndex;
        }
    }
}


--file SubSystem.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Linq;
using MuEmu.Resources;
using System.Drawing;
using MU.Network.Game;
using MuEmu.Network.Data;
using MuEmu.Events.BloodCastle;
using Serilog;
using Serilog.Core;
using MuEmu.Entity;
using WebZen.Util;
using MuEmu.Resources.Map;
using System.Threading.Tasks;
using MuEmu.Util;
using MU.Resources;
using MU.Network.Guild;
using MU.Network.GensSystem;
using System.Net;
using MuEmu.Network.ConnectServer;
using WebZen.Handlers;
using WebZen.Network;
using MU.Resources.XML;
using MU.Network;

namespace MuEmu
{
    public class DelayedMessage
    {
        public Player Player;
        public DateTimeOffset Time;
        public object Message;
    }

    public class SubSystem
    {
        public static GameContext db;
        private static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(SubSystem));
        private Thread _workerDelayed;
        private Thread _workerViewPort;
        private Thread _workerEvents;
        private Thread _workerSavePlayers;
        private Thread _workerIA;
        private Thread _workerCS;
        private List<DelayedMessage> _delayedMessages;
        private IPEndPoint _csIp;
        private MessageHandler[] _handlers;
        private MessageFactory[] _factories;
        private byte _show;
        private string _token;
        private static Type _typeBase;
        private static Type _typeBaseC;
        public static SubSystem Instance { get; set; }

        public SubSystem()
        {
            _delayedMessages = new List<DelayedMessage>();
            _workerDelayed = new Thread(WorkerDelayed);
            _workerViewPort = new Thread(WorkerViewPort);
            _workerEvents = new Thread(WorkerEvents);
            _workerSavePlayers = new Thread(WorkerSavePlayers);
            _workerIA = new Thread(WorkerIA);

            _typeBase = Program.Season switch
            {
                ServerSeason.Season16Kor => typeof(VPCreateS16KorDto),
                ServerSeason.Season12Eng => typeof(VPCreateS12Dto),
                ServerSeason.Season9Eng => typeof(VPCreateS9Dto),
                _ => typeof(VPCreateDto),
            };

            _typeBaseC = Program.Season switch
            {
                ServerSeason.Season16Kor => typeof(VPChangeS12Dto),
                ServerSeason.Season12Eng => typeof(VPChangeS12Dto),
                ServerSeason.Season9Eng => typeof(VPChangeS9Dto),
                _ => typeof(VPChangeDto),
            };
        }

        public static void CSSystem(IPEndPoint ip, MessageHandler[] handlers, MessageFactory[] factories, byte show, string token)
        {
            if(Instance == null)
            {
                Logger.Error("Invalid Instance");
                return;
            }
            Instance._csIp = ip;
            Instance._workerCS = new Thread(WorkerCS);
            Instance._handlers = handlers;
            Instance._factories = factories;
            Instance._show = show;
            Instance._token = token;
            Instance._workerCS.Start();
        }

        public void AddDelayedMessage(Player plr, TimeSpan time, object message)
        {
            if (plr == null)
                return;

            _delayedMessages.Add(new DelayedMessage { Player = plr, Message = message, Time = DateTimeOffset.Now.Add(time) });
        }

        private static async void WorkerCS()
        {
            do
            {
                try
                {
                    Program.client = new CSClient(Instance._csIp, Instance._handlers, Instance._factories, Program.ServerCode, Program.server, Instance._show, Instance._token, Program.Name);

                    while (!Program.client.Closed)
                    {
                        await Task.Delay(1000);
                    }

                    Log.Error(ServerMessages.GetMessage(Messages.Server_CSServer_Lost));
                }
                catch (Exception)
                {
                    Log.Error(ServerMessages.GetMessage(Messages.Server_CSServer_Error));
                }

                await Task.Delay(30000);
            } while (true);
        }

        private static async void WorkerDelayed()
        {
            while(true)
            {
                try
                {
                    var toSend = (from msg in Instance._delayedMessages
                                  where DateTimeOffset.Now >= msg.Time
                                  select msg).ToList();

                    foreach (var msg in toSend)
                    {
                        await msg.Player.Session.SendAsync(msg.Message);
                    }

                    Instance._delayedMessages = (from msg in Instance._delayedMessages
                                                 where DateTimeOffset.Now < msg.Time
                                                 select msg).ToList();

                    foreach(var @char in Program.server.Clients.Where(x=> x.Player != null && x.Player.Status == LoginStatus.Playing).Select(x => x.Player.Character))
                    {
                        @char.UpdatePetIA();
                    }

                    Thread.Sleep(100);
                }
                catch (Exception e)
                {
                    Logger.Error(e, DateTime.Now.ToString());
                }
            }
        }

        private static void WorkerViewPort()
        {
            while(true)
            {
                try
                {
                    foreach (var map in ResourceCache.Instance.GetMaps().Values)
                    {
                        var deadPlayers = new List<Character>();
                        var changedPlayers = new List<Character>();
                        foreach (var @char in map.Players.Where(x => x.DataLoaded))
                        {
                            @char.Friends.Update();

                            if (@char.Change)
                                changedPlayers.Add(@char);

                            switch (@char.State)
                            {
                                case ObjectState.Regen:
                                    @char.State = ObjectState.Live;
                                    @char.Spells.ClearAll();
                                    break;
                                case ObjectState.Live:
                                    // Clear dead buffers
                                    @char.Spells.ClearBuffTimeOut();

                                    PlayerPlrViewport(map, @char);
                                    PlayerMonsViewport(map, @char);
                                    PlayerItemViewPort(map, @char);

                                    @char.Autorecovery();
                                    break;
                                case ObjectState.Dying:
                                    @char.State = ObjectState.Die;
                                    break;
                                //case ObjectState.Dying2:
                                //    obj.State = ObjectState.Die;
                                //    break;
                                case ObjectState.Die:
                                    @char.State = ObjectState.WaitRegen;
                                    break;
                                case ObjectState.WaitRegen:
                                    deadPlayers.Add(@char);
                                    break;
                            }
                        }
                        Friends.AddSet = false;

                        foreach (var @char in deadPlayers)
                        {
                            @char.TryRegen();
                        }
                        foreach(var @char in changedPlayers)
                        {
                            @char.Change = false;
                        }

                        // update monster section
                        lock(map.Monsters)
                        foreach(var obj in map.Monsters.Where(x => x.Active))
                        {
                            switch(obj.State)
                            {
                                case ObjectState.Regen:
                                    obj.State = ObjectState.Live;
                                    obj.Spells.ClearAll();
                                    break;
                                case ObjectState.Live:
                                    obj.Spells.ClearBuffTimeOut();
                                    //obj.Update();
                                    break;
                                case ObjectState.Dying:
                                    obj.State = ObjectState.Dying2;
                                    break;
                                case ObjectState.Dying2:
                                    obj.State = ObjectState.Die;
                                    break;
                                case ObjectState.Die:
                                    obj.State = ObjectState.WaitRegen;
                                    break;
                                case ObjectState.WaitRegen:
                                    obj.TryRegen();
                                    break;
                            }
                        }

                        // Update item section
                        lock (map.Items)
                        {
                            foreach (var it in map.Items)
                            {
                                switch (it.Value.State)
                                {
                                    case ItemMapState.Creating:
                                        it.Value.State = ItemMapState.Created;
                                        break;
                                    case ItemMapState.Created:
                                        if (it.Value.validTime < DateTimeOffset.Now)
                                            it.Value.State = ItemMapState.Deleting;
                                        break;
                                    case ItemMapState.Deleting:
                                        map.DeleteItem(it.Value);
                                        break;
                                }
                            }
                        }
                    }
                    Thread.Sleep(1000);
                }
                catch (Exception e)
                {
                    Logger.Error(e, DateTime.Now.ToString());
                }
            }
        }

        internal static async void PlayerPlrViewport(MapInfo Map, Character plr)
        {
            var pos = plr.Position;
            pos.Offset(15, 15);
            List<Character> newPlr, PShop, existPlr;
            List<Player> deadPlr, lostPlr;
            List<GuildViewPortDto> guildVP;
            List<VPGensDto> gensVP;

            PartyManager.SendAll(plr.Party);
            lock (plr.PlayersVP)
            {

                var playerVP = from obj in Map.Players
                               let rect = new Rectangle(obj.Position, new Size(30, 30))
                               where rect.Contains(pos) && obj.Player.Session.ID != plr.Player.Session.ID
                               select obj;

                if(Map.Map == (int)Maps.NewQuest)
                {
                    playerVP = from obj in playerVP
                               where obj.Party == plr.Party
                               select obj;
                }

                PShop = (from obj in playerVP
                             where obj.Shop.Open
                             select obj).ToList();

                newPlr = (from obj in playerVP
                              where obj.State == ObjectState.Regen
                              select obj).ToList();

                existPlr = (from obj in playerVP
                                where (!plr.PlayersVP.Contains(obj.Player) || obj.Player.Character.Change) && obj.State == ObjectState.Live
                                select obj).ToList();

                deadPlr = (from obj in playerVP
                               where obj.State == ObjectState.WaitRegen
                               select obj.Player).ToList();

                lostPlr = (from obj in plr.PlayersVP
                               where !playerVP.Contains(obj.Character)
                               select obj).ToList();

                plr.PlayersVP.AddRange(newPlr.Select(x => x.Player));
                plr.PlayersVP.AddRange(existPlr.Select(x => x.Player));

                guildVP = newPlr
                    .Where(x => x.Guild != null)
                    .Select(x => new GuildViewPortDto
                    {
                        ID = x.Guild.Index,
                        Number = x.Index,
                        RelationShip = plr.Guild?.GetRelation(x.Guild) ?? GuildRelation.None,
                        CastleState = 0,
                        Status = x.Guild.Find(x.Name).Rank,
                        Type = x.Guild.Type,
                    }).ToList();

                guildVP.AddRange(existPlr
                    .Where(x => x.Guild != null)
                    .Select(x => new GuildViewPortDto
                    {
                        ID = x.Guild.Index,
                        Number = x.Index,
                        RelationShip = plr.Guild?.GetRelation(x.Guild) ?? GuildRelation.None,
                        CastleState = 0,
                        Status = x.Guild.Find(x.Name).Rank,
                        Type = x.Guild.Type,
                    }));

                gensVP = newPlr
                    .Where(x => x.Gens.Influence != GensType.None)
                    .Select(x => new VPGensDto
                    {
                        Influence = x.Gens.Influence,
                        iGensClass = x.Gens.Class,
                        iGensRanking = x.Gens.Ranking,
                        iContributePoint = x.Gens.Contribution,
                        wzNumber = x.Index.ShufleEnding()
                    }).ToList();

                gensVP.AddRange(existPlr.Where(x => x.Gens.Influence != GensType.None)
                    .Select(x => new VPGensDto
                    {
                        Influence = x.Gens.Influence,
                        iGensClass = x.Gens.Class,
                        iGensRanking = x.Gens.Ranking,
                        iContributePoint = x.Gens.Contribution,
                        wzNumber = x.Index.ShufleEnding()
                    }));

                foreach (var it in deadPlr)
                    plr.PlayersVP.Remove(it);
                foreach (var it in lostPlr)
                    plr.PlayersVP.Remove(it);
            }

            var addPlr = new List<VPCreateAbs>();
            var changePlayer = new List<VPChangeAbs>();

            foreach (var x in newPlr)
            {
                var obj = Activator.CreateInstance(_typeBase) as VPCreateAbs;
                AssignVP(obj, x, true);                
                addPlr.Add(obj);
            }

            foreach (var x in existPlr.Where(x => x.Transformation))
            {
                var obj = Activator.CreateInstance(_typeBaseC) as VPChangeAbs;
                obj.DirAndPkLevel = (byte)(x.Direction << 4);
                obj.Set("PentagramMainAttribute", (byte)(x.Inventory.Get(Equipament.Pentagrama)?.PentagramaMainAttribute ?? 0));
                obj.CharSet = x.Inventory.GetCharset();
                obj.Set("CurLife", (uint)x.Health);
                obj.Set("Level", x.Level);
                obj.Set("MaxLife", (uint)x.MaxHealth);
                obj.Name = x.Name;
                obj.Number = x.Player.Session.ID;
                obj.Position = x.Position;
                obj.TPosition = x.TPosition;
                obj.Set("ServerCodeOfHomeWorld", 0);
                obj.Skin = x.Skin;
                //AssignVP(obj, x, false);
                changePlayer.Add(obj);
            }

            foreach (var x in existPlr.Where(x => x.Transformation == false))
            {
                var obj = Activator.CreateInstance(_typeBase) as VPCreateAbs;
                AssignVP(obj, x, false);
                addPlr.Add(obj);
            }

            var msg = VersionSelector.CreateMessage<SViewPortCreate>(addPlr);
            await plr.Player.Session.SendAsync(msg);

            if (changePlayer.Any())
                await plr.Player.Session.SendAsync(new SViewPortChange { ViewPort = changePlayer.ToArray() });

            if (lostPlr.Any())
                await plr.Player.Session.SendAsync(new SViewPortDestroy(lostPlr.Select(x => new VPDestroyDto((ushort)x.Session.ID)).ToArray()));

            if(PShop.Any())
                await plr.Player.Session.SendAsync(new SViewPortPShop { VPShops = PShop.Select(x => new VPPShopDto { btName = x.Shop.Name.GetBytes(), wzNumber = x.Index.ShufleEnding() }).ToArray() });

            if (guildVP.Any())
                await plr.Player.Session.SendAsync(new SGuildViewPort { Guilds = guildVP.ToArray() });

            if (gensVP.Any())
                await plr.Player.Session.SendAsync(new SViewPortGens { VPGens = gensVP.ToArray() });
        }
        public static void SelfUpdate(Character x)
        {
            if (!x.Change)
                return;

            if(x.Transformation)
            {
                var obj = Activator.CreateInstance(_typeBaseC) as VPChangeAbs;
                obj.DirAndPkLevel = (byte)(x.Direction << 4);
                obj.Set("PentagramMainAttribute", (byte)(x.Inventory.Get(Equipament.Pentagrama)?.PentagramaMainAttribute ?? 0));
                obj.CharSet = x.Inventory.GetCharset();
                obj.Set("CurLife", (uint)x.Health);
                obj.Set("Level", (ushortle)x.Level);
                obj.Set("MaxLife", (uint)x.MaxHealth);
                obj.Name = x.Name;
                obj.Number = x.Player.Session.ID;
                obj.Position = x.Position;
                obj.TPosition = x.TPosition;
                obj.Set("ServerCodeOfHomeWorld", (ushort)0);
                obj.Skin = x.Skin;
                x.Player.Session.SendAsync(new SViewPortChange { ViewPort = new VPChangeAbs[] { obj } });
            }
            else
            {
                var obj = Activator.CreateInstance(_typeBase) as VPCreateAbs;
                AssignVP(obj, x, false);
                var msg = VersionSelector.CreateMessage<SViewPortCreate>((new VPCreateAbs[] { obj }).ToList());
                x.Player.Session.SendAsync(msg);
            }
        }
        private static void AssignVP(VPCreateAbs obj, Character x, bool create)
        {
            obj.Set("CharSet", x.Inventory.GetCharset());
            obj.Set("DirAndPkLevel", (byte)((x.Direction << 4) | (byte)x.PKLevel));
            obj.Set("Name", x.Name);
            obj.Number = (ushort)(x.Player.Session.ID | (create ? 0x8000 : 0));
            obj.Position = x.Position;
            obj.Set("TPosition", x.TPosition);
            try
            {
                obj.Set("ViewSkillState", x.Spells.ViewSkillStates.Select(y => (ushort)y).ToArray());
            }
            catch(Exception)
            {
                obj.Set("ViewSkillState", x.Spells.ViewSkillStates.Select(y => (byte)y).ToArray());
            }
            obj.Player = x.Player;
            obj.Set("PentagramMainAttribute", (byte)(x.Inventory.Get(Equipament.Pentagrama)?.PentagramaMainAttribute ?? 0));
            obj.Set("CurLife", (uint)x.Health);
            obj.Set("MaxLife", (uint)x.MaxHealth);
            obj.Set("Level", new ushortle(x.Level));
            obj.Set("MuunItem", new ushortle(0xffff));
            obj.Set("MuunRideItem", new ushortle(x.Inventory.GetMuun(0)?.Number.Number??0xffff));
            obj.Set("MuunSubItem", new ushortle(x.Inventory.GetMuun(1)?.Number.Number??0xffff));
            obj.Set("Mount", new ushortle(0xffff));
            obj.Set("ServerCodeOfHomeWorld", (ushort)0);
        }

        private static async void PlayerMonsViewport(MapInfo Map, Character plr)
        {
            List<Monsters.Monster> newObj;
            List<Monsters.Monster> existObj;
            List<Monsters.Monster> deadObj;
            List<Monsters.Monster> lostObj;
            List<ushort> oldVP;
            List<ushort> missing;
            lock (Map.Monsters)
            {
                oldVP = plr.MonstersVP;
                var targetVP = Map.Monsters.Where(x => x.Active);

                var playerVP = from obj in targetVP
                               where obj.Position.Substract(plr.Position).LengthSquared() <= 10
                               select obj;

                if(Map.Map == (int)Maps.NewQuest)
                {
                    playerVP = Quest4th.GetInfo(plr.Player).GetMonsters();
                }

                newObj = (from obj in playerVP
                              where (obj.State == ObjectState.Regen||obj.UseTeleport) && obj.Active
                              select obj).ToList();

                existObj = (from obj in playerVP
                                where !oldVP.Contains(obj.Index) && obj.State == ObjectState.Live && obj.Active
                                select obj).ToList();

                deadObj = (from obj in playerVP
                           where obj.State == ObjectState.Dying2 || obj.Active == false
                           select obj).ToList();

                lostObj = (from obj in targetVP
                           where !(obj.Position.Substract(plr.Position).LengthSquared() <= 10) && oldVP.Contains(obj.Index)
                           select obj).ToList();

                missing = (from old in oldVP
                          where !targetVP.Any(x => x.Index == old)
                          select old).ToList();
            }

            foreach (var it in deadObj)
            {
                oldVP.Remove(it.Index);
                it.ViewPort.Remove(plr.Player);
            }
            foreach (var it in lostObj)
            {
                oldVP.Remove(it.Index);
                it.ViewPort.Remove(plr.Player);
            }

            foreach(var it in newObj)
            {
                it.ViewPort.Add(plr.Player);
                it.UseTeleport = false;
            }

            foreach (var it in existObj)
            {
                it.ViewPort.Add(plr.Player);
            }

            oldVP.AddRange(newObj.Select(x => x.Index));
            oldVP.AddRange(existObj.Select(x => x.Index));

            var addObj = new List<object>();
            var baseType = Program.Season switch
            {
                ServerSeason.Season17Kor75 => typeof(VPMCreateS16KorDto),
                ServerSeason.Season17Kor => typeof(VPMCreateS16KorDto),
                ServerSeason.Season16Kor => typeof(VPMCreateS16KorDto),
                ServerSeason.Season12Eng => typeof(VPMCreateS12Dto),
                ServerSeason.Season9Eng => typeof(VPMCreateS9Dto),
                _ => typeof(VPMCreateDto),
            };

            foreach(var x in newObj)
            {
                var obj = Activator.CreateInstance(baseType);
                AssignVPM((VPMCreateAbs)obj, x, true);
                addObj.Add(obj);
            }
            foreach (var x in existObj)
            {
                var obj = Activator.CreateInstance(baseType);
                AssignVPM((VPMCreateAbs)obj, x, false);
                addObj.Add(obj);
            }

            var remObj = new List<VPDestroyDto>();
                remObj.AddRange(deadObj.Select(x => new VPDestroyDto(x.Index)));
                remObj.AddRange(lostObj.Select(x => new VPDestroyDto(x.Index)));
                remObj.AddRange(missing.Select(x => new VPDestroyDto(x)));

            if (remObj.Any())
            {
                switch(Program.Season)
                {
                    default:
                        await plr.Player.Session.SendAsync(new SViewPortDestroy(remObj.ToArray()));
                        break;
                }
            }
            if (addObj.Any())
            {
                var c = 0;
                // Packet for Season 12Eng is with problem in the SkillState Effect list
                var limit = ServerSeason.Season12Eng==Program.Season?1:20;
                while(c < addObj.Count)
                {
                    var send = addObj.Skip(c).Take(limit);

                    c += limit;

                    var msg = VersionSelector.CreateMessage<SViewPortMonCreateS6Kor>(send);
                    await plr.Player.Session.SendAsync(msg);
                }                
            }
        }

        private static void AssignVPM(VPMCreateAbs obj, Monsters.Monster x, bool v)
        {
            obj.Number = (ushort)(x.Index | (v?0x8000:0));
            obj.Position = x.Position;
            obj.TPosition = x.TPosition;
            obj.Type = x.Info.Monster;
            obj.Path = (byte)(x.Direction << 4);
            try
            {
                obj.Set("ViewSkillState", x.Spells.ViewSkillStates);
            }catch(Exception)
            {
                obj.Set("ViewSkillState", x.Spells.ViewSkillStates.Select(y => (byte)y).ToArray());
            }
            obj.Set("PentagramMainAttribute", x.Element);
            obj.Set("Level", new ushortle(x.Level));
            obj.Set("Life", (uint)x.Life);
            obj.Set("MaxLife", (uint)x.MaxLife);

            obj.Set("CriticalDMGResistance", (byte)0);
            obj.Set("ExcellentDMGResistance", (byte)0);
            obj.Set("DebuffResistance", new ushortle(0));
            obj.Set("DamageAbsorb", (byte)0);
            obj.Set("Elite", (byte)0);
        }

        private static async void PlayerItemViewPort(MapInfo Map, Character plr)
        {
            var oldVP = plr.ItemsVP;
            var targetVP = Map.Items.Values.ToList();
            var pos = plr.Position;
            pos.Offset(15, 15);

            var playerVP = (from obj in targetVP
                           let rect = new Rectangle(obj.Position, new Size(30, 30))
                           where rect.Contains(pos)
                           select obj).ToList();

            if (!playerVP.Any())
            {
                oldVP.Clear();
                return;
            }

            var newObj = (from obj in playerVP
                          where obj.State == ItemMapState.Creating
                          select obj).ToList();

            var existObj = (from obj in playerVP
                            where !oldVP.Contains(obj.Index) && obj.State == ItemMapState.Created
                            select obj).ToList();

            var existObjVP = (from obj in playerVP
                              where oldVP.Contains(obj.Index) && obj.State == ItemMapState.Created
                              select obj).ToList();

            var deadObj = (from obj in playerVP
                           where obj.State == ItemMapState.Deleting
                           select new VPDestroyDto(obj.Index)).ToList();

            var lostObj = (from obj in targetVP
                           let rect = new Rectangle(obj.Position, new Size(30, 30))
                           where !rect.Contains(pos) && oldVP.Contains(obj.Index) && obj.State == ItemMapState.Created
                           select new VPDestroyDto(obj.Index)).ToList();

            // Update the old player VP
            oldVP.AddRange(newObj.Select(x => x.Index));
            oldVP.AddRange(existObj.Select(x => x.Index));

            foreach (var it in deadObj)
                oldVP.Remove(it.Number.ShufleEnding());
            foreach (var it in lostObj)
                oldVP.Remove(it.Number.ShufleEnding());

            var addItem = new List<VPICreateDto>();
            addItem.AddRange(newObj.Select(x => new VPICreateDto { ItemInfo = x.Item.GetBytes(), wzNumber = ((ushort)(x.Index | 0x8000)).ShufleEnding(), X = (byte)x.Position.X, Y = (byte)x.Position.Y }));
            addItem.AddRange(existObj.Select(x => new VPICreateDto { ItemInfo = x.Item.GetBytes(), wzNumber = ((ushort)(x.Index | 0x0000)).ShufleEnding(), X = (byte)x.Position.X, Y = (byte)x.Position.Y }));

            if (addItem.Any())
            {
                // fix VP
                addItem.AddRange(existObjVP.Select(x => new VPICreateDto { ItemInfo = x.Item.GetBytes(), wzNumber = ((ushort)(x.Index | 0x0000)).ShufleEnding(), X = (byte)x.Position.X, Y = (byte)x.Position.Y }));
                await plr.Player.Session.SendAsync(new SViewPortItemCreate(addItem.ToArray()));
            }

            var remItem = new List<VPDestroyDto>();
            remItem.AddRange(deadObj);
            remItem.AddRange(lostObj);

            if (remItem.Any())
                await plr.Player.Session.SendAsync(new SViewPortItemDestroy { ViewPort = remItem.ToArray() });
        }

        private static void WorkerEvents()
        {
            while (true)
            {
                try
                {
                    Program.EventManager.Update();
                    Program.GlobalEventsManager.Update();
                    Quest4th.Update();
                    Thread.Sleep(1000);
                }
                catch(Exception e)
                {
                    Logger.Error(e, DateTime.Now.ToString());
                }
            }
        }

        private static async void WorkerIA()
        {
            var kalimaGateDisposed = new List<Character>();
            while (true)
            {
                Marlon.Run();
                Program.GoldenInvasionManager.Update();
                foreach (var map in ResourceCache.Instance.GetMaps().Values)
                {
                    try
                    {
                        await map.WeatherUpdate();
                    }
                    catch (Exception)
                    { }
                    lock(map.Monsters)
                    foreach (var obj in map.Monsters)
                    {
                        if (obj.State != ObjectState.Live)
                            continue;

                        obj.Update();
                        switch(obj.Info.Monster)
                            {
                                case 152://Stone Gate 1
                                case 153://Stone Gate 2
                                case 154://Stone Gate 3
                                case 155://Stone Gate 4
                                case 156://Stone Gate 5
                                case 157://Stone Gate 6
                                case 158://Stone Gate 7
                                    {
                                        if (obj.ViewPort.Count == 0)
                                            break;

                                        var lvl = obj.Info.Monster - 152;
                                        var kalimaGates = new List<int> { 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x74 };
                                        var _params = (int)obj.Params;
                                        var players = obj.ViewPort
                                            .Where(x => x.Character.Position.Substract(obj.Position).LengthSquared() < 2)
                                            .Where(x => x.Character.KalimaGate == obj || x.Character.Party?.Master.Character.KalimaGate == obj)
                                            .Take(_params)
                                            .ToList();
                                        players.ForEach(x => x.Character.WarpTo(kalimaGates[lvl]));
                                        _params -= players.Count;
                                        obj.Params = _params;

                                        if(_params <= 0)
                                            kalimaGateDisposed.Add(obj.Caller.Character);
                                    }
                                    break;
                            }
                    }

                    foreach(var Character in map.Players)
                    {
                        Character?.MuHelper.Update();
                    }

                    kalimaGateDisposed.ForEach(x => x.DisposeKalimaGate());
                    kalimaGateDisposed.Clear();
                }
                Thread.Sleep(100);
            }
        }

        private static async void WorkerSavePlayers()
        {
            var news = ResourceLoader.XmlLoader<XmlNewsDto>("./Data/news.xml");
            var Interval = news.Interval;
            var currentNew = 0;
            using (db = new GameContext())
            {
                while (true)
                {
                    try
                    {
                        Logger.Information("Saving players");
                        foreach (var plr in Program.server.Clients.Where(x => x.Player != null).Select(x => x.Player))
                        {
                            var plrLog = Logger
                                    .ForAccount(plr.Session);

                            plrLog.Information("Saving for {0}", plr.Character?.Name ?? "UNK");

                            if(plr.Character != null)
                            {
                                if(plr.Character.Guild != null && plr.Character.Guild.Master.Player == plr)
                                {
                                    GuildManager.GuildMatchingNotifications(plr.Character, GuildStatus.GuildMaster);
                                }
                                else
                                {
                                    GuildManager.GuildMatchingNotifications(plr.Character, GuildStatus.NoMember);
                                }
                            }

                            try
                            {
                                await plr.Save(db);
                                plr.Character?.MuHelper.Update();
                                db.SaveChanges();
                            }catch(Exception ex)
                            {
                                plrLog.Error(ex, "Player Save:");
                            }
                        }
                        Logger.Information("Saved players");
                        var maps = ResourceCache.Instance.GetMaps();
                        foreach(var map in maps)
                        {
                            lock (map.Value.Items)
                            {
                                var fordel = map.Value.Items.Values.Where(x => x.State == ItemMapState.Deleting).ToList();
                                fordel.ForEach(x =>
                                {
                                    map.Value.Items.Remove(x.Index);
                                    x.Item.Delete();
                                });
                            }
                        }
                        if(--Interval==0)
                        {
                            Interval = news.Interval;
                            if(news.New != null && news.New.Length > currentNew)
                            {
                                news.New[currentNew++]
                                    .Split("\n")
                                    .ToList()
                                    .ForEach(x => _ = Program.GlobalAnoucement(x));

                                currentNew %= news.New.Length;
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        Logger.Error(e, DateTime.Now.ToString());
                    }
                    Thread.Sleep(60000);
                }

            }
        }

        public static void Initialize()
        {
            if (Instance != null)
                throw new Exception("Already Initialized");

            Instance = new SubSystem();

            Instance._workerDelayed.Start();
            Instance._workerViewPort.Start();
            Instance._workerEvents.Start();
            Instance._workerSavePlayers.Start();
            Instance._workerIA.Start();
        }
    }
}


--file DateTimeExtensions.cs
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu.Util
{
    public static class DateTimeExtensions
    {
        public static int ToTimeT(this DateTime dt)
        {
            return (int)Math.Floor((dt.ToUniversalTime() - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds);
        }
    }
}


--file IEnumerableExtensions.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MuEmu.Util
{
    public static class IEnumerableExtensions
    {
        public static T PopBack<T>(this IList<T> ts)
        {
            var last = ts.Last();
            ts.Remove(last);
            return last;
        }
        public static T PopFront<T>(this IList<T> ts)
        {
            var first = ts.First();
            ts.Remove(first);
            return first;
        }
        public static bool IsDefault<T>(this T value) where T : struct
        {
            bool isDefault = value.Equals(default(T));

            return isDefault;
        }
    }
}


--file Line.cs
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;

namespace MuEmu.Util
{
    struct Line
    {
        public Point Start { get; set; }
        public Point End { get; set; }
    }
}


--file LoadWZTXT.cs
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml.Serialization;

namespace MuEmu.Util
{
    public class LoadWZSectionTXT<T>
    {
        private Regex fileRegex;
        private List<PropertyInfo> propList;
        public LoadWZSectionTXT()
        {
            var t = typeof(T);
            var props = t.GetProperties();
            int i = 0;
            var tmpString = "";
            var posAdd = "";

            propList = new List<PropertyInfo>();
            foreach (var prop in props)
            {
                var res = prop.GetCustomAttribute<XmlAttributeAttribute>();
                var res2 = prop.GetCustomAttribute<XmlTextAttribute>();
                if (res2 != null)
                {
                    posAdd = "(?s)(.*?)\n";
                    propList.Add(prop);
                }
                if (res == null)
                {
                    continue;
                }

                propList.Add(prop);

                if (i > 0)
                {
                    tmpString += @"[^\S\r\n]+";
                }

                if (prop.PropertyType == typeof(string))
                {
                    tmpString += "\"(.*)\"";
                }
                else if (prop.PropertyType.IsPrimitive || prop.PropertyType.IsEnum)
                {
                    tmpString += i == 0 ? @"([\/0-9]+)" : @"(\-*[0-9]+)";
                }
                i++;
            }

            tmpString += @"\s*";
            tmpString += posAdd;

            fileRegex = new Regex(tmpString);
        }

        public T[] Load(string section)
        {
            List<T> _res = new List<T>();
            foreach(Match m in fileRegex.Matches(section))
            {
                if (m.Value.StartsWith("//"))
                    continue;

                var res = Activator.CreateInstance<T>();

                var i = 1;
                foreach(var prop in propList)
                {
                    prop.AssingProperty(res, m.Groups[i++]);
                }
                _res.Add(res);
            }

            return _res.ToArray();
        }
    }

    public class LoadWZTXT<T>
    {
        //private Regex sectionRegex = new Regex(@"\n+([0-9]+)\s*(.*?)\n+(?s)(.*?)\nend");//@"\n+([0-9]+)\s*\n+(?s)(.*?)\n+end");
        private Regex sectionRegex = new Regex(@"^([0-9]+)\s+(.+?)\s+(^end+)", RegexOptions.Singleline | RegexOptions.Multiline);
        private List<PropertyInfo> props;
        public LoadWZTXT()
        {
            var t = typeof(T);
            var p = t.GetProperties();
            props = p.Where(x => x.GetCustomAttribute<XmlElementAttribute>() != null && x.PropertyType.IsArray).ToList();
        }
        public T Load(string file)
        {
            var result = Activator.CreateInstance<T>();
            using (var tf = File.OpenText(file))
            {
                var contents = tf.ReadToEnd();
                if(props.Count() > 1)
                {
                    int i = 0;
                    foreach(Match m in sectionRegex.Matches(contents))
                    {
                        var propIndex = int.Parse(m.Groups[1].Value);
                        var prop = props[propIndex];

                        var constructed = typeof(LoadWZSectionTXT<>).MakeGenericType(prop.PropertyType.GetElementType());
                        object o = Activator.CreateInstance(constructed, null);
                        var load = constructed.GetMethod("Load");
                        var ret = load.Invoke(o, new object[] { m.Groups[2].Value });

                        if (prop.GetValue(result) == null)
                        {
                            prop.SetValue(result, ret);
                        }else
                        {
                            var ar = prop.GetValue(result);
                            var lenNew = ((Array)ar).Length + ((Array)ret).Length;
                            var nArr = Array.CreateInstance(prop.PropertyType.GetElementType(), lenNew);
                            ((Array)ar).CopyTo(nArr, 0);
                            ((Array)ret).CopyTo(nArr, ((Array)ar).Length);
                            prop.SetValue(result, nArr);
                        }
                        i++;
                    }
                }else if(props.Count() == 1)
                {
                    var type = typeof(LoadWZSectionTXT<>);
                    var constructed = type.MakeGenericType(props[0].PropertyType.GetElementType());
                    object o = Activator.CreateInstance(constructed, null);
                    var load = constructed.GetMethod("Load");
                    var ret = load.Invoke(o, new object[] { contents });
                    props[0].SetValue(result, ret);
                }
            }

            return result;
        }
    }
}


--file ObjectExtensions.cs
﻿using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;

namespace MuEmu.Util
{
    public static class ObjectExtensions
    {
        public static void AssingProperty(this PropertyInfo pinfo, object a, Group g)
        {
            if (pinfo.PropertyType == typeof(string))
            {
                pinfo.SetValue(a, g.Value);
            }
            else if (pinfo.PropertyType == typeof(sbyte))
            {
                pinfo.SetValue(a, sbyte.Parse(g.Value));
            }
            else if (pinfo.PropertyType == typeof(short))
            {
                pinfo.SetValue(a, short.Parse(g.Value));
            }
            else if (pinfo.PropertyType == typeof(int))
            {
                pinfo.SetValue(a, int.Parse(g.Value));
            }
            else if (pinfo.PropertyType == typeof(long))
            {
                pinfo.SetValue(a, long.Parse(g.Value));
            }
            else if (pinfo.PropertyType == typeof(byte))
            {
                pinfo.SetValue(a, byte.Parse(g.Value));
            }
            else if (pinfo.PropertyType == typeof(ushort))
            {
                pinfo.SetValue(a, ushort.Parse(g.Value));
            }
            else if (pinfo.PropertyType == typeof(uint))
            {
                pinfo.SetValue(a, uint.Parse(g.Value));
            }
            else if (pinfo.PropertyType == typeof(ulong))
            {
                pinfo.SetValue(a, ulong.Parse(g.Value));
            }
            else if (pinfo.PropertyType.IsEnum)
            {
                pinfo.SetValue(a, Enum.Parse(pinfo.PropertyType, g.Value));
            }
        }
        public static T AssignRegex<T>(this T a, Group[] g)
        {
            var props = typeof(T).GetProperties();
            for (var i = 0; i < Math.Min(props.Length, g.Length); i++)
            {
                props[i].AssingProperty(a, g[i + 1]);
            }

            return a;
        }

        public static object Get<T>(this T a, string name)
        {
            var type = typeof(T);
            var prop = type.GetProperty(name);
            var get = prop.GetGetMethod();
            return get.Invoke(a, null);
        }

        public static void Set<T>(this T a, string name, object value)
        {
            var type = a.GetType();
            var prop = type.GetProperty(name);
            if(prop != null)
                prop.SetValue(a, value);
        }

        public static void SetBit(this byte a, byte bit)
        {
            a = (byte)(a | (1 << bit));
        }
        public static void ClearBit(this byte a, byte bit)
        {
            a = (byte)(a & ~(1 << bit));
        }
        public static bool GetBit(this byte a, byte bit)
        {
            return (a & (1 << bit)) != 0;
        }
    }
}


--file PointExtensions.cs
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;

namespace MuEmu.Util
{
    public static class PointExtensions
    {
        public static Point Substract(this Point a, Point b)
        {
            var x = b.X - a.X;
            var y = b.Y - a.Y;
            return new Point(x, y);
        }
        public static Point Add(this Point a, Point b)
        {
            var x = b.X + a.X;
            var y = b.Y + a.Y;
            return new Point(x, y);
        }
        public static int Length(this Point a)
        {
            return a.X*a.X + a.Y*a.Y;
        }
        public static double LengthSquared(this Point a)
        {
            return Math.Sqrt(a.X * a.X + a.Y * a.Y);
        }
        public static PointF Normalize(this Point a)
        {
            var ls = (float)a.LengthSquared();
            return new PointF(a.X / ls, a.Y / ls);
        }
    }
}


--file SendExtensions.cs
﻿using MuEmu.Network;
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;

namespace MuEmu.Util
{
    public static class SendExtensions
    {
        public static async Task SendAsync(this IEnumerable<GSSession> array, object message)
        {
            foreach(var client in array)
                await client.SendAsync(message);
        }
        public static async Task SendAsync(this IEnumerable<Player> array, object message)
        {
            foreach (var client in array)
                await client.Session.SendAsync(message);
        }
        public static async Task SendAsync(this IEnumerable<Character> array, object message)
        {
            foreach (var client in array)
                await client.Player.Session.SendAsync(message);
        }
    }
}


--file SessionExtensions.cs
﻿using MU.Network.Game;
using MuEmu.Network;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu.Util
{
    public static class SessionExtensions
    {
        public static async void Exception(this GSSession session, Exception exception, string messageTemplate = "")
        {
            await session.SendAsync(new SNotice(MU.Resources.NoticeType.Blue, exception.Message));
            Log.Logger.ForAccount(session).Error(exception, messageTemplate);
        }
    }
}


--file StateMachine.cs
﻿using MU.Resources;
using MuEmu.Resources;
using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Text;

namespace MuEmu.Util
{
    public abstract class StateMachine<T>
        where T : struct, IConvertible
    {
        public T CurrentState { get; private set; }
        private T _nextState;
        private DateTimeOffset _nextStateIn;
        private DateTimeOffset _currentState;
        protected ILogger _logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(StateMachine<T>));

        public TimeSpan TimeLeft => _nextStateIn - DateTimeOffset.Now;
        public TimeSpan Time => DateTimeOffset.Now - _currentState;
        public DateTimeOffset Start => _currentState;
        public DateTimeOffset End => _nextStateIn;

        public abstract void Initialize();

        public virtual void Update()
        {
            if (!_nextState.Equals(CurrentState) && _nextStateIn < DateTimeOffset.Now)
            {
                var protectedState = _nextState;
                _logger.Information(ServerMessages.GetMessage(Messages.Server_EventStateChange), CurrentState, _nextState);
                OnTransition(_nextState);
                CurrentState = protectedState;
            }
        }

        public abstract void OnTransition(T NextState);
        
        public void Trigger(T nextSate)
        {
            _nextState = nextSate;
            _nextStateIn = DateTimeOffset.Now;
            _currentState = DateTimeOffset.Now;
        }

        public void Trigger(T nextSate, TimeSpan @in)
        {
            _nextState = nextSate;
            _currentState = DateTimeOffset.Now;
            _nextStateIn = DateTimeOffset.Now.Add(@in);
        }

        public void ChangeState(T nextState)
        {
            if (!nextState.Equals(CurrentState))
            {
                var protectedState = nextState;
                OnTransition(nextState);
                CurrentState = protectedState;
            }
        }
    }
}


--file Triangle.cs
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;

namespace MuEmu.Util
{
    struct Triangle
    {
        public Point A { get; set; }
        public Point B { get; set; }
        public Point C { get; set; }
        public Triangle(Point a, Point b, Point c)
        {
            A = a;
            B = b;
            C = c;
        }

        private float sign(PointF p1, PointF p2, PointF p3)
        {
            return (p1.X - p3.X) * (p2.Y - p3.Y) - (p2.X - p3.X) * (p1.Y - p3.Y);
        }

        public bool Contains(PointF pt)
        {
            float d1, d2, d3;
            bool has_neg, has_pos;

            d1 = sign(pt, A, B);
            d2 = sign(pt, B, B);
            d3 = sign(pt, C, A);

            has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0);
            has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);

            return !(has_neg && has_pos);
        }
    }
}


--file Form1.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using WebZen.Network;

namespace PacketHelper
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
            SimpleModulus.LoadDecryptionKey("Dec2.dat");
        }

        private void textBox1_TextChanged(object sender, EventArgs e)
        {
            var clear = textBox1.Text.Split(new char[] { ' ', '\t' });
            var ms = new MemoryStream();
            var i = 0;
            foreach(var c in clear)
            {
                if (!string.IsNullOrWhiteSpace(c))
                    ms.WriteByte(byte.Parse(c, System.Globalization.NumberStyles.HexNumber));

                i++;
            }

            var stream = new byte[ms.Length];
            Array.Copy(ms.GetBuffer(), stream, stream.Length);
            ms.Dispose();

            byte[] dec;
            try
            {
                if (stream[0] == 0xC3)
                {
                    var substream = new byte[stream.Length - 2];
                    Array.Copy(stream, 2, substream, 0, substream.Length);
                    dec = SimpleModulus.Decoder(substream);
                }
                else
                {
                    var substream = new byte[stream.Length - 3];
                    Array.Copy(stream, 3, substream, 0, substream.Length);
                    dec = SimpleModulus.Decoder(substream);
                }
            }catch(Exception)
            {
                textBox2.Text = "Invalid Packet";
                return;
            }


            textBox2.Text = string.Join(" ", dec.Select(x => x.ToString("X2")));
        }
    }
}


--file Form1.Designer.cs
﻿namespace PacketHelper
{
    partial class Form1
    {
        /// <summary>
        /// Variable del diseñador necesaria.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Limpiar los recursos que se estén usando.
        /// </summary>
        /// <param name="disposing">true si los recursos administrados se deben desechar; false en caso contrario.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Código generado por el Diseñador de Windows Forms

        /// <summary>
        /// Método necesario para admitir el Diseñador. No se puede modificar
        /// el contenido de este método con el editor de código.
        /// </summary>
        private void InitializeComponent()
        {
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.textBox2 = new System.Windows.Forms.TextBox();
            this.SuspendLayout();
            // 
            // textBox1
            // 
            this.textBox1.Location = new System.Drawing.Point(12, 52);
            this.textBox1.Multiline = true;
            this.textBox1.Name = "textBox1";
            this.textBox1.Size = new System.Drawing.Size(775, 190);
            this.textBox1.TabIndex = 0;
            this.textBox1.TextChanged += new System.EventHandler(this.textBox1_TextChanged);
            // 
            // textBox2
            // 
            this.textBox2.Location = new System.Drawing.Point(12, 248);
            this.textBox2.Multiline = true;
            this.textBox2.Name = "textBox2";
            this.textBox2.Size = new System.Drawing.Size(775, 190);
            this.textBox2.TabIndex = 1;
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(800, 450);
            this.Controls.Add(this.textBox2);
            this.Controls.Add(this.textBox1);
            this.Name = "Form1";
            this.Text = "Form1";
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.TextBox textBox1;
        private System.Windows.Forms.TextBox textBox2;
    }
}



--file SimpleModulus.cs
﻿using System;
using System.IO;

namespace WebZen.Network
{
    public static class SimpleModulus
    {
        private static readonly uint[] s_saveLoadXor = new uint[] { 0x3F08A79B, 0xE25CC287, 0x93D27AB9, 0x20DEA7BF };
        private static Modulus s_enc;
        private static Modulus s_dec;

        public static byte[] Encoder(byte[] src) => s_enc.Enc(src);
        public static byte[] Decoder(byte[] src) => s_dec.Dec(src);

        public static void LoadEncryptionKey(string file)
        {
            s_enc = LoadKey(file, 4370, true, true, false, true);
        }

        public static void LoadDecryptionKey(string file)
        {
            s_dec = LoadKey(file, 4370, true, false, true, true);
        }

        private static Modulus LoadKey(string file, ushort header, bool loadModulus, bool loadEncKey, bool loadDecKey, bool loadXOrKey)
        {
            var key = new Modulus();

            using (var f = File.OpenRead(file))
            {
                var Size = 6;
                Size += loadModulus ? 16 : 0;
                Size += loadEncKey ? 16 : 0;
                Size += loadDecKey ? 16 : 0;
                Size += loadXOrKey ? 16 : 0;

                var temp = new byte[16];

                if (loadModulus)
                {
                    f.Read(temp, 0, 16);
                    for (var i = 0; i < 4; i++)
                    {
                        key.modulus[i] = s_saveLoadXor[i] ^ BitConverter.ToUInt32(temp, i * 4);
                    }
                }

                if (loadEncKey)
                {
                    f.Read(temp, 0, 16);
                    for (var i = 0; i < 4; i++)
                    {
                        key.encryptionKey[i] = s_saveLoadXor[i] ^ BitConverter.ToUInt32(temp, i * 4);
                    }
                }

                if (loadDecKey)
                {
                    f.Read(temp, 0, 16);
                    for (var i = 0; i < 4; i++)
                    {
                        key.decryptionKey[i] = s_saveLoadXor[i] ^ BitConverter.ToUInt32(temp, i * 4);
                    }
                }

                if (loadXOrKey)
                {
                    f.Read(temp, 0, 16);
                    for (var i = 0; i < 4; i++)
                    {
                        key.xor[i] = s_saveLoadXor[i] ^ BitConverter.ToUInt32(temp, i * 4);
                    }
                }
            }

            return key;
        }

        private static void SaveKey(string file, Modulus key, ushort header, bool loadModulus, bool loadEncKey, bool loadDecKey, bool loadXOrKey)
        {
            using (var f = File.OpenWrite(file))
            {
                var Size = 6;
                Size += loadModulus ? 16 : 0;
                Size += loadEncKey ? 16 : 0;
                Size += loadDecKey ? 16 : 0;
                Size += loadXOrKey ? 16 : 0;

                var temp = 0u;

                if (loadModulus)
                {
                    for (var i = 0; i < 4; i++)
                    {
                        temp = s_saveLoadXor[i] ^ key.modulus[i];
                    }
                    f.Write(BitConverter.GetBytes(temp), 0, 4);
                }

                if (loadEncKey)
                {
                    for (var i = 0; i < 4; i++)
                    {
                        temp = s_saveLoadXor[i] ^ key.encryptionKey[i];
                    }
                    f.Write(BitConverter.GetBytes(temp), 0, 4);
                }

                if (loadDecKey)
                {
                    for (var i = 0; i < 4; i++)
                    {
                        temp = s_saveLoadXor[i] ^ key.decryptionKey[i];
                    }
                    f.Write(BitConverter.GetBytes(temp), 0, 4);
                }

                if (loadXOrKey)
                {
                    for (var i = 0; i < 4; i++)
                    {
                        temp = s_saveLoadXor[i] ^ key.xor[i];
                    }
                    f.Write(BitConverter.GetBytes(temp), 0, 4);
                }
            }
        }
    }

    public class Modulus
    {
        public uint[] xor = new uint[4];
        public uint[] encryptionKey = new uint[4];
        public uint[] decryptionKey = new uint[4];
        public uint[] modulus = new uint[4];

        public byte[] Enc(byte[] src)
        {
            var iDec = ((src.Length + 7) / 8);
            iDec = (iDec + iDec * 4) * 2 + iDec;

            var dest = new byte[iDec];

            var iOriSize = src.Length;
            var iDest = 0;
            var iTempSize2 = 0;

            var tempDest = new byte[11];
            var tempSrc = new byte[8];

            for (int i = 0; i < src.Length; i += 8, iOriSize -= 8, iDest += 11)
            {
                iTempSize2 = iOriSize;
                if (iOriSize >= 8)
                    iTempSize2 = 8;

                Array.Copy(src, i, tempSrc, 0, iTempSize2);

                EncBlock(tempDest, tempSrc, iTempSize2);

                Array.Copy(tempDest, 0, dest, iDest, 11);
            }

            return dest;
        }

        public byte[] Dec(byte[] src)
        {
            var iEnc = src.Length * 8 / 11;
            var dest = new byte[iEnc];

            var decLen = 0;
            var destPos = 0;
            var iResult = 0;
            var tempDest = new byte[8];
            var tempSrc = new byte[11];

            while (decLen < src.Length)
            {
                Array.Copy(src, decLen, tempSrc, 0, 11);

                var tempResult = DecBlock(tempDest, tempSrc);

                Array.Copy(tempDest, 0, dest, destPos, 8);

                if (iResult < 0 || tempResult < 0)
                    throw new InvalidDataException("Error decoding buffer");

                iResult += tempResult;
                decLen += 11;
                destPos += 8;
            }

            return dest;
        }

        private int EncBlock(byte[] dest, byte[] src, int size)
        {
            var EncBuffer = new uint[4];
            var EncValue = 0u;

            for (var i = 0; i < 4; i++)
            {
                var EncSource = BitConverter.ToUInt16(src, i * 2);
                EncBuffer[i] = (xor[i] ^ EncSource ^ EncValue) * encryptionKey[i] % modulus[i];
                EncValue = EncBuffer[i] & 0xffff;
            }

            for (var i = 0; i < 3; i++)
            {
                EncBuffer[i] = EncBuffer[i] ^ xor[i] ^ (EncBuffer[i + 1] & 0xFFFF);
            }

            var iBitPos = 0;

            for (int i = 0; i < 4; i++)
            {
                var EncBuffBytes = BitConverter.GetBytes(EncBuffer[i]);
                iBitPos = AddBits(dest, iBitPos, EncBuffBytes, 0, 16);
                iBitPos = AddBits(dest, iBitPos, EncBuffBytes, 22, 2);
            }

            var btCheckSum = (byte)0xF8;

            for (int i = 0; i < 8; i++)
                btCheckSum ^= src[i];

            var cs = new byte[] { (byte)(btCheckSum ^ size ^ 0x3D), btCheckSum };

            return AddBits(dest, iBitPos, cs, 0, 16);
        }

        private int DecBlock(byte[] dest, byte[] src)
        {
            var tempDest = new byte[4];
            var decBuffer = new uint[4];
            var bitPos = 0;

            for (var i = 0; i < 4; i++)
            {
                AddBits(tempDest, 0, src, bitPos, 16);
                bitPos += 16;
                AddBits(tempDest, 22, src, bitPos, 2);
                bitPos += 2;
                decBuffer[i] = BitConverter.ToUInt32(tempDest, 0);

                //Array.Fill<byte>(tempDest, 0);
                for (var j = 0; j < tempDest.Length; j++)
                    tempDest[j] = 0;
            }

            for (var i = 2; i >= 0; i--)
            {
                decBuffer[i] = (decBuffer[i] ^ xor[i] ^ (decBuffer[i + 1] & 0xFFFF));
            }

            ushort Temp = 0;
            var Temp1 = 0u;

            for (var i = 0; i < 4; i++)
            {
                Temp1 = ((decryptionKey[i] * decBuffer[i]) % modulus[i]) ^ xor[i] ^ Temp;
                Temp = (ushort)(decBuffer[i] & 0xFFFF);
                Array.Copy(BitConverter.GetBytes(Temp1), 0, dest, i * 2, 2);
            }


            //Array.Fill<byte>(tempDest, 0);
            for (var j = 0; j < tempDest.Length; j++)
                tempDest[j] = 0;
            AddBits(tempDest, 0, src, bitPos, 16);

            tempDest[0] = (byte)(tempDest[1] ^ tempDest[0] ^ 0x3D);

            var CheckSum = (byte)0xF8;
            for (var i = 0; i < 8; i++)
                CheckSum ^= dest[i];

            if (CheckSum != tempDest[1])
                return -1;

            return tempDest[0];
        }

        private int AddBits(byte[] dest, int destPos, byte[] src, int srcPos, int srcLen)
        {
            var iSourceBufferBitLen = srcLen + srcPos;
            var iTempBufferLen = GetByteOfBit(iSourceBufferBitLen -1);
            iTempBufferLen += 1 - GetByteOfBit(srcPos);

            // Copy the Source Buffer
            var pTempBuffer = new byte[iTempBufferLen + 1];
            //Array.Fill<byte>(pTempBuffer, 0);
            Array.Copy(src, GetByteOfBit(srcPos), pTempBuffer, 0, iTempBufferLen);

            // Save the Last ibt if exist
            if ((iSourceBufferBitLen % 8) != 0)
            {
                pTempBuffer[iTempBufferLen - 1] &= (byte)(255 << (8 - (iSourceBufferBitLen % 8)));
            }

            // Get the Values to Shift
            var iShiftLeft = (srcPos % 8);
            var iShiftRight = (destPos % 8);

            // Shift the Values to Add the right space of the desired bits
            Shift(pTempBuffer, iTempBufferLen, -iShiftLeft);
            Shift(pTempBuffer, iTempBufferLen + 1, iShiftRight);

            // Copy the the bits of Source to the Dest
            int iNewTempBufferLen = ((iShiftRight <= iShiftLeft) ? 0 : 1) + iTempBufferLen;

            var iDest = GetByteOfBit(destPos);
            for (int i = 0; i < iNewTempBufferLen; i++)
            {
                dest[iDest + i] |= pTempBuffer[i];
            }

            // Return the number of bits of the new Dest Buffer
            return destPos + srcLen;
        }

        private void Shift(byte[] TempBuff, int iSize, int ShiftLen)
        {
            // Case no Shift Len
            if (ShiftLen != 0)
            {
                // Shift Right
                if (ShiftLen > 0)
                {
                    if ((iSize - 1) > 0)
                    {
                        for (int i = (iSize - 1); i > 0; i--)
                        {
                            TempBuff[i] = (byte)((TempBuff[i - 1] << ((8 - ShiftLen))) | (TempBuff[i] >> ShiftLen));
                        }
                    }

                    TempBuff[0] >>= ShiftLen;
                }
                else    // Shift Left
                {
                    ShiftLen = -ShiftLen;

                    if ((iSize - 1) > 0)
                    {
                        for (int i = 0; i < (iSize - 1); i++)
                        {
                            TempBuff[i] = (byte)((TempBuff[i + 1] >> ((8 - ShiftLen))) | (TempBuff[i] << ShiftLen));
                        }
                    }

                    TempBuff[iSize - 1] <<= ShiftLen;
                }
            }
        }

        private int GetByteOfBit(int bit)
        {
            return bit >> 3;
        }
    }
}


--file StreamPacketEngine.cs
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace WebZen.Network
{
    public class StreamPacketEngine : IDisposable
    {
        private MemoryStream _stream = new MemoryStream();
        private readonly byte[] XORFilter = new byte[]
        {
            0xE7, 0x6D, 0x3A, 0x89, 0xBC, 0xB2, 0x9F, 0x73, 0x23, 0xA8, 0xFE, 0xB6, 0x49,
            0x5D, 0x39, 0x5D, 0x8A, 0xCB, 0x63, 0x8D, 0xEA, 0x7D, 0x2B, 0x5F, 0xC3, 0xB1,
            0xE9, 0x83, 0x29, 0x51, 0xE8, 0x56
        };

        public bool AddData(byte[] data)
        {
            _stream.Write(data, 0, data.Length);

            return true;
        }

        public byte[] ExtractPacket()
        {
            _stream.Seek(0, SeekOrigin.Begin);

            var type = _stream.ReadByte();
            ushort size = 0;
            switch(type)
            {
                case 0xC1:
                    size = (ushort)_stream.ReadByte();
                    break;
                case 0xC2:
                    size = (ushort)((_stream.ReadByte() << 8) | _stream.ReadByte());
                    break;
                default:
                    throw new Exception($"Invalid packet type 0x{type:X2}");
            }

            return XorData(size, type == 0xC1 ? 2 : 3);
        }

        public byte[] ExtractData()
        {
            _stream.Seek(0, SeekOrigin.Begin);

            var type = _stream.ReadByte();
            ushort size = 0;
            switch (type)
            {
                case 0xC1:
                    size = (ushort)_stream.ReadByte();
                    break;
                case 0xC2:
                    size = (ushort)((_stream.ReadByte() << 8) | _stream.ReadByte());
                    break;
                default:
                    throw new Exception($"Invalid packet type 0x{type:X2}");
            }

            return IXorData(size, type == 0xC1 ? 2 : 3);
        }

        private byte[] XorData(int Size, int Skip)
        {
            var packet = new byte[Size];
            _stream.Seek(0, SeekOrigin.Begin);
            _stream.Read(packet, 0, Size);
            var tmpstream = new MemoryStream();
            tmpstream.Write(_stream.ToArray(), Size, (int)(_stream.Length - Size));
            _stream.Dispose();
            _stream = tmpstream;

            for (int i = Size - 1; i != Skip; i--)
            {
                packet[i] ^= (byte)(packet[i - 1] ^ XORFilter[(i & (XORFilter.Length - 1))]);
            }

            return packet;
        }

        private byte[] IXorData(int Size, int Skip)
        {
            var packet = new byte[Size];
            _stream.Seek(0, SeekOrigin.Begin);
            _stream.Read(packet, 0, Size);
            var tmpstream = new MemoryStream();
            tmpstream.Write(_stream.ToArray(), Size, (int)(_stream.Length - Size));
            _stream.Dispose();
            _stream = tmpstream;

            for (int i = Skip; i < Size - 1; i++)
            {
                packet[i+1] ^= (byte)(packet[i] ^ XORFilter[(i+1 & (XORFilter.Length - 1))]);
            }

            return packet;
        }

        public void Dispose()
        {
            _stream.Dispose();
        }
    }
}


--file Program.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

namespace PacketHelper
{
    static class Program
    {
        /// <summary>
        /// Punto de entrada principal para la aplicación.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}


--file AssemblyInfo.cs
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// La información general de un ensamblado se controla mediante el siguiente 
// conjunto de atributos. Cambie estos valores de atributo para modificar la información
// asociada con un ensamblado.
[assembly: AssemblyTitle("PacketHelper")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("PacketHelper")]
[assembly: AssemblyCopyright("Copyright ©  2018")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Si establece ComVisible en false, los tipos de este ensamblado no estarán visibles 
// para los componentes COM.  Si es necesario obtener acceso a un tipo en este ensamblado desde 
// COM, establezca el atributo ComVisible en true en este tipo.
[assembly: ComVisible(false)]

// El siguiente GUID sirve como id. de typelib si este proyecto se expone a COM.
[assembly: Guid("620a79e7-ccec-40d0-8456-68842e33904f")]

// La información de versión de un ensamblado consta de los cuatro valores siguientes:
//
//      Versión principal
//      Versión secundaria
//      Número de compilación
//      Revisión
//
// Puede especificar todos los valores o utilizar los números de compilación y de revisión predeterminados
// mediante el carácter '*', como se muestra a continuación:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]


--file Resources.Designer.cs
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     Este código fue generado por una herramienta.
//     Versión de runtime: 4.0.30319.42000
//
//     Los cambios de este archivo pueden provocar un comportamiento inesperado y se perderán si
//     el código se vuelve a generar.
// </auto-generated>
//------------------------------------------------------------------------------

namespace PacketHelper.Properties
{


    /// <summary>
    ///   Clase de recurso fuertemente tipado para buscar cadenas traducidas, etc.
    /// </summary>
    // StronglyTypedResourceBuilder generó automáticamente esta clase
    // a través de una herramienta como ResGen o Visual Studio.
    // Para agregar o quitar un miembro, edite el archivo .ResX y, a continuación, vuelva a ejecutar ResGen
    // con la opción /str o recompile su proyecto de VS.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Devuelve la instancia ResourceManager almacenada en caché utilizada por esta clase.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("PacketHelper.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Invalida la propiedad CurrentUICulture del subproceso actual para todas las
        ///   búsquedas de recursos usando esta clase de recursos fuertemente tipados.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}


--file Settings.Designer.cs
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace PacketHelper.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}


--file MessageHandler.cs
﻿using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using WebZen.Network;

namespace WebZen.Handlers
{
    public class MessageHandler : IMessageHandler
    {
        public virtual async Task<bool> OnMessageReceived(WZClient session, object message)
        {
            foreach (var m in GetType().GetMethods())
            {
                foreach (var a in m.GetCustomAttributes(false))
                {
                    if(a.GetType() == typeof(MessageHandlerAttribute))
                    {
                        var mh = a as MessageHandlerAttribute;
                        if (mh._type == message.GetType())
                        {
                            var isAsync = m.GetCustomAttributes().Where(x => x.GetType() == typeof(AsyncStateMachineAttribute)).Count() > 0;
                            var lArgs = new List<object>
                            {
                                session,
                                message
                            };
                            var args = lArgs.Take(m.GetParameters().Length).ToArray();
                            try
                            {
                                if (isAsync)
                                    await (Task)m.Invoke(this, args);
                                else
                                    m.Invoke(this, args);
                            }catch(Exception e)
                            {
                                Log.ForContext(Constants.SourceContextPropertyName, nameof(MessageHandler))
                                    .Error(e, "Is Async:" + isAsync.ToString());
                                return false;
                            }
                            return true;
                        }
                    }
                }
            }

            return false;
        }
    }

    public interface IMessageHandler
    {
        Task<bool> OnMessageReceived(WZClient session, object message);
    }
}


--file MessageHandlerAttribute.cs
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace WebZen.Handlers
{
    public class MessageHandlerAttribute : Attribute
    {
        public readonly Type _type;

        public MessageHandlerAttribute(Type type)
        {
            _type = type;
        }
    }
}


--file IExtraEncoder.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;

namespace WebZen.Network
{
    internal interface IExtraEncoder
    {
        void Encoder(MemoryStream ms);
    }
}


--file ISessionFactory.cs
﻿using System;
using System.Collections.Generic;
using System.Net.Sockets;
using System.Text;

namespace WebZen.Network
{
    public interface ISessionFactory
    {
        WZClient Create(WZServer server, Socket socket, AsyncCallback onRecv);
    }
}


--file MessageFactory.cs
﻿using BlubLib;
using BlubLib.Serialization;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace WebZen.Network
{
    public class MessageFactory
    {
        private readonly Dictionary<ushort, Type> _typeLookup = new Dictionary<ushort, Type>();
        private readonly Dictionary<Type, ushort> _opCodeLookup = new Dictionary<Type, ushort>();

        protected void Register<T>(ushort opCode)
            where T : new()
        {
            var type = typeof(T);
            _opCodeLookup.Add(type, opCode);

            if(!_typeLookup.ContainsKey(opCode))
                _typeLookup.Add(opCode, type);
        }

        protected void ChangeOPCode<T>(ushort opCode)
            where T : new()
        {
            var type = typeof(T);
            var old = _opCodeLookup[type];
            _typeLookup.Remove(old);
            _opCodeLookup[type] = opCode;
            if(!_typeLookup.ContainsKey(opCode))
                _typeLookup.Add(opCode, type);
        }

        protected void ChangeType<T>(ushort opCode, Type oldType)
            where T : new()
        {
            var type = typeof(T);
            _opCodeLookup.Remove(oldType);
            _opCodeLookup.Add(type,opCode);
            if (_typeLookup.ContainsValue(oldType))
            {
                _typeLookup[opCode] = type;
            }
            else
            {
                _typeLookup.Add(opCode, type);
            }
        }

        public ushort GetOpCode(Type type)
        {
            ushort opCode;
            if (_opCodeLookup.TryGetValue(type, out opCode))
                return opCode;

            throw new Exception($"No opcode found for type {type.FullName}");
        }

        public object GetMessage(ushort opCode, Stream stream)
        {
            Type type;
            if (!_typeLookup.TryGetValue(opCode, out type))
                throw new Exception($"No type found for opcode {opCode}");

            try
            {
                return Serializer.Deserialize(stream, type);
            }catch(Exception ex)
            {
                throw new Exception("Type: " + type + ", OPCode: " + opCode + ", Stream Length: " + stream.Length, ex);
            }
        }

        public object GetMessage(ushort opCode, BinaryReader reader)
        {
            Type type;
            if (!_typeLookup.TryGetValue(opCode, out type))
                throw new ArgumentException($"bad OPCode {opCode}");

            return Serializer.Deserialize(reader, type);
        }

        public bool ContainsType(Type type)
        {
            return _opCodeLookup.ContainsKey(type);
        }

        public bool ContainsOpCode(ushort opCode)
        {
            return _typeLookup.ContainsKey(opCode);
        }
    }

    public class MessageFactory<TOpCode, TMessage> : MessageFactory
    {
        protected Func<TOpCode, TOpCode> Converter = (opCode) => opCode;
        protected void Register<T>(TOpCode opCode)
            where T : TMessage, new()
        {
            Register<T>(DynamicCast<ushort>.From(Converter(opCode)));
        }
        protected void ChangeOPCode<T>(TOpCode opCode)
            where T : TMessage, new()
        {
            ChangeOPCode<T>(DynamicCast<ushort>.From(opCode));
        }

        protected void ChangeType<T>(TOpCode opCode, Type oldType)
            where T : TMessage, new()
        {
            ChangeType<T>(DynamicCast<ushort>.From(opCode), oldType);
        }

        public new TOpCode GetOpCode(Type type)
        {
            return DynamicCast<TOpCode>.From(base.GetOpCode(type));
        }

        public TMessage GetMessage(TOpCode opCode, Stream stream)
        {
            return (TMessage)GetMessage(DynamicCast<ushort>.From(opCode), stream);
        }

        public TMessage GetMessage(TOpCode opCode, BinaryReader reader)
        {
            return (TMessage)GetMessage(DynamicCast<ushort>.From(opCode), reader);
        }

        public bool ContainsOpCode(TOpCode opCode)
        {
            return ContainsOpCode(DynamicCast<ushort>.From(opCode));
        }
    }
}


--file Packet.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Text;
using BlubLib.Serialization;
using WebZen.Handlers;
using WebZen.Serialization;
using Serilog;
using Serilog.Core;
using WebZen.Util;
using System.Net.Http.Headers;

namespace WebZen.Network
{
    public class WZPacketDecoder
    {
        public static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(WZPacketDecoder));
        private readonly MessageFactory[] _factories;
        private bool _packetRijndael;

        public WZPacketDecoder(MessageFactory[] factories, bool useRijndael)
        {
            _factories = factories;
            _packetRijndael = useRijndael;
        }

        public int Decode(MemoryStream rawPacket, out short serial, List<object> messages, WZClient client)
        {
            using (var decPacket = new MemoryStream())
            using (var posPacket = new MemoryStream())
            {
                //var type = rawPacket[0];
                var type = (byte)rawPacket.ReadByte();
                ushort size = 0;
                serial = -1;

                if (type == 0xC1 || type == 0xC3)
                    size = (ushort)rawPacket.ReadByte();
                else if (type == 0xC2 || type == 0xC4)
                    size = (ushort)((rawPacket.ReadByte() << 8) | rawPacket.ReadByte());
                else
                    throw new InvalidProgramException($"Invalid packet type {type:X2}");

                // Packet Encrypted
                byte[] tmp;
                byte[] dec;
                switch(type)
                {
                    case 0xC1:
                        decPacket.WriteByte(type);
                        decPacket.WriteByte((byte)size);
                        tmp = new byte[size - 2];
                        rawPacket.Read(tmp, 0, tmp.Length);
                        decPacket.Write(tmp, 0, tmp.Length);
                        break;
                    case 0xC2:
                        decPacket.WriteByte(type);
                        decPacket.WriteByte((byte)((size >> 8) & 0xff));
                        decPacket.WriteByte((byte)(size & 0xff));
                        tmp = new byte[size - 3];
                        rawPacket.Read(tmp, 0, tmp.Length);
                        decPacket.Write(tmp, 0, tmp.Length);
                        break;
                    case 0xC3:
                        tmp = new byte[size - 2];
                        rawPacket.Read(tmp, 0, tmp.Length);

                        if(_packetRijndael)
                        {
                            dec = PacketEncrypt.Decrypt(tmp, client);
                            if (dec.Length == 0)
                                return size;

                            decPacket.WriteByte(0xC1);
                            decPacket.WriteByte((byte)(dec.Length + 2));
                            decPacket.Write(dec, 0, dec.Length);
                        }else
                        {
                            dec = SimpleModulus.Decoder(tmp);
                            serial = dec[0];
                            decPacket.WriteByte(0xC1);
                            decPacket.WriteByte((byte)(dec.Length + 1));
                            decPacket.Write(dec, 1, dec.Length - 1);
                        }
                        break;
                    case 0xC4:
                        tmp = new byte[size - 3];
                        rawPacket.Read(tmp, 0, tmp.Length);

                        if (_packetRijndael)
                        {
                            dec = PacketEncrypt.Decrypt(tmp, client);
                            if (dec.Length == 0)
                                return size;

                            decPacket.WriteByte(0xC2);
                            decPacket.WriteByte((byte)((dec.Length + 3) >> 8));
                            decPacket.WriteByte((byte)((dec.Length + 3) & 255));
                            decPacket.Write(dec, 0, dec.Length);
                        }
                        else
                        {
                            dec = SimpleModulus.Decoder(tmp);
                            serial = dec[0];
                            decPacket.WriteByte(0xC2);
                            decPacket.WriteByte((byte)((dec.Length + 2) >> 8));
                            decPacket.WriteByte((byte)((dec.Length + 2) & 255));
                            decPacket.Write(dec, 1, dec.Length - 1);
                        }
                        break;
                }
                
                using (var spe = new StreamPacketEngine(_packetRijndael))
                {
                    spe.AddData(decPacket.ToArray());
                    var posProcess = spe.ExtractPacket();
                    posPacket.Write(posProcess, 0, posProcess.Length);
                }

                posPacket.Seek(0, SeekOrigin.Begin);

#if DEBUG
                Logger.Debug("Incoming Packet: "+string.Join(", 0x", posPacket.GetBuffer().Take((int)posPacket.Length).Select(x => x.ToString("X2"))));
#endif

                ushort opCode;
                ushort pkSize;

                if (type == 0xC1 || type == 0xC3)
                {
                    if (posPacket.Length == 3)
                    {
                        posPacket.Seek(0, SeekOrigin.End);
                        posPacket.WriteByte(0);
                        posPacket.Seek(0, SeekOrigin.Begin);
                    }
                    else if (posPacket.Length < 3)
                    {
                        throw new Exception("Invalid Packet " + type.ToString("X2") + " size " + posPacket.Length + " -");
                    }

                    var tmph = Serializer.Deserialize<WZBPacket>(posPacket);
                    opCode = tmph.Operation;
                    pkSize = tmph.Size;
                }
                else
                {
                    if (posPacket.Length == 4)
                    {
                        posPacket.Seek(0, SeekOrigin.End);
                        posPacket.WriteByte(0);
                        posPacket.Seek(0, SeekOrigin.Begin);
                    }
                    else if(posPacket.Length < 4)
                    {
                        throw new Exception("Invalid Packet " + type.ToString("X2") + " size " + posPacket.Length + " -");
                    }

                    var tmph = Serializer.Deserialize<WZWPacket>(posPacket);
                    opCode = tmph.Operation;
                    pkSize = tmph.Size;
                }

                if ((opCode& 0xFF00)== 0xFF00) posPacket.Position--;
                //posPacket.Seek(0, SeekOrigin.Begin);

                var factory = _factories.FirstOrDefault(f => f.ContainsOpCode(opCode));
                try
                {
                    if (factory != null)
                    {
                        messages.Add(factory.GetMessage(opCode, posPacket));
                    }
                    else
                    {
                        var orgOpCode = opCode;
                        opCode |= 0xFF00;
                        factory = _factories.FirstOrDefault(f => f.ContainsOpCode(opCode));
                        if (factory != null)
                        {
                            posPacket.Position--;
                            messages.Add(factory.GetMessage(opCode, posPacket));
                        }
                        else
                        {
                            Logger.Error("Invalid OpCoder {opCodea:X4}|{opCode:X2} Size:{pkSize}", orgOpCode, opCode & 0xff, pkSize);
                            Logger.Error("Packet " + string.Join(" ", posPacket.GetBuffer().Take(pkSize).Select(x => x.ToString("X2"))));
                        }
                    }
                }catch(Exception ex)
                {
                    throw new Exception("Factory: " + factory, ex);
                }

                return size;
            }
        }
    }

    public class WZPacketDecoderSimple
    {
        public static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(WZPacketDecoder));
        private readonly MessageFactory[] _factories;

        public WZPacketDecoderSimple(MessageFactory[] factories)
        {
            _factories = factories;
        }

        public int Decode(MemoryStream rawPacket, out short serial, List<object> messages)
        {
            using (var decPacket = new MemoryStream())
            using (var posPacket = new MemoryStream())
            {
                //var type = rawPacket[0];
                var type = (byte)rawPacket.ReadByte();
                ushort size = 0;
                serial = -1;

                if (type == 0xC1 || type == 0xC3)
                    size = (ushort)rawPacket.ReadByte();
                else if (type == 0xC2 || type == 0xC4)
                    size = (ushort)((rawPacket.ReadByte() << 8) | rawPacket.ReadByte());
                else
                    throw new InvalidProgramException($"Invalid packet type {type:X2}");

                // Packet Encrypted
                byte[] tmp;
                byte[] dec;
                switch (type)
                {
                    case 0xC1:
                        decPacket.WriteByte(type);
                        decPacket.WriteByte((byte)size);
                        tmp = new byte[size - 2];
                        rawPacket.Read(tmp, 0, tmp.Length);
                        decPacket.Write(tmp, 0, tmp.Length);
                        break;
                    case 0xC2:
                        decPacket.WriteByte(type);
                        decPacket.WriteByte((byte)((size >> 8) & 0xff));
                        decPacket.WriteByte((byte)(size & 0xff));
                        tmp = new byte[size - 3];
                        rawPacket.Read(tmp, 0, tmp.Length);
                        decPacket.Write(tmp, 0, tmp.Length);
                        break;
                    case 0xC3:
                        tmp = new byte[size - 2];
                        rawPacket.Read(tmp, 0, tmp.Length);
                        dec = SimpleModulus.Decoder(tmp);
                        serial = dec[0];
                        decPacket.WriteByte(0xC1);
                        decPacket.WriteByte((byte)(dec.Length + 1));
                        decPacket.Write(dec, 1, dec.Length - 1);
                        break;
                    case 0xC4:
                        tmp = new byte[size - 3];
                        rawPacket.Read(tmp, 0, tmp.Length);
                        dec = SimpleModulus.Decoder(tmp);
                        serial = dec[0];
                        decPacket.WriteByte(0xC2);
                        decPacket.WriteByte((byte)((dec.Length + 2) >> 8));
                        decPacket.WriteByte((byte)((dec.Length + 2) & 255));
                        decPacket.Write(dec, 1, dec.Length - 1);
                        break;
                }

                //using (var spe = new StreamPacketEngine())
                //{
                //    spe.AddData(decPacket.ToArray());
                //    var posProcess = spe.ExtractPacket();
                //    posPacket.Write(posProcess, 0, posProcess.Length);
                //}

                var posProcess = decPacket.ToArray();
                posPacket.Write(posProcess, 0, posProcess.Length);
                posPacket.Seek(0, SeekOrigin.Begin);

                ushort opCode;
                ushort pkSize;

                if (posPacket.Length < 3)
                {
                    //Logger.Error("Invalid Size {0}", posPacket.Length);
                    throw new Exception("Invalid Packet size " + posPacket.Length);
                }

                if (type == 0xC1 || type == 0xC3)
                {
                    var tmph = Serializer.Deserialize<WZBPacket>(posPacket);
                    opCode = tmph.Operation;
                    pkSize = tmph.Size;
                }
                else
                {
                    var tmph = Serializer.Deserialize<WZWPacket>(posPacket);
                    opCode = tmph.Operation;
                    pkSize = tmph.Size;
                }

                //posPacket.Seek(0, SeekOrigin.Begin);

                var factory = _factories.FirstOrDefault(f => f.ContainsOpCode(opCode));
                if (factory != null)
                {
                    messages.Add(factory.GetMessage(opCode, posPacket));
                }
                else
                {
                    var orgOpCode = opCode;
                    opCode |= 0xFF00;
                    factory = _factories.FirstOrDefault(f => f.ContainsOpCode(opCode));
                    if (factory != null)
                    {
                        posPacket.Position--;
                        messages.Add(factory.GetMessage(opCode, posPacket));
                    }
                    else
                    {
                        Logger.Error("Invalid OpCoder {opCodea:X4}|{opCode:X4} {posPacket:X2}", orgOpCode, opCode, posPacket.GetBuffer().Take(pkSize));
                    }
                }

                return size;
            }
        }
    }

    public class WZPacketEncoder
    {
        public static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(WZPacketEncoder));

        private readonly MessageFactory[] _factories;
        private bool _packetRijndael;

        public WZPacketEncoder(MessageFactory[] factories, bool useRijndael)
        {
            _factories = factories;
            _packetRijndael = useRijndael;
        }

        public static void PacketPrint(MemoryStream mem)
        {
            var l = mem.Length;
            var b = mem.ToArray();
            var s = "";

            foreach(var i in b)
            {
                s += i.ToString("X2");
            }

            Logger.Debug("Packet: {0}", s);
        }

        public byte[] Encode(object message, ref short serial, WZClient client)
        {
            MessageFactory factory = null;
            try
            {
                factory = _factories.First(f => f.ContainsType(message.GetType()));
            }catch(Exception ex)
            {
                throw new Exception("Unregisted message " + message.GetType().ToString(), ex);
            }
            
            ushort opCode = factory.GetOpCode(message.GetType());

            var att = message
                .GetType()
                .GetCustomAttributes(false)
                .Where(x => x.GetType() == typeof(WZContractAttribute))
                .FirstOrDefault() as WZContractAttribute;

            if (att == null)
                throw new InvalidOperationException("Invalid message format");

            byte[] res;

            using (var data = new MemoryStream())
            {
                var opCodeSize = (opCode & 0xFF00) == 0xFF00 ? 1 : 2;
                if (att.LongMessage)
                {
                    Serializer.Serialize(data, new WZWPacket(0xC2, (ushort)data.Length, opCode));
                }
                else
                {
                    Serializer.Serialize(data, new WZBPacket(0xC1, (byte)data.Length, opCode));
                }

                var dataStart = (att.LongMessage ? 3 : 2) + opCodeSize;
                data.Position = dataStart;
                Serializer.Serialize(data, message);

                data.Position = dataStart;
                if (att.ExtraEncode != null)
                {
                    var encoder = (IExtraEncoder)Activator.CreateInstance(att.ExtraEncode);
                    encoder.Encoder(data); 
                }

                if (att.Serialized)
                {
                    data.Position = (att.LongMessage ? 3 : 2);
                    if (_packetRijndael == true)
                    {
                        PacketEncrypt.Encrypt(data, data, client);
                        //PacketPrint(data);
                    }
                    else
                        SimpleModulus.Encrypt(data, (byte)serial, data);

                    serial++;
                    data.Position = 0;
                    data.WriteByte((byte)(att.LongMessage ? 0xC4 : 0xC3));
                }

                data.Position = 1;
                if (att.LongMessage)
                {
                    data.Write(BitConverter.GetBytes(((ushort)data.Length).ShufleEnding()), 0, 2);
                }
                else
                {
                    data.Write(new byte[] { (byte)data.Length }, 0, 1);
                    //data.Write(BitConverter.GetBytes((byte)data.Length), 0, 1);
                }
                res = data.ToArray();

                if(att.Dump)
                {
                    Logger.Debug($"Message({message.GetType().Name}):{string.Join(" ", res.Select(x => x.ToString("X")))}");
                }
                    return res;
            }
        }
    }

    public class WZPacketEncoderClient
    {
        private readonly MessageFactory[] _factories;

        public WZPacketEncoderClient(MessageFactory[] factories)
        {
            _factories = factories;
        }

        public byte[] Encode(object message, ref short serial)
        {
            var factory = _factories.FirstOrDefault(f => f.ContainsType(message.GetType()));
            byte[] result = null;

            if (factory == null)
                throw new InvalidProgramException($"Invalid message type {message.GetType()}");

            ushort opCode = factory.GetOpCode(message.GetType());

            var att = message
                .GetType()
                .GetCustomAttributes(false)
                .Where(x => x.GetType() == typeof(WZContractAttribute))
                .FirstOrDefault() as WZContractAttribute;

            if (att == null)
                throw new InvalidOperationException("Invalid message format");

            using (var h = new MemoryStream())
            using (var b = new MemoryStream())
            {
                Serializer.Serialize(b, message);
                var body = b.ToArray();
                var length = body.Length;
                var sizeFix = (((opCode & 0xFF00) == 0xFF00) ? 1 : 0);

                if (att.LongMessage)
                {
                    var header = new WZWPacket
                    {
                        Type = (byte)0xC2,
                        Size = (ushort)(length + 5 - sizeFix),
                        Operation = opCode
                    };

                    if (att.Serialized)
                    {
                        var temp = new byte[header.Size - 2];

                        temp[0] = (byte)serial;

                        Array.Copy(body, 0, temp, 1, body.Length);

                        body = SimpleModulus.Encoder(temp);
                        header.Type += 2;

                        serial++;
                    }

                    Serializer.Serialize(h, header);
                }
                else
                {
                    var header = new WZBPacket
                    {
                        Type = (byte)0xC1,
                        Size = (byte)(length + 4 - sizeFix),
                        Operation = opCode
                    };

                    if (att.Serialized)
                    {
                        var temp = new byte[header.Size - 1];

                        temp[0] = (byte)serial;

                        Array.Copy(body, 0, temp, 1, body.Length);

                        body = SimpleModulus.Encoder(temp);
                        header.Type += 2;

                        serial++;
                    }

                    Serializer.Serialize(h, header);
                }

                var head = h.ToArray();
                var headLen = head.Length - sizeFix;

                result = new byte[headLen + body.Length];
                Array.Copy(head, result, headLen);
                Array.Copy(body, 0, result, headLen, body.Length);

                using (var spe = new StreamPacketEngine(false))
                {
                    spe.AddData(result);
                    result = spe.ExtractData();
                }
            }

            return result;
        }
    }

    public class WZPacket
    {
        public short Serial { get; set; }

        public object message { get; set; }
    }

    [BlubContract]
    public class WZBPacket
    {
        [BlubMember(0)]
        public byte Type { get; set; }

        [BlubMember(1)]
        public byte Size { get; set; }

        [BlubMember(2)]
        public ushort Operation { get; set; }
        public WZBPacket() { }
        public WZBPacket(byte type, byte size, ushort op)
        {
            Type = type;
            Size = size;
            Operation = op;
        }
    }

    [BlubContract]
    public class WZWPacket
    {
        [BlubMember(0)]
        public byte Type { get; set; }

        [BlubMember(1)]
        public ushort wzSize { get; set; }

        [BlubMember(3)]
        public ushort Operation { get; set; }

        public ushort Size {
            get => wzSize.ShufleEnding();
            set
            {
                wzSize = value.ShufleEnding();
            }
        }

        public WZWPacket() { }
        public WZWPacket(byte type, ushort size, ushort op)
        {
            Type = type;
            Size = size;
            Operation = op;
        }
    }
}


--file PacketEncrypt.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Security.Cryptography;
using System.IO;
using Serilog;
using Serilog.Core;
using System.Linq;

namespace WebZen.Network
{
    public class PacketEncrypt
    {
        private static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(WZServer));

        public static void Encrypt(MemoryStream dest, MemoryStream src, WZClient client)
        {
            var destPos = dest.Position;
            var dataLen = (src.Length - src.Position);
            var r = (byte)(dataLen % 16);
            byte paddingSize = 0;
            if(r != 0)
            {
                paddingSize = (byte)(16 - r);
            }

            var tmp = new byte[dataLen + paddingSize];
            src.Read(tmp, 0, (int)dataLen);

            dest.Seek(destPos, SeekOrigin.Begin);
            var cs = new CryptoStream(dest, client.CreateEncryptor(), CryptoStreamMode.Write);
            cs.Write(tmp, 0, tmp.Length);
            dest.WriteByte(paddingSize);
            dest.Seek(0, SeekOrigin.Begin);
        }

        public static byte[] Decrypt(byte[] src, WZClient client)
        {
            byte[] ret = Array.Empty<byte>();
            var bsize = client.BlockSize / 8;

            if (src.Length % bsize == 1)
            {
                var paddingSize = src[src.Length - 1];
                var outLength = src.Length - paddingSize - 1;

                using (var ms = new MemoryStream(src, 0, src.Length - 1))
                {
                    var cs = new CryptoStream(ms, client.CreateDecryptor(), CryptoStreamMode.Read);
                    using (var br = new BinaryReader(cs))
                    {
                        ret = br.ReadBytes(outLength);
                    }
                }

                //Logger.Debug("Input Buffer {0}, Output Buffer {1}", string.Join("",src.Select(x => x.ToString("X2"))), string.Join("", ret.Select(x => x.ToString("X2"))));
            }else
            {
                Logger.Error("Can't decode stream, data size:{1} remainder:{0}", src.Length % bsize, src.Length);
            }

            return ret;
        }
    }
}


--file SimpleModulus.cs
﻿using System;
using System.IO;
using System.Security.Cryptography;
using BlubLib;
using BlubLib.IO;
using BlubLib.Serialization;
using WebZen.Util;

namespace WebZen.Network
{
    public static class SimpleModulus
    {
        private static readonly uint[] s_saveLoadXor = new uint[] { 0x3F08A79B, 0xE25CC287, 0x93D27AB9, 0x20DEA7BF };
        private static Modulus s_enc;
        private static Modulus s_dec;

        public static byte[] Encoder(byte[] src) => s_enc.Enc(src);
        public static void Encrypt(Stream dest, byte serial, Stream src) => s_enc.Encrypt(dest, serial, src);
        public static byte[] Decoder(byte[] src) => s_dec.Dec(src);

        public static void LoadEncryptionKey(string file)
        {
            s_enc = LoadKey(file, 4370, true, true, false, true);
        }

        public static void LoadDecryptionKey(string file)
        {
            s_dec = LoadKey(file, 4370, true, false, true, true);
        }

        private static Modulus LoadKey(string file, ushort header, bool loadModulus, bool loadEncKey, bool loadDecKey, bool loadXOrKey)
        {
            var key = new Modulus();

            using (var f = File.OpenRead(file))
            {
                var fheader = Serializer.Deserialize<ENCDEC_FILEHEADER>(f);

                if (fheader.sFileHeader != header)
                    throw new Exception("Invalid file format");

                var Size = 6;
                Size += loadModulus ? 16 : 0;
                Size += loadEncKey ? 16 : 0;
                Size += loadDecKey ? 16 : 0;
                Size += loadXOrKey ? 16 : 0;

                if (fheader.Size != Size)
                    throw new ArgumentException("Invalid file size");

                var temp = new byte[16];

                if (loadModulus)
                {
                    f.Read(temp, 0, 16);
                    for (var i = 0; i < 4; i++)
                    {
                        key.modulus[i] = s_saveLoadXor[i] ^ BitConverter.ToUInt32(temp, i * 4);
                    }
                }

                if (loadEncKey)
                {
                    f.Read(temp, 0, 16);
                    for (var i = 0; i < 4; i++)
                    {
                        key.encryptionKey[i] = s_saveLoadXor[i] ^ BitConverter.ToUInt32(temp, i * 4);
                    }
                }

                if (loadDecKey)
                {
                    f.Read(temp, 0, 16);
                    for (var i = 0; i < 4; i++)
                    {
                        key.decryptionKey[i] = s_saveLoadXor[i] ^ BitConverter.ToUInt32(temp, i * 4);
                    }
                }

                if (loadXOrKey)
                {
                    f.Read(temp, 0, 16);
                    for (var i = 0; i < 4; i++)
                    {
                        key.xor[i] = s_saveLoadXor[i] ^ BitConverter.ToUInt32(temp, i * 4);
                    }
                }
            }

            return key;
        }

        private static void SaveKey(string file, Modulus key, ushort header, bool loadModulus, bool loadEncKey, bool loadDecKey, bool loadXOrKey)
        {
            using (var f = File.OpenWrite(file))
            {
                var Size = 6;
                Size += loadModulus ? 16 : 0;
                Size += loadEncKey ? 16 : 0;
                Size += loadDecKey ? 16 : 0;
                Size += loadXOrKey ? 16 : 0;

                var fheader = new ENCDEC_FILEHEADER { sFileHeader = (short)header, Size = Size };

                Serializer.Serialize(f, fheader);

                var temp = 0u;

                if (loadModulus)
                {
                    for (var i = 0; i < 4; i++)
                    {
                        temp = s_saveLoadXor[i] ^ key.modulus[i];
                    }
                    f.Write(BitConverter.GetBytes(temp), 0, 4);
                }

                if (loadEncKey)
                {
                    for (var i = 0; i < 4; i++)
                    {
                        temp = s_saveLoadXor[i] ^ key.encryptionKey[i];
                    }
                    f.Write(BitConverter.GetBytes(temp), 0, 4);
                }

                if (loadDecKey)
                {
                    for (var i = 0; i < 4; i++)
                    {
                        temp = s_saveLoadXor[i] ^ key.decryptionKey[i];
                    }
                    f.Write(BitConverter.GetBytes(temp), 0, 4);
                }

                if (loadXOrKey)
                {
                    for (var i = 0; i < 4; i++)
                    {
                        temp = s_saveLoadXor[i] ^ key.xor[i];
                    }
                    f.Write(BitConverter.GetBytes(temp), 0, 4);
                }
            }
        }
    }

    public class Modulus
    {
        public uint[] xor = new uint[4];
        public uint[] encryptionKey = new uint[4];
        public uint[] decryptionKey = new uint[4];
        public uint[] modulus = new uint[4];

        public void Encrypt(Stream dest, byte serial, Stream src)
        {
            var position = src.Position;
            var length = (src.Length - src.Position);
            var missing = length % 8;

            using (var ms = new MemoryStream((int)(length + missing)))
            {
                ms.WriteByte(serial);
                src.CopyTo(ms);
                src.Position = position;
                ms.Position = 0;
                var emptyBlock = new byte[11];
                while (ms.Position < length+1)
                {
                    var bSize = (int)(length+1 - ms.Position);
                    if (bSize > 8)
                        bSize = 8;

                    var pos = dest.Position;
                    dest.Write(emptyBlock, 0, 11);
                    dest.Position = pos;
                    EcryptBlock(dest, ms, bSize);
                    dest.Position += 11;
                }
            }
        }

        public int EcryptBlock(Stream dest, Stream src, int BlockSize)
        {
            var EncSrc = new byte[8];
            var DecPos = src.Position;
            var EncBuffer = new uint[4];
            var EncValue = 0u;

            src.Read(EncSrc, 0, BlockSize);
            src.Position = DecPos;

            for (var i = 0; i < 4; i++)
            {
                EncBuffer[i] = ((xor[i] ^ src.ReadUShort() ^ EncValue) * encryptionKey[i]) % modulus[i];
                EncValue = EncBuffer[i] & 0xFFFF;
            }

            for(var i = 0; i < 3; i++)
            {
                EncBuffer[i] = EncBuffer[i] ^ xor[i] ^ (EncBuffer[i + 1] & 0xFFFF);
            }

            var iBitPos = 0;

            for (var i = 0; i < 4; i++)
            {
                var bytes = BitConverter.GetBytes(EncBuffer[i]);
                iBitPos = AddBits(dest, iBitPos, bytes, 0, 16);
                iBitPos = AddBits(dest, iBitPos, bytes, 22, 2);
            }

            byte btCheckSum = 0xF8;

            for (var i = 0; i < 8; i++)
                btCheckSum ^= EncSrc[i];

            EncSrc[1] = btCheckSum;
            EncSrc[0] = (byte)(btCheckSum ^ BlockSize ^ 0x3D);

            return AddBits(dest, iBitPos, EncSrc, 0, 16);
        }

        private int AddBits(Stream dest, int destPos, byte[] src, int srcPos, int srcLen)
        {
            var iSourceBufferBitLen = srcLen + srcPos;
            var iTempBufferLen = GetByteOfBit(iSourceBufferBitLen - 1);
            iTempBufferLen += 1 - GetByteOfBit(srcPos);

            // Copy the Source Buffer
            var pTempBuffer = new byte[iTempBufferLen + 1];
            Array.Fill<byte>(pTempBuffer, 0);
            Array.Copy(src, GetByteOfBit(srcPos), pTempBuffer, 0, iTempBufferLen);

            // Save the Last ibt if exist
            if ((iSourceBufferBitLen % 8) != 0)
            {
                pTempBuffer[iTempBufferLen - 1] &= (byte)(255 << (8 - (iSourceBufferBitLen % 8)));
            }

            // Get the Values to Shift
            var iShiftLeft = (srcPos % 8);
            var iShiftRight = (destPos % 8);

            // Shift the Values to Add the right space of the desired bits
            Shift(pTempBuffer, iTempBufferLen, -iShiftLeft);
            Shift(pTempBuffer, iTempBufferLen + 1, iShiftRight);

            // Copy the the bits of Source to the Dest
            int iNewTempBufferLen = ((iShiftRight <= iShiftLeft) ? 0 : 1) + iTempBufferLen;

            var orgPosition = dest.Position;
            var iDest = dest.Position + GetByteOfBit(destPos);
            dest.Position = iDest;
            var btDest = new byte[iNewTempBufferLen];
            dest.Read(btDest, 0, iNewTempBufferLen);

            for (int i = 0; i < iNewTempBufferLen; i++)
            {
                btDest[i] |= pTempBuffer[i];
            }

            dest.Position = iDest;
            dest.Write(btDest, 0, iNewTempBufferLen);
            dest.Position = orgPosition;

            // Return the number of bits of the new Dest Buffer
            return destPos + srcLen;
        }

        public byte[] Enc(byte[] src)
        {
            var iDec = ((src.Length + 7) / 8);
            iDec = (iDec + iDec * 4) * 2 + iDec;

            var dest = new byte[iDec];

            var iOriSize = src.Length;
            var iDest = 0;
            var iTempSize2 = 0;

            var tempDest = new byte[11];
            var tempSrc = new byte[8];

            for (int i = 0; i < src.Length; i += 8, iOriSize -= 8, iDest += 11)
            {
                iTempSize2 = iOriSize;
                if (iOriSize >= 8)
                    iTempSize2 = 8;

                Array.Copy(src, i, tempSrc, 0, iTempSize2);

                EncBlock(tempDest, tempSrc, iTempSize2);

                Array.Copy(tempDest, 0, dest, iDest, 11);
            }

            return dest;
        }

        public byte[] Dec(byte[] src)
        {
            var iEnc = src.Length * 8 / 11;
            var dest = new byte[iEnc];

            var decLen = 0;
            var destPos = 0;
            var iResult = 0;
            var tempDest = new byte[8];
            var tempSrc = new byte[11];

            while (decLen < src.Length)
            {
                Array.Copy(src, decLen, tempSrc, 0, 11);

                var tempResult = DecBlock(tempDest, tempSrc);

                Array.Copy(tempDest, 0, dest, destPos, 8);

                if (iResult < 0)
                    throw new InvalidDataException("Error decoding buffer");

                iResult += tempResult;
                decLen += 11;
                destPos += 8;
            }

            return dest;
        }

        private int EncBlock(byte[] dest, byte[] src, int size)
        {
            var EncBuffer = new uint[4];
            var EncValue = 0u;

            for (var i = 0; i < 4; i++)
            {
                var EncSource = BitConverter.ToUInt16(src, i * 2);
                EncBuffer[i] = (xor[i] ^ EncSource ^ EncValue) * encryptionKey[i] % modulus[i];
                EncValue = EncBuffer[i] & 0xffff;
            }

            for (var i = 0; i < 3; i++)
            {
                EncBuffer[i] = EncBuffer[i] ^ xor[i] ^ (EncBuffer[i + 1] & 0xFFFF);
            }

            var iBitPos = 0;

            for (int i = 0; i < 4; i++)
            {
                var EncBuffBytes = BitConverter.GetBytes(EncBuffer[i]);
                iBitPos = AddBits(dest, iBitPos, EncBuffBytes, 0, 16);
                iBitPos = AddBits(dest, iBitPos, EncBuffBytes, 22, 2);
            }

            var btCheckSum = (byte)0xF8;

            for (int i = 0; i < 8; i++)
                btCheckSum ^= src[i];

            //EncValue = (uint)((btCheckSum << 8) | (btCheckSum ^ size ^ 0x3D));
            var cs = new byte[2];
            cs[1] = btCheckSum;
            cs[0] = (byte)(btCheckSum ^ size ^ 0x3D);

            return AddBits(dest, iBitPos, cs, 0, 16);
        }

        private int DecBlock(byte[] dest, byte[] src)
        {
            var tempDest = new byte[4];
            var decBuffer = new uint[4];
            var bitPos = 0;

            for (var i = 0; i < 4; i++)
            {
                AddBits(tempDest, 0, src, bitPos, 16);
                bitPos += 16;
                AddBits(tempDest, 22, src, bitPos, 2);
                bitPos += 2;
                decBuffer[i] = BitConverter.ToUInt32(tempDest, 0);

                Array.Fill<byte>(tempDest, 0);
            }

            for (var i = 2; i >= 0; i--)
            {
                decBuffer[i] = decBuffer[i] ^ xor[i] ^ (decBuffer[i + 1] & 0xFFFF);
            }

            ushort Temp = 0;
            var Temp1 = 0u;

            for (var i = 0; i < 4; i++)
            {
                Temp1 = ((decryptionKey[i] * decBuffer[i]) % modulus[i]) ^ xor[i] ^ Temp;
                Temp = (ushort)(decBuffer[i] & 0xFFFF);
                Array.Copy(BitConverter.GetBytes(Temp1), 0, dest, i * 2, 2);
            }

            Array.Fill<byte>(tempDest, 0);
            AddBits(tempDest, 0, src, bitPos, 16);

            tempDest[0] = (byte)(tempDest[1] ^ tempDest[0] ^ 0x3D);

            var CheckSum = (byte)0xF8;
            for (var i = 0; i < 8; i++)
                CheckSum ^= dest[i];

            if (CheckSum != tempDest[1])
                return -1;

            return tempDest[0];
        }

        private int AddBits(byte[] dest, int destPos, byte[] src, int srcPos, int srcLen)
        {
            var iSourceBufferBitLen = srcLen + srcPos;
            var iTempBufferLen = GetByteOfBit(iSourceBufferBitLen -1);
            iTempBufferLen += 1 - GetByteOfBit(srcPos);

            // Copy the Source Buffer
            var pTempBuffer = new byte[iTempBufferLen + 1];
            Array.Fill<byte>(pTempBuffer, 0);
            Array.Copy(src, GetByteOfBit(srcPos), pTempBuffer, 0, iTempBufferLen);

            // Save the Last ibt if exist
            if ((iSourceBufferBitLen % 8) != 0)
            {
                pTempBuffer[iTempBufferLen - 1] &= (byte)(255 << (8 - (iSourceBufferBitLen % 8)));
            }

            // Get the Values to Shift
            var iShiftLeft = (srcPos % 8);
            var iShiftRight = (destPos % 8);

            // Shift the Values to Add the right space of the desired bits
            Shift(pTempBuffer, iTempBufferLen, -iShiftLeft);
            Shift(pTempBuffer, iTempBufferLen + 1, iShiftRight);

            // Copy the the bits of Source to the Dest
            int iNewTempBufferLen = ((iShiftRight <= iShiftLeft) ? 0 : 1) + iTempBufferLen;

            var iDest = GetByteOfBit(destPos);
            for (int i = 0; i < iNewTempBufferLen; i++)
            {
                dest[iDest + i] |= pTempBuffer[i];
            }

            // Return the number of bits of the new Dest Buffer
            return destPos + srcLen;
        }

        private void Shift(byte[] TempBuff, int iSize, int ShiftLen)
        {
            // Case no Shift Len
            if (ShiftLen != 0)
            {
                // Shift Right
                if (ShiftLen > 0)
                {
                    if ((iSize - 1) > 0)
                    {
                        for (int i = (iSize - 1); i > 0; i--)
                        {
                            TempBuff[i] = (byte)((TempBuff[i - 1] << ((8 - ShiftLen))) | (TempBuff[i] >> ShiftLen));
                        }
                    }

                    TempBuff[0] >>= ShiftLen;
                }
                else    // Shift Left
                {
                    ShiftLen = -ShiftLen;

                    if ((iSize - 1) > 0)
                    {
                        for (int i = 0; i < (iSize - 1); i++)
                        {
                            TempBuff[i] = (byte)((TempBuff[i + 1] >> ((8 - ShiftLen))) | (TempBuff[i] << ShiftLen));
                        }
                    }

                    TempBuff[iSize - 1] <<= ShiftLen;
                }
            }
        }

        private int GetByteOfBit(int bit)
        {
            return bit >> 3;
        }
    }

    [BlubContract]
    public class ENCDEC_FILEHEADER
    {
        [BlubMember(0)]
        public short sFileHeader { get; set; }

        [BlubMember(1)]
        public int Size { get; set; }
    }
}


--file StreamPacketEngine.cs
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace WebZen.Network
{
    public class StreamPacketEngine : IDisposable
    {
        private MemoryStream _stream = new MemoryStream();
        private readonly byte[] XORFilter;

        public StreamPacketEngine(bool _rijndael)
        {
            if (_rijndael)
            {
                XORFilter = new byte[]
                {
                0xAB, 0x11, 0xCD, 0xFE, 0x18, 0x23, 0xC5, 0xA3, 0xCA, 0x33, 0xC1, 0xCC, 0x66,
                0x67, 0x21, 0xF3, 0x32, 0x12, 0x15, 0x35, 0x29, 0xFF, 0xFE, 0x1D, 0x44, 0xEF, 
                0xCD, 0x41, 0x26, 0x3C, 0x4E, 0x4D
                };
            }
            else
            {
                XORFilter = new byte[]
                {
                0xE7, 0x6D, 0x3A, 0x89, 0xBC, 0xB2, 0x9F, 0x73, 0x23, 0xA8, 0xFE, 0xB6, 0x49,
                0x5D, 0x39, 0x5D, 0x8A, 0xCB, 0x63, 0x8D, 0xEA, 0x7D, 0x2B, 0x5F, 0xC3, 0xB1,
                0xE9, 0x83, 0x29, 0x51, 0xE8, 0x56
                };
            }
        }

        public bool AddData(byte[] data)
        {
            _stream.Write(data, 0, data.Length);

            return true;
        }

        public byte[] ExtractPacket()
        {
            _stream.Seek(0, SeekOrigin.Begin);

            var type = _stream.ReadByte();
            ushort size = 0;
            switch(type)
            {
                case 0xC1:
                    size = (ushort)_stream.ReadByte();
                    break;
                case 0xC2:
                    size = (ushort)((_stream.ReadByte() << 8) | _stream.ReadByte());
                    break;
                default:
                    throw new Exception($"Invalid packet type 0x{type:X2}");
            }

            return XorData(size, type == 0xC1 ? 2 : 3);
        }

        public byte[] ExtractData()
        {
            _stream.Seek(0, SeekOrigin.Begin);

            var type = _stream.ReadByte();
            ushort size = 0;
            switch (type)
            {
                case 0xC1:
                    size = (ushort)_stream.ReadByte();
                    break;
                case 0xC2:
                    size = (ushort)((_stream.ReadByte() << 8) | _stream.ReadByte());
                    break;
                default:
                    throw new Exception($"Invalid packet type 0x{type:X2}");
            }

            return IXorData(size, type == 0xC1 ? 2 : 3);
        }

        private byte[] XorData(int Size, int Skip)
        {
            var packet = new byte[Size];
            _stream.Seek(0, SeekOrigin.Begin);
            _stream.Read(packet, 0, Size);
            var tmpstream = new MemoryStream();
            tmpstream.Write(_stream.ToArray(), Size, (int)(_stream.Length - Size));
            _stream.Dispose();
            _stream = tmpstream;

            for (int i = Size - 1; i != Skip; i--)
            {
                packet[i] ^= (byte)(packet[i - 1] ^ XORFilter[(i & (XORFilter.Length - 1))]);
            }

            return packet;
        }

        private byte[] IXorData(int Size, int Skip)
        {
            var packet = new byte[Size];
            _stream.Seek(0, SeekOrigin.Begin);
            _stream.Read(packet, 0, Size);
            var tmpstream = new MemoryStream();
            tmpstream.Write(_stream.ToArray(), Size, (int)(_stream.Length - Size));
            _stream.Dispose();
            _stream = tmpstream;

            for (int i = Skip; i < Size - 1; i++)
            {
                packet[i+1] ^= (byte)(packet[i] ^ XORFilter[(i+1 & (XORFilter.Length - 1))]);
            }

            return packet;
        }

        public void Dispose()
        {
            _stream.Dispose();
        }
    }
}


--file WZServer.cs
﻿using Serilog;
using Serilog.Core;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using WebZen.Handlers;

namespace WebZen.Network
{
    public class WZServer
    {
        public static readonly ILogger Logger = Log.ForContext(Constants.SourceContextPropertyName, nameof(WZServer));
        protected Dictionary<int, WZClient> _clients;

        private TcpListener _listener;
        private WZPacketDecoder _decoder;
        private WZPacketDecoderSimple _decoderSimple;
        private ISessionFactory _factory;
        private MessageHandler[] _handler;
        private WZPacketEncoder _encoder;

        public IPAddress IPAddress => ((IPEndPoint)_listener.LocalEndpoint).Address;
        public string IPPublic { get; set; }

        public ushort Port => (ushort)((IPEndPoint)_listener.LocalEndpoint).Port;

        public int MaxUsers { get; set; }

        public float Load => _clients.Count / MaxUsers * 100.0f;

        public bool SimpleStream { get; set; }

        public byte[] Encode(object message, ref short serial, WZClient client) => _encoder.Encode(message, ref serial, client);
        
        public WZServer()
        {
            _clients = new Dictionary<int, WZClient>();
            MaxUsers = 300;
        }

        public void Initialize(IPEndPoint address, MessageHandler[] handler, ISessionFactory factory, MessageFactory[] message, bool useRijndael)
        {
            _listener = new TcpListener(address);
            _decoder = new WZPacketDecoder(message, useRijndael);
            _decoderSimple = new WZPacketDecoderSimple(message);
            _encoder = new WZPacketEncoder(message, useRijndael);
            _listener.Start();
            _factory = factory;
            _handler = handler;

            Task.Run(AcceptClients);

            Logger.Information("Started on TCP-IP:{ip} TCP-PORT:{port}", address.Address, address.Port);
        }

        protected virtual void OnConnect(WZClient session)
        { }

        public virtual void OnDisconnect(WZClient session)
        {
            Logger.Information($"Client at Index {session.ID} closed");
            var element = _clients.FirstOrDefault(c => c.Value == session);
            _clients.Remove(element.Key);
        }

        private async Task AcceptClients()
        {
            while (true)
            {
                var client = _factory.Create(this, await _listener.AcceptSocketAsync(), OnRecv);
                client.ID = FreeIndex();
                if(client.ID == -1)
                {
                    Logger.Error("All index are in use");
                    client.Disconnect();
                    continue;
                }
                _clients.Add(client.ID, client);
                Logger.Information($"New Client added at index {client.ID}");
                OnConnect(client);
                client.Recv();
            }
        }

        private async void OnRecv(IAsyncResult result)
        {
            var sender = (WZClient)result.AsyncState;
            var messages = new List<object>();
            short serial = 0;
            long TotalRecv = 0;
            byte type = 0x00;

            try
            {
                var @in = sender.Received(result);
                if (@in.Length == 0)
                {
                    sender.Disconnect();
                    return;
                }

                TotalRecv = @in.Length;
                type = @in[0];
                using (var received = new MemoryStream(2048))
                {
                    received.Write(@in, 0, (int)TotalRecv);
                    received.Seek(0, SeekOrigin.Begin);
                    int readed = 0;
                    received.SetLength(1024);
                    do
                    {
                        if (SimpleStream)
                        {
                            readed += _decoderSimple.Decode(received, out serial, messages);
                        }
                        else
                        {
                            readed += _decoder.Decode(received, out serial, messages, sender);
                        }

                        if (serial != -1 && !sender.IsValidSerial(serial))
                        {
                            sender.Disconnect();
                            Logger.Error($"Serialized packet with invalid serial {serial}");
                            return;
                        }
                    } while (readed < TotalRecv);
                }

                sender.Recv();

                foreach (var message in messages)
                {
                    //Console.WriteLine("[C->S] " + message.GetType());
                    foreach (var handler in _handler)
                    {
                        var handled = await handler.OnMessageReceived(sender, message);
                        if(!handled)
                        {
                            Logger.Warning("Un handled message {0}", message.GetType());
                        }
                    }
                }
            }catch(Exception e)
            {
                Logger.Error(e, $"packet decode pSize:{TotalRecv} pType:{type:X}");
                sender.Disconnect();
                return;
            }
        }

        private int FreeIndex()
        {
            for(var i = 1; i < 1000; i++)
            {
                if (_clients.Keys.Any(k => k == i))
                    continue;

                return i;
            }

            return -1;
        }
    }

    public class WZClient
    {
        public int ID { get; set; }
        protected WZServer _server;
        protected byte[] _recvBuffer = new byte[2048];
        protected Socket _sock;
        protected AsyncCallback _onRecv;
        protected short _inSerial;
        public short _outSerial;

        private static RandomNumberGenerator _keyGenerator;
        protected Rijndael _rijndael;

        private bool _closed;
        public bool Closed { get => _closed | !(_sock?.Connected??false); private set => _closed = value; }

        public byte[] Data => _recvBuffer;

        public int BlockSize => _rijndael.BlockSize;

        public byte[] Received(IAsyncResult ar)
        {
            int recv = 0;
            try
            {
                recv = _sock.EndReceive(ar);
            }catch(SocketException)
            {
                _sock.Close();
                return Array.Empty<byte>();
            }catch(ObjectDisposedException)
            {
                return Array.Empty<byte>();
            }

            if (recv <= 0)
                return Array.Empty<byte>();

            var packet = new byte[recv];
            Array.Copy(_recvBuffer, packet, recv);
            Array.Fill<byte>(_recvBuffer, 0);

            return packet;
        }

        public WZClient(WZServer server, Socket socket, AsyncCallback onRecv)
        {
            _server = server;
            _sock = socket;
            _onRecv = onRecv;
            Closed = false;

            if (_keyGenerator == null)
                _keyGenerator = RandomNumberGenerator.Create();

            _rijndael = Rijndael.Create();
            var key = new byte[32];
            _keyGenerator.GetBytes(key);
            _rijndael.Key = key;
            _rijndael.Mode = CipherMode.ECB;
            _rijndael.Padding = PaddingMode.None;
        }

        public void Recv()
        {
            _sock.BeginReceive(_recvBuffer, 0, _recvBuffer.Length, SocketFlags.None, _onRecv, this);
        }

        public async Task<int> Send(byte[] data)
        {
            int result = 0;
            try
            {
                result = await _sock.SendAsync(data, SocketFlags.None);//, OnSend, this
            }catch(Exception)
            {
                Closed = true;
            }
            return result;
        }

        //private void OnSend(IAsyncResult result)
        //{

        //}

        public bool IsValidSerial(short serial)
        {
            var valid = serial == _inSerial;
            _inSerial++;
            if (_inSerial > 255)
                _inSerial = 0;
            return valid;
        }

        public void Disconnect()
        {
            _server.OnDisconnect(this);
            try
            {
                _sock.Disconnect(true);
            }catch(Exception)
            {

            }
        }

        internal ICryptoTransform CreateEncryptor()
        {
            return _rijndael.CreateEncryptor();
        }

        internal ICryptoTransform CreateDecryptor()
        {
            return _rijndael.CreateDecryptor();
        }
    }
}


--file .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


--file WebZen.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("WebZen")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("WebZen")]
[assembly: System.Reflection.AssemblyTitleAttribute("WebZen")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file .NETCoreApp,Version=v3.1.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v3.1", FrameworkDisplayName = ".NET Core 3.1")]


--file WebZen.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("WebZen")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("WebZen")]
[assembly: System.Reflection.AssemblyTitleAttribute("WebZen")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


--file WebZen.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("WebZen")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("WebZen")]
[assembly: System.Reflection.AssemblyTitleAttribute("WebZen")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file ArraySerializer.cs
﻿using BlubLib.Serialization;
using Sigil;
using Sigil.NonGeneric;
using System;
using System.Collections.Generic;
using System.Text;

namespace WebZen.Serialization
{
    public class ArraySerializer : ISerializerCompiler
    {
        private readonly ISerializerCompiler _compiler;
        private readonly ISerializer _serializer;

        public bool CanHandle(Type type)
        {
            throw new NotImplementedException();
        }

        public void EmitDeserialize(Emit emiter, Local value)
        {
            var elementType = value.LocalType.GetElementType();

            //value = new Type[100];
            emiter.LoadConstant(100);
            emiter.NewArray(elementType);
            emiter.StoreLocal(value);
            
            var loop = emiter.DefineLabel();
            var loopCheck = emiter.DefineLabel();

            using (var ex = emiter.DeclareLocal<Exception>("_ex"))
            using (var element = emiter.DeclareLocal(elementType, "element"))
            using (var i = emiter.DeclareLocal<int>("i"))
            {
                emiter.MarkLabel(loop);

                var eb = emiter.BeginExceptionBlock();
                if (_compiler != null)
                    _compiler.EmitDeserialize(emiter, element);
                else if (_serializer != null)
                    emiter.CallDeserializer(_serializer, element);
                else
                    emiter.CallDeserializerForType(elementType, element);
                var cb = emiter.BeginCatchBlock<Exception>(eb);
                emiter.StoreLocal(ex);
                emiter.EndCatchBlock(cb);
                emiter.EndExceptionBlock(eb);

                // value[i] = element
                emiter.LoadLocal(value);
                emiter.LoadLocal(i);
                emiter.LoadLocal(element);
                emiter.StoreElement(elementType);

                // ++i
                emiter.LoadLocal(i);
                emiter.LoadConstant(1);
                emiter.Add();
                emiter.StoreLocal(i);

                // i < length
                emiter.MarkLabel(loopCheck);
                emiter.LoadLocal(i);
                emiter.LoadConstant(100);
                emiter.BranchIfLess(loop);
            }
        }

        public void EmitSerialize(Emit emiter, Local value)
        {
            var elementType = value.LocalType.GetElementType();
            using (var length = emiter.DeclareLocal<int>("length"))
            {
                // length = value.Length
                emiter.LoadLocal(value);
                emiter.Call(value.LocalType.GetProperty(nameof(Array.Length)).GetMethod);
                emiter.StoreLocal(length);

                //emiter.CallSerializerForType(length.LocalType, length);

                var loop = emiter.DefineLabel();
                var loopCheck = emiter.DefineLabel();

                using (var element = emiter.DeclareLocal(elementType, "element"))
                using (var i = emiter.DeclareLocal<int>("i"))
                {
                    emiter.Branch(loopCheck);
                    emiter.MarkLabel(loop);

                    // element = value[i]
                    emiter.LoadLocal(value);
                    emiter.LoadLocal(i);
                    emiter.LoadElement(elementType);
                    emiter.StoreLocal(element);

                    if (_compiler != null)
                        _compiler.EmitSerialize(emiter, element);
                    else if (_serializer != null)
                        emiter.CallSerializer(_serializer, element);
                    else
                        emiter.CallSerializerForType(elementType, element);

                    // ++i
                    emiter.LoadLocal(i);
                    emiter.LoadConstant(1);
                    emiter.Add();
                    emiter.StoreLocal(i);

                    // i < length
                    emiter.MarkLabel(loopCheck);
                    emiter.LoadLocal(i);
                    emiter.LoadLocal(length);
                    emiter.BranchIfLess(loop);
                }
            }
        }
    }
}


--file ArrayWithScalarByteSerializer.cs
﻿using BlubLib.Serialization;
using Sigil;
using Sigil.NonGeneric;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;

namespace WebZen.Serialization
{
    public class ArrayWithScalarSerializer<T> : ISerializerCompiler
    {
        private readonly ISerializerCompiler _compiler;
        private readonly ISerializer _serializer;

        public bool CanHandle(Type type)
        {
            throw new NotImplementedException();
        }

        public void EmitDeserialize(Emit emiter, Local value)
        {
            var elementType = value.LocalType.GetElementType();
            var emptyArray = emiter.DefineLabel();
            var end = emiter.DefineLabel();
            Type lType = typeof(T);

            if(lType.IsClass || lType.IsInterface)
            {
                lType = typeof(T).GetMethod("op_Implicit", new[] { typeof(T) }).ReturnType;
            }
            
            using (var length = emiter.DeclareLocal<T>("length"))
            using(var l = emiter.DeclareLocal(lType, "lengthLoop"))
            {
                emiter.CallDeserializerForType(length.LocalType, length);
                if(length.LocalType.IsClass || length.LocalType.IsInterface)
                {
                    emiter.LoadLocal(length);
                    emiter.Call(typeof(T).GetMethod("op_Implicit", new[] { typeof(T) }));
                    emiter.StoreLocal(l);
                }
                else
                {
                    emiter.LoadLocal(length);
                    emiter.StoreLocal(l);
                }

                // if(length < 1) {
                //  value = Array.Empty<>()
                //  return
                // }
                emiter.LoadLocal(l);
                emiter.LoadConstant(1);
                emiter.BranchIfLess(emptyArray);

                // value = new [length]
                emiter.LoadLocal(l);
                emiter.NewArray(elementType);
                emiter.StoreLocal(value);

                var loop = emiter.DefineLabel();
                var loopCheck = emiter.DefineLabel();

                using (var element = emiter.DeclareLocal(elementType, "element"))
                using (var i = emiter.DeclareLocal<int>("i"))
                {
                    emiter.MarkLabel(loop);

                    if (_compiler != null)
                        _compiler.EmitDeserialize(emiter, element);
                    else if (_serializer != null)
                        emiter.CallDeserializer(_serializer, element);
                    else
                        emiter.CallDeserializerForType(elementType, element);

                    // value[i] = element
                    emiter.LoadLocal(value);
                    emiter.LoadLocal(i);
                    emiter.LoadLocal(element);
                    emiter.StoreElement(elementType);

                    // ++i
                    emiter.LoadLocal(i);
                    emiter.LoadConstant(1);
                    emiter.Add();
                    emiter.StoreLocal(i);

                    // i < length
                    emiter.MarkLabel(loopCheck);
                    emiter.LoadLocal(i);
                    emiter.LoadLocal(l);
                    emiter.BranchIfLess(loop);
                }
                emiter.Branch(end);
            }

            // value = Array.Empty<>()
            emiter.MarkLabel(emptyArray);
            emiter.Call(typeof(Array)
                .GetMethod(nameof(Array.Empty))
                .GetGenericMethodDefinition()
                .MakeGenericMethod(elementType));
            emiter.StoreLocal(value);
            emiter.MarkLabel(end);
        }

        public void EmitSerialize(Emit emiter, Local value)
        {
            var elementType = value.LocalType.GetElementType();
            var scalarType = typeof(T);
            using (var length = emiter.DeclareLocal<T>("length"))
            using(var l = emiter.DeclareLocal<int>("lengthLoop"))
            {
                // length = value.Length
                emiter.LoadLocal(value);
                emiter.Call(value.LocalType.GetProperty(nameof(Array.Length)).GetMethod);
                emiter.StoreLocal(l);
                emiter.LoadLocal(l);

                if (scalarType.IsClass || scalarType.IsInterface)
                {
                    emiter.Call(typeof(T).GetMethod("op_Implicit", new[] { l.LocalType }));
                }
                emiter.StoreLocal(length);

                emiter.CallSerializerForType(length.LocalType, length);

                var loop = emiter.DefineLabel();
                var loopCheck = emiter.DefineLabel();

                using (var element = emiter.DeclareLocal(elementType, "element"))
                using (var i = emiter.DeclareLocal<int>("i"))
                {
                    emiter.Branch(loopCheck);
                    emiter.MarkLabel(loop);

                    // element = value[i]
                    emiter.LoadLocal(value);
                    emiter.LoadLocal(i);
                    emiter.LoadElement(elementType);
                    emiter.StoreLocal(element);

                    if (_compiler != null)
                        _compiler.EmitSerialize(emiter, element);
                    else if (_serializer != null)
                        emiter.CallSerializer(_serializer, element);
                    else
                        emiter.CallSerializerForType(elementType, element);

                    // ++i
                    emiter.LoadLocal(i);
                    emiter.LoadConstant(1);
                    emiter.Add();
                    emiter.StoreLocal(i);

                    // i < length
                    emiter.MarkLabel(loopCheck);
                    emiter.LoadLocal(i);
                    emiter.LoadLocal(l);
                    emiter.BranchIfLess(loop);
                }
            }
        }
    }
}


--file BinarySerializer.cs
﻿using BlubLib.Reflection;
using BlubLib.Serialization;
using Sigil;
using Sigil.NonGeneric;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace WebZen.Serialization
{
    public class BinarySerializer : ISerializerCompiler
    {
        private readonly int _size;
        public BinarySerializer(int Size)
        {
            _size = Size;
        }

        public bool CanHandle(Type type)
        {
            //throw new NotImplementedException();
            if (type == typeof(byte[]))
                return true;
            return false;
        }

        public void EmitDeserialize(Emit emiter, Local value)
        {
            // value = BinaryReaderExtensions.ReadIPEndPoint(reader)
            var elementType = value.LocalType.GetElementType();
            // value = new [length]
            emiter.LoadConstant(_size);
            emiter.NewArray(elementType);
            emiter.StoreLocal(value);
            emiter.LoadArgument(1);
            emiter.LoadConstant(_size);
            emiter.Call(ReflectionHelper.GetMethod((BinaryReader x) => x.ReadBytes(default(int))));
            emiter.StoreLocal(value);
        }

        public void EmitSerialize(Emit emiter, Local value)
        {
            using (var length = emiter.DeclareLocal<int>("length"))
            {
                // length = value.Length
                emiter.LoadLocal(value);
                emiter.Call(value.LocalType.GetProperty(nameof(Array.Length)).GetMethod);
                emiter.StoreLocal(length);

                var elementType = value.LocalType.GetElementType();

                var loop = emiter.DefineLabel();
                var loopCheck = emiter.DefineLabel();
                var loopFill = emiter.DefineLabel();
                var loopFillCheck = emiter.DefineLabel();

                using (var element = emiter.DeclareLocal(elementType, "element"))
                using (var i = emiter.DeclareLocal<int>("i"))
                {
                    emiter.Branch(loopCheck);
                    emiter.MarkLabel(loop);

                    // element = value[i]
                    emiter.LoadLocal(value);
                    emiter.LoadLocal(i);
                    emiter.LoadElement(elementType);
                    emiter.StoreLocal(element);

                    emiter.CallSerializerForType(elementType, element);

                    // ++i
                    emiter.LoadLocal(i);
                    emiter.LoadConstant(1);
                    emiter.Add();
                    emiter.StoreLocal(i);

                    // i >= _size
                    emiter.MarkLabel(loopCheck);
                    emiter.LoadLocal(i);
                    emiter.LoadConstant(_size);
                    emiter.BranchIfGreaterOrEqual(loopFillCheck);

                    // i < length
                    emiter.LoadLocal(i);
                    emiter.LoadLocal(length);
                    emiter.BranchIfLess(loop);

                    emiter.Branch(loopFillCheck);
                    emiter.MarkLabel(loopFill);
                    // element = 0
                    emiter.LoadConstant(0);
                    emiter.StoreLocal(element);

                    emiter.CallSerializerForType(elementType, element);
                    // ++i
                    emiter.LoadLocal(i);
                    emiter.LoadConstant(1);
                    emiter.Add();
                    emiter.StoreLocal(i);

                    emiter.MarkLabel(loopFillCheck);
                    emiter.LoadLocal(i);
                    emiter.LoadConstant(_size);
                    emiter.BranchIfLess(loopFill);
                }
            }
        }
    }
}


--file BinaryStringSerializer.cs
﻿using BlubLib.Reflection;
using BlubLib.Serialization;
using Sigil;
using Sigil.NonGeneric;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using WebZen.Util;

namespace WebZen.Serialization
{
    public class BinaryStringSerializer: ISerializerCompiler
    {
        private readonly int _size;
        public BinaryStringSerializer(int Size)
        {
            _size = Size;
        }

        public bool CanHandle(Type type)
        {
            //throw new NotImplementedException();
            if (type == typeof(string))
                return true;
            return false;
        }

        public void EmitDeserialize(Emit emiter, Local value)
        {
            emiter.LoadArgument(1);
            emiter.LoadConstant(_size);
            emiter.Call(typeof(CString).GetMethod(nameof(CString.ReadString)));
            emiter.StoreLocal(value);
        }

        public void EmitSerialize(Emit emiter, Local value)
        {
            emiter.LoadArgument(1);
            emiter.LoadLocal(value);
            emiter.LoadConstant(_size);
            emiter.Call(typeof(CString).GetMethod(nameof(CString.WriteString),
                new[] { typeof(BinaryWriter), typeof(string), typeof(int) }));
        }
    }
}


--file WZContractAttribute.cs
﻿using BlubLib.Serialization;
using System;
using System.Collections.Generic;
using System.Text;

namespace WebZen.Serialization
{
    public class WZContractAttribute : BlubContractAttribute
    {
        public bool Serialized { get; set; }

        public bool LongMessage { get; set; }

        public Type ExtraEncode { get; set; }

        public bool Dump { get; set; }

        public WZContractAttribute()
            : base()
        { }

        public WZContractAttribute(Type serializerType, params object[] serializerParameters)
            : base(serializerType, serializerParameters)
        { }
    }
}


--file WZMemberAttribute.cs
﻿using BlubLib.Serialization;
using System;
using System.Collections.Generic;
using System.Text;

namespace WebZen.Serialization
{
    public class WZMemberAttribute : BlubMemberAttribute
    {

        public WZMemberAttribute(int order)
            : base(order)
        { }

        public WZMemberAttribute(int order, int size)
            : base(order, typeof(BinarySerializer), size)
        { }

        public WZMemberAttribute(int order, Type serializerType, params object[] serializerParameters)
            : base(order, serializerType, serializerParameters)
        { }
    }
}


--file BuxDecode.cs
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using WebZen.Network;

namespace WebZen.Util
{
    public static class BuxDecode
    {
        private static byte[] bBuxCode = new byte[] { 0xFC, 0xCF, 0xAB };
        private static byte[] bBuxCode2 = new byte[] { 0x81, 0xDE, 0xE1 };

        private static void Decode(byte[] buffer, byte[] key)
        {
            for (var n = 0; n < buffer.Length; n++)
            {
                buffer[n] ^= key[n % 3];      // Nice trick from WebZen
            }
        }

        public static void Decode(byte[] buffer)
        {
            Decode(buffer, bBuxCode);
        }

        public static void Decode2(byte[] buffer)
        {
            Decode(buffer, bBuxCode2);
        }
    }

    public class WZExtraPacketEncodeS16Kor : IExtraEncoder
    {
        private byte[] buffer = new byte[16];
        public void Encoder(MemoryStream ms)
        {
            //Function 00CEA0CC
            BitConverter.GetBytes(0x67452301).CopyTo(buffer, 0);
            BitConverter.GetBytes(0xEFCDAB89).CopyTo(buffer, 4);
            BitConverter.GetBytes(0x98BADCEF).CopyTo(buffer, 8);
            BitConverter.GetBytes(0x10325476).CopyTo(buffer, 12);
            //End Function 00CEA0CC

            var initial = ms.Position;
            var length = ms.Length - ms.Position;
            var tmp = new byte[length];
            ms.Read(tmp, 0, (int)length);
            for(var i =0; i < length; i++)
            {
                tmp[i] ^= buffer[i%16];
            }
            ms.Position = initial;
            ms.Write(tmp, 0, (int)length);
        }
    }
}


--file ByteArrayExtensions.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;

namespace WebZen.Util
{
    public static class ByteArrayExtensions
    {
        public static string GetHex(this byte[] byteArray)
        {
            return string.Join("", byteArray.Select(x => x.ToString("X2")));
        }
    }
}


--file Command.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WebZen.Network;

namespace WebZen.Util
{
    public class CommandEventArgs : EventArgs
    {
        public string Argument { get; set; }
    }
    public class Command<T>
    {
        private Command<T> _parent;
        private Predicate<T> _autority;
        private string _command;
        private List<Command<T>> _subCommands;
        private bool _partial;
        private string _help;

        public event EventHandler<CommandEventArgs> OnCommand;

        public Command(string cmd, EventHandler<CommandEventArgs> _event = null, Predicate<T> autority = null, string help = "")
        {
            if(string.IsNullOrEmpty(cmd))
            {
                throw new ArgumentNullException("cmd");
            }

            _autority = autority ?? (x => true);
            _subCommands = new List<Command<T>>();
            OnCommand = _event;
            _command = cmd;
            _partial = false;
            _help = help;
        }

        public Command<T> AddCommand(Command<T> cmd)
        {
            _subCommands.Add(cmd);
            cmd._parent = this;
            return this;
        }

        public Command<T> Find(T client, string text)
        {
            var splited = text.Split(" ");
            var cmd = splited.First();
            var args = string.Join(" ", splited.Skip(1));
            if (_partial)
            {
                var substring = cmd.Substring(0, _command.Length);
                if (!substring.Equals(_command, StringComparison.InvariantCultureIgnoreCase))
                    return null;

                args = text.Substring(_command.Length);
            }
            else
            {
                if (!cmd.Equals(_command, StringComparison.InvariantCultureIgnoreCase))
                    return null;
            }

            if (client != null && !_autority(client))
                return null;

            if (_subCommands.Count == 0 || string.IsNullOrWhiteSpace(args))
                return this;
            else
            {
                foreach (var scmd in _subCommands)
                {
                    var res = scmd.Find(client, args);
                    if (res == null)
                        continue;

                    return res;
                }
            }

            return null;
        }

        public bool Process(T client, string text)
        {
            var splited = text.Split(" ");
            var cmd = splited.First();
            var args = string.Join(" ", splited.Skip(1));

            if (_partial)
            {
                var substring = cmd.Substring(0, _command.Length);
                if (!substring.Equals(_command, StringComparison.InvariantCultureIgnoreCase))
                    return false;

                args = text.Substring(_command.Length);
            }
            else
            {
                if (!cmd.Equals(_command, StringComparison.InvariantCultureIgnoreCase))
                    return false;
            }

            if (client != null && !_autority(client))
                throw new Exception("No tienes acceso suficiente");

            if (_subCommands.Count == 0)
                OnCommand(client, new CommandEventArgs { Argument = args });
            else
            {
                foreach (var scmd in _subCommands)
                {
                    if (scmd.Process(client, args))
                    {
                        return true;
                    }
                }
            }

            return true;
        }

        public Command<T> SetPartial()
        {
            _partial = true;
            return this;
        }

        public string Help()
        {
            var output = FullName();

            if (!_partial)
                output += ":" + _help;

            if(_subCommands.Count > 0)
            {
                output += "\n\tSubCommand List:\n\t\t";
                output += string.Join("\n\t\t", _subCommands.Select(x => x.FullName()));
            }

            return output;
        }

        public string FullName()
        {
            var output = "";
            if (_parent != null)
            {
                output = _parent.FullName();
                if (!_parent._partial)
                    output += " ";
            }

            output += _command;

            return output;
        }

        public string Name => _command;
        public bool IsPartial => _partial;

        public List<Command<T>> GetCommandList()
        {
            var a = (from c in _subCommands
                     where !c.IsPartial
                     select c).ToList();

            var b = _subCommands
                .Where(x => x.IsPartial)
                .SelectMany(x => x.GetCommandList());

            a.AddRange(b);
            return a;
        }
    }
}


--file CommandHandler.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WebZen.Network;

namespace WebZen.Util
{
    public class CommandHandler<TSession>
        where TSession : WZClient
    {
        private List<Command<TSession>> _commands;

        public CommandHandler()
        {
            _commands = new List<Command<TSession>>();
        }

        public CommandHandler<TSession> AddCommand(Command<TSession> command)
        {
            _commands.Add(command);
            return this;
        }

        public bool ProcessCommands(TSession source, string text)
        {
            if (string.IsNullOrWhiteSpace(text))
                return false;

            foreach(var cmd in _commands)
            {
                if(cmd.Process(source, text))
                {
                    return true;
                }
            }
            return false;
        }

        public Command<TSession> FindCommand(TSession source, string text)
        {
            if (string.IsNullOrWhiteSpace(text))
                return null;

            foreach (var cmd in _commands)
            {
                var res = cmd.Find(source, text);

                if (res != null)
                {
                    return res;
                }
            }

            return null;
        }

        public List<Command<TSession>> GetCommandList()
        {
            var a = (from c in _commands
                    where !c.IsPartial
                    select c).ToList();

            var b = _commands
                .Where(x => x.IsPartial)
                .SelectMany(x => x.GetCommandList());

            a.AddRange(b);

            return a;
        }
    }
}


--file CString.cs
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using System.IO;
using BlubLib.IO;
using System.ComponentModel.DataAnnotations;

namespace WebZen.Util
{
    public static class CString
    {
        public static string MakeString(this byte[] stringBytes)
        {
            var id = Array.FindIndex(stringBytes, x => x == (byte)0);
            //var id = stringBytes.FirstOrDefault(x => x == 0);
            if (id == -1) id = (byte)stringBytes.Length;
            return Encoding.ASCII.GetString(stringBytes, 0, id);
        }

        public static byte[] GetBytes(this string String)
        {
            if (String == null)
                return Array.Empty<byte>();

            return Encoding.ASCII.GetBytes(String);
        }

        public static void WriteString(this BinaryWriter w, string value, int length)
        {
            var a = new byte[length];

            if(value != null)
                Array.Copy(value.GetBytes(), a, Math.Min(length, value.Length));

            w.Write(a, 0, length);
        }

        public static string ReadString(this BinaryReader w, int length)
        {
            return w.ReadBytes(length).MakeString();
        }
    }
}


--file LittleEndian.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WebZen.Serialization;

namespace WebZen.Util
{
    [WZContract]
    public class ushortle
    {
        [WZMember(0)] public ushort dataFinal { get; set; } = 0;
        public ushortle()
        {
            Set(0);
        }
        public ushortle(ushort value)
        {
            Set(value);
        }
        public void Set(ushort value)
        {
            var tmp = BitConverter.GetBytes(value).Reverse().ToArray();
            dataFinal = BitConverter.ToUInt16(tmp);
        }
        public ushort Get()
        {
            var tmp = BitConverter.GetBytes(dataFinal).Reverse().ToArray();
            return BitConverter.ToUInt16(tmp, 0);
        }

        public static implicit operator ushortle(ushort value)
        {
            var r = new ushortle();
            r.Set(value);
            return r;
        }

        public static implicit operator ushortle(int value)
        {
            var r = new ushortle();
            r.Set((ushort)value);
            return r;
        }

        public static implicit operator ushort(ushortle value)=> value.Get();
    }

    [WZContract]
    public class uintle
    {
        [WZMember(0, typeof(ArraySerializer))] public byte[] data { get; set; }
        public void Set(uint value)
        {
            data = BitConverter.GetBytes(value).Reverse().ToArray();
        }
        public uint Get()
        {
            return BitConverter.ToUInt32(data.Reverse().ToArray(), 0);
        }

        public static implicit operator uintle(uint value)
        {
            var r = new uintle();
            r.Set(value);
            return r;
        }

        public static implicit operator uint(uintle value) => value.Get();
    }
}


--file NumberExtensions.cs
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace WebZen.Util
{
    public static class NumberExtensions
    {
        public static byte[] Shufle(byte[] array)
        {
            var output = new byte[array.Length];

            for(int i = array.Length - 1, j = 0; i >= 0 && j < array.Length; i--, j++)
            {
                output[j] = array[i];
            }

            return output;
        }

        public static ushort ShufleEnding(this ushort number)
        {
            return BitConverter.ToUInt16(Shufle(BitConverter.GetBytes(number)), 0);
        }

        public static short ShufleEnding(this short number)
        {
            return BitConverter.ToInt16(Shufle(BitConverter.GetBytes(number)), 0);
        }

        public static uint ShufleEnding(this uint number)
        {
            return BitConverter.ToUInt32(Shufle(BitConverter.GetBytes(number)), 0);
        }

        public static int ShufleEnding(this int number)
        {
            return BitConverter.ToInt32(Shufle(BitConverter.GetBytes(number)), 0);
        }

        public static ulong ShufleEnding(this ulong number)
        {
            return BitConverter.ToUInt64(Shufle(BitConverter.GetBytes(number)), 0);
        }

        public static long ShufleEnding(this long number)
        {
            return BitConverter.ToInt64(Shufle(BitConverter.GetBytes(number)), 0);
        }
    }
}


--file StreamExtensions.cs
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace WebZen.Util
{
    public static class StreamExtensions
    {
        public static short ReadShort(this Stream stream)
        {
            var ret = new byte[2];
            stream.Read(ret, 0, 2);
            return BitConverter.ToInt16(ret, 0);
        }
        public static ushort ReadUShort(this Stream stream)
        {
            var ret = new byte[2];
            stream.Read(ret, 0, 2);
            return BitConverter.ToUInt16(ret, 0);
        }
        public static int ReadInt(this Stream stream)
        {
            var ret = new byte[4];
            stream.Read(ret, 0, 4);
            return BitConverter.ToInt32(ret, 0);
        }
        public static uint ReadUInt(this Stream stream)
        {
            var ret = new byte[4];
            stream.Read(ret, 0, 4);
            return BitConverter.ToUInt32(ret, 0);
        }
    }
}


--file AccountDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace MU.DataBase
{
    [Table("Account")]
    public class AccountDto
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int AccountId { get; set; }

        [Required]
        [MaxLength(11)]
        public string Account { get; set; }

        [Required]
        public string Password { get; set; }

        public string Salt { get; set; }

        public int VaultCount { get; set; }
        public int VaultMoney { get; set; }

        public int ServerCode { get; set; }

        [Column(TypeName = "TINYINT(1)")]
        public bool IsConnected { get; set; }

        public DateTime LastConnection { get; set; } = DateTime.Now;

        [MaxLength(33)]
        public string AuthToken { get; set; }

        public List<CharacterDto> Characters { get; set; }
    }
}


--file BloodCastleDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text;

namespace MU.DataBase
{
    [Table("BloodCastle")]
    public class BloodCastleDto
    {
        [Key]
        public int CharacterId { get; set; }
        public CharacterDto Character { get; set; }

        public int Points { get; set; }
    }
}


--file CharacterDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Net.NetworkInformation;
using System.Text;

namespace MU.DataBase
{
    [Table("Character")]
    public class CharacterDto
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int CharacterId { get; set; }

        public string Name { get; set; }

        public int Class { get; set; }

        public int CtlCode { get; set; }

        public int? GuildId { get; set; }
        public GuildDto Guild { get; set; }

        [Column(TypeName = "SMALLINT(5)")]
        public ushort Map { get; set; }
        public short X { get; set; }
        public short Y { get; set; }

        // Stats Info
        [Column(TypeName = "SMALLINT(5)")]
        public ushort Level { get; set; }

        [Column(TypeName = "SMALLINT(5)")]
        public ushort Life { get; set; }
        [Column(TypeName = "SMALLINT(5)")]
        public ushort MaxLife { get; set; }

        [Column(TypeName = "SMALLINT(5)")]
        public ushort Mana { get; set; }
        [Column(TypeName = "SMALLINT(5)")]
        public ushort MaxMana { get; set; }

        public long Experience { get; set; }

        [Column(TypeName = "SMALLINT(5)")]
        public ushort LevelUpPoints { get; set; }

        [Column(TypeName = "SMALLINT(5)")]
        public ushort Str { get; set; }

        [Column(TypeName = "SMALLINT(5)")]
        public ushort Agility { get; set; }

        [Column(TypeName = "SMALLINT(5)")]
        public ushort Vitality { get; set; }

        [Column(TypeName = "SMALLINT(5)")]
        public ushort Energy { get; set; }

        [Column(TypeName = "SMALLINT(5)")]
        public ushort Command { get; set; }

        [Column(TypeName = "INT(11)")]
        public uint Money { get; set; }
        [Column(TypeName = "INT(11)")]
        public uint Ruud { get; set; }

        public byte ExpandedInventory { get; set; }
        public short PKLevel { get; set; } = 3;
        public int PKTime { get; set; } = 0;

        // Inventory
        [NotMapped]
        public List<ItemDto> Items { get; set; }

        // Spells
        public List<SpellDto> Spells { get; set; }

        // Quest
        public List<QuestDto> Quests { get; set; }
        public List<QuestEXDto> QuestEX { get; set; }

        // Friends
        public List<FriendDto> Friends { get; set; }
        public List<MemoDto> Memos { get; set; }

        [NotMapped]
        public List<GremoryCaseDto> GremoryCases { get; set; }

        public SkillKeyDto SkillKey { get; set; } = new SkillKeyDto();

        public MasterInfoDto MasterInfo { get; set; } = new MasterInfoDto { Experience = 0, Level = 1, Points = 0 };

        public FavoritesDto Favorites { get; set; } = new FavoritesDto();

        public int AccountId { get; set; }
        public AccountDto Account { get; set; }

        [Column(TypeName = "SMALLINT(5) UNSIGNED")]
        public ushort Resets { get; set; }

        // Gens
        public GensDto Gens { get; set; } = new GensDto { Class = 14, Contribution = 0, Influence = 0, Ranking = 9999 };
        public BloodCastleDto BloodCastle { get; set; } = new BloodCastleDto { Points = 0 };
    }
}


--file FavoritesDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text;

namespace MU.DataBase
{
    [Table("FavoritesList")]
    public class FavoritesDto
    {
        [Key]
        public int CharacterId { get; set; }
        public CharacterDto Character { get; set; }
        public int Fav01 { get; set; } = -1;
        public int Fav02 { get; set; } = -1;
        public int Fav03 { get; set; } = -1;
        public int Fav04 { get; set; } = -1;
        public int Fav05 { get; set; } = -1;
    }
}


--file FriendDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text;

namespace MU.DataBase
{
    [Table("Friends")]
    public class FriendDto
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int Id { get; set; }

        public int CharacterId { get; set; }
        public CharacterDto Character { get; set; }

        public int FriendId { get; set; }
        public CharacterDto Friend { get; set; }

        public int State { get; set; }
    }
}


--file GameContext.cs
﻿using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using MU.DataBase;
using Serilog;
using Serilog.Core;
using Serilog.Extensions.Logging;

namespace MuEmu.Entity
{
    public class GameContext : DbContext
    {
        private static readonly LoggerFactory ChangeTrackingAndSqlConsoleLoggerFactory
            = new LoggerFactory(new[] {
                new SerilogLoggerProvider (Log.ForContext(Constants.SourceContextPropertyName, nameof(GameContext)), true)
            }, new LoggerFilterOptions().AddFilter((str, level) => str.Contains("Command") && level == LogLevel.Error));
        public static string ConnectionString;
        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder
                .UseLoggerFactory(ChangeTrackingAndSqlConsoleLoggerFactory)
                .EnableSensitiveDataLogging()
                .EnableDetailedErrors()
                .UseMySQL(ConnectionString);
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<AccountDto>()
                .HasMany(x => x.Characters)
                .WithOne(y => y.Account);

            modelBuilder.Entity<AccountDto>()
                .Navigation(x => x.Characters)
                .UsePropertyAccessMode(PropertyAccessMode.Property)
                .AutoInclude();

            modelBuilder
                .Entity<CharacterDto>()
                .HasOne(x => x.Account)
                .WithMany(y => y.Characters);

            modelBuilder.Entity<CharacterDto>()
                .HasMany(x => x.Quests)
                .WithOne(y => y.Character);

            modelBuilder.Entity<CharacterDto>()
                .HasMany(x => x.Spells)
                .WithOne(y => y.Character);

            /*modelBuilder.Entity<CharacterDto>()
                .HasMany(x => x.Items)
                .WithOne(y => y.Character); */

             modelBuilder.Entity<CharacterDto>()
                 .HasMany(x => x.Friends)
                 .WithOne(y => y.Character);

            modelBuilder.Entity<CharacterDto>()
                .HasOne(x => x.Gens)
                .WithOne(y => y.Character);

            modelBuilder.Entity<CharacterDto>()
                .HasOne(x => x.BloodCastle)
                .WithOne(y => y.Character);

            /*modelBuilder.Entity<CharacterDto>()
                .Navigation(x => x.Items)
                .UsePropertyAccessMode(PropertyAccessMode.Property)
                .AutoInclude();*/

            modelBuilder.Entity<CharacterDto>()
                .Navigation(x => x.Gens)
                .UsePropertyAccessMode(PropertyAccessMode.Property)
                .AutoInclude();

            modelBuilder.Entity<CharacterDto>()
                .Navigation(x => x.BloodCastle)
                .UsePropertyAccessMode(PropertyAccessMode.Property)
                .AutoInclude();

            /*modelBuilder.Entity<CharacterDto>()
                .Navigation(x => x.GremoryCases)
                .UsePropertyAccessMode(PropertyAccessMode.Property)
                .AutoInclude();*/

            //modelBuilder.Entity<ItemDto>()
            //    .HasOne(x => x.Account)
            //    .WithMany();

            modelBuilder.Entity<GuildDto>()
                .HasMany(x => x.MembersInfo)
                .WithOne(y => y.Guild);

            modelBuilder.Entity<GuildDto>()
                .Navigation(x => x.MembersInfo)
                .UsePropertyAccessMode(PropertyAccessMode.Property)
                .AutoInclude();

            modelBuilder.Entity<GuildMemberDto>()
                .HasOne(x => x.Guild)
                .WithMany(y => y.MembersInfo);

            modelBuilder.Entity<GuildMemberDto>()
                .HasOne(x => x.Memb)
                .WithOne();

            modelBuilder.Entity<GuildMemberDto>()
                .Navigation(x => x.Guild)
                .UsePropertyAccessMode(PropertyAccessMode.Property)
                .AutoInclude();

            modelBuilder.Entity<GuildMemberDto>()
                .Navigation(x => x.Memb)
                .UsePropertyAccessMode(PropertyAccessMode.Property)
                .AutoInclude();

            modelBuilder.Entity<GuildMatchingDto>()
                .Navigation(x => x.Guild)
                .UsePropertyAccessMode(PropertyAccessMode.Property)
                .AutoInclude();

            modelBuilder.Entity<GuildMatchingJoinDto>()
                .Navigation(x => x.Character)
                .UsePropertyAccessMode(PropertyAccessMode.Property)
                .AutoInclude();
        }

        public DbSet<AccountDto> Accounts { get; set; }
        public DbSet<CharacterDto> Characters { get; set; }
        public DbSet<GuildDto> Guilds { get; set; }
        public DbSet<GuildMemberDto> GuildMembers { get; set; }
        public DbSet<ItemDto> Items { get; set; }
        public DbSet<FriendDto> Friends { get; set; }
        public DbSet<MemoDto> Letters { get; set; }
        public DbSet<SpellDto> Spells { get; set; }
        public DbSet<QuestDto> Quests { get; set; }
        public DbSet<QuestEXDto> QuestsEX { get; set; }
        public DbSet<SkillKeyDto> Config { get; set; }
        public DbSet<FavoritesDto> Favorites { get; set; }
        public DbSet<MasterInfoDto> MasterLevel { get; set; }
        public DbSet<GremoryCaseDto> GremoryCase { get; set; }
        public DbSet<HuntingDto> HuntingRecords { get; set; }
        public DbSet<GensDto> Gens { get; set; }
        public DbSet<BloodCastleDto> BloodCastles { get; set; }
        public DbSet<GuildMatchingDto> GuildMatching { get; set; }
        public DbSet<GuildMatchingJoinDto> GuildMatchingJoin { get; set; }
        public DbSet<SellDto> Sell { get; set; }
    }
}


--file GensDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text;

namespace MU.DataBase
{
    [Table("Gens")]
    public class GensDto
    {
        [Key]
        public int CharacterId { get; set; }
        public CharacterDto Character { get; set; }

        public int Influence { get; set; }

        public int Class { get; set; }
        public int Ranking { get; set; }
        public int Contribution { get; set; }
    }
}


--file GremoryCaseDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text;

namespace MU.DataBase
{
    [Table("GremoryCase")]
    public class GremoryCaseDto
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public long GiftId { get; set; }

        public int AccountId { get; set; }
        public AccountDto Account { get; set; }

        public byte Inventory { get; set; }
        public byte Source { get; set; }

        public int? CharacterId { get; set; }
        public uint Auth { get; set; }
        //public uint ItemGUID { get; set; }

        // Item Information
        [Column(TypeName = "SMALLINT(5) UNSIGNED")]
        public ushort ItemNumber { get; set; }
        public byte Plus { get; set; }

        [Column(TypeName = "TINYINT(1)")]
        public bool Luck { get; set; }

        [Column(TypeName = "TINYINT(1)")]
        public bool Skill { get; set; }

        [Column(TypeName = "TINYINT(1) UNSIGNED")]
        public byte Durability { get; set; }

        [Column(TypeName = "TINYINT(1) UNSIGNED")]
        public byte Option { get; set; }

        [Column(TypeName = "TINYINT(1) UNSIGNED")]
        public byte OptionExe { get; set; }

        [Column(TypeName = "TINYINT(1) UNSIGNED")]
        public byte HarmonyOption { get; set; }

        public string SocketOptions { get; set; }

        public DateTime ExpireTime { get; set; }
    }
}


--file GuildDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text;

namespace MU.DataBase
{
    [Table("Guild")]
    public class GuildDto
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int GuildId { get; set; }

        public string Name { get; set; }

        public int? AllianceId { get; set; }

        public byte[] Mark { get; set; }

        public byte GuildType { get; set; }

        public virtual ICollection<GuildMemberDto> MembersInfo { get; set; }

        public int? Rival1 { get; set; }

        public int? Rival2 { get; set; }

        public int? Rival3 { get; set; }

        public int? Rival4 { get; set; }

        public int? Rival5 { get; set; }

        //public List<CharacterDto> Characters { get; set; }
    }
}


--file GuildMatchingDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text;

namespace MU.DataBase
{
    [Table("GuildMatching")]
    public class GuildMatchingDto
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int Id { get; set; }

        [Required]
        public int GuildId { get; set; }
        public GuildDto Guild { get; set; }

        public string Title { get; set; }
        public short InterestType { get; set; }
        public short LevelRange { get; set; }
        [Column(TypeName = "SMALLINT(5)")]
        public ushort Class { get; set; }
    }
    [Table("GuildMatchingJoin")]
    public class GuildMatchingJoinDto
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int Id { get; set; }

        [Required]
        public int GuildMatchingId { get; set; }
        public GuildMatchingDto GuildMatching { get; set; }
        public int CharacterId { get; set; }
        public CharacterDto Character { get; set; }
        public byte State { get; set; }
    }
}


--file GuildMemberDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text;

namespace MU.DataBase
{
    [Table("GuildMember")]
    public class GuildMemberDto
    {
        [Key]
        public int MembId { get; set; }
        public CharacterDto Memb { get; set; }

        public int GuildId { get; set; }
        public GuildDto Guild { get; set; }

        public int Rank { get; set; }
    }
}


--file HuntingDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text;

namespace MU.DataBase
{
    [Table("Hunting")]
    public class HuntingDto
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int Id { get; set; }

        public int CharacterId { get; set; }
        public CharacterDto Character { get; set; }
        [Column(TypeName = "SMALLINT(5) UNSIGNED")]
        public ushort Map { get; set; }
        public DateTime DateTime { get; set; } = DateTime.Now;

        [Column(TypeName = "SMALLINT(5) UNSIGNED")]
        public ushort Level { get; set; }
        public long Experience { get; set; }
        public float HealingUse { get; set; }
        public long AttackPVM { get; set; }
        public long ElementalAttackPVM { get; set; }
        public int KilledMonsters { get; set; }
        public int Duration { get; set; }

    }
}


--file ItemDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text;

namespace MU.DataBase
{
    [Table("Item")]
    public class ItemDto
    {
        [Key]
        [Column(TypeName = "BIGINT(5)")]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public long ItemId { get; set; }

        public DateTime DateCreation { get; set; } = DateTime.Now;

        public int AccountId { get; set; } = 0;

        public int CharacterId { get; set; } = 0;

        public int VaultId { get; set; }
        public int SlotId { get; set; }

        [Column(TypeName = "SMALLINT(5) UNSIGNED")]
        public ushort Number { get; set; }

        public byte Plus { get; set; }

        [Column(TypeName = "TINYINT(1)")]
        public bool Luck { get; set; }

        [Column(TypeName = "TINYINT(1)")]
        public bool Skill { get; set; }

        [Column(TypeName = "TINYINT(1) UNSIGNED")]
        public byte Durability { get; set; }

        [Column(TypeName = "TINYINT(1) UNSIGNED")]
        public byte Option { get; set; }

        [Column(TypeName = "TINYINT(1) UNSIGNED")]
        public byte OptionExe { get; set; }

        [Column(TypeName = "TINYINT(1) UNSIGNED")]
        public byte HarmonyOption { get; set; }

        public string SocketOptions { get; set; }

        [Column(TypeName = "TINYINT(1) UNSIGNED")]
        public byte SocketBonus { get; set; }

        public string PJewels { get; set; }

        [Column(TypeName = "SMALLINT(5) UNSIGNED")]
        public byte PetLevel { get; set; }

        [Column(TypeName = "BIGINT(5)")]
        public long PetEXP { get; set; }

        [Column(TypeName = "TINYINT(1) UNSIGNED")]
        public byte SetOption { get; set; }
    }
}


--file MasterInfoDto.cs
﻿using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace MU.DataBase
{
    [Table("MasterInfo")]
    public class MasterInfoDto
    {
        [Key]
        public int MasterInfoId { get; set; }
        // Stats Info
        [Column(TypeName = "SMALLINT(5) UNSIGNED")]
        public ushort Level { get; set; }

        [Column(TypeName = "BIGINT UNSIGNED")]
        public long Experience { get; set; }
        // Stats Info
        [Column(TypeName = "SMALLINT(5) UNSIGNED")]
        public ushort Points { get; set; }
    }
}


--file MemoDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text;

namespace MU.DataBase
{
    [Table("Letters")]
    public class MemoDto
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int MemoId { get; set; }

        public int CharacterId { get; set; }

        public int SenderId { get; set; }
        public CharacterDto Sender { get; set; }

        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public DateTime Date { get; set; }

        [MaxLength(32)]
        public string Subject { get; set; }
    }
}


--file .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


--file MU.DataBase.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("MU.DataBase")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("MU.DataBase")]
[assembly: System.Reflection.AssemblyTitleAttribute("MU.DataBase")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file .NETCoreApp,Version=v3.1.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v3.1", FrameworkDisplayName = ".NET Core 3.1")]


--file MU.DataBase.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("MU.DataBase")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("MU.DataBase")]
[assembly: System.Reflection.AssemblyTitleAttribute("MU.DataBase")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file .NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


--file MU.DataBase.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("MU.DataBase")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dd9ea991833926498435f375db28a9b4f4f916d3")]
[assembly: System.Reflection.AssemblyProductAttribute("MU.DataBase")]
[assembly: System.Reflection.AssemblyTitleAttribute("MU.DataBase")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



--file QuestDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text;

namespace MU.DataBase
{
    [Table("Quest")]
    public class QuestDto
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int QuestId { get; set; }

        public int Quest { get; set; }
        public byte State { get; set; }

        public string Details { get; set; }

        public int CharacterId { get; set; }
        public CharacterDto Character { get; set; }
    }

    [Table("QuestEX")]
    public class QuestEXDto
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int QuestId { get; set; }

        public int Quest { get; set; }
        public int State { get; set; }

        public int CharacterId { get; set; }
        public CharacterDto Character { get; set; }
    }
}


--file SellDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text;

namespace MU.DataBase
{
    [Table("Sell")]
    public class SellDto
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int Index { get; set; }
        public int CharacterId { get; set; }

        [MaxLength(15)]
        public byte[] Item { get; set; }
        public DateTime Date { get; set; }
        public int Price { get; set; }
        [Column(TypeName = "SMALLINT(5)")]
        public ushort Count { get; set; }
    }
}


--file SkillKeyDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text;

namespace MU.DataBase
{
    [Table("SkillKey")]
    public class SkillKeyDto
    {
        [Key]
        public int SkillKeyId { get; set; }

        public byte[] SkillKey { get; set; }

        [Column(TypeName = "TINYINT UNSIGNED")]
        public byte GameOption { get; set; }    // E

        [Column(TypeName = "TINYINT UNSIGNED")]
        public byte QkeyDefine { get; set; }    // F

        [Column(TypeName = "TINYINT UNSIGNED")]
        public byte WkeyDefine { get; set; }    // 10

        [Column(TypeName = "TINYINT UNSIGNED")]
        public byte EkeyDefine { get; set; }    // 11

        [Column(TypeName = "TINYINT UNSIGNED")]
        public byte ChatWindow { get; set; }    // 13

        [Column(TypeName = "TINYINT UNSIGNED")]
        public byte RkeyDefine { get; set; }

        public Int64 QWERLevelDefine { get; set; }
    }
}


--file SpellDto.cs
﻿using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text;

namespace MU.DataBase
{
    [Table("Spells")]
    public class SpellDto
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int SpellId { get; set; }

        public int CharacterId { get; set; }
        public CharacterDto Character { get; set; }

        public short Magic { get; set; }
        public short Level { get; set; }
    }
}


